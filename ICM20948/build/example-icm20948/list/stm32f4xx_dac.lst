###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:34
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\stm32f4xx_dac.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\stm32f4xx_dac.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dac.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    21-October-2015
      7             * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Digital-to-Analog Converter (DAC) peripheral: 
      9            *           + DAC channels configuration: trigger, output buffer, data format
     10            *           + DMA management      
     11            *           + Interrupts and flags management
     12            *
     13           @verbatim      
     14           ===============================================================================
     15                                ##### DAC Peripheral features #####
     16           ===============================================================================
     17              [..]        
     18                *** DAC Channels ***
     19                ====================  
     20              [..]  
     21              The device integrates two 12-bit Digital Analog Converters that can 
     22              be used independently or simultaneously (dual mode):
     23                (#) DAC channel1 with DAC_OUT1 (PA4) as output
     24                (#) DAC channel2 with DAC_OUT2 (PA5) as output
     25            
     26                *** DAC Triggers ***
     27                ====================
     28              [..]
     29              Digital to Analog conversion can be non-triggered using DAC_Trigger_None
     30              and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register 
     31              using DAC_SetChannel1Data() / DAC_SetChannel2Data() functions.
     32              [..] 
     33              Digital to Analog conversion can be triggered by:
     34                (#) External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
     35                    The used pin (GPIOx_Pin9) must be configured in input mode.
     36            
     37                (#) Timers TRGO: TIM2, TIM4, TIM5, TIM6, TIM7 and TIM8 
     38                    (DAC_Trigger_T2_TRGO, DAC_Trigger_T4_TRGO...)
     39                    The timer TRGO event should be selected using TIM_SelectOutputTrigger()
     40            
     41                (#) Software using DAC_Trigger_Software
     42            
     43                *** DAC Buffer mode feature ***
     44                =============================== 
     45                [..] 
     46                Each DAC channel integrates an output buffer that can be used to 
     47                reduce the output impedance, and to drive external loads directly
     48                without having to add an external operational amplifier.
     49                To enable, the output buffer use  
     50                DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
     51                [..]           
     52                (@) Refer to the device datasheet for more details about output 
     53                    impedance value with and without output buffer.
     54                      
     55                 *** DAC wave generation feature ***
     56                 =================================== 
     57                 [..]     
     58                 Both DAC channels can be used to generate
     59                   (#) Noise wave using DAC_WaveGeneration_Noise
     60                   (#) Triangle wave using DAC_WaveGeneration_Triangle
     61                    
     62                    -@-  Wave generation can be disabled using DAC_WaveGeneration_None
     63            
     64                 *** DAC data format ***
     65                 =======================
     66                 [..]   
     67                 The DAC data format can be:
     68                   (#) 8-bit right alignment using DAC_Align_8b_R
     69                   (#) 12-bit left alignment using DAC_Align_12b_L
     70                   (#) 12-bit right alignment using DAC_Align_12b_R
     71            
     72                 *** DAC data value to voltage correspondence ***  
     73                 ================================================ 
     74                 [..] 
     75                 The analog output voltage on each DAC channel pin is determined
     76                 by the following equation: 
     77                 DAC_OUTx = VREF+ * DOR / 4095
     78                 with  DOR is the Data Output Register
     79                    VEF+ is the input voltage reference (refer to the device datasheet)
     80                  e.g. To set DAC_OUT1 to 0.7V, use
     81                    DAC_SetChannel1Data(DAC_Align_12b_R, 868);
     82                    Assuming that VREF+ = 3.3V, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
     83            
     84                 *** DMA requests  ***
     85                 =====================
     86                 [..]    
     87                 A DMA1 request can be generated when an external trigger (but not
     88                 a software trigger) occurs if DMA1 requests are enabled using
     89                 DAC_DMACmd()
     90                 [..]
     91                 DMA1 requests are mapped as following:
     92                   (#) DAC channel1 : mapped on DMA1 Stream5 channel7 which must be 
     93                       already configured
     94                   (#) DAC channel2 : mapped on DMA1 Stream6 channel7 which must be 
     95                       already configured
     96            
     97                
     98                                ##### How to use this driver #####
     99           ===============================================================================
    100              [..]          
    101                (+) DAC APB clock must be enabled to get write access to DAC
    102                    registers using
    103                    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
    104                (+) Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
    105                (+) Configure the DAC channel using DAC_Init() function
    106                (+) Enable the DAC channel using DAC_Cmd() function
    107             
    108           @endverbatim    
    109            ******************************************************************************
    110            * @attention
    111            *
    112            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
    113            *
    114            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    115            * You may not use this file except in compliance with the License.
    116            * You may obtain a copy of the License at:
    117            *
    118            *        http://www.st.com/software_license_agreement_liberty_v2
    119            *
    120            * Unless required by applicable law or agreed to in writing, software 
    121            * distributed under the License is distributed on an "AS IS" BASIS, 
    122            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    123            * See the License for the specific language governing permissions and
    124            * limitations under the License.
    125            *
    126            ******************************************************************************  
    127            */ 
    128          
    129          
    130          /* Includes ------------------------------------------------------------------*/
    131          #include "stm32f4xx_dac.h"
    132          #include "stm32f4xx_rcc.h"
    133          
    134          /** @addtogroup STM32F4xx_StdPeriph_Driver
    135            * @{
    136            */
    137          
    138          /** @defgroup DAC 
    139            * @brief DAC driver modules
    140            * @{
    141            */ 
    142          
    143          /* Private typedef -----------------------------------------------------------*/
    144          /* Private define ------------------------------------------------------------*/
    145          
    146          /* CR register Mask */
    147          #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
    148          
    149          /* DAC Dual Channels SWTRIG masks */
    150          #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
    151          #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
    152          
    153          /* DHR registers offsets */
    154          #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
    155          #define DHR12R2_OFFSET             ((uint32_t)0x00000014)
    156          #define DHR12RD_OFFSET             ((uint32_t)0x00000020)
    157          
    158          /* DOR register offset */
    159          #define DOR_OFFSET                 ((uint32_t)0x0000002C)
    160          
    161          /* Private macro -------------------------------------------------------------*/
    162          /* Private variables ---------------------------------------------------------*/
    163          /* Private function prototypes -----------------------------------------------*/
    164          /* Private functions ---------------------------------------------------------*/
    165          
    166          /** @defgroup DAC_Private_Functions
    167            * @{
    168            */
    169          
    170          /** @defgroup DAC_Group1 DAC channels configuration
    171           *  @brief   DAC channels configuration: trigger, output buffer, data format 
    172           *
    173          @verbatim   
    174           ===============================================================================
    175             ##### DAC channels configuration: trigger, output buffer, data format #####
    176           ===============================================================================  
    177          
    178          @endverbatim
    179            * @{
    180            */
    181          
    182          /**
    183            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
    184            * @param  None
    185            * @retval None
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          void DAC_DeInit(void)
    188          {
   \                     DAC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    189            /* Enable DAC reset state */
    190            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF04F 0x5000      MOV      R0,#+536870912
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    191            /* Release DAC from reset state */
    192            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF04F 0x5000      MOV      R0,#+536870912
   \   00000012   0xE8BD 0x4004      POP      {R2,LR}
   \   00000016   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    193          }
    194          
    195          /**
    196            * @brief  Initializes the DAC peripheral according to the specified parameters
    197            *         in the DAC_InitStruct.
    198            * @param  DAC_Channel: the selected DAC channel. 
    199            *          This parameter can be one of the following values:
    200            *            @arg DAC_Channel_1: DAC Channel1 selected
    201            *            @arg DAC_Channel_2: DAC Channel2 selected
    202            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
    203            *         the configuration information for the  specified DAC channel.
    204            * @retval None
    205            */

   \                                 In section .text, align 2, keep-with-next
    206          void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
    207          {
   \                     DAC_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    208            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    209          
    210            /* Check the DAC parameters */
    211            assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
    212            assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
    213            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
    214            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
    215          
    216          /*---------------------------- DAC CR Configuration --------------------------*/
    217            /* Get the DAC CR value */
    218            tmpreg1 = DAC->CR;
   \   00000002   0x....             LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000004   0x6813             LDR      R3,[R2, #+0]
    219            /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
    220            tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
    221            /* Configure for the selected DAC channel: buffer output, trigger, 
    222               wave generation, mask/amplitude for wave generation */
    223            /* Set TSELx and TENx bits according to DAC_Trigger value */
    224            /* Set WAVEx bits according to DAC_WaveGeneration value */
    225            /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
    226            /* Set BOFFx bit according to DAC_OutputBuffer value */   
    227            tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
    228                       DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
    229                       DAC_InitStruct->DAC_OutputBuffer);
    230            /* Calculate CR register value depending on DAC_Channel */
    231            tmpreg1 |= tmpreg2 << DAC_Channel;
    232            /* Write to DAC CR */
    233            DAC->CR = tmpreg1;
   \   00000006   0xF640 0x74FE      MOVW     R4,#+4094
   \   0000000A   0x4084             LSLS     R4,R4,R0
   \   0000000C   0x43A3             BICS     R3,R3,R4
   \   0000000E   0x680C             LDR      R4,[R1, #+0]
   \   00000010   0x684D             LDR      R5,[R1, #+4]
   \   00000012   0x432C             ORRS     R4,R5,R4
   \   00000014   0x688D             LDR      R5,[R1, #+8]
   \   00000016   0x432C             ORRS     R4,R5,R4
   \   00000018   0x68C9             LDR      R1,[R1, #+12]
   \   0000001A   0x4321             ORRS     R1,R1,R4
   \   0000001C   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000020   0x4318             ORRS     R0,R0,R3
   \   00000022   0x6010             STR      R0,[R2, #+0]
    234          }
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
    235          
    236          /**
    237            * @brief  Fills each DAC_InitStruct member with its default value.
    238            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
    239            *         be initialized.
    240            * @retval None
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
    243          {
    244          /*--------------- Reset DAC init structure parameters values -----------------*/
    245            /* Initialize the DAC_Trigger member */
    246            DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
   \                     DAC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    247            /* Initialize the DAC_WaveGeneration member */
    248            DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    249            /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
    250            DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    251            /* Initialize the DAC_OutputBuffer member */
    252            DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    253          }
   \   0000000A   0x4770             BX       LR               ;; return
    254          
    255          /**
    256            * @brief  Enables or disables the specified DAC channel.
    257            * @param  DAC_Channel: The selected DAC channel. 
    258            *          This parameter can be one of the following values:
    259            *            @arg DAC_Channel_1: DAC Channel1 selected
    260            *            @arg DAC_Channel_2: DAC Channel2 selected
    261            * @param  NewState: new state of the DAC channel. 
    262            *          This parameter can be: ENABLE or DISABLE.
    263            * @note   When the DAC channel is enabled the trigger source can no more be modified.
    264            * @retval None
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
    267          {
    268            /* Check the parameters */
    269            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    270            assert_param(IS_FUNCTIONAL_STATE(NewState));
    271          
    272            if (NewState != DISABLE)
   \                     DAC_Cmd: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xFA02 0xF000      LSL      R0,R2,R0
   \   00000006   0x....             LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0x6811             LDR      R1,[R2, #+0]
   \   0000000C   0xD002             BEQ.N    ??DAC_Cmd_0
    273            {
    274              /* Enable the selected DAC channel */
    275              DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
   \   0000000E   0x4308             ORRS     R0,R0,R1
   \   00000010   0x6010             STR      R0,[R2, #+0]
   \   00000012   0x4770             BX       LR
    276            }
    277            else
    278            {
    279              /* Disable the selected DAC channel */
    280              DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
   \                     ??DAC_Cmd_0: (+1)
   \   00000014   0xEA21 0x0000      BIC      R0,R1,R0
   \   00000018   0x6010             STR      R0,[R2, #+0]
    281            }
    282          }
   \   0000001A   0x4770             BX       LR               ;; return
    283          
    284          /**
    285            * @brief  Enables or disables the selected DAC channel software trigger.
    286            * @param  DAC_Channel: The selected DAC channel. 
    287            *          This parameter can be one of the following values:
    288            *            @arg DAC_Channel_1: DAC Channel1 selected
    289            *            @arg DAC_Channel_2: DAC Channel2 selected
    290            * @param  NewState: new state of the selected DAC channel software trigger.
    291            *          This parameter can be: ENABLE or DISABLE.
    292            * @retval None
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
    295          {
    296            /* Check the parameters */
    297            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    298            assert_param(IS_FUNCTIONAL_STATE(NewState));
    299          
    300            if (NewState != DISABLE)
   \                     DAC_SoftwareTriggerCmd: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x0900             LSRS     R0,R0,#+4
   \   00000004   0xFA02 0xF000      LSL      R0,R2,R0
   \   00000008   0x....             LDR.N    R2,??DataTable14_1  ;; 0x40007404
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0x6811             LDR      R1,[R2, #+0]
   \   0000000E   0xD002             BEQ.N    ??DAC_SoftwareTriggerCmd_0
    301            {
    302              /* Enable software trigger for the selected DAC channel */
    303              DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
   \   00000010   0x4308             ORRS     R0,R0,R1
   \   00000012   0x6010             STR      R0,[R2, #+0]
   \   00000014   0x4770             BX       LR
    304            }
    305            else
    306            {
    307              /* Disable software trigger for the selected DAC channel */
    308              DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
   \                     ??DAC_SoftwareTriggerCmd_0: (+1)
   \   00000016   0xEA21 0x0000      BIC      R0,R1,R0
   \   0000001A   0x6010             STR      R0,[R2, #+0]
    309            }
    310          }
   \   0000001C   0x4770             BX       LR               ;; return
    311          
    312          /**
    313            * @brief  Enables or disables simultaneously the two DAC channels software triggers.
    314            * @param  NewState: new state of the DAC channels software triggers.
    315            *          This parameter can be: ENABLE or DISABLE.
    316            * @retval None
    317            */

   \                                 In section .text, align 2, keep-with-next
    318          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    319          {
    320            /* Check the parameters */
    321            assert_param(IS_FUNCTIONAL_STATE(NewState));
    322          
    323            if (NewState != DISABLE)
   \                     DAC_DualSoftwareTriggerCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_1  ;; 0x40007404
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DAC_DualSoftwareTriggerCmd_0
    324            {
    325              /* Enable software trigger for both DAC channels */
    326              DAC->SWTRIGR |= DUAL_SWTRIG_SET;
   \   00000008   0xF040 0x0003      ORR      R0,R0,#0x3
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    327            }
    328            else
    329            {
    330              /* Disable software trigger for both DAC channels */
    331              DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
   \                     ??DAC_DualSoftwareTriggerCmd_0: (+1)
   \   00000010   0x0880             LSRS     R0,R0,#+2
   \   00000012   0x0080             LSLS     R0,R0,#+2
   \   00000014   0x6008             STR      R0,[R1, #+0]
    332            }
    333          }
   \   00000016   0x4770             BX       LR               ;; return
    334          
    335          /**
    336            * @brief  Enables or disables the selected DAC channel wave generation.
    337            * @param  DAC_Channel: The selected DAC channel. 
    338            *          This parameter can be one of the following values:
    339            *            @arg DAC_Channel_1: DAC Channel1 selected
    340            *            @arg DAC_Channel_2: DAC Channel2 selected
    341            * @param  DAC_Wave: specifies the wave type to enable or disable.
    342            *          This parameter can be one of the following values:
    343            *            @arg DAC_Wave_Noise: noise wave generation
    344            *            @arg DAC_Wave_Triangle: triangle wave generation
    345            * @param  NewState: new state of the selected DAC channel wave generation.
    346            *          This parameter can be: ENABLE or DISABLE.  
    347            * @retval None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
    350          {
    351            /* Check the parameters */
    352            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    353            assert_param(IS_DAC_WAVE(DAC_Wave)); 
    354            assert_param(IS_FUNCTIONAL_STATE(NewState));
    355          
    356            if (NewState != DISABLE)
   \                     DAC_WaveGenerationCmd: (+1)
   \   00000000   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000004   0x....             LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xD002             BEQ.N    ??DAC_WaveGenerationCmd_0
    357            {
    358              /* Enable the selected wave generation for the selected DAC channel */
    359              DAC->CR |= DAC_Wave << DAC_Channel;
   \   0000000C   0x4310             ORRS     R0,R0,R2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x4770             BX       LR
    360            }
    361            else
    362            {
    363              /* Disable the selected wave generation for the selected DAC channel */
    364              DAC->CR &= ~(DAC_Wave << DAC_Channel);
   \                     ??DAC_WaveGenerationCmd_0: (+1)
   \   00000012   0xEA22 0x0000      BIC      R0,R2,R0
   \   00000016   0x6008             STR      R0,[R1, #+0]
    365            }
    366          }
   \   00000018   0x4770             BX       LR               ;; return
    367          
    368          /**
    369            * @brief  Set the specified data holding register value for DAC channel1.
    370            * @param  DAC_Align: Specifies the data alignment for DAC channel1.
    371            *          This parameter can be one of the following values:
    372            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    373            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    374            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    375            * @param  Data: Data to be loaded in the selected data holding register.
    376            * @retval None
    377            */

   \                                 In section .text, align 2, keep-with-next
    378          void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
    379          {  
   \                     DAC_SetChannel1Data: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    380            __IO uint32_t tmp = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x9200             STR      R2,[SP, #+0]
    381            
    382            /* Check the parameters */
    383            assert_param(IS_DAC_ALIGN(DAC_Align));
    384            assert_param(IS_DAC_DATA(Data));
    385            
    386            tmp = (uint32_t)DAC_BASE; 
   \   00000006   0x....             LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000008   0x9200             STR      R2,[SP, #+0]
    387            tmp += DHR12R1_OFFSET + DAC_Align;
   \   0000000A   0x9A00             LDR      R2,[SP, #+0]
   \   0000000C   0x3008             ADDS     R0,R0,#+8
   \   0000000E   0x1880             ADDS     R0,R0,R2
   \   00000010   0x9000             STR      R0,[SP, #+0]
    388          
    389            /* Set the DAC channel1 selected data holding register */
    390            *(__IO uint32_t *) tmp = Data;
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x6001             STR      R1,[R0, #+0]
    391          }
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
    392          
    393          /**
    394            * @brief  Set the specified data holding register value for DAC channel2.
    395            * @param  DAC_Align: Specifies the data alignment for DAC channel2.
    396            *          This parameter can be one of the following values:
    397            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    398            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    399            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    400            * @param  Data: Data to be loaded in the selected data holding register.
    401            * @retval None
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
    404          {
   \                     DAC_SetChannel2Data: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    405            __IO uint32_t tmp = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x9200             STR      R2,[SP, #+0]
    406          
    407            /* Check the parameters */
    408            assert_param(IS_DAC_ALIGN(DAC_Align));
    409            assert_param(IS_DAC_DATA(Data));
    410            
    411            tmp = (uint32_t)DAC_BASE;
   \   00000006   0x....             LDR.N    R2,??DataTable14  ;; 0x40007400
   \   00000008   0x9200             STR      R2,[SP, #+0]
    412            tmp += DHR12R2_OFFSET + DAC_Align;
   \   0000000A   0x9A00             LDR      R2,[SP, #+0]
   \   0000000C   0x3014             ADDS     R0,R0,#+20
   \   0000000E   0x1880             ADDS     R0,R0,R2
   \   00000010   0x9000             STR      R0,[SP, #+0]
    413          
    414            /* Set the DAC channel2 selected data holding register */
    415            *(__IO uint32_t *)tmp = Data;
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x6001             STR      R1,[R0, #+0]
    416          }
   \   00000016   0xB001             ADD      SP,SP,#+4
   \   00000018   0x4770             BX       LR               ;; return
    417          
    418          /**
    419            * @brief  Set the specified data holding register value for dual channel DAC.
    420            * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
    421            *          This parameter can be one of the following values:
    422            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    423            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    424            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    425            * @param  Data2: Data for DAC Channel2 to be loaded in the selected data holding register.
    426            * @param  Data1: Data for DAC Channel1 to be loaded in the selected data  holding register.
    427            * @note   In dual mode, a unique register access is required to write in both
    428            *          DAC channels at the same time.
    429            * @retval None
    430            */

   \                                 In section .text, align 2, keep-with-next
    431          void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
    432          {
    433            uint32_t data = 0, tmp = 0;
    434            
    435            /* Check the parameters */
    436            assert_param(IS_DAC_ALIGN(DAC_Align));
    437            assert_param(IS_DAC_DATA(Data1));
    438            assert_param(IS_DAC_DATA(Data2));
    439            
    440            /* Calculate and set dual DAC data holding register value */
    441            if (DAC_Align == DAC_Align_8b_R)
   \                     DAC_SetDualChannelData: (+1)
   \   00000000   0x2808             CMP      R0,#+8
   \   00000002   0xD102             BNE.N    ??DAC_SetDualChannelData_0
    442            {
    443              data = ((uint32_t)Data2 << 8) | Data1; 
   \   00000004   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000008   0xE001             B.N      ??DAC_SetDualChannelData_1
    444            }
    445            else
    446            {
    447              data = ((uint32_t)Data2 << 16) | Data1;
   \                     ??DAC_SetDualChannelData_0: (+1)
   \   0000000A   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
    448            }
    449            
    450            tmp = (uint32_t)DAC_BASE;
    451            tmp += DHR12RD_OFFSET + DAC_Align;
    452          
    453            /* Set the dual DAC selected data holding register */
    454            *(__IO uint32_t *)tmp = data;
   \                     ??DAC_SetDualChannelData_1: (+1)
   \   0000000E   0x....             LDR.N    R2,??DataTable14_2  ;; 0x40007420
   \   00000010   0x1810             ADDS     R0,R2,R0
   \   00000012   0x6001             STR      R1,[R0, #+0]
    455          }
   \   00000014   0x4770             BX       LR               ;; return
    456          
    457          /**
    458            * @brief  Returns the last data output value of the selected DAC channel.
    459            * @param  DAC_Channel: The selected DAC channel. 
    460            *          This parameter can be one of the following values:
    461            *            @arg DAC_Channel_1: DAC Channel1 selected
    462            *            @arg DAC_Channel_2: DAC Channel2 selected
    463            * @retval The selected DAC channel data output value.
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
    466          {
   \                     DAC_GetDataOutputValue: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    467            __IO uint32_t tmp = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
    468            
    469            /* Check the parameters */
    470            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    471            
    472            tmp = (uint32_t) DAC_BASE ;
   \   00000006   0x....             LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000008   0x9100             STR      R1,[SP, #+0]
    473            tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
   \   0000000A   0x9900             LDR      R1,[SP, #+0]
   \   0000000C   0x0880             LSRS     R0,R0,#+2
   \   0000000E   0x302C             ADDS     R0,R0,#+44
   \   00000010   0x1840             ADDS     R0,R0,R1
   \   00000012   0x9000             STR      R0,[SP, #+0]
    474            
    475            /* Returns the DAC channel data output register value */
    476            return (uint16_t) (*(__IO uint32_t*) tmp);
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xB280             UXTH     R0,R0
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0x4770             BX       LR               ;; return
    477          }
    478          /**
    479            * @}
    480            */
    481          
    482          /** @defgroup DAC_Group2 DMA management functions
    483           *  @brief   DMA management functions
    484           *
    485          @verbatim   
    486           ===============================================================================
    487                                 ##### DMA management functions #####
    488           ===============================================================================  
    489          
    490          @endverbatim
    491            * @{
    492            */
    493          
    494          /**
    495            * @brief  Enables or disables the specified DAC channel DMA request.
    496            * @note   When enabled DMA1 is generated when an external trigger (EXTI Line9,
    497            *         TIM2, TIM4, TIM5, TIM6, TIM7 or TIM8  but not a software trigger) occurs.
    498            * @param  DAC_Channel: The selected DAC channel. 
    499            *          This parameter can be one of the following values:
    500            *            @arg DAC_Channel_1: DAC Channel1 selected
    501            *            @arg DAC_Channel_2: DAC Channel2 selected
    502            * @param  NewState: new state of the selected DAC channel DMA request.
    503            *          This parameter can be: ENABLE or DISABLE.
    504            * @note   The DAC channel1 is mapped on DMA1 Stream 5 channel7 which must be
    505            *          already configured.
    506            * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
    507            *          already configured.    
    508            * @retval None
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
    511          {
    512            /* Check the parameters */
    513            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    514            assert_param(IS_FUNCTIONAL_STATE(NewState));
    515          
    516            if (NewState != DISABLE)
   \                     DAC_DMACmd: (+1)
   \   00000000   0xF44F 0x5280      MOV      R2,#+4096
   \   00000004   0xFA02 0xF000      LSL      R0,R2,R0
   \   00000008   0x....             LDR.N    R2,??DataTable14  ;; 0x40007400
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0x6811             LDR      R1,[R2, #+0]
   \   0000000E   0xD002             BEQ.N    ??DAC_DMACmd_0
    517            {
    518              /* Enable the selected DAC channel DMA request */
    519              DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
   \   00000010   0x4308             ORRS     R0,R0,R1
   \   00000012   0x6010             STR      R0,[R2, #+0]
   \   00000014   0x4770             BX       LR
    520            }
    521            else
    522            {
    523              /* Disable the selected DAC channel DMA request */
    524              DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
   \                     ??DAC_DMACmd_0: (+1)
   \   00000016   0xEA21 0x0000      BIC      R0,R1,R0
   \   0000001A   0x6010             STR      R0,[R2, #+0]
    525            }
    526          }
   \   0000001C   0x4770             BX       LR               ;; return
    527          /**
    528            * @}
    529            */
    530          
    531          /** @defgroup DAC_Group3 Interrupts and flags management functions
    532           *  @brief   Interrupts and flags management functions
    533           *
    534          @verbatim   
    535           ===============================================================================
    536                       ##### Interrupts and flags management functions #####
    537           ===============================================================================  
    538          
    539          @endverbatim
    540            * @{
    541            */
    542          
    543          /**
    544            * @brief  Enables or disables the specified DAC interrupts.
    545            * @param  DAC_Channel: The selected DAC channel. 
    546            *          This parameter can be one of the following values:
    547            *            @arg DAC_Channel_1: DAC Channel1 selected
    548            *            @arg DAC_Channel_2: DAC Channel2 selected
    549            * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
    550            *          This parameter can be the following values:
    551            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    552            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    553            *         acknowledgement for the first external trigger is received (first request).
    554            * @param  NewState: new state of the specified DAC interrupts.
    555            *          This parameter can be: ENABLE or DISABLE.
    556            * @retval None
    557            */ 

   \                                 In section .text, align 2, keep-with-next
    558          void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
    559          {
    560            /* Check the parameters */
    561            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    562            assert_param(IS_FUNCTIONAL_STATE(NewState));
    563            assert_param(IS_DAC_IT(DAC_IT)); 
    564          
    565            if (NewState != DISABLE)
   \                     DAC_ITConfig: (+1)
   \   00000000   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000004   0x....             LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xD002             BEQ.N    ??DAC_ITConfig_0
    566            {
    567              /* Enable the selected DAC interrupts */
    568              DAC->CR |=  (DAC_IT << DAC_Channel);
   \   0000000C   0x4310             ORRS     R0,R0,R2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x4770             BX       LR
    569            }
    570            else
    571            {
    572              /* Disable the selected DAC interrupts */
    573              DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
   \                     ??DAC_ITConfig_0: (+1)
   \   00000012   0xEA22 0x0000      BIC      R0,R2,R0
   \   00000016   0x6008             STR      R0,[R1, #+0]
    574            }
    575          }
   \   00000018   0x4770             BX       LR               ;; return
    576          
    577          /**
    578            * @brief  Checks whether the specified DAC flag is set or not.
    579            * @param  DAC_Channel: The selected DAC channel. 
    580            *          This parameter can be one of the following values:
    581            *            @arg DAC_Channel_1: DAC Channel1 selected
    582            *            @arg DAC_Channel_2: DAC Channel2 selected
    583            * @param  DAC_FLAG: specifies the flag to check. 
    584            *          This parameter can be only of the following value:
    585            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag
    586            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    587            *         acknowledgement for the first external trigger is received (first request).
    588            * @retval The new state of DAC_FLAG (SET or RESET).
    589            */

   \                                 In section .text, align 2, keep-with-next
    590          FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    591          {
    592            FlagStatus bitstatus = RESET;
   \                     DAC_GetFlagStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    593            /* Check the parameters */
    594            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    595            assert_param(IS_DAC_FLAG(DAC_FLAG));
    596          
    597            /* Check the status of the specified DAC flag */
    598            if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
   \   00000002   0x....             LDR.N    R3,??DataTable14_3  ;; 0x40007434
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0xFA01 0xF000      LSL      R0,R1,R0
   \   0000000A   0x4203             TST      R3,R0
   \   0000000C   0xD000             BEQ.N    ??DAC_GetFlagStatus_0
    599            {
    600              /* DAC_FLAG is set */
    601              bitstatus = SET;
   \   0000000E   0x2201             MOVS     R2,#+1
    602            }
    603            else
    604            {
    605              /* DAC_FLAG is reset */
    606              bitstatus = RESET;
    607            }
    608            /* Return the DAC_FLAG status */
    609            return  bitstatus;
   \                     ??DAC_GetFlagStatus_0: (+1)
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR               ;; return
    610          }
    611          
    612          /**
    613            * @brief  Clears the DAC channel's pending flags.
    614            * @param  DAC_Channel: The selected DAC channel. 
    615            *          This parameter can be one of the following values:
    616            *            @arg DAC_Channel_1: DAC Channel1 selected
    617            *            @arg DAC_Channel_2: DAC Channel2 selected
    618            * @param  DAC_FLAG: specifies the flag to clear. 
    619            *          This parameter can be of the following value:
    620            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag 
    621            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    622            *         acknowledgement for the first external trigger is received (first request).                           
    623            * @retval None
    624            */

   \                                 In section .text, align 2, keep-with-next
    625          void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    626          {
    627            /* Check the parameters */
    628            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    629            assert_param(IS_DAC_FLAG(DAC_FLAG));
    630          
    631            /* Clear the selected DAC flags */
    632            DAC->SR = (DAC_FLAG << DAC_Channel);
   \                     DAC_ClearFlag: (+1)
   \   00000000   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000004   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40007434
   \   00000006   0x6008             STR      R0,[R1, #+0]
    633          }
   \   00000008   0x4770             BX       LR               ;; return
    634          
    635          /**
    636            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    637            * @param  DAC_Channel: The selected DAC channel. 
    638            *          This parameter can be one of the following values:
    639            *            @arg DAC_Channel_1: DAC Channel1 selected
    640            *            @arg DAC_Channel_2: DAC Channel2 selected
    641            * @param  DAC_IT: specifies the DAC interrupt source to check. 
    642            *          This parameter can be the following values:
    643            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    644            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    645            *         acknowledgement for the first external trigger is received (first request).
    646            * @retval The new state of DAC_IT (SET or RESET).
    647            */

   \                                 In section .text, align 2, keep-with-next
    648          ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
    649          {
    650            ITStatus bitstatus = RESET;
   \                     DAC_GetITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    651            uint32_t enablestatus = 0;
    652            
    653            /* Check the parameters */
    654            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    655            assert_param(IS_DAC_IT(DAC_IT));
    656          
    657            /* Get the DAC_IT enable bit status */
    658            enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0x....             LDR.N    R1,??DataTable14  ;; 0x40007400
   \   00000008   0x680B             LDR      R3,[R1, #+0]
   \   0000000A   0x4003             ANDS     R3,R0,R3
    659            
    660            /* Check the status of the specified DAC interrupt */
    661            if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
   \   0000000C   0x6B49             LDR      R1,[R1, #+52]
   \   0000000E   0x4201             TST      R1,R0
   \   00000010   0xD002             BEQ.N    ??DAC_GetITStatus_0
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD000             BEQ.N    ??DAC_GetITStatus_0
    662            {
    663              /* DAC_IT is set */
    664              bitstatus = SET;
   \   00000016   0x2201             MOVS     R2,#+1
    665            }
    666            else
    667            {
    668              /* DAC_IT is reset */
    669              bitstatus = RESET;
    670            }
    671            /* Return the DAC_IT status */
    672            return  bitstatus;
   \                     ??DAC_GetITStatus_0: (+1)
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
    673          }
    674          
    675          /**
    676            * @brief  Clears the DAC channel's interrupt pending bits.
    677            * @param  DAC_Channel: The selected DAC channel. 
    678            *          This parameter can be one of the following values:
    679            *            @arg DAC_Channel_1: DAC Channel1 selected
    680            *            @arg DAC_Channel_2: DAC Channel2 selected
    681            * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
    682            *          This parameter can be the following values:
    683            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
    684            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    685            *         acknowledgement for the first external trigger is received (first request).                           
    686            * @retval None
    687            */

   \                                 In section .text, align 2, keep-with-next
    688          void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
    689          {
    690            /* Check the parameters */
    691            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    692            assert_param(IS_DAC_IT(DAC_IT)); 
    693          
    694            /* Clear the selected DAC interrupt pending bits */
    695            DAC->SR = (DAC_IT << DAC_Channel);
   \                     DAC_ClearITPendingBit: (+1)
   \   00000000   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000004   0x....             LDR.N    R1,??DataTable14_3  ;; 0x40007434
   \   00000006   0x6008             STR      R0,[R1, #+0]
    696          }
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40007400         DC32     0x40007400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40007404         DC32     0x40007404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40007420         DC32     0x40007420

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40007434         DC32     0x40007434
    697          
    698          /**
    699            * @}
    700            */
    701          
    702          /**
    703            * @}
    704            */
    705          
    706          /**
    707            * @}
    708            */
    709          
    710          /**
    711            * @}
    712            */
    713          
    714          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DAC_ClearFlag
       0   DAC_ClearITPendingBit
       0   DAC_Cmd
       0   DAC_DMACmd
       8   DAC_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
       0   DAC_DualSoftwareTriggerCmd
       4   DAC_GetDataOutputValue
       0   DAC_GetFlagStatus
       0   DAC_GetITStatus
       0   DAC_ITConfig
       8   DAC_Init
       4   DAC_SetChannel1Data
       4   DAC_SetChannel2Data
       0   DAC_SetDualChannelData
       0   DAC_SoftwareTriggerCmd
       0   DAC_StructInit
       0   DAC_WaveGenerationCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
      10  DAC_ClearFlag
      10  DAC_ClearITPendingBit
      28  DAC_Cmd
      30  DAC_DMACmd
      26  DAC_DeInit
      24  DAC_DualSoftwareTriggerCmd
      30  DAC_GetDataOutputValue
      20  DAC_GetFlagStatus
      28  DAC_GetITStatus
      26  DAC_ITConfig
      40  DAC_Init
      26  DAC_SetChannel1Data
      26  DAC_SetChannel2Data
      22  DAC_SetDualChannelData
      30  DAC_SoftwareTriggerCmd
      12  DAC_StructInit
      26  DAC_WaveGenerationCmd

 
 430 bytes in section .text
 
 430 bytes of CODE memory

Errors: none
Warnings: none
