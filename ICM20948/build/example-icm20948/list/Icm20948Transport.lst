###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:30
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948Transport.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948Transport.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\Icm20948Transport.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\Icm20948Transport.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948Transport.c
      1          /*
      2           * ________________________________________________________________________________________________________
      3           * Copyright (c) 2015-2015 InvenSense Inc. All rights reserved.
      4           *
      5           * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      6           * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
      7           * and other intellectual property rights laws.
      8           *
      9           * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
     10           * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
     11           * from InvenSense is strictly prohibited.
     12           *
     13           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
     14           * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
     15           * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
     17           * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18           * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
     19           * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20           * OF THE SOFTWARE.
     21           * ________________________________________________________________________________________________________
     22           */
     23          
     24          #include "Icm20948Transport.h"
     25          #include "Icm20948Serif.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int inv_icm20948_serif_read_reg(struct inv_icm20948_serif *, uint8_t, uint8_t *, uint32_t)
   \                     inv_icm20948_serif_read_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD107             BNE.N    ??inv_icm20948_serif_read_reg_0
   \   0000000E   0x224E             MOVS     R2,#+78
   \   00000010   0x.... 0x....      ADR.W    R1,?_1
   \   00000014   0x....             ADR.N    R0,??DataTable4  ;; "s"
   \   00000016   0x.... 0x....      BL       __aeabi_assert
   \   0000001A   0x.... 0x....      BL       __iar_EmptyStepPoint
   \                     ??inv_icm20948_serif_read_reg_0: (+1)
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
   \   00000020   0x42B8             CMP      R0,R7
   \   00000022   0xD202             BCS.N    ??inv_icm20948_serif_read_reg_1
   \   00000024   0xF06F 0x0004      MVN      R0,#+4
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??inv_icm20948_serif_read_reg_1: (+1)
   \   0000002A   0x463B             MOV      R3,R7
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6864             LDR      R4,[R4, #+4]
   \   00000034   0x47A0             BLX      R4
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??inv_icm20948_serif_read_reg_2
   \   0000003A   0xF06F 0x0002      MVN      R0,#+2
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??inv_icm20948_serif_read_reg_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp int inv_icm20948_serif_write_reg(struct inv_icm20948_serif *, uint8_t, uint8_t const *, uint32_t)
   \                     inv_icm20948_serif_write_reg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD107             BNE.N    ??inv_icm20948_serif_write_reg_0
   \   0000000E   0x225C             MOVS     R2,#+92
   \   00000010   0x.... 0x....      ADR.W    R1,?_1
   \   00000014   0x....             ADR.N    R0,??DataTable4  ;; "s"
   \   00000016   0x.... 0x....      BL       __aeabi_assert
   \   0000001A   0x.... 0x....      BL       __iar_EmptyStepPoint
   \                     ??inv_icm20948_serif_write_reg_0: (+1)
   \   0000001E   0x6920             LDR      R0,[R4, #+16]
   \   00000020   0x42B8             CMP      R0,R7
   \   00000022   0xD202             BCS.N    ??inv_icm20948_serif_write_reg_1
   \   00000024   0xF06F 0x0004      MVN      R0,#+4
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??inv_icm20948_serif_write_reg_1: (+1)
   \   0000002A   0x463B             MOV      R3,R7
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x4629             MOV      R1,R5
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x68A4             LDR      R4,[R4, #+8]
   \   00000034   0x47A0             BLX      R4
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??inv_icm20948_serif_write_reg_2
   \   0000003A   0xF06F 0x0002      MVN      R0,#+2
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??inv_icm20948_serif_write_reg_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     26          #include "Icm20948.h"
     27          

   \                                 In section .bss, align 4
     28          struct inv_icm20948 * icm20948_instance;
   \                     icm20948_instance:
   \   00000000                      DS8 4
     29          

   \                                 In section .text, align 2, keep-with-next
     30          int inv_icm20948_read_reg(struct inv_icm20948 * s, uint8_t reg,	uint8_t * buf, uint32_t len)
     31          {
     32          	return inv_icm20948_serif_read_reg(&s->serif, reg, buf, len);
   \                     inv_icm20948_read_reg: (+1)
   \   00000000   0x....             B.N      inv_icm20948_serif_read_reg
     33          }
     34          

   \                                 In section .text, align 2, keep-with-next
     35          int inv_icm20948_write_reg(struct inv_icm20948 * s, uint8_t reg, const uint8_t * buf, uint32_t len)
     36          {
     37          	return inv_icm20948_serif_write_reg(&s->serif, reg, buf, len);
   \                     inv_icm20948_write_reg: (+1)
   \   00000000   0x....             B.N      inv_icm20948_serif_write_reg
     38          }
     39          

   \                                 In section .text, align 2, keep-with-next
     40          void inv_icm20948_sleep_100us(unsigned long nHowMany100MicroSecondsToSleep)  // time in 100 us
     41          {
     42          	inv_icm20948_sleep_us(nHowMany100MicroSecondsToSleep * 100);
   \                     inv_icm20948_sleep_100us: (+1)
   \   00000000   0x2164             MOVS     R1,#+100
   \   00000002   0x4348             MULS     R0,R1,R0
   \   00000004   0x.... 0x....      B.W      inv_icm20948_sleep_us
     43          }
     44          

   \                                 In section .text, align 2, keep-with-next
     45          long inv_icm20948_get_tick_count(void)
     46          {
     47          	return (long)inv_icm20948_get_time_us();
   \                     inv_icm20948_get_tick_count: (+1)
   \   00000000   0x.... 0x....      B.W      inv_icm20948_get_time_us
     48          }
     49          
     50          /* driver transport function */
     51          
     52          #include "Icm20948Defs.h"
     53          #include "Icm20948DataBaseDriver.h"
     54          #include "Icm20948DataBaseControl.h"
     55          

   \                                 In section .text, align 2, keep-with-next
     56          void inv_icm20948_transport_init(struct inv_icm20948 * s)
     57          {
     58          	s->lastBank = 0x7E;
   \                     inv_icm20948_transport_init: (+1)
   \   00000000   0xF200 0x40DB      ADDW     R0,R0,#+1243
   \   00000004   0x217E             MOVS     R1,#+126
   \   00000006   0x7001             STRB     R1,[R0, #+0]
     59          	s->lLastBankSelected = 0xFF;
   \   00000008   0x21FF             MOVS     R1,#+255
   \   0000000A   0x7041             STRB     R1,[R0, #+1]
     60          }
   \   0000000C   0x4770             BX       LR               ;; return
     61          

   \                                 In section .text, align 2, keep-with-next
     62          static uint8_t check_reg_access_lp_disable(struct inv_icm20948 * s, unsigned short reg)
     63          {
     64          	switch(reg){
   \                     check_reg_access_lp_disable: (+1)
   \   00000000   0x1F49             SUBS     R1,R1,#+5
   \   00000002   0x2902             CMP      R1,#+2
   \   00000004   0xD90E             BLS.N    ??check_reg_access_lp_disable_0
   \   00000006   0x390A             SUBS     R1,R1,#+10
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD90B             BLS.N    ??check_reg_access_lp_disable_0
   \   0000000C   0x3909             SUBS     R1,R1,#+9
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD90A             BLS.N    ??check_reg_access_lp_disable_1
   \   00000012   0x3958             SUBS     R1,R1,#+88
   \   00000014   0x2902             CMP      R1,#+2
   \   00000016   0xD905             BLS.N    ??check_reg_access_lp_disable_0
   \   00000018   0x1F89             SUBS     R1,R1,#+6
   \   0000001A   0xD005             BEQ.N    ??check_reg_access_lp_disable_1
   \   0000001C   0x3908             SUBS     R1,R1,#+8
   \   0000001E   0x2901             CMP      R1,#+1
   \   00000020   0xD902             BLS.N    ??check_reg_access_lp_disable_1
   \   00000022   0xE003             B.N      ??check_reg_access_lp_disable_2
     65          		case REG_LP_CONFIG:      /** (BANK_0 | 0x05) */
     66          		case REG_PWR_MGMT_1:     /** (BANK_0 | 0x06) */
     67          		case REG_PWR_MGMT_2:     /** (BANK_0 | 0x07) */
     68          		case REG_INT_PIN_CFG:    /** (BANK_0 | 0x0F) */
     69          		case REG_INT_ENABLE:     /** (BANK_0 | 0x10) */
     70          		case REG_FIFO_COUNT_H:   /** (BANK_0 | 0x70) */
     71          		case REG_FIFO_COUNT_L:   /** (BANK_0 | 0x71) */
     72          		case REG_FIFO_R_W:       /** (BANK_0 | 0x72) */
     73          			return inv_icm20948_ctrl_get_batch_mode_status(s);
   \                     ??check_reg_access_lp_disable_0: (+1)
   \   00000024   0x.... 0x....      B.W      inv_icm20948_ctrl_get_batch_mode_status
     74          		case REG_FIFO_CFG:       /** (BANK_0 | 0x76) */
     75          		case REG_MEM_BANK_SEL:   /** (BANK_0 | 0x7E) */
     76          		case REG_BANK_SEL:       /** 0x7F */
     77          		case REG_INT_STATUS:     /** (BANK_0 | 0x19) */
     78          		case REG_DMP_INT_STATUS: /** (BANK_0 | 0x18) */
     79          			return 0;
   \                     ??check_reg_access_lp_disable_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR
     80          			break;
     81          		default:
     82          			break;
     83              }
     84              return 1;
   \                     ??check_reg_access_lp_disable_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x4770             BX       LR               ;; return
     85          }
     86          
     87          /**
     88          *  @brief      Set up the register bank register for accessing registers in 20630.
     89          *  @param[in]  register bank number
     90          *  @return     0 if successful.
     91          */
     92          

   \                                 In section .text, align 2, keep-with-next
     93          static int inv_set_bank(struct inv_icm20948 * s, unsigned char bank)
     94          {
   \                     inv_set_bank: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     95          	int result;
     96              //if bank reg was set before, just return
     97              if(bank==s->lastBank) 
   \   00000006   0xF204 0x46DA      ADDW     R6,R4,#+1242
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x7871             LDRB     R1,[R6, #+1]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD101             BNE.N    ??inv_set_bank_0
     98                  return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD70             POP      {R4-R6,PC}
     99              else 
    100                  s->lastBank = bank;
   \                     ??inv_set_bank_0: (+1)
   \   00000016   0x7075             STRB     R5,[R6, #+1]
    101          
    102              result = inv_icm20948_read_reg(s, REG_BANK_SEL, &s->reg, 1);
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x4632             MOV      R2,R6
   \   0000001C   0x217F             MOVS     R1,#+127
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_read_reg
    103          
    104              if (result)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD10D             BNE.N    ??inv_set_bank_1
    105          		return result;
    106              
    107          	s->reg &= 0xce;
   \   00000028   0x7830             LDRB     R0,[R6, #+0]
   \   0000002A   0xF000 0x00CE      AND      R0,R0,#0xCE
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
    108          	s->reg |= (bank << 4);
   \   00000030   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \   00000034   0x7030             STRB     R0,[R6, #+0]
    109              result = inv_icm20948_write_reg(s, REG_BANK_SEL, &s->reg, 1);
    110          
    111          	return result;
   \   00000036   0x2301             MOVS     R3,#+1
   \   00000038   0x4632             MOV      R2,R6
   \   0000003A   0x217F             MOVS     R1,#+127
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000042   0x....             B.N      inv_icm20948_write_reg
   \                     ??inv_set_bank_1: (+1)
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    112          }
    113          
    114          /* the following functions are used for configuring the secondary devices */
    115          
    116          /**
    117          *  @brief      Write data to a register on MEMs.
    118          *  @param[in]  Register address
    119          *  @param[in]  Length of data
    120          *  @param[in]  Data to be written
    121          *  @return     0 if successful.
    122          */

   \                                 In section .text, align 2, keep-with-next
    123          int inv_icm20948_write_mems_reg(struct inv_icm20948 * s, uint16_t reg, unsigned int length, const unsigned char *data)
    124          {
   \                     inv_icm20948_write_mems_reg: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    125              int result = 0;
   \   0000000C   0xF04F 0x0A00      MOV      R10,#+0
    126          	unsigned int bytesWrite = 0;
   \   00000010   0x46D0             MOV      R8,R10
    127              unsigned char regOnly = (unsigned char)(reg & 0x7F);
   \   00000012   0xF005 0x097F      AND      R9,R5,#0x7F
    128          
    129              unsigned char power_state = inv_icm20948_get_chip_power_state(s);
    130          
    131              if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
   \   00000016   0x.... 0x....      BL       inv_icm20948_get_chip_power_state
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD405             BMI.N    ??inv_icm20948_write_mems_reg_0
    132                  result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x4611             MOV      R1,R2
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000028   0x4682             MOV      R10,R0
    133          
    134              if(check_reg_access_lp_disable(s, reg))    // Check if register needs LP_EN to be disabled   
   \                     ??inv_icm20948_write_mems_reg_0: (+1)
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       check_reg_access_lp_disable
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD006             BEQ.N    ??inv_icm20948_write_mems_reg_1
    135                  result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
   \   00000036   0x4642             MOV      R2,R8
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000040   0xEA40 0x0A0A      ORR      R10,R0,R10
    136          
    137              result |= inv_set_bank(s, reg >> 7);
   \                     ??inv_icm20948_write_mems_reg_1: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x09C1             LSRS     R1,R0,#+7
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       inv_set_bank
   \   00000050   0xEA40 0x0A0A      ORR      R10,R0,R10
   \   00000054   0xE00C             B.N      ??inv_icm20948_write_mems_reg_2
    138              
    139          	while (bytesWrite<length) 
    140          	{
    141          		int thisLen = min(INV_MAX_SERIAL_WRITE, length-bytesWrite);
    142                  
    143                  result |= inv_icm20948_write_reg(s, regOnly+bytesWrite,&data[bytesWrite], thisLen);
   \                     ??inv_icm20948_write_mems_reg_3: (+1)
   \   00000056   0x465B             MOV      R3,R11
   \   00000058   0xEB07 0x0208      ADD      R2,R7,R8
   \   0000005C   0xEB08 0x0109      ADD      R1,R8,R9
   \   00000060   0xB2C9             UXTB     R1,R1
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       inv_icm20948_write_reg
   \   00000068   0xEA50 0x0A0A      ORRS     R10,R0,R10
    144          
    145          		if (result)
   \   0000006C   0xD117             BNE.N    ??inv_icm20948_write_mems_reg_4
    146          			return result;
    147                  
    148          		bytesWrite += thisLen;
   \   0000006E   0x44D8             ADD      R8,R11,R8
   \                     ??inv_icm20948_write_mems_reg_2: (+1)
   \   00000070   0x45B0             CMP      R8,R6
   \   00000072   0xD207             BCS.N    ??inv_icm20948_write_mems_reg_5
   \   00000074   0xEBA6 0x0B08      SUB      R11,R6,R8
   \   00000078   0xF1BB 0x0F11      CMP      R11,#+17
   \   0000007C   0xD3EB             BCC.N    ??inv_icm20948_write_mems_reg_3
   \   0000007E   0xF04F 0x0B10      MOV      R11,#+16
   \   00000082   0xE7E8             B.N      ??inv_icm20948_write_mems_reg_3
    149          	}
    150          
    151              if(check_reg_access_lp_disable(s, reg))   //Enable LP_EN since we disabled it at begining of this function.
   \                     ??inv_icm20948_write_mems_reg_5: (+1)
   \   00000084   0x4629             MOV      R1,R5
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       check_reg_access_lp_disable
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD006             BEQ.N    ??inv_icm20948_write_mems_reg_4
    152                  result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
   \   00000090   0x2201             MOVS     R2,#+1
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   0000009A   0xEA40 0x0A0A      ORR      R10,R0,R10
    153          
    154          	return result;
   \                     ??inv_icm20948_write_mems_reg_4: (+1)
   \   0000009E   0x4650             MOV      R0,R10
   \   000000A0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    155          }
    156          
    157          /**
    158          *  @brief      Write single byte of data to a register on MEMs.
    159          *  @param[in]  Register address
    160          *  @param[in]  Data to be written
    161          *  @return     0 if successful.
    162          */

   \                                 In section .text, align 2, keep-with-next
    163          int inv_icm20948_write_single_mems_reg(struct inv_icm20948 * s, uint16_t reg, const unsigned char data)
    164          {
   \                     inv_icm20948_write_single_mems_reg: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    165              int result = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    166              unsigned char regOnly = (unsigned char)(reg & 0x7F);
   \   00000008   0xF005 0x077F      AND      R7,R5,#0x7F
    167          
    168          
    169              unsigned char power_state = inv_icm20948_get_chip_power_state(s);
    170          
    171              if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
   \   0000000C   0x.... 0x....      BL       inv_icm20948_get_chip_power_state
   \   00000010   0x07C0             LSLS     R0,R0,#+31
   \   00000012   0xD405             BMI.N    ??inv_icm20948_write_single_mems_reg_0
    172                  result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x4611             MOV      R1,R2
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   0000001E   0x4606             MOV      R6,R0
    173          
    174              if(check_reg_access_lp_disable(s, reg))   // Check if register needs LP_EN to be disabled
   \                     ??inv_icm20948_write_single_mems_reg_0: (+1)
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       check_reg_access_lp_disable
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD005             BEQ.N    ??inv_icm20948_write_single_mems_reg_1
    175                  result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000036   0x4306             ORRS     R6,R0,R6
    176          
    177              result |= inv_set_bank(s, reg >> 7);
   \                     ??inv_icm20948_write_single_mems_reg_1: (+1)
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x09C1             LSRS     R1,R0,#+7
   \   0000003C   0xB2C9             UXTB     R1,R1
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       inv_set_bank
   \   00000044   0x4306             ORRS     R6,R0,R6
    178              result |= inv_icm20948_write_reg(s, regOnly, &data, 1);
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x466A             MOV      R2,SP
   \   0000004A   0x4639             MOV      R1,R7
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       inv_icm20948_write_reg
   \   00000052   0x4306             ORRS     R6,R0,R6
    179          
    180              if(check_reg_access_lp_disable(s, reg))   //Enable LP_EN since we disabled it at begining of this function.
   \   00000054   0x4629             MOV      R1,R5
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       check_reg_access_lp_disable
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD005             BEQ.N    ??inv_icm20948_write_single_mems_reg_2
    181                  result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0x2102             MOVS     R1,#+2
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   0000006A   0x4306             ORRS     R6,R0,R6
    182          
    183              return result;
   \                     ??inv_icm20948_write_single_mems_reg_2: (+1)
   \   0000006C   0x4630             MOV      R0,R6
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    184          }
    185          
    186          /**
    187          *  @brief      Read data from a register on MEMs.
    188          *  @param[in]  Register address
    189          *  @param[in]  Length of data
    190          *  @param[in]  Data to be written
    191          *  @return     0 if successful.
    192          */

   \                                 In section .text, align 2, keep-with-next
    193          int inv_icm20948_read_mems_reg(struct inv_icm20948 * s, uint16_t reg, unsigned int length, unsigned char *data)
    194          {
   \                     inv_icm20948_read_mems_reg: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    195          	int result = 0;
   \   0000000E   0xF04F 0x0A00      MOV      R10,#+0
    196          	unsigned int bytesRead = 0;
   \   00000012   0x46D0             MOV      R8,R10
    197          	unsigned char regOnly = (unsigned char)(reg & 0x7F);
   \   00000014   0xF005 0x097F      AND      R9,R5,#0x7F
    198          	unsigned char i, dat[INV_MAX_SERIAL_READ];
    199          	unsigned char power_state = inv_icm20948_get_chip_power_state(s);
    200          
    201          	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
   \   00000018   0x.... 0x....      BL       inv_icm20948_get_chip_power_state
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD405             BMI.N    ??inv_icm20948_read_mems_reg_0
    202          		result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x4611             MOV      R1,R2
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   0000002A   0x4682             MOV      R10,R0
    203          
    204          	if(check_reg_access_lp_disable(s, reg))   // Check if register needs LP_EN to be disabled
   \                     ??inv_icm20948_read_mems_reg_0: (+1)
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       check_reg_access_lp_disable
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??inv_icm20948_read_mems_reg_1
    205          		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
   \   00000038   0x4642             MOV      R2,R8
   \   0000003A   0x2102             MOVS     R1,#+2
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000042   0xEA40 0x0A0A      ORR      R10,R0,R10
    206          
    207          	result |= inv_set_bank(s, reg >> 7);
   \                     ??inv_icm20948_read_mems_reg_1: (+1)
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x09C1             LSRS     R1,R0,#+7
   \   0000004A   0xB2C9             UXTB     R1,R1
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       inv_set_bank
   \   00000052   0xEA40 0x0A0A      ORR      R10,R0,R10
   \   00000056   0xE00B             B.N      ??inv_icm20948_read_mems_reg_2
    208          
    209          	while (bytesRead<length) 
    210          	{
    211          		int thisLen = min(INV_MAX_SERIAL_READ, length-bytesRead);
    212          		if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
    213          			result |= inv_icm20948_read_reg(s, regOnly+bytesRead, &dat[bytesRead], thisLen);
    214          		} else {
    215          			result |= inv_icm20948_read_reg(s, regOnly+bytesRead, &data[bytesRead],thisLen);
   \                     ??inv_icm20948_read_mems_reg_3: (+1)
   \   00000058   0xEB07 0x0208      ADD      R2,R7,R8
   \   0000005C   0xB2C9             UXTB     R1,R1
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       inv_icm20948_read_reg
   \   00000064   0xEA40 0x0A0A      ORR      R10,R0,R10
    216          		}
    217          
    218          		if (result)
   \                     ??inv_icm20948_read_mems_reg_4: (+1)
   \   00000068   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000006C   0xD135             BNE.N    ??inv_icm20948_read_mems_reg_5
    219          			return result;
    220          
    221          		bytesRead += thisLen;
   \   0000006E   0x44D8             ADD      R8,R11,R8
   \                     ??inv_icm20948_read_mems_reg_2: (+1)
   \   00000070   0x45B0             CMP      R8,R6
   \   00000072   0xD217             BCS.N    ??inv_icm20948_read_mems_reg_6
   \   00000074   0xEBA6 0x0B08      SUB      R11,R6,R8
   \   00000078   0xF1BB 0x0F11      CMP      R11,#+17
   \   0000007C   0xD301             BCC.N    ??inv_icm20948_read_mems_reg_7
   \   0000007E   0xF04F 0x0B10      MOV      R11,#+16
   \                     ??inv_icm20948_read_mems_reg_7: (+1)
   \   00000082   0xEB08 0x0109      ADD      R1,R8,R9
   \   00000086   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0x465B             MOV      R3,R11
   \   0000008E   0xD1E3             BNE.N    ??inv_icm20948_read_mems_reg_3
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0xEB00 0x0208      ADD      R2,R0,R8
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       inv_icm20948_read_reg
   \   0000009E   0xEA40 0x0A0A      ORR      R10,R0,R10
   \   000000A2   0xE7E1             B.N      ??inv_icm20948_read_mems_reg_4
    222          	}
    223          
    224          	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
   \                     ??inv_icm20948_read_mems_reg_6: (+1)
   \   000000A4   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   000000A8   0x2802             CMP      R0,#+2
   \   000000AA   0xD109             BNE.N    ??inv_icm20948_read_mems_reg_8
    225          		for (i=0; i< length; i++) {
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE004             B.N      ??inv_icm20948_read_mems_reg_9
    226          			*data= dat[i];
   \                     ??inv_icm20948_read_mems_reg_10: (+1)
   \   000000B0   0x4669             MOV      R1,SP
   \   000000B2   0x5C09             LDRB     R1,[R1, R0]
   \   000000B4   0xF807 0x1B01      STRB     R1,[R7], #+1
    227          			 data++;
    228          		}
   \   000000B8   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_read_mems_reg_9: (+1)
   \   000000BA   0xB2C0             UXTB     R0,R0
   \   000000BC   0x42B0             CMP      R0,R6
   \   000000BE   0xD3F7             BCC.N    ??inv_icm20948_read_mems_reg_10
    229          	}
    230          
    231          	if(check_reg_access_lp_disable(s, reg))    // Check if register needs LP_EN to be enabled  
   \                     ??inv_icm20948_read_mems_reg_8: (+1)
   \   000000C0   0x4629             MOV      R1,R5
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       check_reg_access_lp_disable
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD006             BEQ.N    ??inv_icm20948_read_mems_reg_5
    232          		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);  //Enable LP_EN
   \   000000CC   0x2201             MOVS     R2,#+1
   \   000000CE   0x2102             MOVS     R1,#+2
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   000000D6   0xEA40 0x0A0A      ORR      R10,R0,R10
    233          
    234          	return result;
   \                     ??inv_icm20948_read_mems_reg_5: (+1)
   \   000000DA   0x4650             MOV      R0,R10
   \   000000DC   0xB005             ADD      SP,SP,#+20
   \   000000DE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    235          }
    236          
    237          /**
    238          *  @brief      Read data from a register in DMP memory 
    239          *  @param[in]  DMP memory address
    240          *  @param[in]  number of byte to be read
    241          *  @param[in]  input data from the register
    242          *  @return     0 if successful.
    243          */

   \                                 In section .text, align 2, keep-with-next
    244          int inv_icm20948_read_mems(struct inv_icm20948 * s, unsigned short reg, unsigned int length, unsigned char *data)
    245          {
   \                     inv_icm20948_read_mems: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    246          	int result=0;
   \   0000000E   0x2700             MOVS     R7,#+0
    247          	unsigned int bytesWritten = 0;
   \   00000010   0x46B8             MOV      R8,R7
    248          	unsigned int thisLen;
    249          	unsigned char i, dat[INV_MAX_SERIAL_READ] = {0};
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0x2110             MOVS     R1,#+16
   \   00000016   0x.... 0x....      BL       __aeabi_memclr4
    250          	unsigned char power_state = inv_icm20948_get_chip_power_state(s);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       inv_icm20948_get_chip_power_state
    251          	unsigned char lBankSelected;
    252          	unsigned char lStartAddrSelected;
    253          
    254          	if(!data)
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD102             BNE.N    ??inv_icm20948_read_mems_0
    255          		return -1;
   \   00000024   0xF04F 0x30FF      MOV      R0,#-1
   \   00000028   0xE077             B.N      ??inv_icm20948_read_mems_1
    256          
    257          	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
   \                     ??inv_icm20948_read_mems_0: (+1)
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD405             BMI.N    ??inv_icm20948_read_mems_2
    258          		result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x4611             MOV      R1,R2
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000038   0x4607             MOV      R7,R0
    259          
    260          	if(check_reg_access_lp_disable(s, reg))
   \                     ??inv_icm20948_read_mems_2: (+1)
   \   0000003A   0x4649             MOV      R1,R9
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       check_reg_access_lp_disable
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD005             BEQ.N    ??inv_icm20948_read_mems_3
    261          		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);
   \   00000046   0x4642             MOV      R2,R8
   \   00000048   0x2102             MOVS     R1,#+2
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000050   0x4307             ORRS     R7,R0,R7
    262          
    263          	result |= inv_set_bank(s, 0);
   \                     ??inv_icm20948_read_mems_3: (+1)
   \   00000052   0x4641             MOV      R1,R8
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       inv_set_bank
   \   0000005A   0x4307             ORRS     R7,R0,R7
    264          
    265          	lBankSelected = (reg >> 8);
   \   0000005C   0x4648             MOV      R0,R9
   \   0000005E   0x0A00             LSRS     R0,R0,#+8
   \   00000060   0xF88D 0x0000      STRB     R0,[SP, #+0]
    266          	if (lBankSelected != s->lLastBankSelected)
   \   00000064   0xF894 0x14DC      LDRB     R1,[R4, #+1244]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD017             BEQ.N    ??inv_icm20948_read_mems_4
    267          	{
    268          		result |= inv_icm20948_write_reg(s, REG_MEM_BANK_SEL, &lBankSelected, 1);
   \   0000006C   0x2301             MOVS     R3,#+1
   \   0000006E   0x466A             MOV      R2,SP
   \   00000070   0x217E             MOVS     R1,#+126
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       inv_icm20948_write_reg
   \   00000078   0x4307             ORRS     R7,R0,R7
    269          		if (result)
   \   0000007A   0xD14D             BNE.N    ??inv_icm20948_read_mems_5
    270          			return result;
    271          		s->lLastBankSelected = lBankSelected;
   \   0000007C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000080   0xF884 0x04DC      STRB     R0,[R4, #+1244]
   \   00000084   0xE00A             B.N      ??inv_icm20948_read_mems_4
    272          	}
    273          
    274          	while (bytesWritten < length) 
    275          	{
    276          		lStartAddrSelected = (reg & 0xff);
    277          		/* Sets the starting read or write address for the selected memory, inside of the selected page (see MEM_SEL Register).
    278          		   Contents are changed after read or write of the selected memory.
    279          		   This register must be written prior to each access to initialize the register to the proper starting address.
    280          		   The address will auto increment during burst transactions.  Two consecutive bursts without re-initializing the start address would skip one address. */
    281          		result |= inv_icm20948_write_reg(s, REG_MEM_START_ADDR, &lStartAddrSelected, 1);
    282          		if (result)
    283          			return result;
    284          		
    285          		thisLen = min(INV_MAX_SERIAL_READ, length-bytesWritten);
    286          		/* Write data */
    287          		if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
    288          			result |= inv_icm20948_read_reg(s, REG_MEM_R_W, &dat[bytesWritten], thisLen);
    289          		} else {
    290          			result |= inv_icm20948_read_reg(s, REG_MEM_R_W, &data[bytesWritten], thisLen);
   \                     ??inv_icm20948_read_mems_6: (+1)
   \   00000086   0xEB06 0x0208      ADD      R2,R6,R8
   \   0000008A   0x217D             MOVS     R1,#+125
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       inv_icm20948_read_reg
   \   00000092   0x4607             MOV      R7,R0
    291          		}
    292          		if (result)
   \                     ??inv_icm20948_read_mems_7: (+1)
   \   00000094   0x2F00             CMP      R7,#+0
   \   00000096   0xD13F             BNE.N    ??inv_icm20948_read_mems_5
    293          			return result;
    294          		
    295          		bytesWritten += thisLen;
   \   00000098   0x44D0             ADD      R8,R10,R8
    296          		reg += thisLen;
   \   0000009A   0x44D1             ADD      R9,R10,R9
   \                     ??inv_icm20948_read_mems_4: (+1)
   \   0000009C   0x45A8             CMP      R8,R5
   \   0000009E   0xD220             BCS.N    ??inv_icm20948_read_mems_8
   \   000000A0   0x4648             MOV      R0,R9
   \   000000A2   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   000000A6   0x2301             MOVS     R3,#+1
   \   000000A8   0xF10D 0x0201      ADD      R2,SP,#+1
   \   000000AC   0x217C             MOVS     R1,#+124
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       inv_icm20948_write_reg
   \   000000B4   0x4307             ORRS     R7,R0,R7
   \   000000B6   0xD12F             BNE.N    ??inv_icm20948_read_mems_5
   \   000000B8   0xEBA5 0x0A08      SUB      R10,R5,R8
   \   000000BC   0xF1BA 0x0F11      CMP      R10,#+17
   \   000000C0   0xD301             BCC.N    ??inv_icm20948_read_mems_9
   \   000000C2   0xF04F 0x0A10      MOV      R10,#+16
   \                     ??inv_icm20948_read_mems_9: (+1)
   \   000000C6   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   000000CA   0x2802             CMP      R0,#+2
   \   000000CC   0x4653             MOV      R3,R10
   \   000000CE   0xD1DA             BNE.N    ??inv_icm20948_read_mems_6
   \   000000D0   0xA801             ADD      R0,SP,#+4
   \   000000D2   0xEB00 0x0208      ADD      R2,R0,R8
   \   000000D6   0x217D             MOVS     R1,#+125
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0x.... 0x....      BL       inv_icm20948_read_reg
   \   000000DE   0x4607             MOV      R7,R0
   \   000000E0   0xE7D8             B.N      ??inv_icm20948_read_mems_7
    297          	}
    298          
    299          	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
   \                     ??inv_icm20948_read_mems_8: (+1)
   \   000000E2   0xF894 0x0027      LDRB     R0,[R4, #+39]
   \   000000E6   0x2802             CMP      R0,#+2
   \   000000E8   0xD109             BNE.N    ??inv_icm20948_read_mems_10
    300          		for (i=0; i< length; i++) {
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xE004             B.N      ??inv_icm20948_read_mems_11
    301          			*data= dat[i];
   \                     ??inv_icm20948_read_mems_12: (+1)
   \   000000EE   0xA901             ADD      R1,SP,#+4
   \   000000F0   0x5C09             LDRB     R1,[R1, R0]
   \   000000F2   0xF806 0x1B01      STRB     R1,[R6], #+1
    302          			 data++;
    303          		}
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_read_mems_11: (+1)
   \   000000F8   0xB2C0             UXTB     R0,R0
   \   000000FA   0x42A8             CMP      R0,R5
   \   000000FC   0xD3F7             BCC.N    ??inv_icm20948_read_mems_12
    304          	}
    305          
    306          	//Enable LP_EN if we disabled it at begining of this function.
    307          	if(check_reg_access_lp_disable(s, reg))
   \                     ??inv_icm20948_read_mems_10: (+1)
   \   000000FE   0x4649             MOV      R1,R9
   \   00000100   0xB289             UXTH     R1,R1
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0x.... 0x....      BL       check_reg_access_lp_disable
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD005             BEQ.N    ??inv_icm20948_read_mems_5
    308          		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
   \   0000010C   0x2201             MOVS     R2,#+1
   \   0000010E   0x2102             MOVS     R1,#+2
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000116   0x4307             ORRS     R7,R0,R7
    309          
    310          	return result;
   \                     ??inv_icm20948_read_mems_5: (+1)
   \   00000118   0x4638             MOV      R0,R7
   \                     ??inv_icm20948_read_mems_1: (+1)
   \   0000011A   0xB006             ADD      SP,SP,#+24
   \   0000011C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    311          }
    312          
    313          /**
    314          *  @brief       Write data to a register in DMP memory 
    315          *  @param[in]   DMP memory address
    316          *  @param[in]   number of byte to be written
    317          *  @param[out]  output data from the register
    318          *  @return     0 if successful.
    319          */

   \                                 In section .text, align 2, keep-with-next
    320          int inv_icm20948_write_mems(struct inv_icm20948 * s, unsigned short reg, unsigned int length, const unsigned char *data)
    321          {
   \                     inv_icm20948_write_mems: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x461E             MOV      R6,R3
    322              int result=0;
   \   0000000E   0xF04F 0x0800      MOV      R8,#+0
    323              unsigned int bytesWritten = 0;
   \   00000012   0x4647             MOV      R7,R8
    324              unsigned int thisLen;
    325              unsigned char lBankSelected;
    326              unsigned char lStartAddrSelected;
    327              
    328              unsigned char power_state = inv_icm20948_get_chip_power_state(s);
   \   00000014   0x.... 0x....      BL       inv_icm20948_get_chip_power_state
    329          
    330              if(!data)
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD102             BNE.N    ??inv_icm20948_write_mems_0
    331                  return -1;
   \   0000001C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000020   0xE056             B.N      ??inv_icm20948_write_mems_1
    332              
    333              if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
   \                     ??inv_icm20948_write_mems_0: (+1)
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD405             BMI.N    ??inv_icm20948_write_mems_2
    334                  result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x4611             MOV      R1,R2
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000030   0x4680             MOV      R8,R0
    335          
    336              result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);
   \                     ??inv_icm20948_write_mems_2: (+1)
   \   00000032   0x463A             MOV      R2,R7
   \   00000034   0x2102             MOVS     R1,#+2
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   0000003C   0xEA40 0x0808      ORR      R8,R0,R8
    337                      
    338          	result |= inv_set_bank(s, 0);
   \   00000040   0x4639             MOV      R1,R7
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       inv_set_bank
   \   00000048   0xEA40 0x0808      ORR      R8,R0,R8
    339              
    340              lBankSelected = (reg >> 8);
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x0A00             LSRS     R0,R0,#+8
   \   00000050   0xF88D 0x0000      STRB     R0,[SP, #+0]
    341          	if (lBankSelected != s->lLastBankSelected)
   \   00000054   0xF894 0x14DC      LDRB     R1,[R4, #+1244]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD00F             BEQ.N    ??inv_icm20948_write_mems_3
    342          	{
    343          		result |= inv_icm20948_write_reg(s, REG_MEM_BANK_SEL, &lBankSelected, 1);
   \   0000005C   0x2301             MOVS     R3,#+1
   \   0000005E   0x466A             MOV      R2,SP
   \   00000060   0x217E             MOVS     R1,#+126
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       inv_icm20948_write_reg
   \   00000068   0xEA50 0x0808      ORRS     R8,R0,R8
    344          		if (result)
   \   0000006C   0xD126             BNE.N    ??inv_icm20948_write_mems_4
    345          			return result;
    346          		s->lLastBankSelected = lBankSelected;
   \   0000006E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000072   0xF884 0x04DC      STRB     R0,[R4, #+1244]
   \   00000076   0xE001             B.N      ??inv_icm20948_write_mems_3
    347          	}
    348              
    349              while (bytesWritten < length) 
    350              {
    351                  lStartAddrSelected = (reg & 0xff);
    352                  /* Sets the starting read or write address for the selected memory, inside of the selected page (see MEM_SEL Register).
    353                     Contents are changed after read or write of the selected memory.
    354                     This register must be written prior to each access to initialize the register to the proper starting address.
    355                     The address will auto increment during burst transactions.  Two consecutive bursts without re-initializing the start address would skip one address. */
    356                  result |= inv_icm20948_write_reg(s, REG_MEM_START_ADDR, &lStartAddrSelected, 1);
    357                  if (result)
    358                      return result;
    359                  
    360                  thisLen = min(INV_MAX_SERIAL_WRITE, length-bytesWritten);
    361                  
    362                  /* Write data */ 
    363                  result |= inv_icm20948_write_reg(s, REG_MEM_R_W, &data[bytesWritten], thisLen);
    364                  if (result)
    365                      return result;
    366                  
    367                  bytesWritten += thisLen;
   \                     ??inv_icm20948_write_mems_5: (+1)
   \   00000078   0x4457             ADD      R7,R10,R7
    368                  reg += thisLen;
   \   0000007A   0x44D1             ADD      R9,R10,R9
   \                     ??inv_icm20948_write_mems_3: (+1)
   \   0000007C   0x42AF             CMP      R7,R5
   \   0000007E   0xD21F             BCS.N    ??inv_icm20948_write_mems_6
   \   00000080   0x4648             MOV      R0,R9
   \   00000082   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000086   0x2301             MOVS     R3,#+1
   \   00000088   0xF10D 0x0201      ADD      R2,SP,#+1
   \   0000008C   0x217C             MOVS     R1,#+124
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       inv_icm20948_write_reg
   \   00000094   0xEA50 0x0808      ORRS     R8,R0,R8
   \   00000098   0xD110             BNE.N    ??inv_icm20948_write_mems_4
   \   0000009A   0xEBA5 0x0A07      SUB      R10,R5,R7
   \   0000009E   0xF1BA 0x0F11      CMP      R10,#+17
   \   000000A2   0xD301             BCC.N    ??inv_icm20948_write_mems_7
   \   000000A4   0xF04F 0x0A10      MOV      R10,#+16
   \                     ??inv_icm20948_write_mems_7: (+1)
   \   000000A8   0x4653             MOV      R3,R10
   \   000000AA   0x19F2             ADDS     R2,R6,R7
   \   000000AC   0x217D             MOVS     R1,#+125
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       inv_icm20948_write_reg
   \   000000B4   0x4680             MOV      R8,R0
   \   000000B6   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000BA   0xD0DD             BEQ.N    ??inv_icm20948_write_mems_5
   \                     ??inv_icm20948_write_mems_4: (+1)
   \   000000BC   0x4640             MOV      R0,R8
   \   000000BE   0xE007             B.N      ??inv_icm20948_write_mems_1
    369              }
    370          
    371              //Enable LP_EN since we disabled it at begining of this function.
    372              result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
   \                     ??inv_icm20948_write_mems_6: (+1)
   \   000000C0   0x2201             MOVS     R2,#+1
   \   000000C2   0x2102             MOVS     R1,#+2
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   000000CA   0xEA40 0x0808      ORR      R8,R0,R8
    373          
    374              return result;
   \   000000CE   0x4640             MOV      R0,R8
   \                     ??inv_icm20948_write_mems_1: (+1)
   \   000000D0   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    375          }
    376          
    377          /**
    378          *  @brief      Write single byte of data to a register on MEMs with no power control
    379          *  @param[in]  Register address
    380          *  @param[in]  Data to be written
    381          *  @return     0 if successful.
    382          */

   \                                 In section .text, align 2, keep-with-next
    383          int inv_icm20948_write_single_mems_reg_core(struct inv_icm20948 * s, uint16_t reg, const uint8_t data)
    384          {
   \                     inv_icm20948_write_single_mems_reg_core: (+1)
   \   00000000   0xB576             PUSH     {R1,R2,R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    385              int result = 0;
    386              unsigned char regOnly = (unsigned char)(reg & 0x7F);
    387          
    388              result |= inv_set_bank(s, reg >> 7);
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x09C1             LSRS     R1,R0,#+7
   \   0000000A   0xB2C9             UXTB     R1,R1
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       inv_set_bank
   \   00000012   0x4606             MOV      R6,R0
    389              result |= inv_icm20948_write_reg(s, regOnly, &data, 1);
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0xAA01             ADD      R2,SP,#+4
   \   00000018   0xF005 0x017F      AND      R1,R5,#0x7F
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       inv_icm20948_write_reg
   \   00000022   0x4330             ORRS     R0,R0,R6
    390          
    391              return result;
   \   00000024   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    392          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x73 0x00          DC8      "s",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x70          DC8 5CH, 70H, 72H, 61H, 73H, 61H, 5CH, 44H
   \              0x72 0x61    
   \              0x73 0x61    
   \              0x5C 0x44    
   \   00000010   0x6F 0x63          DC8 6FH, 63H, 75H, 6DH, 65H, 6EH, 74H, 73H
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x73    
   \   00000018   0x5C 0x31          DC8 5CH, 31H, 2EH, 30H, 2EH, 30H, 5CH, 73H
   \              0x2E 0x30    
   \              0x2E 0x30    
   \              0x5C 0x73    
   \   00000020   0x6F 0x75          DC8 6FH, 75H, 72H, 63H, 65H, 73H, 5CH, 49H
   \              0x72 0x63    
   \              0x65 0x73    
   \              0x5C 0x49    
   \   00000028   0x6E 0x76          DC8 6EH, 76H, 6EH, 5CH, 44H, 65H, 76H, 69H
   \              0x6E 0x5C    
   \              0x44 0x65    
   \              0x76 0x69    
   \   00000030   0x63 0x65          DC8 63H, 65H, 73H, 5CH, 44H, 72H, 69H, 76H
   \              0x73 0x5C    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000038   0x65 0x72          DC8 65H, 72H, 73H, 5CH, 49H, 63H, 6DH, 32H
   \              0x73 0x5C    
   \              0x49 0x63    
   \              0x6D 0x32    
   \   00000040   0x30 0x39          DC8 30H, 39H, 34H, 38H, 5CH, 49H, 63H, 6DH
   \              0x34 0x38    
   \              0x5C 0x49    
   \              0x63 0x6D    
   \   00000048   0x32 0x30          DC8 32H, 30H, 39H, 34H, 38H, 53H, 65H, 72H
   \              0x39 0x34    
   \              0x38 0x53    
   \              0x65 0x72    
   \   00000050   0x69 0x66          DC8 69H, 66H, 2EH, 68H, 0
   \              0x2E 0x68    
   \              0x00         
   \   00000055   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_0:
   \   00000000   0x73 0x00          DC8 "s"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   check_reg_access_lp_disable
         0   -> inv_icm20948_ctrl_get_batch_mode_status
       0   inv_icm20948_get_tick_count
         0   -> inv_icm20948_get_time_us
      56   inv_icm20948_read_mems
        56   -> __aeabi_memclr4
        56   -> check_reg_access_lp_disable
        56   -> inv_icm20948_get_chip_power_state
        56   -> inv_icm20948_read_reg
        56   -> inv_icm20948_set_chip_power_state
        56   -> inv_icm20948_write_reg
        56   -> inv_set_bank
      56   inv_icm20948_read_mems_reg
        56   -> check_reg_access_lp_disable
        56   -> inv_icm20948_get_chip_power_state
        56   -> inv_icm20948_read_reg
        56   -> inv_icm20948_set_chip_power_state
        56   -> inv_set_bank
       0   inv_icm20948_read_reg
         0   -> inv_icm20948_serif_read_reg
      24   inv_icm20948_serif_read_reg
        24   -- Indirect call
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
      24   inv_icm20948_serif_write_reg
        24   -- Indirect call
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
       0   inv_icm20948_sleep_100us
         0   -> inv_icm20948_sleep_us
       0   inv_icm20948_transport_init
      40   inv_icm20948_write_mems
        40   -> inv_icm20948_get_chip_power_state
        40   -> inv_icm20948_set_chip_power_state
        40   -> inv_icm20948_write_reg
        40   -> inv_set_bank
      40   inv_icm20948_write_mems_reg
        40   -> check_reg_access_lp_disable
        40   -> inv_icm20948_get_chip_power_state
        40   -> inv_icm20948_set_chip_power_state
        40   -> inv_icm20948_write_reg
        40   -> inv_set_bank
       0   inv_icm20948_write_reg
         0   -> inv_icm20948_serif_write_reg
      24   inv_icm20948_write_single_mems_reg
        24   -> check_reg_access_lp_disable
        24   -> inv_icm20948_get_chip_power_state
        24   -> inv_icm20948_set_chip_power_state
        24   -> inv_icm20948_write_reg
        24   -> inv_set_bank
      24   inv_icm20948_write_single_mems_reg_core
        24   -> inv_icm20948_write_reg
        24   -> inv_set_bank
      16   inv_set_bank
        16   -> inv_icm20948_read_reg
         0   -> inv_icm20948_write_reg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       2  ?_0
      88  ?_1
      16  ?_2
      48  check_reg_access_lp_disable
       4  icm20948_instance
       4  inv_icm20948_get_tick_count
     288  inv_icm20948_read_mems
     226  inv_icm20948_read_mems_reg
       2  inv_icm20948_read_reg
      68  inv_icm20948_serif_read_reg
      68  inv_icm20948_serif_write_reg
       8  inv_icm20948_sleep_100us
      14  inv_icm20948_transport_init
     212  inv_icm20948_write_mems
     164  inv_icm20948_write_mems_reg
       2  inv_icm20948_write_reg
     112  inv_icm20948_write_single_mems_reg
      38  inv_icm20948_write_single_mems_reg_core
      70  inv_set_bank

 
     4 bytes in section .bss
    18 bytes in section .rodata
 1 416 bytes in section .text
 
 1 416 bytes of CODE  memory
    18 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
