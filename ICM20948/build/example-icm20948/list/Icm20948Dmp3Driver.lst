###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:29
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948Dmp3Driver.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948Dmp3Driver.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\Icm20948Dmp3Driver.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\Icm20948Dmp3Driver.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948Dmp3Driver.c
      1          /*
      2          * ________________________________________________________________________________________________________
      3          * Copyright © 2014 InvenSense Inc.  All rights reserved.
      4          *
      5          * This software and/or documentation  (collectively “Software”) is subject to InvenSense intellectual property rights 
      6          * under U.S. and international copyright and other intellectual property rights laws.
      7          *
      8          * The Software contained herein is PROPRIETARY and CONFIDENTIAL to InvenSense and is provided 
      9          * solely under the terms and conditions of a form of InvenSense software license agreement between 
     10          * InvenSense and you and any use, modification, reproduction or disclosure of the Software without 
     11          * such agreement or the express written consent of InvenSense is strictly prohibited.
     12          *
     13          * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS 
     14          * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED 
     15          * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16          * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL 
     17          * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18          * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, 
     19          * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20          * OF THE SOFTWARE.
     21          * ________________________________________________________________________________________________________
     22          */
     23          
     24          #include "Icm20948.h"
     25          #include "Icm20948Dmp3Driver.h"
     26          #include "Icm20948LoadFirmware.h"
     27          #include "Icm20948Defs.h"
     28          
     29          #define CFG_FIFO_SIZE                   (4184)
     30          
     31          // data output control
     32          #define DATA_OUT_CTL1			(4 * 16)
     33          #define DATA_OUT_CTL2			(4 * 16 + 2)
     34          #define DATA_INTR_CTL			(4 * 16 + 12)
     35          #define FIFO_WATERMARK			(31 * 16 + 14)
     36          
     37          // motion event control
     38          #define MOTION_EVENT_CTL		(4 * 16 + 14)
     39          
     40          // indicates to DMP which sensors are available
     41          /*	1: gyro samples available
     42          	2: accel samples available
     43          	8: secondary samples available	*/
     44          #define DATA_RDY_STATUS			(8 * 16 + 10)
     45          
     46          // batch mode
     47          #define BM_BATCH_CNTR			(27 * 16)
     48          #define BM_BATCH_THLD			(19 * 16 + 12)
     49          #define BM_BATCH_MASK			(21 * 16 + 14)
     50          
     51          // sensor output data rate
     52          #define ODR_ACCEL				(11 * 16 + 14)
     53          #define ODR_GYRO				(11 * 16 + 10)
     54          #define ODR_CPASS				(11 * 16 +  6)
     55          #define ODR_ALS					(11 * 16 +  2)
     56          #define ODR_QUAT6				(10 * 16 + 12)
     57          #define ODR_QUAT9				(10 * 16 +  8)
     58          #define ODR_PQUAT6				(10 * 16 +  4)
     59          #define ODR_GEOMAG				(10 * 16 +  0)
     60          #define ODR_PRESSURE			(11 * 16 + 12)
     61          #define ODR_GYRO_CALIBR			(11 * 16 +  8)
     62          #define ODR_CPASS_CALIBR		(11 * 16 +  4)
     63          
     64          // sensor output data rate counter
     65          #define ODR_CNTR_ACCEL			(9 * 16 + 14)
     66          #define ODR_CNTR_GYRO			(9 * 16 + 10)
     67          #define ODR_CNTR_CPASS			(9 * 16 +  6)
     68          #define ODR_CNTR_ALS			(9 * 16 +  2)
     69          #define ODR_CNTR_QUAT6			(8 * 16 + 12)
     70          #define ODR_CNTR_QUAT9			(8 * 16 +  8)
     71          #define ODR_CNTR_PQUAT6			(8 * 16 +  4)
     72          #define ODR_CNTR_GEOMAG			(8 * 16 +  0)
     73          #define ODR_CNTR_PRESSURE		(9 * 16 + 12)
     74          #define ODR_CNTR_GYRO_CALIBR	(9 * 16 +  8)
     75          #define ODR_CNTR_CPASS_CALIBR	(9 * 16 +  4)
     76          
     77          // mounting matrix
     78          #define CPASS_MTX_00            (23 * 16)
     79          #define CPASS_MTX_01            (23 * 16 + 4)
     80          #define CPASS_MTX_02            (23 * 16 + 8)
     81          #define CPASS_MTX_10            (23 * 16 + 12)
     82          #define CPASS_MTX_11            (24 * 16)
     83          #define CPASS_MTX_12            (24 * 16 + 4)
     84          #define CPASS_MTX_20            (24 * 16 + 8)
     85          #define CPASS_MTX_21            (24 * 16 + 12)
     86          #define CPASS_MTX_22            (25 * 16)
     87          
     88          #define GYRO_SF					(19 * 16)
     89          #define ACCEL_FB_GAIN			(34 * 16)
     90          #define ACCEL_ONLY_GAIN			(16 * 16 + 12)
     91          
     92          // bias calibration
     93          #define GYRO_BIAS_X				(139 * 16 +  4)
     94          #define GYRO_BIAS_Y				(139 * 16 +  8)
     95          #define GYRO_BIAS_Z				(139 * 16 + 12)
     96          #define GYRO_ACCURACY			(138 * 16 +  2)
     97          #define GYRO_BIAS_SET			(138 * 16 +  6)
     98          #define GYRO_LAST_TEMPR			(134 * 16)
     99          #define GYRO_SLOPE_X			( 78 * 16 +  4)
    100          #define GYRO_SLOPE_Y			( 78 * 16 +  8)
    101          #define GYRO_SLOPE_Z			( 78 * 16 + 12)
    102          
    103          #define ACCEL_BIAS_X            (110 * 16 +  4)
    104          #define ACCEL_BIAS_Y            (110 * 16 +  8)
    105          #define ACCEL_BIAS_Z            (110 * 16 + 12)
    106          #define ACCEL_ACCURACY			(97 * 16)
    107          #define ACCEL_CAL_RESET			(77 * 16)
    108          #define ACCEL_VARIANCE_THRESH	(93 * 16)
    109          #define ACCEL_CAL_RATE			(94 * 16 + 4)
    110          #define ACCEL_PRE_SENSOR_DATA	(97 * 16 + 4)
    111          #define ACCEL_COVARIANCE		(101 * 16 + 8)
    112          #define ACCEL_ALPHA_VAR			(91 * 16)
    113          #define ACCEL_A_VAR				(92 * 16)
    114          #define ACCEL_CAL_INIT			(94 * 16 + 2)
    115          #define ACCEL_CAL_SCALE_COVQ_IN_RANGE	(194 * 16)
    116          #define ACCEL_CAL_SCALE_COVQ_OUT_RANGE	(195 * 16)
    117          #define ACCEL_CAL_TEMPERATURE_SENSITIVITY	(194 * 16 + 4)
    118          #define ACCEL_CAL_TEMPERATURE_OFFSET_TRIM	(194 * 16 + 12)
    119          
    120          #define CPASS_BIAS_X            (126 * 16 +  4)
    121          #define CPASS_BIAS_Y            (126 * 16 +  8)
    122          #define CPASS_BIAS_Z            (126 * 16 + 12)
    123          #define CPASS_ACCURACY			(37 * 16)
    124          #define CPASS_BIAS_SET			(34 * 16 + 14)
    125          #define MAR_MODE				(37 * 16 + 2)
    126          #define CPASS_COVARIANCE		(115 * 16)
    127          #define CPASS_COVARIANCE_CUR	(118 * 16 +  8)
    128          #define CPASS_REF_MAG_3D		(122 * 16)
    129          #define CPASS_CAL_INIT			(114 * 16)
    130          #define CPASS_EST_FIRST_BIAS	(113 * 16)
    131          #define MAG_DISTURB_STATE		(113 * 16 + 2)
    132          #define CPASS_VAR_COUNT			(112 * 16 + 6)
    133          #define CPASS_COUNT_7			( 87 * 16 + 2)
    134          #define CPASS_MAX_INNO			(124 * 16)
    135          #define CPASS_BIAS_OFFSET		(113 * 16 + 4)
    136          #define CPASS_CUR_BIAS_OFFSET	(114 * 16 + 4)
    137          #define CPASS_PRE_SENSOR_DATA	( 87 * 16 + 4)
    138          
    139          // Compass Cal params to be adjusted according to sampling rate
    140          #define CPASS_TIME_BUFFER		(112 * 16 + 14)
    141          #define CPASS_RADIUS_3D_THRESH_ANOMALY	(112 * 16 + 8)
    142          
    143          #define CPASS_STATUS_CHK		(25 * 16 + 12)
    144          
    145          // 9-axis
    146          #define MAGN_THR_9X				(80 * 16)
    147          #define MAGN_LPF_THR_9X			(80 * 16 +  8)
    148          #define QFB_THR_9X				(80 * 16 + 12)
    149          
    150          // DMP running counter
    151          #define DMPRATE_CNTR			(18 * 16 + 4)
    152          
    153          // pedometer
    154          #define PEDSTD_BP_B				(49 * 16 + 12)
    155          #define PEDSTD_BP_A4			(52 * 16)
    156          #define PEDSTD_BP_A3			(52 * 16 +  4)
    157          #define PEDSTD_BP_A2			(52 * 16 +  8)
    158          #define PEDSTD_BP_A1			(52 * 16 + 12)
    159          #define PEDSTD_SB				(50 * 16 +  8)
    160          #define PEDSTD_SB_TIME			(50 * 16 + 12)
    161          #define PEDSTD_PEAKTHRSH		(57 * 16 +  8)
    162          #define PEDSTD_TIML				(50 * 16 + 10)
    163          #define PEDSTD_TIMH				(50 * 16 + 14)
    164          #define PEDSTD_PEAK				(57 * 16 +  4)
    165          #define PEDSTD_STEPCTR			(54 * 16)
    166          #define PEDSTD_STEPCTR2			(58 * 16 +  8)
    167          #define PEDSTD_TIMECTR			(60 * 16 +  4)
    168          #define PEDSTD_DECI				(58 * 16)
    169          #define PEDSTD_SB2				(60 * 16 + 14)
    170          #define STPDET_TIMESTAMP		(18 * 16 +  8)
    171          #define PEDSTEP_IND				(19 * 16 +  4)
    172          #define PED_Y_RATIO				(17 * 16 +  0)
    173          
    174          // SMD
    175          #define SMD_VAR_TH              (141 * 16 + 12)
    176          #define SMD_VAR_TH_DRIVE        (143 * 16 + 12)
    177          #define SMD_DRIVE_TIMER_TH      (143 * 16 +  8)
    178          #define SMD_TILT_ANGLE_TH       (179 * 16 + 12)
    179          #define BAC_SMD_ST_TH           (179 * 16 +  8)
    180          #define BAC_ST_ALPHA4           (180 * 16 + 12)
    181          #define BAC_ST_ALPHA4A          (176 * 16 + 12)
    182          
    183          // Wake on Motion
    184          #define WOM_ENABLE              (64 * 16 + 14)
    185          #define WOM_STATUS              (64 * 16 + 6)
    186          #define WOM_THRESHOLD           (64 * 16)
    187          #define WOM_CNTR_TH             (64 * 16 + 12)
    188          
    189          // Activity Recognition
    190          #define BAC_RATE                (48  * 16 + 10)
    191          #define BAC_STATE               (179 * 16 +  0)
    192          #define BAC_STATE_PREV          (179 * 16 +  4)
    193          #define BAC_ACT_ON              (182 * 16 +  0)
    194          #define BAC_ACT_OFF             (183 * 16 +  0)
    195          #define BAC_STILL_S_F           (177 * 16 +  0)
    196          #define BAC_RUN_S_F             (177 * 16 +  4)
    197          #define BAC_DRIVE_S_F           (178 * 16 +  0)
    198          #define BAC_WALK_S_F            (178 * 16 +  4)
    199          #define BAC_SMD_S_F             (178 * 16 +  8)
    200          #define BAC_BIKE_S_F            (178 * 16 + 12)
    201          #define BAC_E1_SHORT            (146 * 16 +  0)
    202          #define BAC_E2_SHORT            (146 * 16 +  4)
    203          #define BAC_E3_SHORT            (146 * 16 +  8)
    204          #define BAC_VAR_RUN             (148 * 16 + 12)
    205          #define BAC_TILT_INIT           (181 * 16 +  0)
    206          #define BAC_MAG_ON              (225 * 16 +  0)
    207          #define BAC_PS_ON               (74  * 16 +  0)
    208          #define BAC_BIKE_PREFERENCE     (173 * 16 +  8)
    209          #define BAC_MAG_I2C_ADDR        (229 * 16 +  8)
    210          #define BAC_PS_I2C_ADDR         (75  * 16 +  4)
    211          #define BAC_DRIVE_CONFIDENCE    (144 * 16 +  0)
    212          #define BAC_WALK_CONFIDENCE     (144 * 16 +  4)
    213          #define BAC_SMD_CONFIDENCE      (144 * 16 +  8)
    214          #define BAC_BIKE_CONFIDENCE     (144 * 16 + 12)
    215          #define BAC_STILL_CONFIDENCE    (145 * 16 +  0)
    216          #define BAC_RUN_CONFIDENCE      (145 * 16 +  4)
    217          #define BAC_MODE_CNTR           (150 * 16)
    218          #define BAC_STATE_T_PREV        (185 * 16 +  4)
    219          #define BAC_ACT_T_ON            (184 * 16 +  0)
    220          #define BAC_ACT_T_OFF           (184 * 16 +  4)
    221          #define BAC_STATE_WRDBS_PREV    (185 * 16 +  8)
    222          #define BAC_ACT_WRDBS_ON        (184 * 16 +  8)
    223          #define BAC_ACT_WRDBS_OFF       (184 * 16 + 12)
    224          #define BAC_ACT_ON_OFF          (190 * 16 +  2)
    225          #define PREV_BAC_ACT_ON_OFF     (188 * 16 +  2)
    226          #define BAC_CNTR                (48  * 16 +  2)
    227          
    228          // Flip/Pick-up
    229          #define FP_VAR_ALPHA            (245 * 16 +  8)
    230          #define FP_STILL_TH             (246 * 16 +  4)
    231          #define FP_MID_STILL_TH         (244 * 16 +  8)
    232          #define FP_NOT_STILL_TH         (246 * 16 +  8)
    233          #define FP_VIB_REJ_TH           (241 * 16 +  8)
    234          #define FP_MAX_PICKUP_T_TH      (244 * 16 + 12)
    235          #define FP_PICKUP_TIMEOUT_TH    (248 * 16 +  8)
    236          #define FP_STILL_CONST_TH       (246 * 16 + 12)
    237          #define FP_MOTION_CONST_TH      (240 * 16 +  8)
    238          #define FP_VIB_COUNT_TH         (242 * 16 +  8)
    239          #define FP_STEADY_TILT_TH       (247 * 16 +  8)
    240          #define FP_STEADY_TILT_UP_TH    (242 * 16 + 12)
    241          #define FP_Z_FLAT_TH_MINUS      (243 * 16 +  8)
    242          #define FP_Z_FLAT_TH_PLUS       (243 * 16 + 12)
    243          #define FP_DEV_IN_POCKET_TH     (76  * 16 + 12)
    244          #define FP_PICKUP_CNTR          (247 * 16 +  4)
    245          #define FP_RATE                 (240 * 16 + 12)
    246          
    247          // Accel FSR
    248          #define ACC_SCALE               (30 * 16 + 0)
    249          #define ACC_SCALE2              (79 * 16 + 4)
    250          
    251          // EIS authentication
    252          #define EIS_AUTH_INPUT			(160 * 16 +   4)
    253          #define EIS_AUTH_OUTPUT			(160 * 16 +   0)
    254          
    255          // B2S
    256          #define B2S_RATE                (48  * 16 +   8)
    257          // mounting matrix
    258          #define B2S_MTX_00              (208 * 16)
    259          #define B2S_MTX_01              (208 * 16 + 4)
    260          #define B2S_MTX_02              (208 * 16 + 8)
    261          #define B2S_MTX_10              (208 * 16 + 12)
    262          #define B2S_MTX_11              (209 * 16)
    263          #define B2S_MTX_12              (209 * 16 + 4)
    264          #define B2S_MTX_20              (209 * 16 + 8)
    265          #define B2S_MTX_21              (209 * 16 + 12)
    266          #define B2S_MTX_22              (210 * 16)
    267          
    268          #define DMP_START_ADDRESS   ((unsigned short)0x1000)
    269          #define DMP_MEM_BANK_SIZE   256
    270          #define DMP_LOAD_START      0x90
    271          
    272          #define DMP_CODE_SIZE 14290
    273          
    274          /** Loads the dmp firmware for the icm20948 part.
    275          * @param[in] dmp_image_sram Load DMP3 image from SRAM.
    276          */

   \                                 In section .text, align 2, keep-with-next
    277          int inv_icm20948_load_firmware(struct inv_icm20948 * s, const unsigned char *dmp3_image, unsigned int dmp3_image_size)
    278          {
    279          	return inv_icm20948_firmware_load(s, dmp3_image, dmp3_image_size, DMP_LOAD_START);
   \                     inv_icm20948_load_firmware: (+1)
   \   00000000   0x2390             MOVS     R3,#+144
   \   00000002   0xB292             UXTH     R2,R2
   \   00000004   0x.... 0x....      B.W      inv_icm20948_firmware_load
    280          }
    281          
    282          /** Loads the dmp firmware for the icm20948 part.
    283          * @param[out] dmp_cnfg The config item
    284          */

   \                                 In section .text, align 2, keep-with-next
    285          void inv_icm20948_get_dmp_start_address(struct inv_icm20948 * s, unsigned short *dmp_cnfg)
    286          {
    287          
    288          	(void)s;
    289          
    290          	*dmp_cnfg = DMP_START_ADDRESS;
   \                     inv_icm20948_get_dmp_start_address: (+1)
   \   00000000   0xF44F 0x5080      MOV      R0,#+4096
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    291          }
   \   00000006   0x4770             BX       LR               ;; return
    292          
    293          /**
    294          * Sets data output control register 1.
    295          * @param[in] output_mask	Turns sensors on/off according to following bit definition,
    296          *							bit set indicates on, bit clear indicates off.
    297          *							DMP will also turn hw sensors on/off based on bits set in output_mask.
    298          *
    299          *	ACCEL_SET			0x8000 - calibrated accel if accel calibrated, raw accel otherwise
    300          *	GYRO_SET			0x4000 - raw gyro
    301          *	CPASS_SET			0x2000 - raw magnetic
    302          *	ALS_SET				0x1000 - ALS/proximity
    303          *	QUAT6_SET			0x0800 - game rotation vector
    304          *	QUAT9_SET			0x0400 - rotation vector with heading accuracy
    305          *	PQUAT6_SET			0x0200 - truncated game rotation vector for batching
    306          *	GEOMAG_SET			0x0100 - geomag rotation vector with heading accuracy
    307          *	PRESSURE_SET		0x0080 - pressure
    308          *	GYRO_CALIBR_SET		0x0040 - calibrated gyro
    309          *	CPASS_CALIBR_SET	0x0020 - calibrated magnetic
    310          *	PED_STEPDET_SET		0x0010 - timestamp when each step is detected
    311          *	HEADER2_SET			0x0008 - enable/disable data output in data output control register 2
    312          *	PED_STEPIND_SET		0x0007 - number of steps detected will be attached to the 3 least significant bits of header
    313          */

   \                                 In section .text, align 2, keep-with-next
    314          int dmp_icm20948_set_data_output_control1(struct inv_icm20948 * s, int output_mask)
    315          {
   \                     dmp_icm20948_set_data_output_control1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    316            
    317              int result;
    318              unsigned char data_output_control_reg1[2];
    319              
    320              data_output_control_reg1[0] = (unsigned char)(output_mask >> 8);
   \   00000002   0x120A             ASRS     R2,R1,#+8
   \   00000004   0xF88D 0x2000      STRB     R2,[SP, #+0]
    321              data_output_control_reg1[1] = (unsigned char)(output_mask & 0xff);
   \   00000008   0xF88D 0x1001      STRB     R1,[SP, #+1]
    322          
    323              result = inv_icm20948_write_mems(s, DATA_OUT_CTL1, 2, data_output_control_reg1);
    324          
    325              return result;
   \   0000000C   0x466B             MOV      R3,SP
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0x2140             MOVS     R1,#+64
   \   00000012   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    326          }
    327          
    328          /**
    329          * Sets data output control register 2.
    330          * @param[in] output_mask	Turns features on/off according to following bit definition,
    331          *							bit set indicates on, bit clear indicates off.
    332          *
    333          *	ACCEL_ACCURACY_SET	0x4000 - accel accuracy when changes, HEADER2_SET also needs to be set in data output control regsiter 1
    334          *	GYRO_ACCURACY_SET	0x2000 - gyro accuracy when changes, HEADER2_SET also needs to be set in data output control regsiter 1
    335          *	CPASS_ACCURACY_SET	0x1000 - compass accuracy when changes, HEADER2_SET also needs to be set in data output control regsiter 1
    336          *	BATCH_MODE_EN		0x0100 - enable batching
    337          */

   \                                 In section .text, align 2, keep-with-next
    338          int dmp_icm20948_set_data_output_control2(struct inv_icm20948 * s, int output_mask)
    339          {
    340              int result;
    341          	static unsigned char data_output_control_reg2[2]={0};
    342              
    343              data_output_control_reg2[0] = (unsigned char)(output_mask >> 8);
   \                     dmp_icm20948_set_data_output_control2: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable28
   \   00000002   0x120A             ASRS     R2,R1,#+8
   \   00000004   0x701A             STRB     R2,[R3, #+0]
    344              data_output_control_reg2[1] = (unsigned char)(output_mask & 0xff);
   \   00000006   0x7059             STRB     R1,[R3, #+1]
    345          
    346              result = inv_icm20948_write_mems(s, DATA_OUT_CTL2, 2, data_output_control_reg2);
    347          
    348              return result;
   \   00000008   0x2202             MOVS     R2,#+2
   \   0000000A   0x2142             MOVS     R1,#+66
   \   0000000C   0x.... 0x....      B.W      inv_icm20948_write_mems
    349          }

   \                                 In section .bss, align 2
   \                     `dmp_icm20948_set_data_output_control2::data_output_control_reg2`:
   \   00000000                      DS8 2
    350          
    351          /**
    352          * Clears all output control registers:
    353          *	data output control register 1, data output control register 2, data interrupt control register, motion event control regsiter, data ready status register
    354          */

   \                                 In section .text, align 2, keep-with-next
    355          int dmp_icm20948_reset_control_registers(struct inv_icm20948 * s)
    356          {
   \                     dmp_icm20948_reset_control_registers: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    357              int result;
    358              unsigned char data[4]={0};
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
    359              
    360              //reset data output control registers
    361              result = inv_icm20948_write_mems(s, DATA_OUT_CTL1, 2, &data[0]);
   \   0000000A   0x466B             MOV      R3,SP
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0x2140             MOVS     R1,#+64
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000016   0x4605             MOV      R5,R0
    362              result += inv_icm20948_write_mems(s, DATA_OUT_CTL2, 2, &data[0]);
   \   00000018   0x466B             MOV      R3,SP
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x2142             MOVS     R1,#+66
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x1945             ADDS     R5,R0,R5
    363          
    364          	//reset data interrupt control register
    365              result += inv_icm20948_write_mems(s, DATA_INTR_CTL, 2, &data[0]);
   \   00000026   0x466B             MOV      R3,SP
   \   00000028   0x2202             MOVS     R2,#+2
   \   0000002A   0x214C             MOVS     R1,#+76
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000032   0x1945             ADDS     R5,R0,R5
    366          
    367              //reset motion event control register
    368              result += inv_icm20948_write_mems(s, MOTION_EVENT_CTL, 2, &data[0]);
   \   00000034   0x466B             MOV      R3,SP
   \   00000036   0x2202             MOVS     R2,#+2
   \   00000038   0x214E             MOVS     R1,#+78
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000040   0x1945             ADDS     R5,R0,R5
    369          
    370              //reset data ready status register
    371              result += inv_icm20948_write_mems(s, DATA_RDY_STATUS, 2, &data[0]);
   \   00000042   0x466B             MOV      R3,SP
   \   00000044   0x2202             MOVS     R2,#+2
   \   00000046   0x218A             MOVS     R1,#+138
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000004E   0x1940             ADDS     R0,R0,R5
    372          	//result += inv_icm20948_write_mems(s, DATA_RDY_STATUS, 2, inv_icm20948_convert_int16_to_big8(3, data)); //fixme
    373          
    374              if (result) 
   \   00000050   0xD100             BNE.N    ??dmp_icm20948_reset_control_registers_0
    375                  return result;
    376          
    377          	return 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_reset_control_registers_0: (+1)
   \   00000054   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    378          }
    379          
    380          /**
    381          * Sets data interrupt control register.
    382          * @param[in] interrupt_ctl	Determines which sensors can generate interrupt according to following bit definition,
    383          *							bit set indicates interrupt, bit clear indicates no interrupt.
    384          *
    385          *	ACCEL_SET			0x8000 - calibrated accel if accel calibrated, raw accel otherwise
    386          *	GYRO_SET			0x4000 - raw gyro
    387          *	CPASS_SET			0x2000 - raw magnetic
    388          *	ALS_SET				0x1000 - ALS/proximity
    389          *	QUAT6_SET			0x0800 - game rotation vector
    390          *	QUAT9_SET			0x0400 - rotation vector with heading accuracy
    391          *	PQUAT6_SET			0x0200 - truncated game rotation vector for batching
    392          *	GEOMAG_SET			0x0100 - geomag rotation vector with heading accuracy
    393          *	PRESSURE_SET		0x0080 - pressure
    394          *	GYRO_CALIBR_SET		0x0040 - calibrated gyro
    395          *	CPASS_CALIBR_SET	0x0020 - calibrated magnetic
    396          *	PED_STEPDET_SET		0x0010 - timestamp when each step is detected
    397          *	HEADER2_SET			0x0008 - data output defined in data output control register 2
    398          *	PED_STEPIND_SET		0x0007 - number of steps detected will be attached to the 3 least significant bits of header
    399          */

   \                                 In section .text, align 2, keep-with-next
    400          int dmp_icm20948_set_data_interrupt_control(struct inv_icm20948 * s, uint32_t interrupt_ctl)
    401          {
   \                     dmp_icm20948_set_data_interrupt_control: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
    402          	int result;
    403              unsigned char big8[2]={0};
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    404          
    405              result = inv_icm20948_write_mems(s, DATA_INTR_CTL, 2, inv_icm20948_convert_int16_to_big8(interrupt_ctl, big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0xB200             SXTH     R0,R0
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x214C             MOVS     R1,#+76
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       inv_icm20948_write_mems
    406          
    407              if (result) 
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD100             BNE.N    ??dmp_icm20948_set_data_interrupt_control_0
    408                  return result;
    409          
    410          	return 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_data_interrupt_control_0: (+1)
   \   00000028   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    411          }
    412          
    413          /**
    414          * Sets FIFO watermark. DMP will send FIFO interrupt if FIFO count > FIFO watermark
    415          * @param[in] fifo_wm	FIFO watermark set to 80% of actual FIFO size by default
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          int dmp_icm20948_set_FIFO_watermark(struct inv_icm20948 * s, unsigned short fifo_wm)
    418          {
   \                     dmp_icm20948_set_FIFO_watermark: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
    419              int result;
    420          	unsigned char big8[2]={0};
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    421          
    422          	result = inv_icm20948_write_mems(s, FIFO_WATERMARK, 2, inv_icm20948_convert_int16_to_big8(fifo_wm,big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0xB200             SXTH     R0,R0
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0xF44F 0x71FF      MOV      R1,#+510
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
    423          
    424          	if (result)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD100             BNE.N    ??dmp_icm20948_set_FIFO_watermark_0
    425                  return result;
    426          
    427          	return 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_FIFO_watermark_0: (+1)
   \   0000002A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    428          }
    429          
    430          /**
    431          * Sets data rdy status register.
    432          * @param[in] data_rdy	Indicates which sensor data is available.
    433          *
    434          *	gyro samples available		0x1
    435          *	accel samples available		0x2
    436          *	secondary samples available	0x8
    437          */

   \                                 In section .text, align 2, keep-with-next
    438          int dmp_icm20948_set_data_rdy_status(struct inv_icm20948 * s, unsigned short data_rdy)
    439          {
   \                     dmp_icm20948_set_data_rdy_status: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
    440          	int result;
    441              unsigned char big8[2]={0};
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    442          
    443              result = inv_icm20948_write_mems(s, DATA_RDY_STATUS, 2, inv_icm20948_convert_int16_to_big8(data_rdy, big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0xB200             SXTH     R0,R0
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x218A             MOVS     R1,#+138
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       inv_icm20948_write_mems
    444          
    445              if (result) 
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD100             BNE.N    ??dmp_icm20948_set_data_rdy_status_0
    446                  return result;
    447          
    448          	return 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_data_rdy_status_0: (+1)
   \   00000028   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    449          }
    450          
    451          /**
    452          * Sets motion event control register.
    453          * @param[in] output_mask	Turns features on/off according to following bit definition,
    454          *							bit set indicates on, bit clear indicates off.
    455          *
    456          *   BAC_WEAR_EN         0x8000 - change BAC behavior for wearable platform
    457          *	PEDOMETER_EN		0x4000 - pedometer engine
    458          *	PEDOMETER_INT_EN	0x2000 - pedometer step detector interrupt
    459          *	SMD_EN				0x0800 - significant motion detection interrupt
    460          *	ACCEL_CAL_EN		0x0200 - accel calibration
    461          *	GYRO_CAL_EN			0x0100 - gyro calibration
    462          *	COMPASS_CAL_EN		0x0080 - compass calibration
    463          *	NINE_AXIS_EN        0x0040 - 9-axis algorithm execution
    464          *	GEOMAG_EN			0x0008 - Geomag algorithm execution
    465          *	BTS_LTS_EN          0x0004 - bring & look to see
    466          *	BAC_ACCEL_ONLY_EN   0x0002 - run BAC as accel only
    467          */

   \                                 In section .text, align 2, keep-with-next
    468          int dmp_icm20948_set_motion_event_control(struct inv_icm20948 * s, unsigned short output_mask)
    469          {
   \                     dmp_icm20948_set_motion_event_control: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    470              int result;
    471              unsigned char motion_event_control_reg[2];
    472              
    473              motion_event_control_reg[0] = (unsigned char)(output_mask >> 8);
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x0A12             LSRS     R2,R2,#+8
   \   00000006   0xF88D 0x2000      STRB     R2,[SP, #+0]
    474              motion_event_control_reg[1] = (unsigned char)(output_mask & 0xff);
   \   0000000A   0xF88D 0x1001      STRB     R1,[SP, #+1]
    475          
    476              result = inv_icm20948_write_mems(s, MOTION_EVENT_CTL, 2, motion_event_control_reg);
    477          
    478              return result;
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x214E             MOVS     R1,#+78
   \   00000014   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    479          }
    480          
    481          /**
    482          * Sets sensor ODR.
    483          * @param[in] sensor		sensor number based on INV_SENSORS
    484          *	enum INV_SENSORS {
    485          *		INV_SENSOR_ACCEL = 0,
    486          *		INV_SENSOR_GYRO,        
    487          *	    INV_SENSOR_LPQ,
    488          *		INV_SENSOR_COMPASS,
    489          *		INV_SENSOR_ALS,
    490          *		INV_SENSOR_SIXQ,
    491          *		INV_SENSOR_NINEQ,
    492          *		INV_SENSOR_GEOMAG,
    493          *		INV_SENSOR_PEDQ,
    494          *		INV_SENSOR_PRESSURE,
    495          *		INV_SENSOR_CALIB_GYRO,
    496          *		INV_SENSOR_CALIB_COMPASS,
    497          *		INV_SENSOR_NUM_MAX,
    498          *		INV_SENSOR_INVALID,
    499          *	};					
    500          * @param[in] divider	desired ODR = base engine rate/(divider + 1)
    501          */

   \                                 In section .text, align 4, keep-with-next
    502          int dmp_icm20948_set_sensor_rate(struct inv_icm20948 * s, int invSensor, short divider)
    503          {
   \                     dmp_icm20948_set_sensor_rate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    504          	int result;
    505              unsigned char big8[2]={0};
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    506          	int odr_addr = 0;
   \   0000000A   0x4605             MOV      R5,R0
    507          
    508              switch (invSensor) {
   \   0000000C   0x290B             CMP      R1,#+11
   \   0000000E   0xD81C             BHI.N    ??dmp_icm20948_set_sensor_rate_1
   \   00000010   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??dmp_icm20948_set_sensor_rate_0:
   \   00000014   0x06 0x08          DC8      0x6,0x8,0x1B,0xA
   \              0x1B 0x0A    
   \   00000018   0x0C 0x0E          DC8      0xC,0xE,0x10,0x12
   \              0x10 0x12    
   \   0000001C   0x14 0x16          DC8      0x14,0x16,0x18,0x1A
   \              0x18 0x1A    
    509          		case INV_SENSOR_ACCEL:
    510          			odr_addr = ODR_ACCEL;
   \                     ??dmp_icm20948_set_sensor_rate_2: (+1)
   \   00000020   0x25BE             MOVS     R5,#+190
    511          			break;
   \   00000022   0xE012             B.N      ??dmp_icm20948_set_sensor_rate_1
    512          		case INV_SENSOR_GYRO:
    513          			odr_addr = ODR_GYRO;
   \                     ??dmp_icm20948_set_sensor_rate_3: (+1)
   \   00000024   0x25BA             MOVS     R5,#+186
    514          			break;
   \   00000026   0xE010             B.N      ??dmp_icm20948_set_sensor_rate_1
    515          		case INV_SENSOR_COMPASS:
    516          			odr_addr = ODR_CPASS;
   \                     ??dmp_icm20948_set_sensor_rate_4: (+1)
   \   00000028   0x25B6             MOVS     R5,#+182
    517          			break;
   \   0000002A   0xE00E             B.N      ??dmp_icm20948_set_sensor_rate_1
    518          		case INV_SENSOR_ALS:
    519          			odr_addr = ODR_ALS;
   \                     ??dmp_icm20948_set_sensor_rate_5: (+1)
   \   0000002C   0x25B2             MOVS     R5,#+178
    520          			break;
   \   0000002E   0xE00C             B.N      ??dmp_icm20948_set_sensor_rate_1
    521          		case INV_SENSOR_SIXQ:
    522          			odr_addr = ODR_QUAT6;
   \                     ??dmp_icm20948_set_sensor_rate_6: (+1)
   \   00000030   0x25AC             MOVS     R5,#+172
    523          			break;
   \   00000032   0xE00A             B.N      ??dmp_icm20948_set_sensor_rate_1
    524          		case INV_SENSOR_NINEQ:
    525          			odr_addr = ODR_QUAT9;
   \                     ??dmp_icm20948_set_sensor_rate_7: (+1)
   \   00000034   0x25A8             MOVS     R5,#+168
    526          			break;
   \   00000036   0xE008             B.N      ??dmp_icm20948_set_sensor_rate_1
    527          		case INV_SENSOR_GEOMAG:
    528          			odr_addr = ODR_GEOMAG;
   \                     ??dmp_icm20948_set_sensor_rate_8: (+1)
   \   00000038   0x25A0             MOVS     R5,#+160
    529          			break;
   \   0000003A   0xE006             B.N      ??dmp_icm20948_set_sensor_rate_1
    530          		case INV_SENSOR_PEDQ:
    531          			odr_addr = ODR_PQUAT6;
   \                     ??dmp_icm20948_set_sensor_rate_9: (+1)
   \   0000003C   0x25A4             MOVS     R5,#+164
    532          			break;
   \   0000003E   0xE004             B.N      ??dmp_icm20948_set_sensor_rate_1
    533          		case INV_SENSOR_PRESSURE:
    534          			odr_addr = ODR_PRESSURE;
   \                     ??dmp_icm20948_set_sensor_rate_10: (+1)
   \   00000040   0x25BC             MOVS     R5,#+188
    535          			break;
   \   00000042   0xE002             B.N      ??dmp_icm20948_set_sensor_rate_1
    536          		case INV_SENSOR_CALIB_GYRO:
    537          			odr_addr = ODR_GYRO_CALIBR;
   \                     ??dmp_icm20948_set_sensor_rate_11: (+1)
   \   00000044   0x25B8             MOVS     R5,#+184
    538          			break;
   \   00000046   0xE000             B.N      ??dmp_icm20948_set_sensor_rate_1
    539          		case INV_SENSOR_CALIB_COMPASS:
    540          			odr_addr = ODR_CPASS_CALIBR;
   \                     ??dmp_icm20948_set_sensor_rate_12: (+1)
   \   00000048   0x25B4             MOVS     R5,#+180
    541          			break;
    542          		case INV_SENSOR_STEP_COUNTER:
    543          			//odr_addr = PED_RATE + 2; //PED_RATE is a 4-byte address but only writing 2 bytes here
    544          			break;
    545              }	
    546          
    547              result = inv_icm20948_write_mems(s, odr_addr, 2, inv_icm20948_convert_int16_to_big8(divider, big8));
   \                     ??dmp_icm20948_set_sensor_rate_1: (+1)
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x4610             MOV      R0,R2
   \   0000004E   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000052   0x4603             MOV      R3,R0
   \   00000054   0x2202             MOVS     R2,#+2
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       inv_icm20948_write_mems
    548          
    549          	if (result)
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD100             BNE.N    ??dmp_icm20948_set_sensor_rate_13
    550                  return result;
    551          
    552          	return 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_sensor_rate_13: (+1)
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    553          }
    554          
    555          /**
    556          * Resets batch counter and sets batch mode parameters.
    557          * @param[in] thld	sets batch timeout in DMP ticks, e.g. batch 1 sec, thld= (1 sec * engine base rate in Hz)
    558          * @param[in] mask	ties batch counter to engine specified with same bit definiton as HW register DATA_RDY_STATUS,
    559          *					i.e. batch counter increments only if the engine specified is available in multi-rate setting
    560          *	BIT 0 set: 1 - tie to gyro
    561          *	BIT 1 set: 2 - tie to accel
    562          *	BIT 2 set: 4 - tie to pressure in Diamond
    563          *	BIT 3 set: 8 - tie to secondary
    564          */

   \                                 In section .text, align 2, keep-with-next
    565          int dmp_icm20948_set_batchmode_params(struct inv_icm20948 * s, unsigned int thld, short mask)
    566          {
   \                     dmp_icm20948_set_batchmode_params: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    567              int result;
    568          	unsigned char big8[4]={0};
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    569          	unsigned char data[2]={0};
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    570          
    571          	result = inv_icm20948_write_mems(s, BM_BATCH_CNTR, 4, big8);
   \   00000016   0x466B             MOV      R3,SP
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF44F 0x71D8      MOV      R1,#+432
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x4607             MOV      R7,R0
    572          	result += inv_icm20948_write_mems(s, BM_BATCH_THLD, 4, inv_icm20948_convert_int32_to_big8(thld,big8));
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF44F 0x719E      MOV      R1,#+316
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003C   0x19C5             ADDS     R5,R0,R7
    573          	result += inv_icm20948_write_mems(s, BM_BATCH_MASK, 2, inv_icm20948_convert_int16_to_big8(mask,data));
   \   0000003E   0xA901             ADD      R1,SP,#+4
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000046   0x4603             MOV      R3,R0
   \   00000048   0x2202             MOVS     R2,#+2
   \   0000004A   0xF44F 0x71AF      MOV      R1,#+350
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000054   0x1940             ADDS     R0,R0,R5
    574          
    575          	if (result)
   \   00000056   0xD100             BNE.N    ??dmp_icm20948_set_batchmode_params_0
    576                  return result;
    577          
    578          	return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_batchmode_params_0: (+1)
   \   0000005A   0xBDFE             POP      {R1-R7,PC}       ;; return
    579          }
    580          
    581          /**
    582          * Sets acc's bias in DMP.
    583          * @param[in] bias
    584          *	array is set as follows:
    585          *	[0] accel_x
    586          *	[1] accel_y
    587          *	[2] accel_z
    588          */

   \                                 In section .text, align 2, keep-with-next
    589          int dmp_icm20948_set_bias_acc(struct inv_icm20948 * s, int *bias)
    590          {
   \                     dmp_icm20948_set_bias_acc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    591          	int result;
    592          	unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    593          
    594          	result = inv_icm20948_write_mems(s, ACCEL_BIAS_X, 4, inv_icm20948_convert_int32_to_big8(bias[0], big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF240 0x61E4      MOVW     R1,#+1764
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x4606             MOV      R6,R0
    595          	result += inv_icm20948_write_mems(s, ACCEL_BIAS_Y, 4, inv_icm20948_convert_int32_to_big8(bias[1], big8));
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF44F 0x61DD      MOV      R1,#+1768
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003C   0x1986             ADDS     R6,R0,R6
    596          	result += inv_icm20948_write_mems(s, ACCEL_BIAS_Z, 4, inv_icm20948_convert_int32_to_big8(bias[2], big8));
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000046   0x4603             MOV      R3,R0
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0xF240 0x61EC      MOVW     R1,#+1772
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000054   0x1980             ADDS     R0,R0,R6
    597          	
    598          	if (result)
   \   00000056   0xD100             BNE.N    ??dmp_icm20948_set_bias_acc_0
    599          		return result;
    600          
    601          	return 0; 
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_bias_acc_0: (+1)
   \   0000005A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    602          }
    603          
    604          /**
    605          * Sets gyro's bias in DMP.
    606          * @param[in] bias
    607          *	array is set as follows:
    608          *	[0] gyro_x
    609          *	[1] gyro_y
    610          *	[2] gyro_z
    611          */

   \                                 In section .text, align 2, keep-with-next
    612          int dmp_icm20948_set_bias_gyr(struct inv_icm20948 * s, int *bias)
    613          {
   \                     dmp_icm20948_set_bias_gyr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    614          	int result;
    615          	unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    616          
    617          	result = inv_icm20948_write_mems(s, GYRO_BIAS_X, 4, inv_icm20948_convert_int32_to_big8(bias[0], big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF640 0x01B4      MOVW     R1,#+2228
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x4606             MOV      R6,R0
    618          	result += inv_icm20948_write_mems(s, GYRO_BIAS_Y, 4, inv_icm20948_convert_int32_to_big8(bias[1], big8));
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF640 0x01B8      MOVW     R1,#+2232
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003C   0x1986             ADDS     R6,R0,R6
    619          	result += inv_icm20948_write_mems(s, GYRO_BIAS_Z, 4, inv_icm20948_convert_int32_to_big8(bias[2], big8));
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000046   0x4603             MOV      R3,R0
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0xF640 0x01BC      MOVW     R1,#+2236
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000054   0x1980             ADDS     R0,R0,R6
    620          	
    621          	if (result)
   \   00000056   0xD100             BNE.N    ??dmp_icm20948_set_bias_gyr_0
    622          		return result;
    623          
    624          	return 0; 
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_bias_gyr_0: (+1)
   \   0000005A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    625          }
    626          
    627          /**
    628          * Sets compass' bias in DMP.
    629          * @param[in] bias
    630          *	array is set as follows:
    631          *	[0] compass_x
    632          *	[1] compass_y
    633          *	[2] compass_z
    634          */

   \                                 In section .text, align 2, keep-with-next
    635          int dmp_icm20948_set_bias_cmp(struct inv_icm20948 * s, int *bias)
    636          {
   \                     dmp_icm20948_set_bias_cmp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    637          	int result;
    638          	unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    639          
    640          	result = inv_icm20948_write_mems(s, CPASS_BIAS_X, 4, inv_icm20948_convert_int32_to_big8(bias[0], big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF240 0x71E4      MOVW     R1,#+2020
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x4606             MOV      R6,R0
    641          	result += inv_icm20948_write_mems(s, CPASS_BIAS_Y, 4, inv_icm20948_convert_int32_to_big8(bias[1], big8));
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF44F 0x61FD      MOV      R1,#+2024
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003C   0x1986             ADDS     R6,R0,R6
    642          	result += inv_icm20948_write_mems(s, CPASS_BIAS_Z, 4, inv_icm20948_convert_int32_to_big8(bias[2], big8));
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000046   0x4603             MOV      R3,R0
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0xF240 0x71EC      MOVW     R1,#+2028
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000054   0x1980             ADDS     R0,R0,R6
    643          	
    644          	if (result)
   \   00000056   0xD100             BNE.N    ??dmp_icm20948_set_bias_cmp_0
    645          		return result;
    646          
    647          	return 0; 
   \   00000058   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_bias_cmp_0: (+1)
   \   0000005A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    648          }
    649          
    650          /**
    651          * Gets acc's bias from DMP.
    652          * @param[in] bias
    653          * @param[out] bias
    654          *	array is set as follows:
    655          *	[0] accel_x
    656          *	[1] accel_y
    657          *	[2] accel_z
    658          */

   \                                 In section .text, align 2, keep-with-next
    659          int dmp_icm20948_get_bias_acc(struct inv_icm20948 * s, int *bias)
    660          {
   \                     dmp_icm20948_get_bias_acc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    661          	int result;
    662          	unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    663          
    664          	result = inv_icm20948_read_mems(s, ACCEL_BIAS_X, 4, big8);
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF240 0x61E4      MOVW     R1,#+1764
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_read_mems
   \   0000001C   0x4606             MOV      R6,R0
    665          	bias[0] = inv_icm20948_convert_big8_to_int32(big8);
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   00000024   0x6028             STR      R0,[R5, #+0]
    666          	result += inv_icm20948_read_mems(s, ACCEL_BIAS_Y, 4, big8);
   \   00000026   0x466B             MOV      R3,SP
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0xF44F 0x61DD      MOV      R1,#+1768
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_icm20948_read_mems
   \   00000034   0x1986             ADDS     R6,R0,R6
    667          	bias[1] = inv_icm20948_convert_big8_to_int32(big8);
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   0000003C   0x6068             STR      R0,[R5, #+4]
    668          	result += inv_icm20948_read_mems(s, ACCEL_BIAS_Z, 4, big8);
   \   0000003E   0x466B             MOV      R3,SP
   \   00000040   0x2204             MOVS     R2,#+4
   \   00000042   0xF240 0x61EC      MOVW     R1,#+1772
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       inv_icm20948_read_mems
   \   0000004C   0x1984             ADDS     R4,R0,R6
    669          	bias[2] = inv_icm20948_convert_big8_to_int32(big8);
   \   0000004E   0x4668             MOV      R0,SP
   \   00000050   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   00000054   0x60A8             STR      R0,[R5, #+8]
    670          
    671          	if (result)
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD001             BEQ.N    ??dmp_icm20948_get_bias_acc_0
    672          		return result;
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xBD76             POP      {R1,R2,R4-R6,PC}
    673          
    674          	return 0; 
   \                     ??dmp_icm20948_get_bias_acc_0: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    675          }
    676          
    677          /**
    678          * Gets gyro's bias from DMP.
    679          * @param[in] bias
    680          * @param[out] bias
    681          *	array is set as follows:
    682          *	[0] gyro_x
    683          *	[1] gyro_y
    684          *	[2] gyro_z
    685          */

   \                                 In section .text, align 2, keep-with-next
    686          int dmp_icm20948_get_bias_gyr(struct inv_icm20948 * s, int *bias)
    687          {
   \                     dmp_icm20948_get_bias_gyr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    688          	int result;
    689          	unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    690          
    691          	result = inv_icm20948_read_mems(s, GYRO_BIAS_X, 4, big8);
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF640 0x01B4      MOVW     R1,#+2228
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_read_mems
   \   0000001C   0x4606             MOV      R6,R0
    692          	bias[0] = inv_icm20948_convert_big8_to_int32(big8);
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   00000024   0x6028             STR      R0,[R5, #+0]
    693          	result += inv_icm20948_read_mems(s, GYRO_BIAS_Y, 4, big8);
   \   00000026   0x466B             MOV      R3,SP
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0xF640 0x01B8      MOVW     R1,#+2232
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_icm20948_read_mems
   \   00000034   0x1986             ADDS     R6,R0,R6
    694          	bias[1] = inv_icm20948_convert_big8_to_int32(big8);
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   0000003C   0x6068             STR      R0,[R5, #+4]
    695          	result += inv_icm20948_read_mems(s, GYRO_BIAS_Z, 4, big8);
   \   0000003E   0x466B             MOV      R3,SP
   \   00000040   0x2204             MOVS     R2,#+4
   \   00000042   0xF640 0x01BC      MOVW     R1,#+2236
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       inv_icm20948_read_mems
   \   0000004C   0x1984             ADDS     R4,R0,R6
    696          	bias[2] = inv_icm20948_convert_big8_to_int32(big8);
   \   0000004E   0x4668             MOV      R0,SP
   \   00000050   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   00000054   0x60A8             STR      R0,[R5, #+8]
    697          	
    698          	if (result)
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD001             BEQ.N    ??dmp_icm20948_get_bias_gyr_0
    699          		return result;
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xBD76             POP      {R1,R2,R4-R6,PC}
    700          
    701          	return 0; 
   \                     ??dmp_icm20948_get_bias_gyr_0: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    702          }
    703          
    704          /**
    705          * Gets compass' bias from DMP.
    706          * @param[in] bias
    707          * @param[out] bias
    708          *	array is set as follows:
    709          *	[0] compass_x
    710          *	[1] compass_y
    711          *	[2] compass_z
    712          */

   \                                 In section .text, align 2, keep-with-next
    713          int dmp_icm20948_get_bias_cmp(struct inv_icm20948 * s, int *bias)
    714          {
   \                     dmp_icm20948_get_bias_cmp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    715          	int result;
    716          	unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    717          
    718          	result = inv_icm20948_read_mems(s, CPASS_BIAS_X, 4, big8);
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF240 0x71E4      MOVW     R1,#+2020
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_read_mems
   \   0000001C   0x4606             MOV      R6,R0
    719          	bias[0] = inv_icm20948_convert_big8_to_int32(big8);
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   00000024   0x6028             STR      R0,[R5, #+0]
    720          	result += inv_icm20948_read_mems(s, CPASS_BIAS_Y, 4, big8);
   \   00000026   0x466B             MOV      R3,SP
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0xF44F 0x61FD      MOV      R1,#+2024
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_icm20948_read_mems
   \   00000034   0x1986             ADDS     R6,R0,R6
    721          	bias[1] = inv_icm20948_convert_big8_to_int32(big8);
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   0000003C   0x6068             STR      R0,[R5, #+4]
    722          	result += inv_icm20948_read_mems(s, CPASS_BIAS_Z, 4, big8);
   \   0000003E   0x466B             MOV      R3,SP
   \   00000040   0x2204             MOVS     R2,#+4
   \   00000042   0xF240 0x71EC      MOVW     R1,#+2028
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       inv_icm20948_read_mems
   \   0000004C   0x1984             ADDS     R4,R0,R6
    723          	bias[2] = inv_icm20948_convert_big8_to_int32(big8);
   \   0000004E   0x4668             MOV      R0,SP
   \   00000050   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   00000054   0x60A8             STR      R0,[R5, #+8]
    724          
    725          	if (result)
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD001             BEQ.N    ??dmp_icm20948_get_bias_cmp_0
    726          		return result;
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xBD76             POP      {R1,R2,R4-R6,PC}
    727          
    728          	return 0; 
   \                     ??dmp_icm20948_get_bias_cmp_0: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    729          }
    730          
    731          /**
    732          * Sets the gyro_sf used by quaternions on the DMP.
    733          * @param[in] gyro_sf	see inv_icm20948_set_gyro_sf() for value to set based on gyro rate and gyro fullscale range
    734          */

   \                                 In section .text, align 2, keep-with-next
    735          int dmp_icm20948_set_gyro_sf(struct inv_icm20948 * s, long gyro_sf)
    736          {
   \                     dmp_icm20948_set_gyro_sf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
    737              int result;
    738              unsigned char big8[4];
    739          
    740              result = inv_icm20948_write_mems(s, GYRO_SF, 4, inv_icm20948_convert_int32_to_big8(gyro_sf, big8));
    741          
    742              return result;
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000000E   0x4603             MOV      R3,R0
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF44F 0x7198      MOV      R1,#+304
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000001C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    743          }
    744          
    745          /**
    746          * Sets the accel gain used by accel quaternion on the DMP.
    747          * @param[in] accel_gain		value changes with accel engine rate
    748          */

   \                                 In section .text, align 2, keep-with-next
    749          int dmp_icm20948_set_accel_feedback_gain(struct inv_icm20948 * s, int accel_gain)
    750          {
   \                     dmp_icm20948_set_accel_feedback_gain: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
    751          	int result;
    752              unsigned char big8[4]={0};
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x600A             STR      R2,[R1, #+0]
    753          
    754              result = inv_icm20948_write_mems(s, ACCEL_ONLY_GAIN, 4, inv_icm20948_convert_int32_to_big8(accel_gain, big8));
   \   0000000E   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000012   0x4603             MOV      R3,R0
   \   00000014   0x2204             MOVS     R2,#+4
   \   00000016   0xF44F 0x7186      MOV      R1,#+268
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       inv_icm20948_write_mems
    755          
    756          	if (result)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD100             BNE.N    ??dmp_icm20948_set_accel_feedback_gain_0
    757                  return result;
    758          
    759          	return 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_accel_feedback_gain_0: (+1)
   \   00000026   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    760          }
    761          
    762          /**
    763          * Sets accel cal parameters based on different accel engine rate/accel cal running rate
    764          * @param[in] accel_cal
    765          *	array is set as follows:
    766          *	[0] = ACCEL_CAL_ALPHA_VAR
    767          *	[1] = ACCEL_CAL_A_VAR
    768          *   [2] = ACCEL_CAL_DIV - divider from hardware accel engine rate such that acce cal runs at accel_engine_rate/(divider+1)
    769          */

   \                                 In section .text, align 2, keep-with-next
    770          int dmp_icm20948_set_accel_cal_params(struct inv_icm20948 * s, int *accel_cal)
    771          {
   \                     dmp_icm20948_set_accel_cal_params: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    772          	int result;
    773              unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    774          
    775              result  = inv_icm20948_write_mems(s, ACCEL_ALPHA_VAR, 4, inv_icm20948_convert_int32_to_big8(accel_cal[ACCEL_CAL_ALPHA_VAR], big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF44F 0x61B6      MOV      R1,#+1456
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x4606             MOV      R6,R0
    776              result |= inv_icm20948_write_mems(s, ACCEL_A_VAR, 4, inv_icm20948_convert_int32_to_big8(accel_cal[ACCEL_CAL_A_VAR], big8));
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF44F 0x61B8      MOV      R1,#+1472
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003C   0x4306             ORRS     R6,R0,R6
    777              result |= inv_icm20948_write_mems(s, ACCEL_CAL_RATE, 2, inv_icm20948_convert_int16_to_big8(accel_cal[ACCEL_CAL_DIV], big8));
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0xB200             SXTH     R0,R0
   \   00000044   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000048   0x4603             MOV      R3,R0
   \   0000004A   0x2202             MOVS     R2,#+2
   \   0000004C   0xF240 0x51E4      MOVW     R1,#+1508
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000056   0x4330             ORRS     R0,R0,R6
    778          
    779          	if (result)
   \   00000058   0xD100             BNE.N    ??dmp_icm20948_set_accel_cal_params_0
    780                  return result;
    781          
    782          	return 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_accel_cal_params_0: (+1)
   \   0000005C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    783          }
    784          
    785          /**
    786          * Sets compass cal parameters based on different compass engine rate/compass cal running rate
    787          * @param[in] compass_cal
    788          *	array is set as follows:
    789          *	[0] = CPASS_CAL_TIME_BUFFER
    790          *	[1] = CPASS_CAL_ALPHA_VAR
    791          *	[2] = CPASS_CAL_A_VAR
    792          *	[3] = CPASS_CAL_RADIUS_3D_THRESH_ANOMALY
    793          *	[4] = CPASS_CAL_NOMOT_VAR_THRESH
    794          */

   \                                 In section .text, align 2, keep-with-next
    795          int dmp_icm20948_set_compass_cal_params(struct inv_icm20948 * s, int *compass_cal)
    796          {
   \                     dmp_icm20948_set_compass_cal_params: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    797          	int result;
    798              unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    799          
    800              result = inv_icm20948_write_mems(s, CPASS_TIME_BUFFER, 2, inv_icm20948_convert_int16_to_big8(compass_cal[CPASS_CAL_TIME_BUFFER], big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0xB200             SXTH     R0,R0
   \   00000014   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000018   0x4603             MOV      R3,R0
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0xF240 0x710E      MOVW     R1,#+1806
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000026   0x4606             MOV      R6,R0
    801              result += inv_icm20948_write_mems(s, CPASS_RADIUS_3D_THRESH_ANOMALY, 4, inv_icm20948_convert_int32_to_big8(compass_cal[CPASS_CAL_RADIUS_3D_THRESH_ANOMALY], big8));
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000030   0x4603             MOV      R3,R0
   \   00000032   0x2204             MOVS     R2,#+4
   \   00000034   0xF44F 0x61E1      MOV      R1,#+1800
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003E   0x1980             ADDS     R0,R0,R6
    802          
    803          	if (result)
   \   00000040   0xD100             BNE.N    ??dmp_icm20948_set_compass_cal_params_0
    804                  return result;
    805          
    806          	return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_compass_cal_params_0: (+1)
   \   00000044   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    807          }
    808          
    809          /**
    810          * Sets compass orientation matrix to DMP.
    811          * @param[in] compass_mtx
    812          */

   \                                 In section .text, align 2, keep-with-next
    813          int dmp_icm20948_set_compass_matrix(struct inv_icm20948 * s, int *compass_mtx)
    814          {
   \                     dmp_icm20948_set_compass_matrix: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    815              int result;
    816              unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    817          	    
    818              result = inv_icm20948_write_mems(s, CPASS_MTX_00, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[0], big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF44F 0x71B8      MOV      R1,#+368
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x4606             MOV      R6,R0
    819              result += inv_icm20948_write_mems(s, CPASS_MTX_01, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[1], big8));
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF44F 0x71BA      MOV      R1,#+372
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003C   0x1986             ADDS     R6,R0,R6
    820              result += inv_icm20948_write_mems(s, CPASS_MTX_02, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[2], big8));
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000046   0x4603             MOV      R3,R0
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0xF44F 0x71BC      MOV      R1,#+376
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000054   0x1986             ADDS     R6,R0,R6
    821              result += inv_icm20948_write_mems(s, CPASS_MTX_10, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[3], big8));
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x68E8             LDR      R0,[R5, #+12]
   \   0000005A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000005E   0x4603             MOV      R3,R0
   \   00000060   0x2204             MOVS     R2,#+4
   \   00000062   0xF44F 0x71BE      MOV      R1,#+380
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000006C   0x1986             ADDS     R6,R0,R6
    822              result += inv_icm20948_write_mems(s, CPASS_MTX_11, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[4], big8));
   \   0000006E   0x4669             MOV      R1,SP
   \   00000070   0x6928             LDR      R0,[R5, #+16]
   \   00000072   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000076   0x4603             MOV      R3,R0
   \   00000078   0x2204             MOVS     R2,#+4
   \   0000007A   0xF44F 0x71C0      MOV      R1,#+384
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000084   0x1986             ADDS     R6,R0,R6
    823              result += inv_icm20948_write_mems(s, CPASS_MTX_12, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[5], big8));
   \   00000086   0x4669             MOV      R1,SP
   \   00000088   0x6968             LDR      R0,[R5, #+20]
   \   0000008A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000008E   0x4603             MOV      R3,R0
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF44F 0x71C2      MOV      R1,#+388
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000009C   0x1986             ADDS     R6,R0,R6
    824              result += inv_icm20948_write_mems(s, CPASS_MTX_20, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[6], big8));
   \   0000009E   0x4669             MOV      R1,SP
   \   000000A0   0x69A8             LDR      R0,[R5, #+24]
   \   000000A2   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000A6   0x4603             MOV      R3,R0
   \   000000A8   0x2204             MOVS     R2,#+4
   \   000000AA   0xF44F 0x71C4      MOV      R1,#+392
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000B4   0x1986             ADDS     R6,R0,R6
    825              result += inv_icm20948_write_mems(s, CPASS_MTX_21, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[7], big8));
   \   000000B6   0x4669             MOV      R1,SP
   \   000000B8   0x69E8             LDR      R0,[R5, #+28]
   \   000000BA   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000BE   0x4603             MOV      R3,R0
   \   000000C0   0x2204             MOVS     R2,#+4
   \   000000C2   0xF44F 0x71C6      MOV      R1,#+396
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000CC   0x1986             ADDS     R6,R0,R6
    826              result += inv_icm20948_write_mems(s, CPASS_MTX_22, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[8], big8));
   \   000000CE   0x4669             MOV      R1,SP
   \   000000D0   0x6A28             LDR      R0,[R5, #+32]
   \   000000D2   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000D6   0x4603             MOV      R3,R0
   \   000000D8   0x2204             MOVS     R2,#+4
   \   000000DA   0xF44F 0x71C8      MOV      R1,#+400
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000E4   0x1980             ADDS     R0,R0,R6
    827          
    828          	if (result)
   \   000000E6   0xD100             BNE.N    ??dmp_icm20948_set_compass_matrix_0
    829                  return result;
    830          
    831          	return 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_compass_matrix_0: (+1)
   \   000000EA   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    832          }
    833          
    834          /**
    835          * Gets pedometer step count.
    836          * @param[in] steps
    837          * @param[out] steps
    838          */

   \                                 In section .text, align 2, keep-with-next
    839          int dmp_icm20948_get_pedometer_num_of_steps(struct inv_icm20948 * s, unsigned long *steps)
    840          {
   \                     dmp_icm20948_get_pedometer_num_of_steps: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
    841              int result;
    842          	unsigned char big8[4]={0};
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x600A             STR      R2,[R1, #+0]
    843              (void)s;
    844          	result = inv_icm20948_read_mems(s, PEDSTD_STEPCTR, 4, big8);
   \   0000000C   0x466B             MOV      R3,SP
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0xF44F 0x7158      MOV      R1,#+864
   \   00000014   0x.... 0x....      BL       inv_icm20948_read_mems
    845              if (result) 
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10F             BNE.N    ??dmp_icm20948_get_pedometer_num_of_steps_0
    846                  return result;
    847              *steps = (big8[0]*(1L<<24)) + (big8[1]*(1L<<16)) + (big8[2]*256) + big8[3];
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000024   0x0409             LSLS     R1,R1,#+16
   \   00000026   0xEB01 0x6000      ADD      R0,R1,R0, LSL #+24
   \   0000002A   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   0000002E   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   00000032   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000036   0x1840             ADDS     R0,R0,R1
   \   00000038   0x6020             STR      R0,[R4, #+0]
    848              
    849              return 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_get_pedometer_num_of_steps_0: (+1)
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    850          }
    851          
    852          /**
    853          * Sets pedometer engine running rate.
    854          * @param[in] ped_rate	divider based on accel engine rate
    855          */

   \                                 In section .text, align 2, keep-with-next
    856          int dmp_icm20948_set_pedometer_rate(struct inv_icm20948 * s, int ped_rate)
    857          {
    858          	// int result; 
    859          	// unsigned char big8[4]={0};
    860          	// result = inv_icm20948_write_mems(s, PED_RATE, 4, inv_icm20948_convert_int32_to_big8(ped_rate, big8));
    861          	// if (result)
    862          	//    return result;
    863          
    864          	(void)s;
    865          	(void) ped_rate;
    866          
    867          	return 0;
   \                     dmp_icm20948_set_pedometer_rate: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    868          }
    869          
    870          /**
    871          * Turns software wake on motion feature on/off.
    872          * @param[in] enable		0=off, 1=on
    873          */

   \                                 In section .text, align 2, keep-with-next
    874          int dmp_icm20948_set_wom_enable(struct inv_icm20948 * s, unsigned char enable)
    875          {
   \                     dmp_icm20948_set_wom_enable: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    876          	int result;
    877              unsigned char big8[2]={0};
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    878          
    879          	if (enable) {
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD002             BEQ.N    ??dmp_icm20948_set_wom_enable_0
    880          		big8[1]= 0x1;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF88D 0x1001      STRB     R1,[SP, #+1]
    881              }
    882          
    883              result = inv_icm20948_write_mems(s, WOM_ENABLE, 2, big8);
   \                     ??dmp_icm20948_set_wom_enable_0: (+1)
   \   00000012   0x466B             MOV      R3,SP
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0xF240 0x410E      MOVW     R1,#+1038
   \   0000001A   0x.... 0x....      BL       inv_icm20948_write_mems
    884          
    885          	if (result)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD100             BNE.N    ??dmp_icm20948_set_wom_enable_1
    886                  return result;
    887          
    888          	return 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_wom_enable_1: (+1)
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
    889          }
    890          
    891          /**
    892          * Sets motion threshold to determine motion/no motion for wake on motion feature.
    893          * @param[in] threshold
    894          */

   \                                 In section .text, align 2, keep-with-next
    895          int dmp_icm20948_set_wom_motion_threshold(struct inv_icm20948 * s, int threshold)
    896          {
   \                     dmp_icm20948_set_wom_motion_threshold: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
    897          	int result;
    898              unsigned char big8[4]={0};
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x600A             STR      R2,[R1, #+0]
    899          
    900              result = inv_icm20948_write_mems(s, WOM_THRESHOLD, 4, inv_icm20948_convert_int32_to_big8(threshold, big8));
   \   0000000E   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000012   0x4603             MOV      R3,R0
   \   00000014   0x2204             MOVS     R2,#+4
   \   00000016   0xF44F 0x6180      MOV      R1,#+1024
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       inv_icm20948_write_mems
    901          
    902          	if (result)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD100             BNE.N    ??dmp_icm20948_set_wom_motion_threshold_0
    903                  return result;
    904          
    905          	return 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_wom_motion_threshold_0: (+1)
   \   00000026   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    906          }
    907          
    908          /**
    909          * Sets minimum time threshold of no motion before DMP goes to sleep.
    910          * @param[in] threshold
    911          */

   \                                 In section .text, align 2, keep-with-next
    912          int dmp_icm20948_set_wom_time_threshold(struct inv_icm20948 * s, unsigned short threshold)
    913          {
   \                     dmp_icm20948_set_wom_time_threshold: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
    914          	int result;
    915              unsigned char big8[2]={0};
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    916          
    917              result = inv_icm20948_write_mems(s, WOM_CNTR_TH, 2, inv_icm20948_convert_int16_to_big8(threshold, big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0xB200             SXTH     R0,R0
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0xF240 0x410C      MOVW     R1,#+1036
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
    918          
    919          	if (result)
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD100             BNE.N    ??dmp_icm20948_set_wom_time_threshold_0
    920                  return result;
    921          
    922          	return 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_wom_time_threshold_0: (+1)
   \   0000002A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    923          }
    924          
    925          /**
    926          * Sets scale in DMP to convert accel data to 1g=2^25 regardless of fsr.
    927          * @param[in] fsr for accel parts
    928                       2: 2g. 4: 4g. 8: 8g. 16: 16g. 32: 32g.
    929          
    930                       For 2g parts, 2g = 2^15 -> 1g = 2^14,.
    931                       DMP takes raw accel data and left shifts by 16 bits, so 1g=2^14 (<<16) becomes 1g=2^30, to make 1g=2^25, >>5 bits.
    932                       In Q-30 math, >> 5 equals multiply by 2^25 = 33554432.
    933          
    934                       For 8g parts, 8g = 2^15 -> 1g = 2^12.
    935                       DMP takes raw accel data and left shifts by 16 bits, so 1g=2^12 (<<16) becomes 1g=2^28, to make 1g=2^25, >>3bits.
    936                       In Q-30 math, >> 3 equals multiply by 2^27 = 134217728.
    937          */

   \                                 In section .text, align 2, keep-with-next
    938          int dmp_icm20948_set_accel_fsr(struct inv_icm20948 * s, short accel_fsr)
    939          {
   \                     dmp_icm20948_set_accel_fsr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    940              unsigned char reg[4];
    941              int result;
    942              long scale;
    943          
    944              switch (accel_fsr) {
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD008             BEQ.N    ??dmp_icm20948_set_accel_fsr_0
   \   0000000A   0x2904             CMP      R1,#+4
   \   0000000C   0xD015             BEQ.N    ??dmp_icm20948_set_accel_fsr_1
   \   0000000E   0x2908             CMP      R1,#+8
   \   00000010   0xD016             BEQ.N    ??dmp_icm20948_set_accel_fsr_2
   \   00000012   0x2910             CMP      R1,#+16
   \   00000014   0xD017             BEQ.N    ??dmp_icm20948_set_accel_fsr_3
   \   00000016   0x2920             CMP      R1,#+32
   \   00000018   0xD018             BEQ.N    ??dmp_icm20948_set_accel_fsr_4
   \   0000001A   0xE01A             B.N      ??dmp_icm20948_set_accel_fsr_5
    945              case 2:
    946                  scale =  33554432L;  // 2^25
   \                     ??dmp_icm20948_set_accel_fsr_0: (+1)
   \   0000001C   0xF04F 0x7000      MOV      R0,#+33554432
    947                  break;
    948              case 4:
    949                  scale =  67108864L;  // 2^26
    950                  break;
    951              case 8:
    952                  scale = 134217728L;  // 2^27
    953                  break;
    954              case 16:
    955                  scale = 268435456L;  // 2^28
    956                  break;
    957              case 32:
    958                  scale = 536870912L;  // 2^29
    959                  break;
    960              default:
    961                  return -1;
    962              }
    963          
    964              result = inv_icm20948_write_mems(s, ACC_SCALE, 4, inv_icm20948_convert_int32_to_big8(scale,reg));
   \                     ??dmp_icm20948_set_accel_fsr_6: (+1)
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000026   0x4603             MOV      R3,R0
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0xF44F 0x71F0      MOV      R1,#+480
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_icm20948_write_mems
    965          
    966              if (result) {
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00F             BEQ.N    ??dmp_icm20948_set_accel_fsr_7
    967                  return result;
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}
    968              } else {
   \                     ??dmp_icm20948_set_accel_fsr_1: (+1)
   \   0000003A   0xF04F 0x6080      MOV      R0,#+67108864
   \   0000003E   0xE7EF             B.N      ??dmp_icm20948_set_accel_fsr_6
   \                     ??dmp_icm20948_set_accel_fsr_2: (+1)
   \   00000040   0xF04F 0x6000      MOV      R0,#+134217728
   \   00000044   0xE7EC             B.N      ??dmp_icm20948_set_accel_fsr_6
   \                     ??dmp_icm20948_set_accel_fsr_3: (+1)
   \   00000046   0xF04F 0x5080      MOV      R0,#+268435456
   \   0000004A   0xE7E9             B.N      ??dmp_icm20948_set_accel_fsr_6
   \                     ??dmp_icm20948_set_accel_fsr_4: (+1)
   \   0000004C   0xF04F 0x5000      MOV      R0,#+536870912
   \   00000050   0xE7E6             B.N      ??dmp_icm20948_set_accel_fsr_6
   \                     ??dmp_icm20948_set_accel_fsr_5: (+1)
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}
    969                  return 0;
   \                     ??dmp_icm20948_set_accel_fsr_7: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    970              }
    971          }
    972          
    973          /**
    974          * According to input fsr, a scale factor will be set at memory location ACC_SCALE2
    975          * to convert calibrated accel data to 16-bit format same as what comes out of MPU register.
    976          * It is a reverse scaling of the scale factor written to ACC_SCALE.
    977          * @param[in] fsr for accel parts
    978          			 2: 2g. 4: 4g. 8: 8g. 16: 16g. 32: 32g.
    979          */

   \                                 In section .text, align 2, keep-with-next
    980          int dmp_icm20948_set_accel_scale2(struct inv_icm20948 * s, short accel_fsr)
    981          {
   \                     dmp_icm20948_set_accel_scale2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    982              unsigned char reg[4];
    983              int result;
    984              long scale;
    985          
    986              switch (accel_fsr) {
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD008             BEQ.N    ??dmp_icm20948_set_accel_scale2_0
   \   0000000A   0x2904             CMP      R1,#+4
   \   0000000C   0xD015             BEQ.N    ??dmp_icm20948_set_accel_scale2_1
   \   0000000E   0x2908             CMP      R1,#+8
   \   00000010   0xD016             BEQ.N    ??dmp_icm20948_set_accel_scale2_2
   \   00000012   0x2910             CMP      R1,#+16
   \   00000014   0xD017             BEQ.N    ??dmp_icm20948_set_accel_scale2_3
   \   00000016   0x2920             CMP      R1,#+32
   \   00000018   0xD018             BEQ.N    ??dmp_icm20948_set_accel_scale2_4
   \   0000001A   0xE01A             B.N      ??dmp_icm20948_set_accel_scale2_5
    987              case 2:
    988                  scale = 524288L;  // 2^19
   \                     ??dmp_icm20948_set_accel_scale2_0: (+1)
   \   0000001C   0xF44F 0x2000      MOV      R0,#+524288
    989                  break;
    990              case 4:
    991                  scale = 262144L;  // 2^18
    992                  break;
    993              case 8:
    994                  scale = 131072L;  // 2^17
    995                  break;
    996              case 16:
    997                  scale = 65536L;  // 2^16
    998                  break;
    999              case 32:
   1000                  scale = 32768L;  // 2^15
   1001                  break;
   1002              default:
   1003                  return -1;
   1004              }
   1005          
   1006              result = inv_icm20948_write_mems(s, ACC_SCALE2, 4, inv_icm20948_convert_int32_to_big8(scale,reg));
   \                     ??dmp_icm20948_set_accel_scale2_6: (+1)
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000026   0x4603             MOV      R3,R0
   \   00000028   0x2204             MOVS     R2,#+4
   \   0000002A   0xF240 0x41F4      MOVW     R1,#+1268
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_icm20948_write_mems
   1007          
   1008              if (result) {
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00F             BEQ.N    ??dmp_icm20948_set_accel_scale2_7
   1009                  return result;
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}
   1010              } else {
   \                     ??dmp_icm20948_set_accel_scale2_1: (+1)
   \   0000003A   0xF44F 0x2080      MOV      R0,#+262144
   \   0000003E   0xE7EF             B.N      ??dmp_icm20948_set_accel_scale2_6
   \                     ??dmp_icm20948_set_accel_scale2_2: (+1)
   \   00000040   0xF44F 0x3000      MOV      R0,#+131072
   \   00000044   0xE7EC             B.N      ??dmp_icm20948_set_accel_scale2_6
   \                     ??dmp_icm20948_set_accel_scale2_3: (+1)
   \   00000046   0xF44F 0x3080      MOV      R0,#+65536
   \   0000004A   0xE7E9             B.N      ??dmp_icm20948_set_accel_scale2_6
   \                     ??dmp_icm20948_set_accel_scale2_4: (+1)
   \   0000004C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000050   0xE7E6             B.N      ??dmp_icm20948_set_accel_scale2_6
   \                     ??dmp_icm20948_set_accel_scale2_5: (+1)
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}
   1011                  return 0;
   \                     ??dmp_icm20948_set_accel_scale2_7: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1012              }
   1013          }
   1014          
   1015          /**
   1016          * Sets the input value for EIS library authentication.
   1017          * @param[in] eis_auth_input		random value between (-1,1) in Q30
   1018          */

   \                                 In section .text, align 2, keep-with-next
   1019          int dmp_icm20948_set_eis_auth_input(struct inv_icm20948 * s, long eis_auth_input)
   1020          {
   \                     dmp_icm20948_set_eis_auth_input: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
   1021              int result;
   1022              unsigned char big8[4];
   1023          
   1024              result = inv_icm20948_write_mems(s, EIS_AUTH_INPUT, 4, inv_icm20948_convert_int32_to_big8(eis_auth_input, big8));
   1025          
   1026              return result;
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000000E   0x4603             MOV      R3,R0
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xF640 0x2104      MOVW     R1,#+2564
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000001C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1027          }
   1028          
   1029          /**
   1030          * Gets the output value from DMP for EIS library authentication.
   1031          * @param[out] &eis_auth_output
   1032          */

   \                                 In section .text, align 2, keep-with-next
   1033          int dmp_icm20948_get_eis_auth_output(struct inv_icm20948 * s, long *eis_auth_output)
   1034          {
   \                     dmp_icm20948_get_eis_auth_output: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   1035              int result;
   1036              unsigned char big8[4];
   1037          
   1038              result = inv_icm20948_read_mems(s, EIS_AUTH_OUTPUT, 4, big8);
   \   00000004   0x466B             MOV      R3,SP
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0xF44F 0x6120      MOV      R1,#+2560
   \   0000000C   0x.... 0x....      BL       inv_icm20948_read_mems
   \   00000010   0x4605             MOV      R5,R0
   1039          
   1040          	*eis_auth_output = inv_icm20948_convert_big8_to_int32(big8);
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       inv_icm20948_convert_big8_to_int32
   \   00000018   0x6020             STR      R0,[R4, #+0]
   1041          
   1042              return result;
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1043          }
   1044          
   1045          /**
   1046          * BAC only works in 56 Hz. Set divider to make sure accel ODR into BAC is 56Hz.
   1047          * @param[in] bac_odr. the values are 56 , 112 , 225 450 or 900 Hz
   1048          */

   \                                 In section .text, align 2, keep-with-next
   1049          int dmp_icm20948_set_bac_rate(struct inv_icm20948 * s, short bac_odr)
   1050          {
   \                     dmp_icm20948_set_bac_rate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   1051              unsigned char reg[4]={0,0,0,0};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   1052              int result;
   1053              short odr;
   1054          
   1055              switch (bac_odr) {
   \   0000000C   0x2938             CMP      R1,#+56
   \   0000000E   0xD00A             BEQ.N    ??dmp_icm20948_set_bac_rate_0
   \   00000010   0x2970             CMP      R1,#+112
   \   00000012   0xD016             BEQ.N    ??dmp_icm20948_set_bac_rate_1
   \   00000014   0x29E1             CMP      R1,#+225
   \   00000016   0xD016             BEQ.N    ??dmp_icm20948_set_bac_rate_2
   \   00000018   0xF5B1 0x7FE1      CMP      R1,#+450
   \   0000001C   0xD015             BEQ.N    ??dmp_icm20948_set_bac_rate_3
   \   0000001E   0xF5B1 0x7F61      CMP      R1,#+900
   \   00000022   0xD014             BEQ.N    ??dmp_icm20948_set_bac_rate_4
   \   00000024   0xE015             B.N      ??dmp_icm20948_set_bac_rate_5
   1056              case DMP_ALGO_FREQ_56:
   1057                  odr = 0;
   \                     ??dmp_icm20948_set_bac_rate_0: (+1)
   \   00000026   0x4610             MOV      R0,R2
   1058                  break;
   1059              case DMP_ALGO_FREQ_112:
   1060                  odr = 1;
   1061                  break;
   1062              case DMP_ALGO_FREQ_225:
   1063                  odr = 3;
   1064                  break;
   1065              case DMP_ALGO_FREQ_450:
   1066                  odr = 7;
   1067                  break;
   1068              case DMP_ALGO_FREQ_900:
   1069                  odr = 15;
   1070                  break;
   1071              default:
   1072                  return -1;
   1073              }
   1074          
   1075              result = inv_icm20948_write_mems(s, BAC_RATE, 2, inv_icm20948_convert_int16_to_big8(odr,reg));
   \                     ??dmp_icm20948_set_bac_rate_6: (+1)
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2202             MOVS     R2,#+2
   \   00000032   0xF240 0x310A      MOVW     R1,#+778
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   1076              if (result) {
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD00B             BEQ.N    ??dmp_icm20948_set_bac_rate_7
   1077                  return result;
   \   00000040   0xBD16             POP      {R1,R2,R4,PC}
   1078              } else {
   \                     ??dmp_icm20948_set_bac_rate_1: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE7F0             B.N      ??dmp_icm20948_set_bac_rate_6
   \                     ??dmp_icm20948_set_bac_rate_2: (+1)
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xE7EE             B.N      ??dmp_icm20948_set_bac_rate_6
   \                     ??dmp_icm20948_set_bac_rate_3: (+1)
   \   0000004A   0x2007             MOVS     R0,#+7
   \   0000004C   0xE7EC             B.N      ??dmp_icm20948_set_bac_rate_6
   \                     ??dmp_icm20948_set_bac_rate_4: (+1)
   \   0000004E   0x200F             MOVS     R0,#+15
   \   00000050   0xE7EA             B.N      ??dmp_icm20948_set_bac_rate_6
   \                     ??dmp_icm20948_set_bac_rate_5: (+1)
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}
   1079                  return 0;
   \                     ??dmp_icm20948_set_bac_rate_7: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1080              }
   1081          }
   1082          
   1083          /**
   1084          * B2S only works in 56 Hz. Set divider to make sure accel ODR into B2S is 56Hz.
   1085          * @param[in] bac_odr. the values are 56 , 112 , 225 450 or 900 Hz
   1086          */

   \                                 In section .text, align 2, keep-with-next
   1087          int dmp_icm20948_set_b2s_rate(struct inv_icm20948 * s, short accel_odr)
   1088          {
   \                     dmp_icm20948_set_b2s_rate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   1089              unsigned char reg[4]={0,0,0,0};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   1090              int result;
   1091              short odr;
   1092          
   1093              switch (accel_odr) {
   \   0000000C   0x2938             CMP      R1,#+56
   \   0000000E   0xD00A             BEQ.N    ??dmp_icm20948_set_b2s_rate_0
   \   00000010   0x2970             CMP      R1,#+112
   \   00000012   0xD016             BEQ.N    ??dmp_icm20948_set_b2s_rate_1
   \   00000014   0x29E1             CMP      R1,#+225
   \   00000016   0xD016             BEQ.N    ??dmp_icm20948_set_b2s_rate_2
   \   00000018   0xF5B1 0x7FE1      CMP      R1,#+450
   \   0000001C   0xD015             BEQ.N    ??dmp_icm20948_set_b2s_rate_3
   \   0000001E   0xF5B1 0x7F61      CMP      R1,#+900
   \   00000022   0xD014             BEQ.N    ??dmp_icm20948_set_b2s_rate_4
   \   00000024   0xE015             B.N      ??dmp_icm20948_set_b2s_rate_5
   1094              case DMP_ALGO_FREQ_56:
   1095                  odr = 0;
   \                     ??dmp_icm20948_set_b2s_rate_0: (+1)
   \   00000026   0x4610             MOV      R0,R2
   1096                  break;
   1097              case DMP_ALGO_FREQ_112:
   1098                  odr = 1;
   1099                  break;
   1100              case DMP_ALGO_FREQ_225:
   1101                  odr = 3;
   1102                  break;
   1103              case DMP_ALGO_FREQ_450:
   1104                  odr = 7;
   1105                  break;
   1106              case DMP_ALGO_FREQ_900:
   1107                  odr = 15;
   1108                  break;
   1109              default:
   1110                  return -1;
   1111              }
   1112          
   1113              result = inv_icm20948_write_mems(s, B2S_RATE, 2, inv_icm20948_convert_int16_to_big8(odr,reg));
   \                     ??dmp_icm20948_set_b2s_rate_6: (+1)
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2202             MOVS     R2,#+2
   \   00000032   0xF44F 0x7142      MOV      R1,#+776
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   1114              if (result) {
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD00B             BEQ.N    ??dmp_icm20948_set_b2s_rate_7
   1115                  return result;
   \   00000040   0xBD16             POP      {R1,R2,R4,PC}
   1116              } else {
   \                     ??dmp_icm20948_set_b2s_rate_1: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE7F0             B.N      ??dmp_icm20948_set_b2s_rate_6
   \                     ??dmp_icm20948_set_b2s_rate_2: (+1)
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xE7EE             B.N      ??dmp_icm20948_set_b2s_rate_6
   \                     ??dmp_icm20948_set_b2s_rate_3: (+1)
   \   0000004A   0x2007             MOVS     R0,#+7
   \   0000004C   0xE7EC             B.N      ??dmp_icm20948_set_b2s_rate_6
   \                     ??dmp_icm20948_set_b2s_rate_4: (+1)
   \   0000004E   0x200F             MOVS     R0,#+15
   \   00000050   0xE7EA             B.N      ??dmp_icm20948_set_b2s_rate_6
   \                     ??dmp_icm20948_set_b2s_rate_5: (+1)
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}
   1117                  return 0;
   \                     ??dmp_icm20948_set_b2s_rate_7: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1118              }
   1119          }
   1120          
   1121          
   1122          /**
   1123          * Sets B2S accel orientation matrix to DMP.
   1124          * @param[in] b2s_mtx. Unit: 1 = 2^30.
   1125          */

   \                                 In section .text, align 2, keep-with-next
   1126          int dmp_icm20948_set_B2S_matrix(struct inv_icm20948 * s, int *b2s_mtx)
   1127          {
   \                     dmp_icm20948_set_B2S_matrix: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1128              int result;
   1129              unsigned char big8[4]={0};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1130          	
   1131              result  = inv_icm20948_write_mems(s, B2S_MTX_00, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[0], big8));
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000016   0x4603             MOV      R3,R0
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0xF44F 0x6150      MOV      R1,#+3328
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000024   0x4606             MOV      R6,R0
   1132              result += inv_icm20948_write_mems(s, B2S_MTX_01, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[1], big8));
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF640 0x5104      MOVW     R1,#+3332
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003C   0x1986             ADDS     R6,R0,R6
   1133              result += inv_icm20948_write_mems(s, B2S_MTX_02, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[2], big8));
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x68A8             LDR      R0,[R5, #+8]
   \   00000042   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000046   0x4603             MOV      R3,R0
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0xF640 0x5108      MOVW     R1,#+3336
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000054   0x1986             ADDS     R6,R0,R6
   1134              result += inv_icm20948_write_mems(s, B2S_MTX_10, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[3], big8));
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x68E8             LDR      R0,[R5, #+12]
   \   0000005A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000005E   0x4603             MOV      R3,R0
   \   00000060   0x2204             MOVS     R2,#+4
   \   00000062   0xF640 0x510C      MOVW     R1,#+3340
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000006C   0x1986             ADDS     R6,R0,R6
   1135              result += inv_icm20948_write_mems(s, B2S_MTX_11, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[4], big8));
   \   0000006E   0x4669             MOV      R1,SP
   \   00000070   0x6928             LDR      R0,[R5, #+16]
   \   00000072   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000076   0x4603             MOV      R3,R0
   \   00000078   0x2204             MOVS     R2,#+4
   \   0000007A   0xF44F 0x6151      MOV      R1,#+3344
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000084   0x1986             ADDS     R6,R0,R6
   1136              result += inv_icm20948_write_mems(s, B2S_MTX_12, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[5], big8));
   \   00000086   0x4669             MOV      R1,SP
   \   00000088   0x6968             LDR      R0,[R5, #+20]
   \   0000008A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000008E   0x4603             MOV      R3,R0
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF640 0x5114      MOVW     R1,#+3348
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000009C   0x1986             ADDS     R6,R0,R6
   1137              result += inv_icm20948_write_mems(s, B2S_MTX_20, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[6], big8));
   \   0000009E   0x4669             MOV      R1,SP
   \   000000A0   0x69A8             LDR      R0,[R5, #+24]
   \   000000A2   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000A6   0x4603             MOV      R3,R0
   \   000000A8   0x2204             MOVS     R2,#+4
   \   000000AA   0xF640 0x5118      MOVW     R1,#+3352
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000B4   0x1986             ADDS     R6,R0,R6
   1138              result += inv_icm20948_write_mems(s, B2S_MTX_21, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[7], big8));
   \   000000B6   0x4669             MOV      R1,SP
   \   000000B8   0x69E8             LDR      R0,[R5, #+28]
   \   000000BA   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000BE   0x4603             MOV      R3,R0
   \   000000C0   0x2204             MOVS     R2,#+4
   \   000000C2   0xF640 0x511C      MOVW     R1,#+3356
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000CC   0x1986             ADDS     R6,R0,R6
   1139              result += inv_icm20948_write_mems(s, B2S_MTX_22, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[8], big8));
   \   000000CE   0x4669             MOV      R1,SP
   \   000000D0   0x6A28             LDR      R0,[R5, #+32]
   \   000000D2   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000D6   0x4603             MOV      R3,R0
   \   000000D8   0x2204             MOVS     R2,#+4
   \   000000DA   0xF44F 0x6152      MOV      R1,#+3360
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000E4   0x1980             ADDS     R0,R0,R6
   1140          
   1141          	if (result)
   \   000000E6   0xD100             BNE.N    ??dmp_icm20948_set_B2S_matrix_0
   1142                  return result;
   1143          
   1144          	return 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_set_B2S_matrix_0: (+1)
   \   000000EA   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1145          }
   1146          
   1147          
   1148          /**
   1149          * PickUp only works in 56 Hz. Set divider to make sure accel ODR into PickUp is 56Hz.
   1150          * @param[in] bac_odr. the values are 56 , 112 , 225 450 or 900 Hz
   1151          */

   \                                 In section .text, align 2, keep-with-next
   1152          int dmp_icm20948_set_fp_rate(struct inv_icm20948 * s, short accel_odr)
   1153          {
   \                     dmp_icm20948_set_fp_rate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   1154          	unsigned char reg[4]={0,0,0,0};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x6002             STR      R2,[R0, #+0]
   1155              int result;
   1156              long odr;
   1157          
   1158              switch (accel_odr) {
   \   0000000C   0x2938             CMP      R1,#+56
   \   0000000E   0xD00A             BEQ.N    ??dmp_icm20948_set_fp_rate_0
   \   00000010   0x2970             CMP      R1,#+112
   \   00000012   0xD016             BEQ.N    ??dmp_icm20948_set_fp_rate_1
   \   00000014   0x29E1             CMP      R1,#+225
   \   00000016   0xD016             BEQ.N    ??dmp_icm20948_set_fp_rate_2
   \   00000018   0xF5B1 0x7FE1      CMP      R1,#+450
   \   0000001C   0xD015             BEQ.N    ??dmp_icm20948_set_fp_rate_3
   \   0000001E   0xF5B1 0x7F61      CMP      R1,#+900
   \   00000022   0xD014             BEQ.N    ??dmp_icm20948_set_fp_rate_4
   \   00000024   0xE015             B.N      ??dmp_icm20948_set_fp_rate_5
   1159              case DMP_ALGO_FREQ_56:
   1160                  odr = 0;
   \                     ??dmp_icm20948_set_fp_rate_0: (+1)
   \   00000026   0x4610             MOV      R0,R2
   1161                  break;
   1162              case DMP_ALGO_FREQ_112:
   1163                  odr = 1;
   1164                  break;
   1165              case DMP_ALGO_FREQ_225:
   1166                  odr = 3;
   1167                  break;
   1168              case DMP_ALGO_FREQ_450:
   1169                  odr = 7;
   1170                  break;
   1171              case DMP_ALGO_FREQ_900:
   1172                  odr = 15;
   1173                  break;
   1174              default:
   1175                  return -1;
   1176              }
   1177          
   1178              result = inv_icm20948_write_mems(s, FP_RATE, 4, inv_icm20948_convert_int32_to_big8(odr,reg));
   \                     ??dmp_icm20948_set_fp_rate_6: (+1)
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   0000002E   0x4603             MOV      R3,R0
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF640 0x710C      MOVW     R1,#+3852
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems
   1179              if (result) {
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD00B             BEQ.N    ??dmp_icm20948_set_fp_rate_7
   1180                  return result;
   \   00000040   0xBD16             POP      {R1,R2,R4,PC}
   1181              } else {
   \                     ??dmp_icm20948_set_fp_rate_1: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE7F0             B.N      ??dmp_icm20948_set_fp_rate_6
   \                     ??dmp_icm20948_set_fp_rate_2: (+1)
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xE7EE             B.N      ??dmp_icm20948_set_fp_rate_6
   \                     ??dmp_icm20948_set_fp_rate_3: (+1)
   \   0000004A   0x2007             MOVS     R0,#+7
   \   0000004C   0xE7EC             B.N      ??dmp_icm20948_set_fp_rate_6
   \                     ??dmp_icm20948_set_fp_rate_4: (+1)
   \   0000004E   0x200F             MOVS     R0,#+15
   \   00000050   0xE7EA             B.N      ??dmp_icm20948_set_fp_rate_6
   \                     ??dmp_icm20948_set_fp_rate_5: (+1)
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}
   1182                  return 0;
   \                     ??dmp_icm20948_set_fp_rate_7: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1183              }
   1184          }
   1185          
   1186          /**
   1187          * Clear BAC states when restarting BAC/SMD/Pedometer/Tilt.
   1188          * This avoids false triggering of BAC-related modules.
   1189          */

   \                                 In section .text, align 2, keep-with-next
   1190          int dmp_icm20948_reset_bac_states(struct inv_icm20948 * s)
   1191          {
   \                     dmp_icm20948_reset_bac_states: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   1192              int result;
   1193              unsigned char big8[4]={0,0,0,0};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   1194              unsigned char big8_s[2] = {0,0};
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1195              long reset = 0;
   1196              short reset_s = 0;
   1197          
   1198              result = inv_icm20948_write_mems(s, BAC_STATE,             4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000018   0x4603             MOV      R3,R0
   \   0000001A   0x2204             MOVS     R2,#+4
   \   0000001C   0xF44F 0x6133      MOV      R1,#+2864
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000026   0x4605             MOV      R5,R0
   1199              result += inv_icm20948_write_mems(s, BAC_STATE_PREV,       4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000030   0x4603             MOV      R3,R0
   \   00000032   0x2204             MOVS     R2,#+4
   \   00000034   0xF640 0x3134      MOVW     R1,#+2868
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000003E   0x1945             ADDS     R5,R0,R5
   1200              result += inv_icm20948_write_mems(s, BAC_ACT_ON,           4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000048   0x4603             MOV      R3,R0
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF44F 0x6136      MOV      R1,#+2912
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000056   0x1945             ADDS     R5,R0,R5
   1201              result += inv_icm20948_write_mems(s, BAC_ACT_OFF,          4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000060   0x4603             MOV      R3,R0
   \   00000062   0x2204             MOVS     R2,#+4
   \   00000064   0xF44F 0x6137      MOV      R1,#+2928
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000006E   0x1945             ADDS     R5,R0,R5
   1202              result += inv_icm20948_write_mems(s, BAC_STILL_S_F,        4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000070   0x4669             MOV      R1,SP
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000078   0x4603             MOV      R3,R0
   \   0000007A   0x2204             MOVS     R2,#+4
   \   0000007C   0xF44F 0x6131      MOV      R1,#+2832
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000086   0x1945             ADDS     R5,R0,R5
   1203              result += inv_icm20948_write_mems(s, BAC_RUN_S_F,          4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000088   0x4669             MOV      R1,SP
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000090   0x4603             MOV      R3,R0
   \   00000092   0x2204             MOVS     R2,#+4
   \   00000094   0xF640 0x3114      MOVW     R1,#+2836
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000009E   0x1945             ADDS     R5,R0,R5
   1204              result += inv_icm20948_write_mems(s, BAC_DRIVE_S_F,        4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000000A0   0x4669             MOV      R1,SP
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000A8   0x4603             MOV      R3,R0
   \   000000AA   0x2204             MOVS     R2,#+4
   \   000000AC   0xF44F 0x6132      MOV      R1,#+2848
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000B6   0x1945             ADDS     R5,R0,R5
   1205              result += inv_icm20948_write_mems(s, BAC_WALK_S_F,         4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000000B8   0x4669             MOV      R1,SP
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000C0   0x4603             MOV      R3,R0
   \   000000C2   0x2204             MOVS     R2,#+4
   \   000000C4   0xF640 0x3124      MOVW     R1,#+2852
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000CE   0x1945             ADDS     R5,R0,R5
   1206              result += inv_icm20948_write_mems(s, BAC_SMD_S_F,          4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000000D0   0x4669             MOV      R1,SP
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000D8   0x4603             MOV      R3,R0
   \   000000DA   0x2204             MOVS     R2,#+4
   \   000000DC   0xF640 0x3128      MOVW     R1,#+2856
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000E6   0x1945             ADDS     R5,R0,R5
   1207              result += inv_icm20948_write_mems(s, BAC_BIKE_S_F,         4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000000E8   0x4669             MOV      R1,SP
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000000F0   0x4603             MOV      R3,R0
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0xF640 0x312C      MOVW     R1,#+2860
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000000FE   0x1945             ADDS     R5,R0,R5
   1208              result += inv_icm20948_write_mems(s, BAC_E1_SHORT,         4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000100   0x4669             MOV      R1,SP
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000108   0x4603             MOV      R3,R0
   \   0000010A   0x2204             MOVS     R2,#+4
   \   0000010C   0xF44F 0x6112      MOV      R1,#+2336
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000116   0x1945             ADDS     R5,R0,R5
   1209              result += inv_icm20948_write_mems(s, BAC_E2_SHORT,         4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000118   0x4669             MOV      R1,SP
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000120   0x4603             MOV      R3,R0
   \   00000122   0x2204             MOVS     R2,#+4
   \   00000124   0xF640 0x1124      MOVW     R1,#+2340
   \   00000128   0x4620             MOV      R0,R4
   \   0000012A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000012E   0x1945             ADDS     R5,R0,R5
   1210              result += inv_icm20948_write_mems(s, BAC_E3_SHORT,         4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000130   0x4669             MOV      R1,SP
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000138   0x4603             MOV      R3,R0
   \   0000013A   0x2204             MOVS     R2,#+4
   \   0000013C   0xF640 0x1128      MOVW     R1,#+2344
   \   00000140   0x4620             MOV      R0,R4
   \   00000142   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000146   0x1945             ADDS     R5,R0,R5
   1211              result += inv_icm20948_write_mems(s, BAC_VAR_RUN,          4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000148   0x4669             MOV      R1,SP
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000150   0x4603             MOV      R3,R0
   \   00000152   0x2204             MOVS     R2,#+4
   \   00000154   0xF640 0x114C      MOVW     R1,#+2380
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000015E   0x1945             ADDS     R5,R0,R5
   1212              result += inv_icm20948_write_mems(s, BAC_DRIVE_CONFIDENCE, 4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000160   0x4669             MOV      R1,SP
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000168   0x4603             MOV      R3,R0
   \   0000016A   0x2204             MOVS     R2,#+4
   \   0000016C   0xF44F 0x6110      MOV      R1,#+2304
   \   00000170   0x4620             MOV      R0,R4
   \   00000172   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000176   0x1945             ADDS     R5,R0,R5
   1213              result += inv_icm20948_write_mems(s, BAC_WALK_CONFIDENCE,  4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000178   0x4669             MOV      R1,SP
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000180   0x4603             MOV      R3,R0
   \   00000182   0x2204             MOVS     R2,#+4
   \   00000184   0xF640 0x1104      MOVW     R1,#+2308
   \   00000188   0x4620             MOV      R0,R4
   \   0000018A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000018E   0x1945             ADDS     R5,R0,R5
   1214              result += inv_icm20948_write_mems(s, BAC_SMD_CONFIDENCE,   4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000190   0x4669             MOV      R1,SP
   \   00000192   0x2000             MOVS     R0,#+0
   \   00000194   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000198   0x4603             MOV      R3,R0
   \   0000019A   0x2204             MOVS     R2,#+4
   \   0000019C   0xF640 0x1108      MOVW     R1,#+2312
   \   000001A0   0x4620             MOV      R0,R4
   \   000001A2   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000001A6   0x1945             ADDS     R5,R0,R5
   1215              result += inv_icm20948_write_mems(s, BAC_BIKE_CONFIDENCE,  4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000001A8   0x4669             MOV      R1,SP
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000001B0   0x4603             MOV      R3,R0
   \   000001B2   0x2204             MOVS     R2,#+4
   \   000001B4   0xF640 0x110C      MOVW     R1,#+2316
   \   000001B8   0x4620             MOV      R0,R4
   \   000001BA   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000001BE   0x1945             ADDS     R5,R0,R5
   1216              result += inv_icm20948_write_mems(s, BAC_STILL_CONFIDENCE, 4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000001C0   0x4669             MOV      R1,SP
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000001C8   0x4603             MOV      R3,R0
   \   000001CA   0x2204             MOVS     R2,#+4
   \   000001CC   0xF44F 0x6111      MOV      R1,#+2320
   \   000001D0   0x4620             MOV      R0,R4
   \   000001D2   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000001D6   0x1945             ADDS     R5,R0,R5
   1217              result += inv_icm20948_write_mems(s, BAC_RUN_CONFIDENCE,   4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000001D8   0x4669             MOV      R1,SP
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000001E0   0x4603             MOV      R3,R0
   \   000001E2   0x2204             MOVS     R2,#+4
   \   000001E4   0xF640 0x1114      MOVW     R1,#+2324
   \   000001E8   0x4620             MOV      R0,R4
   \   000001EA   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000001EE   0x1945             ADDS     R5,R0,R5
   1218              result += inv_icm20948_write_mems(s, BAC_MODE_CNTR,        4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   000001F0   0x4669             MOV      R1,SP
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   000001F8   0x4603             MOV      R3,R0
   \   000001FA   0x2204             MOVS     R2,#+4
   \   000001FC   0xF44F 0x6116      MOV      R1,#+2400
   \   00000200   0x4620             MOV      R0,R4
   \   00000202   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000206   0x1945             ADDS     R5,R0,R5
   1219              result += inv_icm20948_write_mems(s, BAC_STATE_T_PREV,     4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000208   0x4669             MOV      R1,SP
   \   0000020A   0x2000             MOVS     R0,#+0
   \   0000020C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000210   0x4603             MOV      R3,R0
   \   00000212   0x2204             MOVS     R2,#+4
   \   00000214   0xF640 0x3194      MOVW     R1,#+2964
   \   00000218   0x4620             MOV      R0,R4
   \   0000021A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000021E   0x1945             ADDS     R5,R0,R5
   1220              result += inv_icm20948_write_mems(s, BAC_ACT_T_ON,         4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000220   0x4669             MOV      R1,SP
   \   00000222   0x2000             MOVS     R0,#+0
   \   00000224   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000228   0x4603             MOV      R3,R0
   \   0000022A   0x2204             MOVS     R2,#+4
   \   0000022C   0xF44F 0x6138      MOV      R1,#+2944
   \   00000230   0x4620             MOV      R0,R4
   \   00000232   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000236   0x1945             ADDS     R5,R0,R5
   1221              result += inv_icm20948_write_mems(s, BAC_ACT_T_OFF,        4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000238   0x4669             MOV      R1,SP
   \   0000023A   0x2000             MOVS     R0,#+0
   \   0000023C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000240   0x4603             MOV      R3,R0
   \   00000242   0x2204             MOVS     R2,#+4
   \   00000244   0xF640 0x3184      MOVW     R1,#+2948
   \   00000248   0x4620             MOV      R0,R4
   \   0000024A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000024E   0x1945             ADDS     R5,R0,R5
   1222              result += inv_icm20948_write_mems(s, BAC_STATE_WRDBS_PREV, 4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000250   0x4669             MOV      R1,SP
   \   00000252   0x2000             MOVS     R0,#+0
   \   00000254   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000258   0x4603             MOV      R3,R0
   \   0000025A   0x2204             MOVS     R2,#+4
   \   0000025C   0xF640 0x3198      MOVW     R1,#+2968
   \   00000260   0x4620             MOV      R0,R4
   \   00000262   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000266   0x1945             ADDS     R5,R0,R5
   1223              result += inv_icm20948_write_mems(s, BAC_ACT_WRDBS_ON,     4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000268   0x4669             MOV      R1,SP
   \   0000026A   0x2000             MOVS     R0,#+0
   \   0000026C   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000270   0x4603             MOV      R3,R0
   \   00000272   0x2204             MOVS     R2,#+4
   \   00000274   0xF640 0x3188      MOVW     R1,#+2952
   \   00000278   0x4620             MOV      R0,R4
   \   0000027A   0x.... 0x....      BL       inv_icm20948_write_mems
   \   0000027E   0x1945             ADDS     R5,R0,R5
   1224              result += inv_icm20948_write_mems(s, BAC_ACT_WRDBS_OFF,    4, inv_icm20948_convert_int32_to_big8(reset, big8));
   \   00000280   0x4669             MOV      R1,SP
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000288   0x4603             MOV      R3,R0
   \   0000028A   0x2204             MOVS     R2,#+4
   \   0000028C   0xF640 0x318C      MOVW     R1,#+2956
   \   00000290   0x4620             MOV      R0,R4
   \   00000292   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000296   0x1945             ADDS     R5,R0,R5
   1225              result += inv_icm20948_write_mems(s, BAC_ACT_ON_OFF,       2, inv_icm20948_convert_int16_to_big8(reset_s, big8_s));
   \   00000298   0xA901             ADD      R1,SP,#+4
   \   0000029A   0x2000             MOVS     R0,#+0
   \   0000029C   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   000002A0   0x4603             MOV      R3,R0
   \   000002A2   0x2202             MOVS     R2,#+2
   \   000002A4   0xF640 0x31E2      MOVW     R1,#+3042
   \   000002A8   0x4620             MOV      R0,R4
   \   000002AA   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000002AE   0x1945             ADDS     R5,R0,R5
   1226              result += inv_icm20948_write_mems(s, PREV_BAC_ACT_ON_OFF,  2, inv_icm20948_convert_int16_to_big8(reset_s, big8_s));
   \   000002B0   0xA901             ADD      R1,SP,#+4
   \   000002B2   0x2000             MOVS     R0,#+0
   \   000002B4   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   000002B8   0x4603             MOV      R3,R0
   \   000002BA   0x2202             MOVS     R2,#+2
   \   000002BC   0xF640 0x31C2      MOVW     R1,#+3010
   \   000002C0   0x4620             MOV      R0,R4
   \   000002C2   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000002C6   0x1945             ADDS     R5,R0,R5
   1227              result += inv_icm20948_write_mems(s, BAC_CNTR,             2, inv_icm20948_convert_int16_to_big8(reset_s, big8_s));
   \   000002C8   0xA901             ADD      R1,SP,#+4
   \   000002CA   0x2000             MOVS     R0,#+0
   \   000002CC   0x.... 0x....      BL       inv_icm20948_convert_int16_to_big8
   \   000002D0   0x4603             MOV      R3,R0
   \   000002D2   0x2202             MOVS     R2,#+2
   \   000002D4   0xF240 0x3102      MOVW     R1,#+770
   \   000002D8   0x4620             MOV      R0,R4
   \   000002DA   0x.... 0x....      BL       inv_icm20948_write_mems
   \   000002DE   0x1940             ADDS     R0,R0,R5
   1228          
   1229          	if (result)
   \   000002E0   0xD100             BNE.N    ??dmp_icm20948_reset_bac_states_0
   1230                  return result;
   1231          
   1232          	return 0;
   \   000002E2   0x2000             MOVS     R0,#+0
   \                     ??dmp_icm20948_reset_bac_states_0: (+1)
   \   000002E4   0xBD3E             POP      {R1-R5,PC}       ;; return
   1233          }
   1234          
   1235          /**
   1236          * Set BAC ped y ration
   1237          * @param[in] ped_y_ratio: value will influence pedometer result
   1238          */

   \                                 In section .text, align 2, keep-with-next
   1239          int dmp_icm20948_set_ped_y_ratio(struct inv_icm20948 * s, long ped_y_ratio)
   1240          {
   \                     dmp_icm20948_set_ped_y_ratio: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
   1241              int result;
   1242              unsigned char big8[4]={0, 0, 0, 0};
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   1243          
   1244              result = inv_icm20948_write_mems(s, PED_Y_RATIO, 4, inv_icm20948_convert_int32_to_big8(ped_y_ratio, big8));
   1245          
   1246              return result;
   \   0000000E   0x.... 0x....      BL       inv_icm20948_convert_int32_to_big8
   \   00000012   0x4603             MOV      R3,R0
   \   00000014   0x2204             MOVS     R2,#+4
   \   00000016   0xF44F 0x7188      MOV      R1,#+272
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       inv_icm20948_write_mems
   \   00000020   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1247          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     `dmp_icm20948_set_data_output_control2::data_output_control_reg2`

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_1:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_2:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_3:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_4:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_6:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_18:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_20:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_21:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_22:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_23:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_24:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_25:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_26:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_27:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   dmp_icm20948_get_bias_acc
        24   -> inv_icm20948_convert_big8_to_int32
        24   -> inv_icm20948_read_mems
      24   dmp_icm20948_get_bias_cmp
        24   -> inv_icm20948_convert_big8_to_int32
        24   -> inv_icm20948_read_mems
      24   dmp_icm20948_get_bias_gyr
        24   -> inv_icm20948_convert_big8_to_int32
        24   -> inv_icm20948_read_mems
      16   dmp_icm20948_get_eis_auth_output
        16   -> inv_icm20948_convert_big8_to_int32
        16   -> inv_icm20948_read_mems
      16   dmp_icm20948_get_pedometer_num_of_steps
        16   -> inv_icm20948_read_mems
      24   dmp_icm20948_reset_bac_states
        24   -> inv_icm20948_convert_int16_to_big8
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      16   dmp_icm20948_reset_control_registers
        16   -> inv_icm20948_write_mems
      24   dmp_icm20948_set_B2S_matrix
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_FIFO_watermark
        16   -> inv_icm20948_convert_int16_to_big8
        16   -> inv_icm20948_write_mems
      24   dmp_icm20948_set_accel_cal_params
        24   -> inv_icm20948_convert_int16_to_big8
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_accel_feedback_gain
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_accel_fsr
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_accel_scale2
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_b2s_rate
        16   -> inv_icm20948_convert_int16_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_bac_rate
        16   -> inv_icm20948_convert_int16_to_big8
        16   -> inv_icm20948_write_mems
      32   dmp_icm20948_set_batchmode_params
        32   -> inv_icm20948_convert_int16_to_big8
        32   -> inv_icm20948_convert_int32_to_big8
        32   -> inv_icm20948_write_mems
      24   dmp_icm20948_set_bias_acc
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      24   dmp_icm20948_set_bias_cmp
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      24   dmp_icm20948_set_bias_gyr
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      24   dmp_icm20948_set_compass_cal_params
        24   -> inv_icm20948_convert_int16_to_big8
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      24   dmp_icm20948_set_compass_matrix
        24   -> inv_icm20948_convert_int32_to_big8
        24   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_data_interrupt_control
        16   -> inv_icm20948_convert_int16_to_big8
        16   -> inv_icm20948_write_mems
       8   dmp_icm20948_set_data_output_control1
         8   -> inv_icm20948_write_mems
       0   dmp_icm20948_set_data_output_control2
         0   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_data_rdy_status
        16   -> inv_icm20948_convert_int16_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_eis_auth_input
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_fp_rate
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_gyro_sf
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
       8   dmp_icm20948_set_motion_event_control
         8   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_ped_y_ratio
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
       0   dmp_icm20948_set_pedometer_rate
      16   dmp_icm20948_set_sensor_rate
        16   -> inv_icm20948_convert_int16_to_big8
        16   -> inv_icm20948_write_mems
       8   dmp_icm20948_set_wom_enable
         8   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_wom_motion_threshold
        16   -> inv_icm20948_convert_int32_to_big8
        16   -> inv_icm20948_write_mems
      16   dmp_icm20948_set_wom_time_threshold
        16   -> inv_icm20948_convert_int16_to_big8
        16   -> inv_icm20948_write_mems
       0   inv_icm20948_get_dmp_start_address
       0   inv_icm20948_load_firmware
         0   -> inv_icm20948_firmware_load


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ?_0
       2  ?_1
       4  ?_10
       4  ?_11
       4  ?_12
       4  ?_13
       4  ?_14
       4  ?_15
       4  ?_16
       4  ?_17
       2  ?_18
       4  ?_19
       2  ?_2
       2  ?_20
       4  ?_21
       4  ?_22
       4  ?_23
       4  ?_24
       4  ?_25
       2  ?_26
       4  ?_27
       2  ?_3
       2  ?_4
       4  ?_5
       2  ?_6
       4  ?_7
       4  ?_8
       4  ?_9
       2  data_output_control_reg2
      98  dmp_icm20948_get_bias_acc
      98  dmp_icm20948_get_bias_cmp
      98  dmp_icm20948_get_bias_gyr
      30  dmp_icm20948_get_eis_auth_output
      62  dmp_icm20948_get_pedometer_num_of_steps
     742  dmp_icm20948_reset_bac_states
      86  dmp_icm20948_reset_control_registers
     236  dmp_icm20948_set_B2S_matrix
      44  dmp_icm20948_set_FIFO_watermark
      94  dmp_icm20948_set_accel_cal_params
      40  dmp_icm20948_set_accel_feedback_gain
      92  dmp_icm20948_set_accel_fsr
      92  dmp_icm20948_set_accel_scale2
      92  dmp_icm20948_set_b2s_rate
      92  dmp_icm20948_set_bac_rate
      92  dmp_icm20948_set_batchmode_params
      92  dmp_icm20948_set_bias_acc
      92  dmp_icm20948_set_bias_cmp
      92  dmp_icm20948_set_bias_gyr
      70  dmp_icm20948_set_compass_cal_params
     236  dmp_icm20948_set_compass_matrix
      42  dmp_icm20948_set_data_interrupt_control
      24  dmp_icm20948_set_data_output_control1
      16  dmp_icm20948_set_data_output_control2
      42  dmp_icm20948_set_data_rdy_status
      30  dmp_icm20948_set_eis_auth_input
      92  dmp_icm20948_set_fp_rate
      30  dmp_icm20948_set_gyro_sf
      26  dmp_icm20948_set_motion_event_control
      34  dmp_icm20948_set_ped_y_ratio
       4  dmp_icm20948_set_pedometer_rate
     102  dmp_icm20948_set_sensor_rate
      38  dmp_icm20948_set_wom_enable
      40  dmp_icm20948_set_wom_motion_threshold
      44  dmp_icm20948_set_wom_time_threshold
       8  inv_icm20948_get_dmp_start_address
       8  inv_icm20948_load_firmware

 
     2 bytes in section .bss
    96 bytes in section .rodata
 3 254 bytes in section .text
 
 3 254 bytes of CODE  memory
    96 bytes of CONST memory
     2 bytes of DATA  memory

Errors: none
Warnings: none
