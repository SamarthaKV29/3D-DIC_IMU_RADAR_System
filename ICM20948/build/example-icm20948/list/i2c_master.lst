###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:27
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\board-hal\i2c_master.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\board-hal\i2c_master.c -D
#        IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D NUCLEO
#        -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000 -D
#        STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\i2c_master.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\i2c_master.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\board-hal\i2c_master.c
      1          /*
      2           * ________________________________________________________________________________________________________
      3           * Copyright (c) 2016-2016 InvenSense Inc. All rights reserved.
      4           *
      5           * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      6           * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
      7           * and other intellectual property rights laws.
      8           *
      9           * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
     10           * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
     11           * from InvenSense is strictly prohibited.
     12           *
     13           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
     14           * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
     15           * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
     17           * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18           * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
     19           * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20           * OF THE SOFTWARE.
     21           * ________________________________________________________________________________________________________
     22           */
     23          
     24          #include "i2c_master.h"
     25          
     26          #include "stm32f4xx.h"
     27          #include "stm32f4xx_gpio.h"
     28          #include "stm32f4xx_i2c.h"
     29          #include "stm32f4xx_rcc.h"
     30          
     31          /********************************* Globals ************************************/
     32          
     33          /********************************* Prototypes *********************************/
     34          

   \                                 In section .bss, align 1
     35          static uint8_t IsInited = 0;
   \                     IsInited:
   \   00000000                      DS8 1
     36          

   \                                 In section .text, align 2, keep-with-next
     37          void i2c_master_init(void)
     38          {
   \                     i2c_master_init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     39          	GPIO_InitTypeDef GPIO_InitStructure;
     40          	I2C_InitTypeDef I2C_InitStructure;
     41          
     42          	if(IsInited != 0)
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable6
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD151             BNE.N    ??i2c_master_init_0
     43          		return;
     44          
     45          	/* Enable I2Cx clock */
     46          	RCC_APB1PeriphClockCmd(SENSORS_I2C_RCC_CLK, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000014   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     47          
     48          	/* Enable I2C GPIO clock */
     49          	RCC_AHB1PeriphClockCmd(SENSORS_I2C_SCL_GPIO_CLK | SENSORS_I2C_SDA_GPIO_CLK, ENABLE);
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
     50          
     51          	/* Configure I2Cx pin: SCL ----------------------------------------*/
     52          	GPIO_InitStructure.GPIO_Pin =  SENSORS_I2C_SCL_GPIO_PIN;
   \   00000020   0xF44F 0x7080      MOV      R0,#+256
   \   00000024   0x9000             STR      R0,[SP, #+0]
     53          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF88D 0x0004      STRB     R0,[SP, #+4]
     54          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF88D 0x0005      STRB     R0,[SP, #+5]
     55          	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
   \   00000032   0xF88D 0x0006      STRB     R0,[SP, #+6]
     56          	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF88D 0x0007      STRB     R0,[SP, #+7]
     57          
     58          	/* Connect pins to Periph */
     59          	GPIO_PinAFConfig(SENSORS_I2C_SCL_GPIO_PORT, SENSORS_I2C_SCL_GPIO_PINSOURCE, SENSORS_I2C_AF_SCL);
   \   0000003C   0x.... 0x....      LDR.W    R5,??DataTable6_1  ;; 0x40020400
   \   00000040   0x2204             MOVS     R2,#+4
   \   00000042   0x2108             MOVS     R1,#+8
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       GPIO_PinAFConfig
     60          	GPIO_Init(SENSORS_I2C_SCL_GPIO_PORT, &GPIO_InitStructure);
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x4628             MOV      R0,R5
   \   0000004E   0x.... 0x....      BL       GPIO_Init
     61          
     62          	/* Configure I2Cx pin: SDA ----------------------------------------*/
     63          	GPIO_InitStructure.GPIO_Pin = SENSORS_I2C_SDA_GPIO_PIN;
   \   00000052   0xF44F 0x7000      MOV      R0,#+512
   \   00000056   0x9000             STR      R0,[SP, #+0]
     64          
     65          	/* Connect pins to Periph */
     66          	GPIO_PinAFConfig(SENSORS_I2C_SDA_GPIO_PORT, SENSORS_I2C_SDA_GPIO_PINSOURCE, SENSORS_I2C_AF_SDA);
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0x2109             MOVS     R1,#+9
   \   0000005C   0x4628             MOV      R0,R5
   \   0000005E   0x.... 0x....      BL       GPIO_PinAFConfig
     67          	GPIO_Init(SENSORS_I2C_SDA_GPIO_PORT, &GPIO_InitStructure);
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x4628             MOV      R0,R5
   \   00000066   0x.... 0x....      BL       GPIO_Init
     68          
     69          	I2C_DeInit(SENSORS_I2C);
   \   0000006A   0x.... 0x....      LDR.W    R5,??DataTable6_2  ;; 0x40005400
   \   0000006E   0x4628             MOV      R0,R5
   \   00000070   0x.... 0x....      BL       I2C_DeInit
     70          	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF8AD 0x000C      STRH     R0,[SP, #+12]
     71          	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000007A   0xF64B 0x70FF      MOVW     R0,#+49151
   \   0000007E   0xF8AD 0x000E      STRH     R0,[SP, #+14]
     72          	I2C_InitStructure.I2C_OwnAddress1 = I2C_OWN_ADDRESS;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF8AD 0x0010      STRH     R0,[SP, #+16]
     73          	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   00000088   0xF44F 0x6080      MOV      R0,#+1024
   \   0000008C   0xF8AD 0x0012      STRH     R0,[SP, #+18]
     74          	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000090   0xF44F 0x4080      MOV      R0,#+16384
   \   00000094   0xF8AD 0x0014      STRH     R0,[SP, #+20]
     75          	I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable6_3  ;; 0x61a80
   \   0000009C   0x9002             STR      R0,[SP, #+8]
     76          
     77          	/* Enable the I2C peripheral */
     78          	I2C_Cmd(SENSORS_I2C, ENABLE);
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x4628             MOV      R0,R5
   \   000000A2   0x.... 0x....      BL       I2C_Cmd
     79          
     80          	/* Initialize the I2C peripheral */
     81          	I2C_Init(SENSORS_I2C, &I2C_InitStructure);
   \   000000A6   0xA902             ADD      R1,SP,#+8
   \   000000A8   0x4628             MOV      R0,R5
   \   000000AA   0x.... 0x....      BL       I2C_Init
     82          
     83          	IsInited = 1;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x7020             STRB     R0,[R4, #+0]
     84          }
   \                     ??i2c_master_init_0: (+1)
   \   000000B2   0xB007             ADD      SP,SP,#+28
   \   000000B4   0xBD30             POP      {R4,R5,PC}       ;; return
     85          
     86          /**
     87            * @brief  Basic management of the timeout situation.
     88            * @param  None.
     89            * @retval None.
     90            */

   \                                 In section .text, align 2, keep-with-next
     91          static uint32_t I2Cx_TIMEOUT_UserCallback(char value)
     92          {
   \                     I2Cx_TIMEOUT_UserCallback: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
     93          	(void)value;
     94          
     95          	/* The following code allows I2C error recovery and return to normal communication
     96          	 if the error source doesn’t still exist (ie. hardware issue..) */
     97          	I2C_InitTypeDef I2C_InitStructure;
     98          
     99          	I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable6_2  ;; 0x40005400
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       I2C_GenerateSTOP
    100          
    101          	I2C_SoftwareResetCmd(SENSORS_I2C, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       I2C_SoftwareResetCmd
    102          	I2C_SoftwareResetCmd(SENSORS_I2C, DISABLE);
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       I2C_SoftwareResetCmd
    103          
    104          	I2C_DeInit(SENSORS_I2C);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       I2C_DeInit
    105          	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    106          	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000002A   0xF64B 0x70FF      MOVW     R0,#+49151
   \   0000002E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    107          	I2C_InitStructure.I2C_OwnAddress1 = I2C_OWN_ADDRESS;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    108          	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   \   00000038   0xF44F 0x6080      MOV      R0,#+1024
   \   0000003C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    109          	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000040   0xF44F 0x4080      MOV      R0,#+16384
   \   00000044   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    110          	I2C_InitStructure.I2C_ClockSpeed = I2C_SPEED;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable6_3  ;; 0x61a80
   \   0000004C   0x9000             STR      R0,[SP, #+0]
    111          
    112          	/* Enable the I2C peripheral */
    113          	I2C_Cmd(SENSORS_I2C, ENABLE);
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       I2C_Cmd
    114          
    115          	/* Initialize the I2C peripheral */
    116          	I2C_Init(SENSORS_I2C, &I2C_InitStructure);
   \   00000056   0x4669             MOV      R1,SP
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       I2C_Init
    117          
    118          	return 1;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xB004             ADD      SP,SP,#+16
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
    119          }
    120          

   \                                 In section .text, align 2, keep-with-next
    121          unsigned long i2c_master_write_register(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, const unsigned char *RegisterValue)
    122          {
   \                     i2c_master_write_register: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
    123          	uint32_t  result = 0;
    124          	uint32_t  i = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
    125          	__IO uint32_t  I2CTimeout = I2Cx_LONG_TIMEOUT;
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable6_4  ;; 0x41eb0
   \   00000012   0x9100             STR      R1,[SP, #+0]
    126          
    127          	/* Shift the 7-bit address */
    128          	Address = Address << 1;
   \   00000014   0xEA4F 0x0940      LSL      R9,R0,#+1
    129          
    130          	/* Wait for the busy flag to be cleared */
    131          	WAIT_FOR_FLAG (I2C_FLAG_BUSY, RESET, I2Cx_LONG_TIMEOUT, 1);
   \   00000018   0x9100             STR      R1,[SP, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R7,??DataTable6_2  ;; 0x40005400
   \                     ??i2c_master_write_register_0: (+1)
   \   0000001E   0xF44F 0x3100      MOV      R1,#+131072
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD008             BEQ.N    ??i2c_master_write_register_1
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x1E41             SUBS     R1,R0,#+1
   \   00000030   0x9100             STR      R1,[SP, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1F3             BNE.N    ??i2c_master_write_register_0
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   0000003C   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    132          
    133          	/* Start the config sequence */
    134          	I2C_GenerateSTART(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_write_register_1: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x4638             MOV      R0,R7
   \   00000042   0x.... 0x....      BL       I2C_GenerateSTART
    135          
    136          	/* Wait for the start bit to be set */
    137          	WAIT_FOR_FLAG (I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 2);
   \   00000046   0xF44F 0x7861      MOV      R8,#+900
   \   0000004A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_write_register_2: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable6_5  ;; 0x10000001
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD008             BEQ.N    ??i2c_master_write_register_3
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x1E41             SUBS     R1,R0,#+1
   \   00000060   0x9100             STR      R1,[SP, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD1F3             BNE.N    ??i2c_master_write_register_2
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   0000006C   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    138          
    139          	/* Transmit the slave address and enable writing operation */
    140          	I2C_Send7bitAddress(SENSORS_I2C, Address, I2C_Direction_Transmitter);
   \                     ??i2c_master_write_register_3: (+1)
   \   0000006E   0x4632             MOV      R2,R6
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0xB2C9             UXTB     R1,R1
   \   00000074   0x4638             MOV      R0,R7
   \   00000076   0x.... 0x....      BL       I2C_Send7bitAddress
    141          
    142          	/* Wait for address bit to be set */
    143          	WAIT_FOR_FLAG (I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 3);
   \   0000007A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_write_register_4: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable6_6  ;; 0x10000002
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD008             BEQ.N    ??i2c_master_write_register_5
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x1E41             SUBS     R1,R0,#+1
   \   00000090   0x9100             STR      R1,[SP, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD1F3             BNE.N    ??i2c_master_write_register_4
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   0000009C   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    144          
    145          	/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    146          	CLEAR_ADDR_BIT
   \                     ??i2c_master_write_register_5: (+1)
   \   0000009E   0x2114             MOVS     R1,#+20
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x.... 0x....      BL       I2C_ReadRegister
   \   000000A6   0x2118             MOVS     R1,#+24
   \   000000A8   0x4638             MOV      R0,R7
   \   000000AA   0x.... 0x....      BL       I2C_ReadRegister
    147          
    148          	/* Wait for address bit to be set */
    149          	WAIT_FOR_FLAG (I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 4);
   \   000000AE   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000B2   0x.... 0x....      LDR.W    R9,??DataTable6_7  ;; 0x10000080
   \                     ??i2c_master_write_register_6: (+1)
   \   000000B6   0x4649             MOV      R1,R9
   \   000000B8   0x4638             MOV      R0,R7
   \   000000BA   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000BE   0x2801             CMP      R0,#+1
   \   000000C0   0xD008             BEQ.N    ??i2c_master_write_register_7
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   \   000000C4   0x1E41             SUBS     R1,R0,#+1
   \   000000C6   0x9100             STR      R1,[SP, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD1F4             BNE.N    ??i2c_master_write_register_6
   \   000000CC   0x2004             MOVS     R0,#+4
   \   000000CE   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   000000D2   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    150          
    151          	/* Transmit the first address for write operation */
    152          	I2C_SendData(SENSORS_I2C, RegisterAddr);
   \                     ??i2c_master_write_register_7: (+1)
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x4638             MOV      R0,R7
   \   000000D8   0x.... 0x....      BL       I2C_SendData
    153          
    154          	for(i=0; i<(RegisterLen); i++)
   \   000000DC   0xE004             B.N      ??i2c_master_write_register_8
    155          	{
    156          		/* Wait for address bit to be set */
    157          		WAIT_FOR_FLAG (I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 5);
    158          
    159          		/* Prepare the register value to be sent */
    160          		I2C_SendData(SENSORS_I2C, RegisterValue[i]);
   \                     ??i2c_master_write_register_9: (+1)
   \   000000DE   0x5DA9             LDRB     R1,[R5, R6]
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0x.... 0x....      BL       I2C_SendData
   \   000000E6   0x1C76             ADDS     R6,R6,#+1
   \                     ??i2c_master_write_register_8: (+1)
   \   000000E8   0x42A6             CMP      R6,R4
   \   000000EA   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000EE   0xD20E             BCS.N    ??i2c_master_write_register_10
   \                     ??i2c_master_write_register_11: (+1)
   \   000000F0   0x4649             MOV      R1,R9
   \   000000F2   0x4638             MOV      R0,R7
   \   000000F4   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD0F0             BEQ.N    ??i2c_master_write_register_9
   \   000000FC   0x9800             LDR      R0,[SP, #+0]
   \   000000FE   0x1E41             SUBS     R1,R0,#+1
   \   00000100   0x9100             STR      R1,[SP, #+0]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD1F4             BNE.N    ??i2c_master_write_register_11
   \   00000106   0x2005             MOVS     R0,#+5
   \   00000108   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   0000010C   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    161          	}
    162          
    163          	/* Wait for address bit to be set */
    164          	WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 6);
   \                     ??i2c_master_write_register_10: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x10000004
   \   00000112   0x4638             MOV      R0,R7
   \   00000114   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000118   0x2801             CMP      R0,#+1
   \   0000011A   0xD008             BEQ.N    ??i2c_master_write_register_12
   \   0000011C   0x9800             LDR      R0,[SP, #+0]
   \   0000011E   0x1E41             SUBS     R1,R0,#+1
   \   00000120   0x9100             STR      R1,[SP, #+0]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD1F3             BNE.N    ??i2c_master_write_register_10
   \   00000126   0x2006             MOVS     R0,#+6
   \   00000128   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   0000012C   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    165          
    166          	/* End the configuration sequence */
    167          	I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_write_register_12: (+1)
   \   0000012E   0x2101             MOVS     R1,#+1
   \   00000130   0x4638             MOV      R0,R7
   \   00000132   0x.... 0x....      BL       I2C_GenerateSTOP
    168          
    169          	/* Return the verifying value: 0 (Passed) or 1 (Failed) */
    170          	return result;
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    171          }
    172          

   \                                 In section .text, align 2, keep-with-next
    173          unsigned long i2c_master_write_raw(unsigned char Address, unsigned short RegisterLen, const unsigned char *RegisterValue)
    174          {
   \                     i2c_master_write_raw: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
    175          	uint32_t  result = 0;
    176          	uint32_t  i = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    177          	__IO uint32_t  I2CTimeout = I2Cx_LONG_TIMEOUT;
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable6_4  ;; 0x41eb0
   \   0000000E   0x9100             STR      R1,[SP, #+0]
    178          
    179          	/* Shift the 7-bit address */
    180          	Address = Address << 1;
   \   00000010   0xEA4F 0x0940      LSL      R9,R0,#+1
    181          
    182          	/* Wait for the busy flag to be cleared */
    183          	WAIT_FOR_FLAG (I2C_FLAG_BUSY, RESET, I2Cx_LONG_TIMEOUT, 1);
   \   00000014   0x9100             STR      R1,[SP, #+0]
   \   00000016   0x.... 0x....      LDR.W    R7,??DataTable6_2  ;; 0x40005400
   \                     ??i2c_master_write_raw_0: (+1)
   \   0000001A   0xF44F 0x3100      MOV      R1,#+131072
   \   0000001E   0x4638             MOV      R0,R7
   \   00000020   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD008             BEQ.N    ??i2c_master_write_raw_1
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x1E41             SUBS     R1,R0,#+1
   \   0000002C   0x9100             STR      R1,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??i2c_master_write_raw_0
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000038   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    184          
    185          	/* Start the config sequence */
    186          	I2C_GenerateSTART(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_write_raw_1: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x4638             MOV      R0,R7
   \   0000003E   0x.... 0x....      BL       I2C_GenerateSTART
    187          
    188          	/* Wait for the start bit to be set */
    189          	WAIT_FOR_FLAG (I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 2);
   \   00000042   0xF44F 0x7861      MOV      R8,#+900
   \   00000046   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_write_raw_2: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable6_5  ;; 0x10000001
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD008             BEQ.N    ??i2c_master_write_raw_3
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x1E41             SUBS     R1,R0,#+1
   \   0000005C   0x9100             STR      R1,[SP, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1F3             BNE.N    ??i2c_master_write_raw_2
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000068   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    190          
    191          	/* Transmit the slave address and enable writing operation */
    192          	I2C_Send7bitAddress(SENSORS_I2C, Address, I2C_Direction_Transmitter);
   \                     ??i2c_master_write_raw_3: (+1)
   \   0000006A   0x4632             MOV      R2,R6
   \   0000006C   0x4649             MOV      R1,R9
   \   0000006E   0xB2C9             UXTB     R1,R1
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0x.... 0x....      BL       I2C_Send7bitAddress
    193          
    194          	/* Wait for address bit to be set */
    195          	WAIT_FOR_FLAG (I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 3);
   \   00000076   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_write_raw_4: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable6_6  ;; 0x10000002
   \   0000007E   0x4638             MOV      R0,R7
   \   00000080   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD008             BEQ.N    ??i2c_master_write_raw_5
   \   00000088   0x9800             LDR      R0,[SP, #+0]
   \   0000008A   0x1E41             SUBS     R1,R0,#+1
   \   0000008C   0x9100             STR      R1,[SP, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD1F3             BNE.N    ??i2c_master_write_raw_4
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000098   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    196          
    197          	/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    198          	CLEAR_ADDR_BIT
   \                     ??i2c_master_write_raw_5: (+1)
   \   0000009A   0x2114             MOVS     R1,#+20
   \   0000009C   0x4638             MOV      R0,R7
   \   0000009E   0x.... 0x....      BL       I2C_ReadRegister
   \   000000A2   0x2118             MOVS     R1,#+24
   \   000000A4   0x4638             MOV      R0,R7
   \   000000A6   0x.... 0x....      BL       I2C_ReadRegister
    199          
    200          	for(i=0; i<(RegisterLen); i++)
   \   000000AA   0xE004             B.N      ??i2c_master_write_raw_6
    201          	{
    202          		/* Wait for address bit to be set */
    203          		WAIT_FOR_FLAG (I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 5);
    204          
    205          		/* Prepare the register value to be sent */
    206          		I2C_SendData(SENSORS_I2C, RegisterValue[i]);
   \                     ??i2c_master_write_raw_7: (+1)
   \   000000AC   0x5DA9             LDRB     R1,[R5, R6]
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0x.... 0x....      BL       I2C_SendData
   \   000000B4   0x1C76             ADDS     R6,R6,#+1
   \                     ??i2c_master_write_raw_6: (+1)
   \   000000B6   0x42A6             CMP      R6,R4
   \   000000B8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000BC   0xD20F             BCS.N    ??i2c_master_write_raw_8
   \                     ??i2c_master_write_raw_9: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable6_7  ;; 0x10000080
   \   000000C2   0x4638             MOV      R0,R7
   \   000000C4   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD0EF             BEQ.N    ??i2c_master_write_raw_7
   \   000000CC   0x9800             LDR      R0,[SP, #+0]
   \   000000CE   0x1E41             SUBS     R1,R0,#+1
   \   000000D0   0x9100             STR      R1,[SP, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD1F3             BNE.N    ??i2c_master_write_raw_9
   \   000000D6   0x2005             MOVS     R0,#+5
   \   000000D8   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   000000DC   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    207          	}
    208          
    209          	/* Wait for address bit to be set */
    210          	WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 6);
   \                     ??i2c_master_write_raw_8: (+1)
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x10000004
   \   000000E2   0x4638             MOV      R0,R7
   \   000000E4   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000E8   0x2801             CMP      R0,#+1
   \   000000EA   0xD008             BEQ.N    ??i2c_master_write_raw_10
   \   000000EC   0x9800             LDR      R0,[SP, #+0]
   \   000000EE   0x1E41             SUBS     R1,R0,#+1
   \   000000F0   0x9100             STR      R1,[SP, #+0]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD1F3             BNE.N    ??i2c_master_write_raw_8
   \   000000F6   0x2006             MOVS     R0,#+6
   \   000000F8   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   000000FC   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    211          
    212          	/* End the configuration sequence */
    213          	I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_write_raw_10: (+1)
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x4638             MOV      R0,R7
   \   00000102   0x.... 0x....      BL       I2C_GenerateSTOP
    214          
    215          	/* Return the verifying value: 0 (Passed) or 1 (Failed) */
    216          	return result;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    217          }
    218          

   \                                 In section .text, align 2, keep-with-next
    219          unsigned long i2c_master_read_register(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, unsigned char *RegisterValue)
    220          {
   \                     i2c_master_read_register: (+1)
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x461C             MOV      R4,R3
    221          	uint32_t i=0, result = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    222          	__IO uint32_t  I2CTimeout = I2Cx_LONG_TIMEOUT;
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable6_4  ;; 0x41eb0
   \   0000000E   0x9600             STR      R6,[SP, #+0]
    223          
    224          	/* Shift the 7-bit address */
    225          	Address = Address << 1;
   \   00000010   0x0040             LSLS     R0,R0,#+1
   \   00000012   0xF88D 0x0004      STRB     R0,[SP, #+4]
    226          
    227          	/* Wait for the busy flag to be cleared */
    228          	WAIT_FOR_FLAG (I2C_FLAG_BUSY, RESET, I2Cx_LONG_TIMEOUT, 7);
   \   00000016   0x9600             STR      R6,[SP, #+0]
   \   00000018   0x.... 0x....      LDR.W    R7,??DataTable6_2  ;; 0x40005400
   \                     ??i2c_master_read_register_0: (+1)
   \   0000001C   0xF44F 0x3100      MOV      R1,#+131072
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD009             BEQ.N    ??i2c_master_read_register_1
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x1E41             SUBS     R1,R0,#+1
   \   0000002E   0x9100             STR      R1,[SP, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD1F3             BNE.N    ??i2c_master_read_register_0
   \   00000034   0x2007             MOVS     R0,#+7
   \   00000036   0xB005             ADD      SP,SP,#+20
   \   00000038   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000003C   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    229          
    230          	/* Start the config sequence */
    231          	I2C_GenerateSTART(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_read_register_1: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x4638             MOV      R0,R7
   \   00000042   0x.... 0x....      BL       I2C_GenerateSTART
    232          
    233          	/* Wait for the start bit to be set */
    234          	WAIT_FOR_FLAG (I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 8);
   \   00000046   0xF44F 0x7861      MOV      R8,#+900
   \   0000004A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R9,??DataTable6_5  ;; 0x10000001
   \                     ??i2c_master_read_register_2: (+1)
   \   00000052   0x4649             MOV      R1,R9
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD009             BEQ.N    ??i2c_master_read_register_3
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0x1E41             SUBS     R1,R0,#+1
   \   00000062   0x9100             STR      R1,[SP, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD1F4             BNE.N    ??i2c_master_read_register_2
   \   00000068   0x2008             MOVS     R0,#+8
   \   0000006A   0xB005             ADD      SP,SP,#+20
   \   0000006C   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000070   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    235          
    236          	/* Transmit the slave address and enable writing operation */
    237          	I2C_Send7bitAddress(SENSORS_I2C, Address, I2C_Direction_Transmitter);
   \                     ??i2c_master_read_register_3: (+1)
   \   00000072   0x462A             MOV      R2,R5
   \   00000074   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x.... 0x....      BL       I2C_Send7bitAddress
    238          
    239          	/* Wait for the start bit to be set */
    240          	WAIT_FOR_FLAG (I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 9);
   \   0000007E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000082   0x.... 0x....      LDR.W    R10,??DataTable6_6  ;; 0x10000002
   \                     ??i2c_master_read_register_4: (+1)
   \   00000086   0x4651             MOV      R1,R10
   \   00000088   0x4638             MOV      R0,R7
   \   0000008A   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xD009             BEQ.N    ??i2c_master_read_register_5
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x1E41             SUBS     R1,R0,#+1
   \   00000096   0x9100             STR      R1,[SP, #+0]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD1F4             BNE.N    ??i2c_master_read_register_4
   \   0000009C   0x2009             MOVS     R0,#+9
   \   0000009E   0xB005             ADD      SP,SP,#+20
   \   000000A0   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000000A4   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    241          
    242          	/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    243          	CLEAR_ADDR_BIT;
   \                     ??i2c_master_read_register_5: (+1)
   \   000000A6   0x2114             MOVS     R1,#+20
   \   000000A8   0x4638             MOV      R0,R7
   \   000000AA   0x.... 0x....      BL       I2C_ReadRegister
   \   000000AE   0x2118             MOVS     R1,#+24
   \   000000B0   0x4638             MOV      R0,R7
   \   000000B2   0x.... 0x....      BL       I2C_ReadRegister
    244          
    245          	/* Wait for address bit to be set */
    246          	WAIT_FOR_FLAG (I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 10);
   \   000000B6   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000BA   0x.... 0x....      LDR.W    R11,??DataTable6_7  ;; 0x10000080
   \                     ??i2c_master_read_register_6: (+1)
   \   000000BE   0x4659             MOV      R1,R11
   \   000000C0   0x4638             MOV      R0,R7
   \   000000C2   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000C6   0x2801             CMP      R0,#+1
   \   000000C8   0xD009             BEQ.N    ??i2c_master_read_register_7
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   \   000000CC   0x1E41             SUBS     R1,R0,#+1
   \   000000CE   0x9100             STR      R1,[SP, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD1F4             BNE.N    ??i2c_master_read_register_6
   \   000000D4   0x200A             MOVS     R0,#+10
   \   000000D6   0xB005             ADD      SP,SP,#+20
   \   000000D8   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000000DC   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    247          
    248          	/* Transmit the register address to be read */
    249          	I2C_SendData(SENSORS_I2C, RegisterAddr);
   \                     ??i2c_master_read_register_7: (+1)
   \   000000DE   0xF89D 0x100C      LDRB     R1,[SP, #+12]
   \   000000E2   0x4638             MOV      R0,R7
   \   000000E4   0x.... 0x....      BL       I2C_SendData
    250          
    251          	/* Wait for address bit to be set */
    252          	WAIT_FOR_FLAG (I2C_FLAG_TXE, SET, I2Cx_FLAG_TIMEOUT, 11);
   \   000000E8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_8: (+1)
   \   000000EC   0x4659             MOV      R1,R11
   \   000000EE   0x4638             MOV      R0,R7
   \   000000F0   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xD009             BEQ.N    ??i2c_master_read_register_9
   \   000000F8   0x9800             LDR      R0,[SP, #+0]
   \   000000FA   0x1E41             SUBS     R1,R0,#+1
   \   000000FC   0x9100             STR      R1,[SP, #+0]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD1F4             BNE.N    ??i2c_master_read_register_8
   \   00000102   0x200B             MOVS     R0,#+11
   \   00000104   0xB005             ADD      SP,SP,#+20
   \   00000106   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000010A   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    253          
    254          	/*!< Send START condition a second time */
    255          	I2C_GenerateSTART(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_read_register_9: (+1)
   \   0000010C   0x2101             MOVS     R1,#+1
   \   0000010E   0x4638             MOV      R0,R7
   \   00000110   0x.... 0x....      BL       I2C_GenerateSTART
    256          
    257          	/* Wait for the start bit to be set */
    258          	WAIT_FOR_FLAG (I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 12);
   \   00000114   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_10: (+1)
   \   00000118   0x4649             MOV      R1,R9
   \   0000011A   0x4638             MOV      R0,R7
   \   0000011C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000120   0x2801             CMP      R0,#+1
   \   00000122   0xD009             BEQ.N    ??i2c_master_read_register_11
   \   00000124   0x9800             LDR      R0,[SP, #+0]
   \   00000126   0x1E41             SUBS     R1,R0,#+1
   \   00000128   0x9100             STR      R1,[SP, #+0]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD1F4             BNE.N    ??i2c_master_read_register_10
   \   0000012E   0x200C             MOVS     R0,#+12
   \   00000130   0xB005             ADD      SP,SP,#+20
   \   00000132   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000136   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    259          
    260          	/*!< Send address for read */
    261          	I2C_Send7bitAddress(SENSORS_I2C, Address, I2C_Direction_Receiver);
   \                     ??i2c_master_read_register_11: (+1)
   \   00000138   0x2201             MOVS     R2,#+1
   \   0000013A   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000013E   0x4638             MOV      R0,R7
   \   00000140   0x.... 0x....      BL       I2C_Send7bitAddress
    262          
    263          	/* Wait for the start bit to be set */
    264          	WAIT_FOR_FLAG (I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 13);
   \   00000144   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_12: (+1)
   \   00000148   0x4651             MOV      R1,R10
   \   0000014A   0x4638             MOV      R0,R7
   \   0000014C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000150   0x2801             CMP      R0,#+1
   \   00000152   0xD009             BEQ.N    ??i2c_master_read_register_13
   \   00000154   0x9800             LDR      R0,[SP, #+0]
   \   00000156   0x1E41             SUBS     R1,R0,#+1
   \   00000158   0x9100             STR      R1,[SP, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD1F4             BNE.N    ??i2c_master_read_register_12
   \   0000015E   0x200D             MOVS     R0,#+13
   \   00000160   0xB005             ADD      SP,SP,#+20
   \   00000162   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000166   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    265          
    266          	if (RegisterLen == 1)
   \                     ??i2c_master_read_register_13: (+1)
   \   00000168   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   0000016C   0x2801             CMP      R0,#+1
   \   0000016E   0xD13E             BNE.N    ??i2c_master_read_register_14
    267          	{
    268          		/*!< Disable Acknowledgment */
    269          		I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
   \   00000170   0x4629             MOV      R1,R5
   \   00000172   0x4638             MOV      R0,R7
   \   00000174   0x.... 0x....      BL       I2C_AcknowledgeConfig
    270          
    271          		/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    272          		CLEAR_ADDR_BIT;
   \   00000178   0x2114             MOVS     R1,#+20
   \   0000017A   0x4638             MOV      R0,R7
   \   0000017C   0x.... 0x....      BL       I2C_ReadRegister
   \   00000180   0x2118             MOVS     R1,#+24
   \   00000182   0x4638             MOV      R0,R7
   \   00000184   0x.... 0x....      BL       I2C_ReadRegister
    273          
    274          		/*!< Send STOP Condition */
    275          		I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
   \   00000188   0x2101             MOVS     R1,#+1
   \   0000018A   0x4638             MOV      R0,R7
   \   0000018C   0x.... 0x....      BL       I2C_GenerateSTOP
    276          
    277          		/* Wait for the RXNE bit to be set */
    278          		WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 14);
   \   00000190   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_15: (+1)
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable6_9  ;; 0x10000040
   \   00000198   0x4638             MOV      R0,R7
   \   0000019A   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000019E   0x2801             CMP      R0,#+1
   \   000001A0   0xD009             BEQ.N    ??i2c_master_read_register_16
   \   000001A2   0x9800             LDR      R0,[SP, #+0]
   \   000001A4   0x1E41             SUBS     R1,R0,#+1
   \   000001A6   0x9100             STR      R1,[SP, #+0]
   \   000001A8   0x2800             CMP      R0,#+0
   \   000001AA   0xD1F3             BNE.N    ??i2c_master_read_register_15
   \   000001AC   0x200E             MOVS     R0,#+14
   \   000001AE   0xB005             ADD      SP,SP,#+20
   \   000001B0   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000001B4   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    279          
    280          		RegisterValue[0] = I2C_ReceiveData(SENSORS_I2C);
   \                     ??i2c_master_read_register_16: (+1)
   \   000001B6   0x4638             MOV      R0,R7
   \   000001B8   0x.... 0x....      BL       I2C_ReceiveData
   \   000001BC   0x7020             STRB     R0,[R4, #+0]
    281          	}
    282          	else if( RegisterLen == 2)
    283          	{
    284          		 /*!< Disable Acknowledgment */
    285          		I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
    286          
    287          		/* Set POS bit */
    288          		SENSORS_I2C->CR1 |= I2C_CR1_POS;
    289          
    290          		/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    291          		CLEAR_ADDR_BIT;
    292          
    293          		/* Wait for the buffer full bit to be set */
    294          		WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 15);
    295          
    296          		/*!< Send STOP Condition */
    297          		I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
    298          
    299          		/* Read 2 bytes */
    300          		RegisterValue[0] = I2C_ReceiveData(SENSORS_I2C);
    301          		RegisterValue[1] = I2C_ReceiveData(SENSORS_I2C);
    302          	}
    303          	else if( RegisterLen == 3)
    304          	{
    305          		CLEAR_ADDR_BIT;
    306          
    307          		/* Wait for the buffer full bit to be set */
    308          		WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 16);
    309          
    310          		/*!< Disable Acknowledgment */
    311          		I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
    312          
    313          		/* Read 1 bytes */
    314          		RegisterValue[0] = I2C_ReceiveData(SENSORS_I2C);
    315          
    316          		/*!< Send STOP Condition */
    317          		I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
    318          
    319          		/* Read 1 bytes */
    320          		RegisterValue[1] = I2C_ReceiveData(SENSORS_I2C);
    321          
    322          		/* Wait for the buffer full bit to be set */
    323          		WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 17);
    324          
    325          		/* Read 1 bytes */
    326          		RegisterValue[2] = I2C_ReceiveData(SENSORS_I2C);
    327          	}
    328          	else /* more than 2 bytes */
    329          	{
    330          		/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    331          		CLEAR_ADDR_BIT;
    332          
    333          		for(i=0; i<(RegisterLen); i++)
    334          		{
    335          			if(i==((unsigned short)(RegisterLen-3)))
    336          			{
    337          				/* Wait for the buffer full bit to be set */
    338          				WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 16);
    339          
    340          				/*!< Disable Acknowledgment */
    341          				I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
    342          
    343          				/* Read 1 bytes */
    344          				RegisterValue[i++] = I2C_ReceiveData(SENSORS_I2C);
    345          
    346          				/*!< Send STOP Condition */
    347          				I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
    348          
    349          				/* Read 1 bytes */
    350          				RegisterValue[i++] = I2C_ReceiveData(SENSORS_I2C);
    351          
    352          				/* Wait for the buffer full bit to be set */
    353          				WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 17);
    354          
    355          				/* Read 1 bytes */
    356          				RegisterValue[i++] = I2C_ReceiveData(SENSORS_I2C);
    357          				goto endReadLoop;
    358          			}
    359          			/* Wait for the RXNE bit to be set */
    360          			WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 18);
    361          			RegisterValue[i] = I2C_ReceiveData(SENSORS_I2C);
    362          		}
    363          	}
    364          
    365          endReadLoop:
    366          	/* Clear BTF flag */
    367          	I2C_ClearFlag(SENSORS_I2C, I2C_FLAG_BTF);
   \                     ??i2c_master_read_register_17: (+1)
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x10000004
   \   000001C2   0x4638             MOV      R0,R7
   \   000001C4   0x.... 0x....      BL       I2C_ClearFlag
    368          
    369          	/* Wait for the busy flag to be cleared */
    370          	WAIT_FOR_FLAG (I2C_FLAG_BUSY, RESET, I2Cx_LONG_TIMEOUT, 19);
   \   000001C8   0x9600             STR      R6,[SP, #+0]
   \                     ??i2c_master_read_register_18: (+1)
   \   000001CA   0xF44F 0x3100      MOV      R1,#+131072
   \   000001CE   0x4638             MOV      R0,R7
   \   000001D0   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000001D4   0x2800             CMP      R0,#+0
   \   000001D6   0xF000 0x80E4      BEQ.W    ??i2c_master_read_register_19
   \   000001DA   0x9800             LDR      R0,[SP, #+0]
   \   000001DC   0x1E41             SUBS     R1,R0,#+1
   \   000001DE   0x9100             STR      R1,[SP, #+0]
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD1F2             BNE.N    ??i2c_master_read_register_18
   \   000001E4   0x2013             MOVS     R0,#+19
   \   000001E6   0xB005             ADD      SP,SP,#+20
   \   000001E8   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000001EC   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_register_14: (+1)
   \   000001EE   0x2802             CMP      R0,#+2
   \   000001F0   0xD12F             BNE.N    ??i2c_master_read_register_20
   \   000001F2   0x4629             MOV      R1,R5
   \   000001F4   0x4638             MOV      R0,R7
   \   000001F6   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   000001FA   0x8838             LDRH     R0,[R7, #+0]
   \   000001FC   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000200   0x8038             STRH     R0,[R7, #+0]
   \   00000202   0x2114             MOVS     R1,#+20
   \   00000204   0x4638             MOV      R0,R7
   \   00000206   0x.... 0x....      BL       I2C_ReadRegister
   \   0000020A   0x2118             MOVS     R1,#+24
   \   0000020C   0x4638             MOV      R0,R7
   \   0000020E   0x.... 0x....      BL       I2C_ReadRegister
   \   00000212   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_21: (+1)
   \   00000216   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x10000004
   \   0000021A   0x4638             MOV      R0,R7
   \   0000021C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000220   0x2801             CMP      R0,#+1
   \   00000222   0xD009             BEQ.N    ??i2c_master_read_register_22
   \   00000224   0x9800             LDR      R0,[SP, #+0]
   \   00000226   0x1E41             SUBS     R1,R0,#+1
   \   00000228   0x9100             STR      R1,[SP, #+0]
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD1F3             BNE.N    ??i2c_master_read_register_21
   \   0000022E   0x200F             MOVS     R0,#+15
   \   00000230   0xB005             ADD      SP,SP,#+20
   \   00000232   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000236   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_register_22: (+1)
   \   00000238   0x2101             MOVS     R1,#+1
   \   0000023A   0x4638             MOV      R0,R7
   \   0000023C   0x.... 0x....      BL       I2C_GenerateSTOP
   \   00000240   0x4638             MOV      R0,R7
   \   00000242   0x.... 0x....      BL       I2C_ReceiveData
   \   00000246   0x7020             STRB     R0,[R4, #+0]
   \   00000248   0x4638             MOV      R0,R7
   \   0000024A   0x.... 0x....      BL       I2C_ReceiveData
   \   0000024E   0x7060             STRB     R0,[R4, #+1]
   \   00000250   0xE7B5             B.N      ??i2c_master_read_register_17
   \                     ??i2c_master_read_register_20: (+1)
   \   00000252   0x2803             CMP      R0,#+3
   \   00000254   0xD142             BNE.N    ??i2c_master_read_register_23
   \   00000256   0x2114             MOVS     R1,#+20
   \   00000258   0x4638             MOV      R0,R7
   \   0000025A   0x.... 0x....      BL       I2C_ReadRegister
   \   0000025E   0x2118             MOVS     R1,#+24
   \   00000260   0x4638             MOV      R0,R7
   \   00000262   0x.... 0x....      BL       I2C_ReadRegister
   \   00000266   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_24: (+1)
   \   0000026A   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x10000004
   \   0000026E   0x4638             MOV      R0,R7
   \   00000270   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000274   0x2801             CMP      R0,#+1
   \   00000276   0xD009             BEQ.N    ??i2c_master_read_register_25
   \   00000278   0x9800             LDR      R0,[SP, #+0]
   \   0000027A   0x1E41             SUBS     R1,R0,#+1
   \   0000027C   0x9100             STR      R1,[SP, #+0]
   \   0000027E   0x2800             CMP      R0,#+0
   \   00000280   0xD1F3             BNE.N    ??i2c_master_read_register_24
   \   00000282   0x2010             MOVS     R0,#+16
   \   00000284   0xB005             ADD      SP,SP,#+20
   \   00000286   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000028A   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_register_25: (+1)
   \   0000028C   0x4629             MOV      R1,R5
   \   0000028E   0x4638             MOV      R0,R7
   \   00000290   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   00000294   0x4638             MOV      R0,R7
   \   00000296   0x.... 0x....      BL       I2C_ReceiveData
   \   0000029A   0x7020             STRB     R0,[R4, #+0]
   \   0000029C   0x2101             MOVS     R1,#+1
   \   0000029E   0x4638             MOV      R0,R7
   \   000002A0   0x.... 0x....      BL       I2C_GenerateSTOP
   \   000002A4   0x4638             MOV      R0,R7
   \   000002A6   0x.... 0x....      BL       I2C_ReceiveData
   \   000002AA   0x7060             STRB     R0,[R4, #+1]
   \   000002AC   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_26: (+1)
   \   000002B0   0x.... 0x....      LDR.W    R1,??DataTable6_9  ;; 0x10000040
   \   000002B4   0x4638             MOV      R0,R7
   \   000002B6   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000002BA   0x2801             CMP      R0,#+1
   \   000002BC   0xD009             BEQ.N    ??i2c_master_read_register_27
   \   000002BE   0x9800             LDR      R0,[SP, #+0]
   \   000002C0   0x1E41             SUBS     R1,R0,#+1
   \   000002C2   0x9100             STR      R1,[SP, #+0]
   \   000002C4   0x2800             CMP      R0,#+0
   \   000002C6   0xD1F3             BNE.N    ??i2c_master_read_register_26
   \   000002C8   0x2011             MOVS     R0,#+17
   \   000002CA   0xB005             ADD      SP,SP,#+20
   \   000002CC   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000002D0   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_register_27: (+1)
   \   000002D2   0x4638             MOV      R0,R7
   \   000002D4   0x.... 0x....      BL       I2C_ReceiveData
   \   000002D8   0x70A0             STRB     R0,[R4, #+2]
   \   000002DA   0xE770             B.N      ??i2c_master_read_register_17
   \                     ??i2c_master_read_register_23: (+1)
   \   000002DC   0x2114             MOVS     R1,#+20
   \   000002DE   0x4638             MOV      R0,R7
   \   000002E0   0x.... 0x....      BL       I2C_ReadRegister
   \   000002E4   0x2118             MOVS     R1,#+24
   \   000002E6   0x4638             MOV      R0,R7
   \   000002E8   0x.... 0x....      BL       I2C_ReadRegister
   \   000002EC   0xE004             B.N      ??i2c_master_read_register_28
   \                     ??i2c_master_read_register_29: (+1)
   \   000002EE   0x4638             MOV      R0,R7
   \   000002F0   0x.... 0x....      BL       I2C_ReceiveData
   \   000002F4   0x5560             STRB     R0,[R4, R5]
   \   000002F6   0x1C6D             ADDS     R5,R5,#+1
   \                     ??i2c_master_read_register_28: (+1)
   \   000002F8   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   000002FC   0x4285             CMP      R5,R0
   \   000002FE   0xF4BF 0xAF5E      BCS.W    ??i2c_master_read_register_17
   \   00000302   0x1EC0             SUBS     R0,R0,#+3
   \   00000304   0xB280             UXTH     R0,R0
   \   00000306   0x4285             CMP      R5,R0
   \   00000308   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000030C   0xD139             BNE.N    ??i2c_master_read_register_30
   \                     ??i2c_master_read_register_31: (+1)
   \   0000030E   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x10000004
   \   00000312   0x4638             MOV      R0,R7
   \   00000314   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000318   0x2801             CMP      R0,#+1
   \   0000031A   0xD009             BEQ.N    ??i2c_master_read_register_32
   \   0000031C   0x9800             LDR      R0,[SP, #+0]
   \   0000031E   0x1E41             SUBS     R1,R0,#+1
   \   00000320   0x9100             STR      R1,[SP, #+0]
   \   00000322   0x2800             CMP      R0,#+0
   \   00000324   0xD1F3             BNE.N    ??i2c_master_read_register_31
   \   00000326   0x2010             MOVS     R0,#+16
   \   00000328   0xB005             ADD      SP,SP,#+20
   \   0000032A   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000032E   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_register_32: (+1)
   \   00000330   0x2100             MOVS     R1,#+0
   \   00000332   0x4638             MOV      R0,R7
   \   00000334   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   00000338   0x4638             MOV      R0,R7
   \   0000033A   0x.... 0x....      BL       I2C_ReceiveData
   \   0000033E   0x5560             STRB     R0,[R4, R5]
   \   00000340   0x1C6D             ADDS     R5,R5,#+1
   \   00000342   0x2101             MOVS     R1,#+1
   \   00000344   0x4638             MOV      R0,R7
   \   00000346   0x.... 0x....      BL       I2C_GenerateSTOP
   \   0000034A   0x4638             MOV      R0,R7
   \   0000034C   0x.... 0x....      BL       I2C_ReceiveData
   \   00000350   0x5560             STRB     R0,[R4, R5]
   \   00000352   0x1C6D             ADDS     R5,R5,#+1
   \   00000354   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \                     ??i2c_master_read_register_33: (+1)
   \   00000358   0x....             LDR.N    R1,??DataTable6_9  ;; 0x10000040
   \   0000035A   0x4638             MOV      R0,R7
   \   0000035C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000360   0x2801             CMP      R0,#+1
   \   00000362   0xD009             BEQ.N    ??i2c_master_read_register_34
   \   00000364   0x9800             LDR      R0,[SP, #+0]
   \   00000366   0x1E41             SUBS     R1,R0,#+1
   \   00000368   0x9100             STR      R1,[SP, #+0]
   \   0000036A   0x2800             CMP      R0,#+0
   \   0000036C   0xD1F4             BNE.N    ??i2c_master_read_register_33
   \   0000036E   0x2011             MOVS     R0,#+17
   \   00000370   0xB005             ADD      SP,SP,#+20
   \   00000372   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000376   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_register_34: (+1)
   \   00000378   0x4638             MOV      R0,R7
   \   0000037A   0x.... 0x....      BL       I2C_ReceiveData
   \   0000037E   0x5560             STRB     R0,[R4, R5]
   \   00000380   0xE71D             B.N      ??i2c_master_read_register_17
   \                     ??i2c_master_read_register_30: (+1)
   \   00000382   0x....             LDR.N    R1,??DataTable6_9  ;; 0x10000040
   \   00000384   0x4638             MOV      R0,R7
   \   00000386   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000038A   0x2801             CMP      R0,#+1
   \   0000038C   0xD0AF             BEQ.N    ??i2c_master_read_register_29
   \   0000038E   0x9800             LDR      R0,[SP, #+0]
   \   00000390   0x1E41             SUBS     R1,R0,#+1
   \   00000392   0x9100             STR      R1,[SP, #+0]
   \   00000394   0x2800             CMP      R0,#+0
   \   00000396   0xD1F4             BNE.N    ??i2c_master_read_register_30
   \   00000398   0x2012             MOVS     R0,#+18
   \   0000039A   0xB005             ADD      SP,SP,#+20
   \   0000039C   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   000003A0   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    371          
    372          	/*!< Re-Enable Acknowledgment to be ready for another reception */
    373          	I2C_AcknowledgeConfig(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_read_register_19: (+1)
   \   000003A2   0x2101             MOVS     R1,#+1
   \   000003A4   0x4638             MOV      R0,R7
   \   000003A6   0x.... 0x....      BL       I2C_AcknowledgeConfig
    374          
    375          	/* Disable POS */
    376          	SENSORS_I2C->CR1 &= ~I2C_CR1_POS;
   \   000003AA   0x8838             LDRH     R0,[R7, #+0]
   \   000003AC   0xF24F 0x71FF      MOVW     R1,#+63487
   \   000003B0   0x4008             ANDS     R0,R1,R0
   \   000003B2   0x8038             STRH     R0,[R7, #+0]
    377          
    378          	/* Return the byte read from sensor */
    379          	return result;
   \   000003B4   0x2000             MOVS     R0,#+0
   \   000003B6   0xB005             ADD      SP,SP,#+20
   \   000003B8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    380          }
    381          

   \                                 In section .text, align 2, keep-with-next
    382          unsigned long i2c_master_read_raw(unsigned char Address, unsigned short RegisterLen, unsigned char *RegisterValue)
    383          {
   \                     i2c_master_read_raw: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
    384          	uint32_t i=0, result = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
    385          	__IO uint32_t  I2CTimeout = I2Cx_LONG_TIMEOUT;
   \   0000000C   0x....             LDR.N    R7,??DataTable6_4  ;; 0x41eb0
   \   0000000E   0x9700             STR      R7,[SP, #+0]
    386          
    387          	/* Shift the 7-bit address */
    388          	Address = Address << 1;
   \   00000010   0xEA4F 0x0A40      LSL      R10,R0,#+1
    389          
    390          	/* Wait for the busy flag to be cleared */
    391          	WAIT_FOR_FLAG (I2C_FLAG_BUSY, RESET, I2Cx_LONG_TIMEOUT, 7);
   \   00000014   0x9700             STR      R7,[SP, #+0]
   \   00000016   0x.... 0x....      LDR.W    R8,??DataTable6_2  ;; 0x40005400
   \                     ??i2c_master_read_raw_0: (+1)
   \   0000001A   0xF44F 0x3100      MOV      R1,#+131072
   \   0000001E   0x4640             MOV      R0,R8
   \   00000020   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD008             BEQ.N    ??i2c_master_read_raw_1
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x1E41             SUBS     R1,R0,#+1
   \   0000002C   0x9100             STR      R1,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??i2c_master_read_raw_0
   \   00000032   0x2007             MOVS     R0,#+7
   \   00000034   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   00000038   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    392          
    393          	/*!< Send START condition a second time */
    394          	I2C_GenerateSTART(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_read_raw_1: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x4640             MOV      R0,R8
   \   0000003E   0x.... 0x....      BL       I2C_GenerateSTART
    395          
    396          	/* Wait for the start bit to be set */
    397          	WAIT_FOR_FLAG (I2C_FLAG_SB, SET, I2Cx_FLAG_TIMEOUT, 12);
   \   00000042   0xF44F 0x7961      MOV      R9,#+900
   \   00000046   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \                     ??i2c_master_read_raw_2: (+1)
   \   0000004A   0x....             LDR.N    R1,??DataTable6_5  ;; 0x10000001
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD008             BEQ.N    ??i2c_master_read_raw_3
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0x1E41             SUBS     R1,R0,#+1
   \   0000005A   0x9100             STR      R1,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD1F4             BNE.N    ??i2c_master_read_raw_2
   \   00000060   0x200C             MOVS     R0,#+12
   \   00000062   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   00000066   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    398          
    399          	/*!< Send address for read */
    400          	I2C_Send7bitAddress(SENSORS_I2C, Address, I2C_Direction_Receiver);
   \                     ??i2c_master_read_raw_3: (+1)
   \   00000068   0x2201             MOVS     R2,#+1
   \   0000006A   0x4651             MOV      R1,R10
   \   0000006C   0xB2C9             UXTB     R1,R1
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       I2C_Send7bitAddress
    401          
    402          	/* Wait for the start bit to be set */
    403          	WAIT_FOR_FLAG (I2C_FLAG_ADDR, SET, I2Cx_FLAG_TIMEOUT, 13);
   \   00000074   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \                     ??i2c_master_read_raw_4: (+1)
   \   00000078   0x....             LDR.N    R1,??DataTable6_6  ;; 0x10000002
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xD008             BEQ.N    ??i2c_master_read_raw_5
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x1E41             SUBS     R1,R0,#+1
   \   00000088   0x9100             STR      R1,[SP, #+0]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD1F4             BNE.N    ??i2c_master_read_raw_4
   \   0000008E   0x200D             MOVS     R0,#+13
   \   00000090   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   00000094   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    404          
    405          	if (RegisterLen == 1)
   \                     ??i2c_master_read_raw_5: (+1)
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD13A             BNE.N    ??i2c_master_read_raw_6
    406          	{
    407          		/*!< Disable Acknowledgment */
    408          		I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
   \   0000009C   0x4631             MOV      R1,R6
   \   0000009E   0x4640             MOV      R0,R8
   \   000000A0   0x.... 0x....      BL       I2C_AcknowledgeConfig
    409          
    410          		/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    411          		CLEAR_ADDR_BIT;
   \   000000A4   0x2114             MOVS     R1,#+20
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x.... 0x....      BL       I2C_ReadRegister
   \   000000AC   0x2118             MOVS     R1,#+24
   \   000000AE   0x4640             MOV      R0,R8
   \   000000B0   0x.... 0x....      BL       I2C_ReadRegister
    412          
    413          		/*!< Send STOP Condition */
    414          		I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x.... 0x....      BL       I2C_GenerateSTOP
    415          
    416          		/* Wait for the RXNE bit to be set */
    417          		WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 14);
   \   000000BC   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \                     ??i2c_master_read_raw_7: (+1)
   \   000000C0   0x....             LDR.N    R1,??DataTable6_9  ;; 0x10000040
   \   000000C2   0x4640             MOV      R0,R8
   \   000000C4   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD008             BEQ.N    ??i2c_master_read_raw_8
   \   000000CC   0x9800             LDR      R0,[SP, #+0]
   \   000000CE   0x1E41             SUBS     R1,R0,#+1
   \   000000D0   0x9100             STR      R1,[SP, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD1F4             BNE.N    ??i2c_master_read_raw_7
   \   000000D6   0x200E             MOVS     R0,#+14
   \   000000D8   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   000000DC   0x....             B.N      I2Cx_TIMEOUT_UserCallback
    418          
    419          		RegisterValue[0] = I2C_ReceiveData(SENSORS_I2C);
   \                     ??i2c_master_read_raw_8: (+1)
   \   000000DE   0x4640             MOV      R0,R8
   \   000000E0   0x.... 0x....      BL       I2C_ReceiveData
   \   000000E4   0x7028             STRB     R0,[R5, #+0]
    420          	}
    421          	else if( RegisterLen == 2)
    422          	{
    423          		 /*!< Disable Acknowledgment */
    424          		I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
    425          
    426          		/* Set POS bit */
    427          		SENSORS_I2C->CR1 |= I2C_CR1_POS;
    428          
    429          		/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    430          		CLEAR_ADDR_BIT;
    431          
    432          		/* Wait for the buffer full bit to be set */
    433          		WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 15);
    434          
    435          		/*!< Send STOP Condition */
    436          		I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
    437          
    438          		/* Read 2 bytes */
    439          		RegisterValue[0] = I2C_ReceiveData(SENSORS_I2C);
    440          		RegisterValue[1] = I2C_ReceiveData(SENSORS_I2C);
    441          	}
    442          	else if( RegisterLen == 3)
    443          	{
    444          		CLEAR_ADDR_BIT;
    445          
    446          		/* Wait for the buffer full bit to be set */
    447          		WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 16);
    448          
    449          		/*!< Disable Acknowledgment */
    450          		I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
    451          
    452          		/* Read 1 bytes */
    453          		RegisterValue[0] = I2C_ReceiveData(SENSORS_I2C);
    454          
    455          		/*!< Send STOP Condition */
    456          		I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
    457          
    458          		/* Read 1 bytes */
    459          		RegisterValue[1] = I2C_ReceiveData(SENSORS_I2C);
    460          
    461          		/* Wait for the buffer full bit to be set */
    462          		WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 17);
    463          
    464          		/* Read 1 bytes */
    465          		RegisterValue[2] = I2C_ReceiveData(SENSORS_I2C);
    466          	}
    467          	else /* more than 2 bytes */
    468          	{
    469          		/* clear the ADDR interrupt bit  - this is done by reading SR1 and SR2*/
    470          		CLEAR_ADDR_BIT;
    471          
    472          		for(i=0; i<(RegisterLen); i++)
    473          		{
    474          			if(i==((unsigned short)(RegisterLen-3)))
    475          			{
    476          				/* Wait for the buffer full bit to be set */
    477          				WAIT_FOR_FLAG (I2C_FLAG_BTF, SET, I2Cx_FLAG_TIMEOUT, 16);
    478          
    479          				/*!< Disable Acknowledgment */
    480          				I2C_AcknowledgeConfig(SENSORS_I2C, DISABLE);
    481          
    482          				/* Read 1 bytes */
    483          				RegisterValue[i++] = I2C_ReceiveData(SENSORS_I2C);
    484          
    485          				/*!< Send STOP Condition */
    486          				I2C_GenerateSTOP(SENSORS_I2C, ENABLE);
    487          
    488          				/* Read 1 bytes */
    489          				RegisterValue[i++] = I2C_ReceiveData(SENSORS_I2C);
    490          
    491          				/* Wait for the buffer full bit to be set */
    492          				WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 17);
    493          
    494          				/* Read 1 bytes */
    495          				RegisterValue[i++] = I2C_ReceiveData(SENSORS_I2C);
    496          				goto endReadLoop;
    497          			}
    498          			/* Wait for the RXNE bit to be set */
    499          			WAIT_FOR_FLAG (I2C_FLAG_RXNE, SET, I2Cx_FLAG_TIMEOUT, 18);
    500          			RegisterValue[i] = I2C_ReceiveData(SENSORS_I2C);
    501          		}
    502          	}
    503          
    504          endReadLoop:
    505          	/* Clear BTF flag */
    506          	I2C_ClearFlag(SENSORS_I2C, I2C_FLAG_BTF);
   \                     ??i2c_master_read_raw_9: (+1)
   \   000000E6   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10000004
   \   000000E8   0x4640             MOV      R0,R8
   \   000000EA   0x.... 0x....      BL       I2C_ClearFlag
    507          
    508          	/* Wait for the busy flag to be cleared */
    509          	WAIT_FOR_FLAG (I2C_FLAG_BUSY, RESET, I2Cx_LONG_TIMEOUT, 19);
   \   000000EE   0x9700             STR      R7,[SP, #+0]
   \                     ??i2c_master_read_raw_10: (+1)
   \   000000F0   0xF44F 0x3100      MOV      R1,#+131072
   \   000000F4   0x4640             MOV      R0,R8
   \   000000F6   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xF000 0x80DE      BEQ.W    ??i2c_master_read_raw_11
   \   00000100   0x9800             LDR      R0,[SP, #+0]
   \   00000102   0x1E41             SUBS     R1,R0,#+1
   \   00000104   0x9100             STR      R1,[SP, #+0]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD1F2             BNE.N    ??i2c_master_read_raw_10
   \   0000010A   0x2013             MOVS     R0,#+19
   \   0000010C   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   00000110   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_raw_6: (+1)
   \   00000112   0x2802             CMP      R0,#+2
   \   00000114   0xD12F             BNE.N    ??i2c_master_read_raw_12
   \   00000116   0x4631             MOV      R1,R6
   \   00000118   0x4640             MOV      R0,R8
   \   0000011A   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   0000011E   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000122   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000126   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000012A   0x2114             MOVS     R1,#+20
   \   0000012C   0x4640             MOV      R0,R8
   \   0000012E   0x.... 0x....      BL       I2C_ReadRegister
   \   00000132   0x2118             MOVS     R1,#+24
   \   00000134   0x4640             MOV      R0,R8
   \   00000136   0x.... 0x....      BL       I2C_ReadRegister
   \   0000013A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \                     ??i2c_master_read_raw_13: (+1)
   \   0000013E   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10000004
   \   00000140   0x4640             MOV      R0,R8
   \   00000142   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xD008             BEQ.N    ??i2c_master_read_raw_14
   \   0000014A   0x9800             LDR      R0,[SP, #+0]
   \   0000014C   0x1E41             SUBS     R1,R0,#+1
   \   0000014E   0x9100             STR      R1,[SP, #+0]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD1F4             BNE.N    ??i2c_master_read_raw_13
   \   00000154   0x200F             MOVS     R0,#+15
   \   00000156   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   0000015A   0x....             B.N      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_raw_14: (+1)
   \   0000015C   0x2101             MOVS     R1,#+1
   \   0000015E   0x4640             MOV      R0,R8
   \   00000160   0x.... 0x....      BL       I2C_GenerateSTOP
   \   00000164   0x4640             MOV      R0,R8
   \   00000166   0x.... 0x....      BL       I2C_ReceiveData
   \   0000016A   0x7028             STRB     R0,[R5, #+0]
   \   0000016C   0x4640             MOV      R0,R8
   \   0000016E   0x.... 0x....      BL       I2C_ReceiveData
   \   00000172   0x7068             STRB     R0,[R5, #+1]
   \   00000174   0xE7B7             B.N      ??i2c_master_read_raw_9
   \                     ??i2c_master_read_raw_12: (+1)
   \   00000176   0x2803             CMP      R0,#+3
   \   00000178   0xD140             BNE.N    ??i2c_master_read_raw_15
   \   0000017A   0x2114             MOVS     R1,#+20
   \   0000017C   0x4640             MOV      R0,R8
   \   0000017E   0x.... 0x....      BL       I2C_ReadRegister
   \   00000182   0x2118             MOVS     R1,#+24
   \   00000184   0x4640             MOV      R0,R8
   \   00000186   0x.... 0x....      BL       I2C_ReadRegister
   \   0000018A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \                     ??i2c_master_read_raw_16: (+1)
   \   0000018E   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10000004
   \   00000190   0x4640             MOV      R0,R8
   \   00000192   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000196   0x2801             CMP      R0,#+1
   \   00000198   0xD009             BEQ.N    ??i2c_master_read_raw_17
   \   0000019A   0x9800             LDR      R0,[SP, #+0]
   \   0000019C   0x1E41             SUBS     R1,R0,#+1
   \   0000019E   0x9100             STR      R1,[SP, #+0]
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD1F4             BNE.N    ??i2c_master_read_raw_16
   \   000001A4   0x2010             MOVS     R0,#+16
   \   000001A6   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   000001AA   0x.... 0x....      B.W      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_raw_17: (+1)
   \   000001AE   0x4631             MOV      R1,R6
   \   000001B0   0x4640             MOV      R0,R8
   \   000001B2   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   000001B6   0x4640             MOV      R0,R8
   \   000001B8   0x.... 0x....      BL       I2C_ReceiveData
   \   000001BC   0x7028             STRB     R0,[R5, #+0]
   \   000001BE   0x2101             MOVS     R1,#+1
   \   000001C0   0x4640             MOV      R0,R8
   \   000001C2   0x.... 0x....      BL       I2C_GenerateSTOP
   \   000001C6   0x4640             MOV      R0,R8
   \   000001C8   0x.... 0x....      BL       I2C_ReceiveData
   \   000001CC   0x7068             STRB     R0,[R5, #+1]
   \   000001CE   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \                     ??i2c_master_read_raw_18: (+1)
   \   000001D2   0x....             LDR.N    R1,??DataTable6_9  ;; 0x10000040
   \   000001D4   0x4640             MOV      R0,R8
   \   000001D6   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000001DA   0x2801             CMP      R0,#+1
   \   000001DC   0xD009             BEQ.N    ??i2c_master_read_raw_19
   \   000001DE   0x9800             LDR      R0,[SP, #+0]
   \   000001E0   0x1E41             SUBS     R1,R0,#+1
   \   000001E2   0x9100             STR      R1,[SP, #+0]
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD1F4             BNE.N    ??i2c_master_read_raw_18
   \   000001E8   0x2011             MOVS     R0,#+17
   \   000001EA   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   000001EE   0x.... 0x....      B.W      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_raw_19: (+1)
   \   000001F2   0x4640             MOV      R0,R8
   \   000001F4   0x.... 0x....      BL       I2C_ReceiveData
   \   000001F8   0x70A8             STRB     R0,[R5, #+2]
   \   000001FA   0xE774             B.N      ??i2c_master_read_raw_9
   \                     ??i2c_master_read_raw_15: (+1)
   \   000001FC   0x2114             MOVS     R1,#+20
   \   000001FE   0x4640             MOV      R0,R8
   \   00000200   0x.... 0x....      BL       I2C_ReadRegister
   \   00000204   0x2118             MOVS     R1,#+24
   \   00000206   0x4640             MOV      R0,R8
   \   00000208   0x.... 0x....      BL       I2C_ReadRegister
   \   0000020C   0xE004             B.N      ??i2c_master_read_raw_20
   \                     ??i2c_master_read_raw_21: (+1)
   \   0000020E   0x4640             MOV      R0,R8
   \   00000210   0x.... 0x....      BL       I2C_ReceiveData
   \   00000214   0x55A8             STRB     R0,[R5, R6]
   \   00000216   0x1C76             ADDS     R6,R6,#+1
   \                     ??i2c_master_read_raw_20: (+1)
   \   00000218   0x42A6             CMP      R6,R4
   \   0000021A   0xF4BF 0xAF64      BCS.W    ??i2c_master_read_raw_9
   \   0000021E   0x1EE0             SUBS     R0,R4,#+3
   \   00000220   0xB280             UXTH     R0,R0
   \   00000222   0x4286             CMP      R6,R0
   \   00000224   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000228   0xD138             BNE.N    ??i2c_master_read_raw_22
   \                     ??i2c_master_read_raw_23: (+1)
   \   0000022A   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10000004
   \   0000022C   0x4640             MOV      R0,R8
   \   0000022E   0x.... 0x....      BL       I2C_GetFlagStatus
   \   00000232   0x2801             CMP      R0,#+1
   \   00000234   0xD009             BEQ.N    ??i2c_master_read_raw_24
   \   00000236   0x9800             LDR      R0,[SP, #+0]
   \   00000238   0x1E41             SUBS     R1,R0,#+1
   \   0000023A   0x9100             STR      R1,[SP, #+0]
   \   0000023C   0x2800             CMP      R0,#+0
   \   0000023E   0xD1F4             BNE.N    ??i2c_master_read_raw_23
   \   00000240   0x2010             MOVS     R0,#+16
   \   00000242   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   00000246   0x.... 0x....      B.W      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_raw_24: (+1)
   \   0000024A   0x2100             MOVS     R1,#+0
   \   0000024C   0x4640             MOV      R0,R8
   \   0000024E   0x.... 0x....      BL       I2C_AcknowledgeConfig
   \   00000252   0x4640             MOV      R0,R8
   \   00000254   0x.... 0x....      BL       I2C_ReceiveData
   \   00000258   0x55A8             STRB     R0,[R5, R6]
   \   0000025A   0x1C74             ADDS     R4,R6,#+1
   \   0000025C   0x2101             MOVS     R1,#+1
   \   0000025E   0x4640             MOV      R0,R8
   \   00000260   0x.... 0x....      BL       I2C_GenerateSTOP
   \   00000264   0x4640             MOV      R0,R8
   \   00000266   0x.... 0x....      BL       I2C_ReceiveData
   \   0000026A   0x5528             STRB     R0,[R5, R4]
   \   0000026C   0x1C66             ADDS     R6,R4,#+1
   \   0000026E   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \                     ??i2c_master_read_raw_25: (+1)
   \   00000272   0x....             LDR.N    R1,??DataTable6_9  ;; 0x10000040
   \   00000274   0x4640             MOV      R0,R8
   \   00000276   0x.... 0x....      BL       I2C_GetFlagStatus
   \   0000027A   0x2801             CMP      R0,#+1
   \   0000027C   0xD009             BEQ.N    ??i2c_master_read_raw_26
   \   0000027E   0x9800             LDR      R0,[SP, #+0]
   \   00000280   0x1E41             SUBS     R1,R0,#+1
   \   00000282   0x9100             STR      R1,[SP, #+0]
   \   00000284   0x2800             CMP      R0,#+0
   \   00000286   0xD1F4             BNE.N    ??i2c_master_read_raw_25
   \   00000288   0x2011             MOVS     R0,#+17
   \   0000028A   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   0000028E   0x.... 0x....      B.W      I2Cx_TIMEOUT_UserCallback
   \                     ??i2c_master_read_raw_26: (+1)
   \   00000292   0x4640             MOV      R0,R8
   \   00000294   0x.... 0x....      BL       I2C_ReceiveData
   \   00000298   0x55A8             STRB     R0,[R5, R6]
   \   0000029A   0xE724             B.N      ??i2c_master_read_raw_9
   \                     ??i2c_master_read_raw_22: (+1)
   \   0000029C   0x....             LDR.N    R1,??DataTable6_9  ;; 0x10000040
   \   0000029E   0x4640             MOV      R0,R8
   \   000002A0   0x.... 0x....      BL       I2C_GetFlagStatus
   \   000002A4   0x2801             CMP      R0,#+1
   \   000002A6   0xD0B2             BEQ.N    ??i2c_master_read_raw_21
   \   000002A8   0x9800             LDR      R0,[SP, #+0]
   \   000002AA   0x1E41             SUBS     R1,R0,#+1
   \   000002AC   0x9100             STR      R1,[SP, #+0]
   \   000002AE   0x2800             CMP      R0,#+0
   \   000002B0   0xD1F4             BNE.N    ??i2c_master_read_raw_22
   \   000002B2   0x2012             MOVS     R0,#+18
   \   000002B4   0xE8BD 0x47F6      POP      {R1,R2,R4-R10,LR}
   \   000002B8   0x.... 0x....      B.W      I2Cx_TIMEOUT_UserCallback
    510          
    511          	/*!< Re-Enable Acknowledgment to be ready for another reception */
    512          	I2C_AcknowledgeConfig(SENSORS_I2C, ENABLE);
   \                     ??i2c_master_read_raw_11: (+1)
   \   000002BC   0x2101             MOVS     R1,#+1
   \   000002BE   0x4640             MOV      R0,R8
   \   000002C0   0x.... 0x....      BL       I2C_AcknowledgeConfig
    513          
    514          	/* Disable POS */
    515          	SENSORS_I2C->CR1 &= ~I2C_CR1_POS;
   \   000002C4   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000002C8   0xF24F 0x71FF      MOVW     R1,#+63487
   \   000002CC   0x4008             ANDS     R0,R1,R0
   \   000002CE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    516          
    517          	/* Return the byte read from sensor */
    518          	return result;
   \   000002D2   0x2000             MOVS     R0,#+0
   \   000002D4   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    519          }
    520          

   \                                 In section .text, align 2, keep-with-next
    521          void i2c_master_deinit(void)
    522          {
   \                     i2c_master_deinit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    523          	/* Disable the I2C peripheral */
    524          	I2C_Cmd(SENSORS_I2C, DISABLE);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40005400
   \   00000006   0x.... 0x....      BL       I2C_Cmd
    525          	IsInited = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable6
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    526          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     IsInited

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x00041EB0         DC32     0x41eb0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x10000001         DC32     0x10000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x10000002         DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x10000080         DC32     0x10000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x10000004         DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x10000040         DC32     0x10000040

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   I2Cx_TIMEOUT_UserCallback
        24   -> I2C_Cmd
        24   -> I2C_DeInit
        24   -> I2C_GenerateSTOP
        24   -> I2C_Init
        24   -> I2C_SoftwareResetCmd
       8   i2c_master_deinit
         8   -> I2C_Cmd
      40   i2c_master_init
        40   -> GPIO_Init
        40   -> GPIO_PinAFConfig
        40   -> I2C_Cmd
        40   -> I2C_DeInit
        40   -> I2C_Init
        40   -> RCC_AHB1PeriphClockCmd
        40   -> RCC_APB1PeriphClockCmd
      40   i2c_master_read_raw
        40   -> I2C_AcknowledgeConfig
        40   -> I2C_ClearFlag
        40   -> I2C_GenerateSTART
        40   -> I2C_GenerateSTOP
        40   -> I2C_GetFlagStatus
        40   -> I2C_ReadRegister
        40   -> I2C_ReceiveData
        40   -> I2C_Send7bitAddress
         0   -> I2Cx_TIMEOUT_UserCallback
      56   i2c_master_read_register
        56   -> I2C_AcknowledgeConfig
        56   -> I2C_ClearFlag
        56   -> I2C_GenerateSTART
        56   -> I2C_GenerateSTOP
        56   -> I2C_GetFlagStatus
        56   -> I2C_ReadRegister
        56   -> I2C_ReceiveData
        56   -> I2C_Send7bitAddress
        56   -> I2C_SendData
         0   -> I2Cx_TIMEOUT_UserCallback
      32   i2c_master_write_raw
        32   -> I2C_GenerateSTART
        32   -> I2C_GenerateSTOP
        32   -> I2C_GetFlagStatus
        32   -> I2C_ReadRegister
        32   -> I2C_Send7bitAddress
        32   -> I2C_SendData
         0   -> I2Cx_TIMEOUT_UserCallback
      40   i2c_master_write_register
        40   -> I2C_GenerateSTART
        40   -> I2C_GenerateSTOP
        40   -> I2C_GetFlagStatus
        40   -> I2C_ReadRegister
        40   -> I2C_Send7bitAddress
        40   -> I2C_SendData
         0   -> I2Cx_TIMEOUT_UserCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     100  I2Cx_TIMEOUT_UserCallback
       1  IsInited
      18  i2c_master_deinit
     182  i2c_master_init
     728  i2c_master_read_raw
     956  i2c_master_read_register
     268  i2c_master_write_raw
     316  i2c_master_write_register

 
     1 byte  in section .bss
 2 608 bytes in section .text
 
 2 608 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
