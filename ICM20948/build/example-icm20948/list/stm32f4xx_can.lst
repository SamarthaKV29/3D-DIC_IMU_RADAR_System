###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:33
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\stm32f4xx_can.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\stm32f4xx_can.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    21-October-2015
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:
      9            *           + Initialization and Configuration 
     10            *           + CAN Frames Transmission
     11            *           + CAN Frames Reception
     12            *           + Operation modes switch
     13            *           + Error management
     14            *           + Interrupts and flags
     15            *
     16          @verbatim
     17           ===============================================================================
     18                                  ##### How to use this driver #####
     19           ===============================================================================
     20              [..]
     21                (#) Enable the CAN controller interface clock using 
     22                    RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     23                    and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     24                -@- In case you are using CAN2 only, you have to enable the CAN1 clock.
     25                 
     26                (#) CAN pins configuration
     27                  (++) Enable the clock for the CAN GPIOs using the following function:
     28                       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     29                  (++) Connect the involved CAN pins to AF9 using the following function 
     30                       GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     31                  (++) Configure these CAN pins in alternate function mode by calling
     32                       the function  GPIO_Init();
     33                
     34                (#) Initialize and configure the CAN using CAN_Init() and 
     35                    CAN_FilterInit() functions.   
     36                           
     37                (#) Transmit the desired CAN frame using CAN_Transmit() function.
     38                     
     39                (#) Check the transmission of a CAN frame using CAN_TransmitStatus()
     40                    function.
     41                           
     42                (#) Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     43                    function.  
     44                        
     45                (#) Receive a CAN frame using CAN_Receive() function.
     46                     
     47                (#) Release the receive FIFOs using CAN_FIFORelease() function.
     48                           
     49                (#) Return the number of pending received frames using 
     50                    CAN_MessagePending() function.            
     51                               
     52                (#) To control CAN events you can use one of the following two methods:
     53                  (++) Check on CAN flags using the CAN_GetFlagStatus() function.  
     54                  (++) Use CAN interrupts through the function CAN_ITConfig() at 
     55                       initialization phase and CAN_GetITStatus() function into 
     56                       interrupt routines to check if the event has occurred or not.
     57                       After checking on a flag you should clear it using CAN_ClearFlag()
     58                       function. And after checking on an interrupt event you should 
     59                       clear it using CAN_ClearITPendingBit() function.            
     60          
     61          @endverbatim
     62                     
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     67            *
     68            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     69            * You may not use this file except in compliance with the License.
     70            * You may obtain a copy of the License at:
     71            *
     72            *        http://www.st.com/software_license_agreement_liberty_v2
     73            *
     74            * Unless required by applicable law or agreed to in writing, software 
     75            * distributed under the License is distributed on an "AS IS" BASIS, 
     76            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     77            * See the License for the specific language governing permissions and
     78            * limitations under the License.
     79            *
     80            ******************************************************************************  
     81            */
     82          
     83          /* Includes ------------------------------------------------------------------*/
     84          #include "stm32f4xx_can.h"
     85          #include "stm32f4xx_rcc.h"
     86          
     87          /** @addtogroup STM32F4xx_StdPeriph_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup CAN 
     92            * @brief CAN driver modules
     93            * @{
     94            */ 
     95          /* Private typedef -----------------------------------------------------------*/
     96          /* Private define ------------------------------------------------------------*/
     97          
     98          /* CAN Master Control Register bits */
     99          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
    100          
    101          /* CAN Mailbox Transmit Request */
    102          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
    103          
    104          /* CAN Filter Master Register bits */
    105          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    106          
    107          /* Time out for INAK bit */
    108          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    109          /* Time out for SLAK bit */
    110          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    111          
    112          /* Flags in TSR register */
    113          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    114          /* Flags in RF1R register */
    115          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    116          /* Flags in RF0R register */
    117          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    118          /* Flags in MSR register */
    119          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    120          /* Flags in ESR register */
    121          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    122          
    123          /* Mailboxes definition */
    124          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    125          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    126          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    127          
    128          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    129          
    130          /* Private macro -------------------------------------------------------------*/
    131          /* Private variables ---------------------------------------------------------*/
    132          /* Private function prototypes -----------------------------------------------*/
    133          /* Private functions ---------------------------------------------------------*/
    134          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    135          
    136          /** @defgroup CAN_Private_Functions
    137            * @{
    138            */
    139          
    140          /** @defgroup CAN_Group1 Initialization and Configuration functions
    141           *  @brief    Initialization and Configuration functions 
    142           *
    143          @verbatim    
    144           ===============================================================================
    145                        ##### Initialization and Configuration functions #####
    146           ===============================================================================  
    147              [..] This section provides functions allowing to 
    148                (+) Initialize the CAN peripherals : Prescaler, operating mode, the maximum 
    149                    number of time quanta to perform resynchronization, the number of time 
    150                    quanta in Bit Segment 1 and 2 and many other modes. 
    151                    Refer to  @ref CAN_InitTypeDef  for more details.
    152                (+) Configures the CAN reception filter.                                      
    153                (+) Select the start bank filter for slave CAN.
    154                (+) Enables or disables the Debug Freeze mode for CAN
    155                (+)Enables or disables the CAN Time Trigger Operation communication mode
    156             
    157          @endverbatim
    158            * @{
    159            */
    160            
    161          /**
    162            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    163            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    164            * @retval None.
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          void CAN_DeInit(CAN_TypeDef* CANx)
    167          {
   \                     CAN_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    168            /* Check the parameters */
    169            assert_param(IS_CAN_ALL_PERIPH(CANx));
    170           
    171            if (CANx == CAN1)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable6  ;; 0x40006400
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD10B             BNE.N    ??CAN_DeInit_0
    172            {
    173              /* Enable CAN1 reset state */
    174              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF04F 0x7000      MOV      R0,#+33554432
   \   00000010   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    175              /* Release CAN1 from reset state */
    176              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF04F 0x7000      MOV      R0,#+33554432
   \   0000001A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001E   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    177            }
    178            else
    179            {  
    180              /* Enable CAN2 reset state */
    181              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
   \                     ??CAN_DeInit_0: (+1)
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000028   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    182              /* Release CAN2 from reset state */
    183              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000032   0xE8BD 0x4004      POP      {R2,LR}
   \   00000036   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    184            }
    185          }
    186          
    187          /**
    188            * @brief  Initializes the CAN peripheral according to the specified
    189            *         parameters in the CAN_InitStruct.
    190            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    191            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    192            *         the configuration information for the CAN peripheral.
    193            * @retval Constant indicates initialization succeed which will be 
    194            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    197          {
   \                     CAN_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
    198            uint8_t InitStatus = CAN_InitStatus_Failed;
   \   00000002   0x2200             MOVS     R2,#+0
    199            uint32_t wait_ack = 0x00000000;
   \   00000004   0x4613             MOV      R3,R2
    200            /* Check the parameters */
    201            assert_param(IS_CAN_ALL_PERIPH(CANx));
    202            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    203            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    204            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    205            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    206            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    207            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    208            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    209            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    210            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    211            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    212            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    213          
    214            /* Exit from sleep mode */
    215            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
   \   00000006   0x6804             LDR      R4,[R0, #+0]
   \   00000008   0xF024 0x0402      BIC      R4,R4,#0x2
   \   0000000C   0x6004             STR      R4,[R0, #+0]
    216          
    217            /* Request initialisation */
    218            CANx->MCR |= CAN_MCR_INRQ ;
   \   0000000E   0x6804             LDR      R4,[R0, #+0]
   \   00000010   0xF044 0x0401      ORR      R4,R4,#0x1
   \   00000014   0x6004             STR      R4,[R0, #+0]
   \   00000016   0xE000             B.N      ??CAN_Init_0
    219          
    220            /* Wait the acknowledge */
    221            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    222            {
    223              wait_ack++;
   \                     ??CAN_Init_1: (+1)
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
    224            }
   \                     ??CAN_Init_0: (+1)
   \   0000001A   0x6844             LDR      R4,[R0, #+4]
   \   0000001C   0x07E4             LSLS     R4,R4,#+31
   \   0000001E   0xD403             BMI.N    ??CAN_Init_2
   \   00000020   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000024   0x42A3             CMP      R3,R4
   \   00000026   0xD1F7             BNE.N    ??CAN_Init_1
    225          
    226            /* Check acknowledge */
    227            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
   \                     ??CAN_Init_2: (+1)
   \   00000028   0x6843             LDR      R3,[R0, #+4]
   \   0000002A   0x07DB             LSLS     R3,R3,#+31
   \   0000002C   0xD569             BPL.N    ??CAN_Init_3
    228            {
    229              InitStatus = CAN_InitStatus_Failed;
    230            }
    231            else 
    232            {
    233              /* Set the time triggered communication mode */
    234              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \   0000002E   0xF991 0x2006      LDRSB    R2,[R1, #+6]
   \   00000032   0x2A01             CMP      R2,#+1
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0xD103             BNE.N    ??CAN_Init_4
    235              {
    236                CANx->MCR |= CAN_MCR_TTCM;
   \   00000038   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000003C   0x6002             STR      R2,[R0, #+0]
   \   0000003E   0xE002             B.N      ??CAN_Init_5
    237              }
    238              else
    239              {
    240                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
   \                     ??CAN_Init_4: (+1)
   \   00000040   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000044   0x6002             STR      R2,[R0, #+0]
    241              }
    242          
    243              /* Set the automatic bus-off management */
    244              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_5: (+1)
   \   00000046   0xF991 0x2007      LDRSB    R2,[R1, #+7]
   \   0000004A   0x2A01             CMP      R2,#+1
   \   0000004C   0x6802             LDR      R2,[R0, #+0]
   \   0000004E   0xD103             BNE.N    ??CAN_Init_6
    245              {
    246                CANx->MCR |= CAN_MCR_ABOM;
   \   00000050   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000054   0x6002             STR      R2,[R0, #+0]
   \   00000056   0xE002             B.N      ??CAN_Init_7
    247              }
    248              else
    249              {
    250                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
   \                     ??CAN_Init_6: (+1)
   \   00000058   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000005C   0x6002             STR      R2,[R0, #+0]
    251              }
    252          
    253              /* Set the automatic wake-up mode */
    254              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_7: (+1)
   \   0000005E   0xF991 0x2008      LDRSB    R2,[R1, #+8]
   \   00000062   0x2A01             CMP      R2,#+1
   \   00000064   0x6802             LDR      R2,[R0, #+0]
   \   00000066   0xD103             BNE.N    ??CAN_Init_8
    255              {
    256                CANx->MCR |= CAN_MCR_AWUM;
   \   00000068   0xF042 0x0220      ORR      R2,R2,#0x20
   \   0000006C   0x6002             STR      R2,[R0, #+0]
   \   0000006E   0xE002             B.N      ??CAN_Init_9
    257              }
    258              else
    259              {
    260                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
   \                     ??CAN_Init_8: (+1)
   \   00000070   0xF022 0x0220      BIC      R2,R2,#0x20
   \   00000074   0x6002             STR      R2,[R0, #+0]
    261              }
    262          
    263              /* Set the no automatic retransmission */
    264              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_9: (+1)
   \   00000076   0xF991 0x2009      LDRSB    R2,[R1, #+9]
   \   0000007A   0x2A01             CMP      R2,#+1
   \   0000007C   0x6802             LDR      R2,[R0, #+0]
   \   0000007E   0xD103             BNE.N    ??CAN_Init_10
    265              {
    266                CANx->MCR |= CAN_MCR_NART;
   \   00000080   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000084   0x6002             STR      R2,[R0, #+0]
   \   00000086   0xE002             B.N      ??CAN_Init_11
    267              }
    268              else
    269              {
    270                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
   \                     ??CAN_Init_10: (+1)
   \   00000088   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000008C   0x6002             STR      R2,[R0, #+0]
    271              }
    272          
    273              /* Set the receive FIFO locked mode */
    274              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_11: (+1)
   \   0000008E   0xF991 0x200A      LDRSB    R2,[R1, #+10]
   \   00000092   0x2A01             CMP      R2,#+1
   \   00000094   0x6802             LDR      R2,[R0, #+0]
   \   00000096   0xD103             BNE.N    ??CAN_Init_12
    275              {
    276                CANx->MCR |= CAN_MCR_RFLM;
   \   00000098   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000009C   0x6002             STR      R2,[R0, #+0]
   \   0000009E   0xE002             B.N      ??CAN_Init_13
    277              }
    278              else
    279              {
    280                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
   \                     ??CAN_Init_12: (+1)
   \   000000A0   0xF022 0x0208      BIC      R2,R2,#0x8
   \   000000A4   0x6002             STR      R2,[R0, #+0]
    281              }
    282          
    283              /* Set the transmit FIFO priority */
    284              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_13: (+1)
   \   000000A6   0xF991 0x200B      LDRSB    R2,[R1, #+11]
   \   000000AA   0x2A01             CMP      R2,#+1
   \   000000AC   0x6802             LDR      R2,[R0, #+0]
   \   000000AE   0xD103             BNE.N    ??CAN_Init_14
    285              {
    286                CANx->MCR |= CAN_MCR_TXFP;
   \   000000B0   0xF042 0x0204      ORR      R2,R2,#0x4
   \   000000B4   0x6002             STR      R2,[R0, #+0]
   \   000000B6   0xE002             B.N      ??CAN_Init_15
    287              }
    288              else
    289              {
    290                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
   \                     ??CAN_Init_14: (+1)
   \   000000B8   0xF022 0x0204      BIC      R2,R2,#0x4
   \   000000BC   0x6002             STR      R2,[R0, #+0]
    291              }
    292          
    293              /* Set the bit timing register */
    294              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    295                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    296                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    297                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    298                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_15: (+1)
   \   000000BE   0x788A             LDRB     R2,[R1, #+2]
   \   000000C0   0x78CB             LDRB     R3,[R1, #+3]
   \   000000C2   0x061B             LSLS     R3,R3,#+24
   \   000000C4   0xEA43 0x7282      ORR      R2,R3,R2, LSL #+30
   \   000000C8   0x790B             LDRB     R3,[R1, #+4]
   \   000000CA   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   000000CE   0x794B             LDRB     R3,[R1, #+5]
   \   000000D0   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   000000D4   0x8809             LDRH     R1,[R1, #+0]
   \   000000D6   0x1E49             SUBS     R1,R1,#+1
   \   000000D8   0x4311             ORRS     R1,R1,R2
   \   000000DA   0x61C1             STR      R1,[R0, #+28]
    299          
    300              /* Request leave initialisation */
    301              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0x0849             LSRS     R1,R1,#+1
   \   000000E0   0x0049             LSLS     R1,R1,#+1
   \   000000E2   0x6001             STR      R1,[R0, #+0]
    302          
    303             /* Wait the acknowledge */
    304             wait_ack = 0;
   \   000000E4   0x2300             MOVS     R3,#+0
   \   000000E6   0xE000             B.N      ??CAN_Init_16
    305          
    306             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    307             {
    308               wait_ack++;
   \                     ??CAN_Init_17: (+1)
   \   000000E8   0x1C5B             ADDS     R3,R3,#+1
    309             }
   \                     ??CAN_Init_16: (+1)
   \   000000EA   0x6841             LDR      R1,[R0, #+4]
   \   000000EC   0x07C9             LSLS     R1,R1,#+31
   \   000000EE   0xD503             BPL.N    ??CAN_Init_18
   \   000000F0   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000F4   0x428B             CMP      R3,R1
   \   000000F6   0xD1F7             BNE.N    ??CAN_Init_17
    310          
    311              /* ...and check acknowledged */
    312              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
   \                     ??CAN_Init_18: (+1)
   \   000000F8   0x6840             LDR      R0,[R0, #+4]
    313              {
    314                InitStatus = CAN_InitStatus_Failed;
    315              }
    316              else
    317              {
    318                InitStatus = CAN_InitStatus_Success ;
   \   000000FA   0xF000 0x0001      AND      R0,R0,#0x1
   \   000000FE   0xF080 0x0201      EOR      R2,R0,#0x1
    319              }
    320            }
    321          
    322            /* At this step, return the status of initialization */
    323            return InitStatus;
   \                     ??CAN_Init_3: (+1)
   \   00000102   0x4610             MOV      R0,R2
   \   00000104   0xBC10             POP      {R4}
   \   00000106   0x4770             BX       LR               ;; return
    324          }
    325          
    326          /**
    327            * @brief  Configures the CAN reception filter according to the specified
    328            *         parameters in the CAN_FilterInitStruct.
    329            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    330            *         contains the configuration information.
    331            * @retval None
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    334          {
   \                     CAN_FilterInit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    335            uint32_t filter_number_bit_pos = 0;
    336            /* Check the parameters */
    337            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    338            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    339            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    340            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    341            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    342          
    343            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7A82             LDRB     R2,[R0, #+10]
   \   00000006   0x4091             LSLS     R1,R1,R2
    344          
    345            /* Initialisation mode for the filter */
    346            CAN1->FMR |= FMR_FINIT;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable6_1  ;; 0x40006600
   \   0000000C   0x6813             LDR      R3,[R2, #+0]
   \   0000000E   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000012   0x6013             STR      R3,[R2, #+0]
    347          
    348            /* Filter Deactivation */
    349            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000014   0x43CB             MVNS     R3,R1
   \   00000016   0x69D4             LDR      R4,[R2, #+28]
   \   00000018   0x401C             ANDS     R4,R3,R4
   \   0000001A   0x61D4             STR      R4,[R2, #+28]
    350          
    351            /* Filter Scale */
    352            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   0000001C   0x7B04             LDRB     R4,[R0, #+12]
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD113             BNE.N    ??CAN_FilterInit_0
    353            {
    354              /* 16-bit scale for the filter */
    355              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000022   0x68D4             LDR      R4,[R2, #+12]
   \   00000024   0x401C             ANDS     R4,R3,R4
   \   00000026   0x60D4             STR      R4,[R2, #+12]
    356          
    357              /* First 16-bit identifier and First 16-bit mask */
    358              /* Or First 16-bit identifier and Second 16-bit identifier */
    359              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    360                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    361                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000028   0x.... 0x....      LDR.W    R4,??DataTable6_2  ;; 0x40006640
   \   0000002C   0x88C5             LDRH     R5,[R0, #+6]
   \   0000002E   0x8846             LDRH     R6,[R0, #+2]
   \   00000030   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000034   0x7A86             LDRB     R6,[R0, #+10]
   \   00000036   0xF844 0x5036      STR      R5,[R4, R6, LSL #+3]
    362          
    363              /* Second 16-bit identifier and Second 16-bit mask */
    364              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    365              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    366                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    367                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   0000003A   0x7A85             LDRB     R5,[R0, #+10]
   \   0000003C   0xEB04 0x04C5      ADD      R4,R4,R5, LSL #+3
   \   00000040   0x8885             LDRH     R5,[R0, #+4]
   \   00000042   0x8806             LDRH     R6,[R0, #+0]
   \   00000044   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000048   0x6065             STR      R5,[R4, #+4]
    368            }
    369          
    370            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0: (+1)
   \   0000004A   0x7B04             LDRB     R4,[R0, #+12]
   \   0000004C   0x2C01             CMP      R4,#+1
   \   0000004E   0xD113             BNE.N    ??CAN_FilterInit_1
    371            {
    372              /* 32-bit scale for the filter */
    373              CAN1->FS1R |= filter_number_bit_pos;
   \   00000050   0x68D4             LDR      R4,[R2, #+12]
   \   00000052   0x430C             ORRS     R4,R1,R4
   \   00000054   0x60D4             STR      R4,[R2, #+12]
    374              /* 32-bit identifier or First 32-bit identifier */
    375              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    376                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    377                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \   00000056   0x.... 0x....      LDR.W    R4,??DataTable6_2  ;; 0x40006640
   \   0000005A   0x8805             LDRH     R5,[R0, #+0]
   \   0000005C   0x8846             LDRH     R6,[R0, #+2]
   \   0000005E   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000062   0x7A86             LDRB     R6,[R0, #+10]
   \   00000064   0xF844 0x5036      STR      R5,[R4, R6, LSL #+3]
    378              /* 32-bit mask or Second 32-bit identifier */
    379              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    380                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    381                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   00000068   0x7A85             LDRB     R5,[R0, #+10]
   \   0000006A   0xEB04 0x04C5      ADD      R4,R4,R5, LSL #+3
   \   0000006E   0x8885             LDRH     R5,[R0, #+4]
   \   00000070   0x88C6             LDRH     R6,[R0, #+6]
   \   00000072   0xEA46 0x4505      ORR      R5,R6,R5, LSL #+16
   \   00000076   0x6065             STR      R5,[R4, #+4]
    382            }
    383          
    384            /* Filter Mode */
    385            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1: (+1)
   \   00000078   0x7AC4             LDRB     R4,[R0, #+11]
   \   0000007A   0x2C00             CMP      R4,#+0
   \   0000007C   0x6854             LDR      R4,[R2, #+4]
   \   0000007E   0xD102             BNE.N    ??CAN_FilterInit_2
    386            {
    387              /*Id/Mask mode for the filter*/
    388              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000080   0x401C             ANDS     R4,R3,R4
   \   00000082   0x6054             STR      R4,[R2, #+4]
   \   00000084   0xE001             B.N      ??CAN_FilterInit_3
    389            }
    390            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    391            {
    392              /*Identifier list mode for the filter*/
    393              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
   \                     ??CAN_FilterInit_2: (+1)
   \   00000086   0x430C             ORRS     R4,R1,R4
   \   00000088   0x6054             STR      R4,[R2, #+4]
    394            }
    395          
    396            /* Filter FIFO assignment */
    397            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
   \                     ??CAN_FilterInit_3: (+1)
   \   0000008A   0x8904             LDRH     R4,[R0, #+8]
   \   0000008C   0x2C00             CMP      R4,#+0
   \   0000008E   0xD102             BNE.N    ??CAN_FilterInit_4
    398            {
    399              /* FIFO 0 assignation for the filter */
    400              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
   \   00000090   0x6954             LDR      R4,[R2, #+20]
   \   00000092   0x4023             ANDS     R3,R3,R4
   \   00000094   0x6153             STR      R3,[R2, #+20]
    401            }
    402          
    403            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
   \                     ??CAN_FilterInit_4: (+1)
   \   00000096   0x8903             LDRH     R3,[R0, #+8]
   \   00000098   0x2B01             CMP      R3,#+1
   \   0000009A   0xD102             BNE.N    ??CAN_FilterInit_5
    404            {
    405              /* FIFO 1 assignation for the filter */
    406              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
   \   0000009C   0x6953             LDR      R3,[R2, #+20]
   \   0000009E   0x430B             ORRS     R3,R1,R3
   \   000000A0   0x6153             STR      R3,[R2, #+20]
    407            }
    408            
    409            /* Filter activation */
    410            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5: (+1)
   \   000000A2   0xF990 0x000D      LDRSB    R0,[R0, #+13]
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD102             BNE.N    ??CAN_FilterInit_6
    411            {
    412              CAN1->FA1R |= filter_number_bit_pos;
   \   000000AA   0x69D0             LDR      R0,[R2, #+28]
   \   000000AC   0x4308             ORRS     R0,R1,R0
   \   000000AE   0x61D0             STR      R0,[R2, #+28]
    413            }
    414          
    415            /* Leave the initialisation mode for the filter */
    416            CAN1->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6: (+1)
   \   000000B0   0x6810             LDR      R0,[R2, #+0]
   \   000000B2   0x0840             LSRS     R0,R0,#+1
   \   000000B4   0x0040             LSLS     R0,R0,#+1
   \   000000B6   0x6010             STR      R0,[R2, #+0]
    417          }
   \   000000B8   0xBC70             POP      {R4-R6}
   \   000000BA   0x4770             BX       LR               ;; return
    418          
    419          /**
    420            * @brief  Fills each CAN_InitStruct member with its default value.
    421            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    422            * @retval None
    423            */

   \                                 In section .text, align 2, keep-with-next
    424          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    425          {
    426            /* Reset CAN init structure parameters values */
    427            
    428            /* Initialize the time triggered communication mode */
    429            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7181             STRB     R1,[R0, #+6]
    430            
    431            /* Initialize the automatic bus-off management */
    432            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   0x71C1             STRB     R1,[R0, #+7]
    433            
    434            /* Initialize the automatic wake-up mode */
    435            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000006   0x7201             STRB     R1,[R0, #+8]
    436            
    437            /* Initialize the no automatic retransmission */
    438            CAN_InitStruct->CAN_NART = DISABLE;
   \   00000008   0x7241             STRB     R1,[R0, #+9]
    439            
    440            /* Initialize the receive FIFO locked mode */
    441            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   0000000A   0x7281             STRB     R1,[R0, #+10]
    442            
    443            /* Initialize the transmit FIFO priority */
    444            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   0000000C   0x72C1             STRB     R1,[R0, #+11]
    445            
    446            /* Initialize the CAN_Mode member */
    447            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
    448            
    449            /* Initialize the CAN_SJW member */
    450            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   00000010   0x70C1             STRB     R1,[R0, #+3]
    451            
    452            /* Initialize the CAN_BS1 member */
    453            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x7101             STRB     R1,[R0, #+4]
    454            
    455            /* Initialize the CAN_BS2 member */
    456            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x7141             STRB     R1,[R0, #+5]
    457            
    458            /* Initialize the CAN_Prescaler member */
    459            CAN_InitStruct->CAN_Prescaler = 1;
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x8001             STRH     R1,[R0, #+0]
    460          }
   \   0000001E   0x4770             BX       LR               ;; return
    461          
    462          /**
    463            * @brief  Select the start bank filter for slave CAN.
    464            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    465            * @retval None
    466            */

   \                                 In section .text, align 2, keep-with-next
    467          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    468          {
    469            /* Check the parameters */
    470            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    471            
    472            /* Enter Initialisation mode for the filter */
    473            CAN1->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x40006600
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000A   0x600A             STR      R2,[R1, #+0]
    474            
    475            /* Select the start slave bank */
    476            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R3,??DataTable6_3  ;; 0xffffc0f1
   \   00000012   0x401A             ANDS     R2,R3,R2
   \   00000014   0x600A             STR      R2,[R1, #+0]
    477            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0xEA42 0x2000      ORR      R0,R2,R0, LSL #+8
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    478            
    479            /* Leave Initialisation mode for the filter */
    480            CAN1->FMR &= ~FMR_FINIT;
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0x6008             STR      R0,[R1, #+0]
    481          }
   \   00000026   0x4770             BX       LR               ;; return
    482          
    483          /**
    484            * @brief  Enables or disables the DBG Freeze for CAN.
    485            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    486            * @param  NewState: new state of the CAN peripheral. 
    487            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    488            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    489            *          or DISABLE (CAN is working during debug).
    490            * @retval None
    491            */

   \                                 In section .text, align 2, keep-with-next
    492          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    493          {
    494            /* Check the parameters */
    495            assert_param(IS_CAN_ALL_PERIPH(CANx));
    496            assert_param(IS_FUNCTIONAL_STATE(NewState));
    497            
    498            if (NewState != DISABLE)
   \                     CAN_DBGFreeze: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xD003             BEQ.N    ??CAN_DBGFreeze_0
    499            {
    500              /* Enable Debug Freeze  */
    501              CANx->MCR |= MCR_DBF;
   \   00000006   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    502            }
    503            else
    504            {
    505              /* Disable Debug Freeze */
    506              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0: (+1)
   \   0000000E   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000012   0x6001             STR      R1,[R0, #+0]
    507            }
    508          }
   \   00000014   0x4770             BX       LR               ;; return
    509          
    510          
    511          /**
    512            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    513            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    514            *         sent over the CAN bus.  
    515            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    516            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    517            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    518            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    519            *         in data byte 7. 
    520            * @retval None
    521            */

   \                                 In section .text, align 2, keep-with-next
    522          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    523          {
    524            /* Check the parameters */
    525            assert_param(IS_CAN_ALL_PERIPH(CANx));
    526            assert_param(IS_FUNCTIONAL_STATE(NewState));
    527            if (NewState != DISABLE)
   \                     CAN_TTComModeCmd: (+1)
   \   00000000   0xF44F 0x72C2      MOV      R2,#+388
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xD00F             BEQ.N    ??CAN_TTComModeCmd_0
    528            {
    529              /* Enable the TTCM mode */
    530              CANx->MCR |= CAN_MCR_TTCM;
   \   0000000C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000010   0x6001             STR      R1,[R0, #+0]
    531          
    532              /* Set TGT bits */
    533              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
   \   00000012   0x6810             LDR      R0,[R2, #+0]
   \   00000014   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000018   0x6010             STR      R0,[R2, #+0]
    534              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
   \   0000001A   0x6910             LDR      R0,[R2, #+16]
   \   0000001C   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000020   0x6110             STR      R0,[R2, #+16]
    535              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
   \   00000022   0x6A10             LDR      R0,[R2, #+32]
   \   00000024   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000028   0x6210             STR      R0,[R2, #+32]
   \   0000002A   0x4770             BX       LR
    536            }
    537            else
    538            {
    539              /* Disable the TTCM mode */
    540              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
   \                     ??CAN_TTComModeCmd_0: (+1)
   \   0000002C   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000030   0x6001             STR      R1,[R0, #+0]
    541          
    542              /* Reset TGT bits */
    543              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
   \   00000032   0x6810             LDR      R0,[R2, #+0]
   \   00000034   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000038   0x6010             STR      R0,[R2, #+0]
    544              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
   \   0000003A   0x6910             LDR      R0,[R2, #+16]
   \   0000003C   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000040   0x6110             STR      R0,[R2, #+16]
    545              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
   \   00000042   0x6A10             LDR      R0,[R2, #+32]
   \   00000044   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000048   0x6210             STR      R0,[R2, #+32]
    546            }
    547          }
   \   0000004A   0x4770             BX       LR               ;; return
    548          /**
    549            * @}
    550            */
    551          
    552          
    553          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    554           *  @brief    CAN Frames Transmission functions 
    555           *
    556          @verbatim    
    557           ===============================================================================
    558                          ##### CAN Frames Transmission functions #####
    559           ===============================================================================  
    560              [..] This section provides functions allowing to 
    561                (+) Initiate and transmit a CAN frame message (if there is an empty mailbox).
    562                (+) Check the transmission status of a CAN Frame
    563                (+) Cancel a transmit request
    564             
    565          @endverbatim
    566            * @{
    567            */
    568          
    569          /**
    570            * @brief  Initiates and transmits a CAN frame message.
    571            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    572            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    573            * @retval The number of the mailbox that is used for transmission or
    574            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    575            */

   \                                 In section .text, align 2, keep-with-next
    576          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    577          {
   \                     CAN_Transmit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    578            uint8_t transmit_mailbox = 0;
    579            /* Check the parameters */
    580            assert_param(IS_CAN_ALL_PERIPH(CANx));
    581            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    582            assert_param(IS_CAN_RTR(TxMessage->RTR));
    583            assert_param(IS_CAN_DLC(TxMessage->DLC));
    584          
    585            /* Select one empty transmit mailbox */
    586            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x0152             LSLS     R2,R2,#+5
   \   00000006   0xD501             BPL.N    ??CAN_Transmit_0
    587            {
    588              transmit_mailbox = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xE00A             B.N      ??CAN_Transmit_1
    589            }
    590            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
   \                     ??CAN_Transmit_0: (+1)
   \   0000000C   0x6882             LDR      R2,[R0, #+8]
   \   0000000E   0x0112             LSLS     R2,R2,#+4
   \   00000010   0xD501             BPL.N    ??CAN_Transmit_2
    591            {
    592              transmit_mailbox = 1;
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xE005             B.N      ??CAN_Transmit_1
    593            }
    594            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
   \                     ??CAN_Transmit_2: (+1)
   \   00000016   0x6882             LDR      R2,[R0, #+8]
   \   00000018   0x00D2             LSLS     R2,R2,#+3
   \   0000001A   0xD501             BPL.N    ??CAN_Transmit_3
    595            {
    596              transmit_mailbox = 2;
   \   0000001C   0x2202             MOVS     R2,#+2
   \   0000001E   0xE000             B.N      ??CAN_Transmit_1
    597            }
    598            else
    599            {
    600              transmit_mailbox = CAN_TxStatus_NoMailBox;
   \                     ??CAN_Transmit_3: (+1)
   \   00000020   0x2204             MOVS     R2,#+4
    601            }
    602          
    603            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
   \                     ??CAN_Transmit_1: (+1)
   \   00000022   0x2A04             CMP      R2,#+4
   \   00000024   0xD040             BEQ.N    ??CAN_Transmit_4
    604            {
    605              /* Set up the Id */
    606              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
   \   00000026   0xEB00 0x1002      ADD      R0,R0,R2, LSL #+4
   \   0000002A   0xF44F 0x73C0      MOV      R3,#+384
   \   0000002E   0x4418             ADD      R0,R0,R3
   \   00000030   0x6803             LDR      R3,[R0, #+0]
   \   00000032   0xF003 0x0301      AND      R3,R3,#0x1
   \   00000036   0x6003             STR      R3,[R0, #+0]
    607              if (TxMessage->IDE == CAN_Id_Standard)
   \   00000038   0x7A4B             LDRB     R3,[R1, #+9]
   \   0000003A   0x7A0C             LDRB     R4,[R1, #+8]
   \   0000003C   0x0025             MOVS     R5,R4
   \   0000003E   0xD106             BNE.N    ??CAN_Transmit_5
    608              {
    609                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    610                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    611                                                            TxMessage->RTR);
   \   00000040   0x6804             LDR      R4,[R0, #+0]
   \   00000042   0x680D             LDR      R5,[R1, #+0]
   \   00000044   0xEA43 0x5345      ORR      R3,R3,R5, LSL #+21
   \   00000048   0x4323             ORRS     R3,R3,R4
   \   0000004A   0x6003             STR      R3,[R0, #+0]
   \   0000004C   0xE006             B.N      ??CAN_Transmit_6
    612              }
    613              else
    614              {
    615                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    616                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    617                                                            TxMessage->IDE | \
    618                                                            TxMessage->RTR);
   \                     ??CAN_Transmit_5: (+1)
   \   0000004E   0x6805             LDR      R5,[R0, #+0]
   \   00000050   0x684E             LDR      R6,[R1, #+4]
   \   00000052   0xEA44 0x04C6      ORR      R4,R4,R6, LSL #+3
   \   00000056   0x4323             ORRS     R3,R3,R4
   \   00000058   0x432B             ORRS     R3,R3,R5
   \   0000005A   0x6003             STR      R3,[R0, #+0]
    619              }
    620              
    621              /* Set up the DLC */
    622              TxMessage->DLC &= (uint8_t)0x0000000F;
   \                     ??CAN_Transmit_6: (+1)
   \   0000005C   0x7A8B             LDRB     R3,[R1, #+10]
   \   0000005E   0xF003 0x030F      AND      R3,R3,#0xF
   \   00000062   0x728B             STRB     R3,[R1, #+10]
    623              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
   \   00000064   0x6843             LDR      R3,[R0, #+4]
   \   00000066   0x091B             LSRS     R3,R3,#+4
   \   00000068   0x011B             LSLS     R3,R3,#+4
   \   0000006A   0x6043             STR      R3,[R0, #+4]
    624              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
   \   0000006C   0x6843             LDR      R3,[R0, #+4]
   \   0000006E   0x7A8C             LDRB     R4,[R1, #+10]
   \   00000070   0x4323             ORRS     R3,R4,R3
   \   00000072   0x6043             STR      R3,[R0, #+4]
    625          
    626              /* Set up the data field */
    627              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    628                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    629                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    630                                                       ((uint32_t)TxMessage->Data[0]));
   \   00000074   0x7B8B             LDRB     R3,[R1, #+14]
   \   00000076   0x7B4C             LDRB     R4,[R1, #+13]
   \   00000078   0x0424             LSLS     R4,R4,#+16
   \   0000007A   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   0000007E   0x7B0C             LDRB     R4,[R1, #+12]
   \   00000080   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000084   0x7ACC             LDRB     R4,[R1, #+11]
   \   00000086   0x4323             ORRS     R3,R4,R3
   \   00000088   0x6083             STR      R3,[R0, #+8]
    631              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    632                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    633                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    634                                                       ((uint32_t)TxMessage->Data[4]));
   \   0000008A   0x7C8B             LDRB     R3,[R1, #+18]
   \   0000008C   0x7C4C             LDRB     R4,[R1, #+17]
   \   0000008E   0x0424             LSLS     R4,R4,#+16
   \   00000090   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   00000094   0x7C0C             LDRB     R4,[R1, #+16]
   \   00000096   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000009A   0x7BC9             LDRB     R1,[R1, #+15]
   \   0000009C   0x4319             ORRS     R1,R1,R3
   \   0000009E   0x60C1             STR      R1,[R0, #+12]
    635              /* Request transmission */
    636              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000A6   0x6001             STR      R1,[R0, #+0]
    637            }
    638            return transmit_mailbox;
   \                     ??CAN_Transmit_4: (+1)
   \   000000A8   0x4610             MOV      R0,R2
   \   000000AA   0xBC70             POP      {R4-R6}
   \   000000AC   0x4770             BX       LR               ;; return
    639          }
    640          
    641          /**
    642            * @brief  Checks the transmission status of a CAN Frame.
    643            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    644            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    645            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    646            *         CAN_TxStatus_Failed in an other case.
    647            */

   \                                 In section .text, align 2, keep-with-next
    648          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    649          {
    650            uint32_t state = 0;
   \                     CAN_TransmitStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    651          
    652            /* Check the parameters */
    653            assert_param(IS_CAN_ALL_PERIPH(CANx));
    654            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    655           
    656            switch (TransmitMailbox)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??CAN_TransmitStatus_0
   \   00000006   0x2902             CMP      R1,#+2
   \   00000008   0xD00D             BEQ.N    ??CAN_TransmitStatus_1
   \   0000000A   0xD306             BCC.N    ??CAN_TransmitStatus_2
   \   0000000C   0xE010             B.N      ??CAN_TransmitStatus_3
    657            {
    658              case (CAN_TXMAILBOX_0): 
    659                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
   \                     ??CAN_TransmitStatus_0: (+1)
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable6_4  ;; 0x4000003
   \   00000014   0xEA01 0x0200      AND      R2,R1,R0
    660                break;
   \   00000018   0xE00A             B.N      ??CAN_TransmitStatus_3
    661              case (CAN_TXMAILBOX_1): 
    662                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
   \                     ??CAN_TransmitStatus_2: (+1)
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable6_5  ;; 0x8000300
   \   00000020   0xEA01 0x0200      AND      R2,R1,R0
    663                break;
   \   00000024   0xE004             B.N      ??CAN_TransmitStatus_3
    664              case (CAN_TXMAILBOX_2): 
    665                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
   \                     ??CAN_TransmitStatus_1: (+1)
   \   00000026   0x6880             LDR      R0,[R0, #+8]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable6_6  ;; 0x10030000
   \   0000002C   0xEA01 0x0200      AND      R2,R1,R0
    666                break;
    667              default:
    668                state = CAN_TxStatus_Failed;
    669                break;
    670            }
    671            switch (state)
   \                     ??CAN_TransmitStatus_3: (+1)
   \   00000030   0x2A00             CMP      R2,#+0
   \   00000032   0xD00C             BEQ.N    ??CAN_TransmitStatus_4
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable6_4  ;; 0x4000003
   \   00000038   0x4282             CMP      R2,R0
   \   0000003A   0xD00A             BEQ.N    ??CAN_TransmitStatus_5
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable6_5  ;; 0x8000300
   \   00000040   0x4282             CMP      R2,R0
   \   00000042   0xD006             BEQ.N    ??CAN_TransmitStatus_5
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable6_6  ;; 0x10030000
   \   00000048   0x4282             CMP      R2,R0
   \   0000004A   0xD002             BEQ.N    ??CAN_TransmitStatus_5
   \   0000004C   0xE003             B.N      ??CAN_TransmitStatus_6
    672            {
    673                /* transmit pending  */
    674              case (0x0): state = CAN_TxStatus_Pending;
   \                     ??CAN_TransmitStatus_4: (+1)
   \   0000004E   0x2002             MOVS     R0,#+2
    675                break;
   \   00000050   0x4770             BX       LR
    676                /* transmit failed  */
    677               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    678                break;
    679               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    680                break;
    681               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    682                break;
    683                /* transmit succeeded  */
    684              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
    685                break;
    686              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
    687                break;
    688              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_5: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
    689                break;
   \   00000054   0x4770             BX       LR
    690              default: state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_6: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
    691                break;
    692            }
    693            return (uint8_t) state;
   \   00000058   0x4770             BX       LR               ;; return
    694          }
    695          
    696          /**
    697            * @brief  Cancels a transmit request.
    698            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    699            * @param  Mailbox: Mailbox number.
    700            * @retval None
    701            */

   \                                 In section .text, align 2, keep-with-next
    702          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    703          {
    704            /* Check the parameters */
    705            assert_param(IS_CAN_ALL_PERIPH(CANx));
    706            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    707            /* abort transmission */
    708            switch (Mailbox)
   \                     CAN_CancelTransmit: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD003             BEQ.N    ??CAN_CancelTransmit_0
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD00B             BEQ.N    ??CAN_CancelTransmit_1
   \   00000008   0xD305             BCC.N    ??CAN_CancelTransmit_2
   \   0000000A   0x4770             BX       LR
    709            {
    710              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0: (+1)
   \   0000000C   0x6881             LDR      R1,[R0, #+8]
   \   0000000E   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000012   0x6081             STR      R1,[R0, #+8]
    711                break;
   \   00000014   0x4770             BX       LR
    712              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2: (+1)
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000001C   0x6081             STR      R1,[R0, #+8]
    713                break;
   \   0000001E   0x4770             BX       LR
    714              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1: (+1)
   \   00000020   0x6881             LDR      R1,[R0, #+8]
   \   00000022   0xF441 0x0100      ORR      R1,R1,#0x800000
   \   00000026   0x6081             STR      R1,[R0, #+8]
    715                break;
    716              default:
    717                break;
    718            }
    719          }
   \   00000028   0x4770             BX       LR               ;; return
    720          /**
    721            * @}
    722            */
    723          
    724          
    725          /** @defgroup CAN_Group3 CAN Frames Reception functions
    726           *  @brief    CAN Frames Reception functions 
    727           *
    728          @verbatim    
    729           ===============================================================================
    730                          ##### CAN Frames Reception functions #####
    731           ===============================================================================  
    732              [..] This section provides functions allowing to 
    733                (+) Receive a correct CAN frame
    734                (+) Release a specified receive FIFO (2 FIFOs are available)
    735                (+) Return the number of the pending received CAN frames
    736             
    737          @endverbatim
    738            * @{
    739            */
    740          
    741          /**
    742            * @brief  Receives a correct CAN frame.
    743            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    744            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    745            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    746            *         CAN DLC, CAN data and FMI number.
    747            * @retval None
    748            */

   \                                 In section .text, align 2, keep-with-next
    749          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    750          {
   \                     CAN_Receive: (+1)
   \   00000000   0xB410             PUSH     {R4}
    751            /* Check the parameters */
    752            assert_param(IS_CAN_ALL_PERIPH(CANx));
    753            assert_param(IS_CAN_FIFO(FIFONumber));
    754            /* Get the Id */
    755            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \   00000002   0xEB00 0x1301      ADD      R3,R0,R1, LSL #+4
   \   00000006   0xF44F 0x74D8      MOV      R4,#+432
   \   0000000A   0x4423             ADD      R3,R3,R4
   \   0000000C   0x681C             LDR      R4,[R3, #+0]
   \   0000000E   0xF014 0x0404      ANDS     R4,R4,#0x4
   \   00000012   0x7214             STRB     R4,[R2, #+8]
    756            if (RxMessage->IDE == CAN_Id_Standard)
   \   00000014   0x681C             LDR      R4,[R3, #+0]
   \   00000016   0xD102             BNE.N    ??CAN_Receive_0
    757            {
    758              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   00000018   0x0D64             LSRS     R4,R4,#+21
   \   0000001A   0x6014             STR      R4,[R2, #+0]
   \   0000001C   0xE001             B.N      ??CAN_Receive_1
    759            }
    760            else
    761            {
    762              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0: (+1)
   \   0000001E   0x08E4             LSRS     R4,R4,#+3
   \   00000020   0x6054             STR      R4,[R2, #+4]
    763            }
    764            
    765            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1: (+1)
   \   00000022   0x681C             LDR      R4,[R3, #+0]
   \   00000024   0xF004 0x0402      AND      R4,R4,#0x2
   \   00000028   0x7254             STRB     R4,[R2, #+9]
    766            /* Get the DLC */
    767            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \   0000002A   0x685C             LDR      R4,[R3, #+4]
   \   0000002C   0xF004 0x040F      AND      R4,R4,#0xF
   \   00000030   0x7294             STRB     R4,[R2, #+10]
    768            /* Get the FMI */
    769            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000032   0x685C             LDR      R4,[R3, #+4]
   \   00000034   0x0A24             LSRS     R4,R4,#+8
   \   00000036   0x74D4             STRB     R4,[R2, #+19]
    770            /* Get the data field */
    771            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \   00000038   0x689C             LDR      R4,[R3, #+8]
   \   0000003A   0x72D4             STRB     R4,[R2, #+11]
    772            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   0000003C   0x689C             LDR      R4,[R3, #+8]
   \   0000003E   0x0A24             LSRS     R4,R4,#+8
   \   00000040   0x7314             STRB     R4,[R2, #+12]
    773            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   00000042   0x689C             LDR      R4,[R3, #+8]
   \   00000044   0x0C24             LSRS     R4,R4,#+16
   \   00000046   0x7354             STRB     R4,[R2, #+13]
    774            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   00000048   0x689C             LDR      R4,[R3, #+8]
   \   0000004A   0x0E24             LSRS     R4,R4,#+24
   \   0000004C   0x7394             STRB     R4,[R2, #+14]
    775            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \   0000004E   0x68DC             LDR      R4,[R3, #+12]
   \   00000050   0x73D4             STRB     R4,[R2, #+15]
    776            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   00000052   0x68DC             LDR      R4,[R3, #+12]
   \   00000054   0x0A24             LSRS     R4,R4,#+8
   \   00000056   0x7414             STRB     R4,[R2, #+16]
    777            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   00000058   0x68DC             LDR      R4,[R3, #+12]
   \   0000005A   0x0C24             LSRS     R4,R4,#+16
   \   0000005C   0x7454             STRB     R4,[R2, #+17]
    778            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   0000005E   0x68DB             LDR      R3,[R3, #+12]
   \   00000060   0x0E1B             LSRS     R3,R3,#+24
   \   00000062   0x7493             STRB     R3,[R2, #+18]
    779            /* Release the FIFO */
    780            /* Release FIFO0 */
    781            if (FIFONumber == CAN_FIFO0)
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD104             BNE.N    ??CAN_Receive_2
    782            {
    783              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000068   0x68C1             LDR      R1,[R0, #+12]
   \   0000006A   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000006E   0x60C1             STR      R1,[R0, #+12]
   \   00000070   0xE003             B.N      ??CAN_Receive_3
    784            }
    785            /* Release FIFO1 */
    786            else /* FIFONumber == CAN_FIFO1 */
    787            {
    788              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_Receive_2: (+1)
   \   00000072   0x6901             LDR      R1,[R0, #+16]
   \   00000074   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000078   0x6101             STR      R1,[R0, #+16]
    789            }
    790          }
   \                     ??CAN_Receive_3: (+1)
   \   0000007A   0xBC10             POP      {R4}
   \   0000007C   0x4770             BX       LR               ;; return
    791          
    792          /**
    793            * @brief  Releases the specified receive FIFO.
    794            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    795            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    796            * @retval None
    797            */

   \                                 In section .text, align 2, keep-with-next
    798          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    799          {
    800            /* Check the parameters */
    801            assert_param(IS_CAN_ALL_PERIPH(CANx));
    802            assert_param(IS_CAN_FIFO(FIFONumber));
    803            /* Release FIFO0 */
    804            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD104             BNE.N    ??CAN_FIFORelease_0
    805            {
    806              CANx->RF0R |= CAN_RF0R_RFOM0;
   \   00000004   0x68C1             LDR      R1,[R0, #+12]
   \   00000006   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
   \   0000000C   0x4770             BX       LR
    807            }
    808            /* Release FIFO1 */
    809            else /* FIFONumber == CAN_FIFO1 */
    810            {
    811              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0: (+1)
   \   0000000E   0x6901             LDR      R1,[R0, #+16]
   \   00000010   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000014   0x6101             STR      R1,[R0, #+16]
    812            }
    813          }
   \   00000016   0x4770             BX       LR               ;; return
    814          
    815          /**
    816            * @brief  Returns the number of pending received messages.
    817            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    818            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    819            * @retval NbMessage : which is the number of pending message.
    820            */

   \                                 In section .text, align 2, keep-with-next
    821          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    822          {
    823            uint8_t message_pending=0;
   \                     CAN_MessagePending: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    824            /* Check the parameters */
    825            assert_param(IS_CAN_ALL_PERIPH(CANx));
    826            assert_param(IS_CAN_FIFO(FIFONumber));
    827            if (FIFONumber == CAN_FIFO0)
   \   00000002   0x000B             MOVS     R3,R1
   \   00000004   0xD103             BNE.N    ??CAN_MessagePending_0
    828            {
    829              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF000 0x0203      AND      R2,R0,#0x3
   \   0000000C   0xE004             B.N      ??CAN_MessagePending_1
    830            }
    831            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0: (+1)
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD102             BNE.N    ??CAN_MessagePending_1
    832            {
    833              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
   \   00000012   0x6900             LDR      R0,[R0, #+16]
   \   00000014   0xF000 0x0203      AND      R2,R0,#0x3
    834            }
    835            else
    836            {
    837              message_pending = 0;
    838            }
    839            return message_pending;
   \                     ??CAN_MessagePending_1: (+1)
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
    840          }
    841          /**
    842            * @}
    843            */
    844          
    845          
    846          /** @defgroup CAN_Group4 CAN Operation modes functions
    847           *  @brief    CAN Operation modes functions 
    848           *
    849          @verbatim    
    850           ===============================================================================
    851                              ##### CAN Operation modes functions #####
    852           ===============================================================================  
    853              [..] This section provides functions allowing to select the CAN Operation modes
    854                (+) sleep mode
    855                (+) normal mode 
    856                (+) initialization mode
    857             
    858          @endverbatim
    859            * @{
    860            */
    861            
    862            
    863          /**
    864            * @brief  Selects the CAN Operation mode.
    865            * @param  CAN_OperatingMode: CAN Operating Mode.
    866            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    867            * @retval status of the requested mode which can be 
    868            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    869            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    870            */

   \                                 In section .text, align 2, keep-with-next
    871          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    872          {
   \                     CAN_OperatingModeRequest: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x460A             MOV      R2,R1
    873            uint8_t status = CAN_ModeStatus_Failed;
   \   00000004   0x2100             MOVS     R1,#+0
    874            
    875            /* Timeout for INAK or also for SLAK bits*/
    876            uint32_t timeout = INAK_TIMEOUT; 
   \   00000006   0xF64F 0x73FF      MOVW     R3,#+65535
    877          
    878            /* Check the parameters */
    879            assert_param(IS_CAN_ALL_PERIPH(CANx));
    880            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    881          
    882            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0xD115             BNE.N    ??CAN_OperatingModeRequest_0
    883            {
    884              /* Request initialisation */
    885              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0x6002             STR      R2,[R0, #+0]
   \   0000001A   0xE000             B.N      ??CAN_OperatingModeRequest_1
    886          
    887              /* Wait the acknowledge */
    888              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    889              {
    890                timeout--;
   \                     ??CAN_OperatingModeRequest_2: (+1)
   \   0000001C   0x1E5B             SUBS     R3,R3,#+1
    891              }
   \                     ??CAN_OperatingModeRequest_1: (+1)
   \   0000001E   0x6842             LDR      R2,[R0, #+4]
   \   00000020   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000024   0x2A01             CMP      R2,#+1
   \   00000026   0xD001             BEQ.N    ??CAN_OperatingModeRequest_3
   \   00000028   0x2B00             CMP      R3,#+0
   \   0000002A   0xD1F7             BNE.N    ??CAN_OperatingModeRequest_2
    892              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
   \                     ??CAN_OperatingModeRequest_3: (+1)
   \   0000002C   0x6840             LDR      R0,[R0, #+4]
   \   0000002E   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD12C             BNE.N    ??CAN_OperatingModeRequest_4
    893              {
    894                status = CAN_ModeStatus_Failed;
    895              }
    896              else
    897              {
    898                status = CAN_ModeStatus_Success;
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xE02A             B.N      ??CAN_OperatingModeRequest_4
    899              }
    900            }
    901            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
   \                     ??CAN_OperatingModeRequest_0: (+1)
   \   0000003A   0x2A01             CMP      R2,#+1
   \   0000003C   0xD111             BNE.N    ??CAN_OperatingModeRequest_5
    902            {
    903              /* Request leave initialisation and sleep mode  and enter Normal mode */
    904              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x0892             LSRS     R2,R2,#+2
   \   00000042   0x0092             LSLS     R2,R2,#+2
   \   00000044   0x6002             STR      R2,[R0, #+0]
   \   00000046   0xE000             B.N      ??CAN_OperatingModeRequest_6
    905          
    906              /* Wait the acknowledge */
    907              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    908              {
    909                timeout--;
   \                     ??CAN_OperatingModeRequest_7: (+1)
   \   00000048   0x1E5B             SUBS     R3,R3,#+1
    910              }
   \                     ??CAN_OperatingModeRequest_6: (+1)
   \   0000004A   0x6842             LDR      R2,[R0, #+4]
   \   0000004C   0xF012 0x0F03      TST      R2,#0x3
   \   00000050   0xD001             BEQ.N    ??CAN_OperatingModeRequest_8
   \   00000052   0x2B00             CMP      R3,#+0
   \   00000054   0xD1F8             BNE.N    ??CAN_OperatingModeRequest_7
    911              if ((CANx->MSR & CAN_MODE_MASK) != 0)
   \                     ??CAN_OperatingModeRequest_8: (+1)
   \   00000056   0x6840             LDR      R0,[R0, #+4]
   \   00000058   0xF010 0x0F03      TST      R0,#0x3
   \   0000005C   0xD118             BNE.N    ??CAN_OperatingModeRequest_4
    912              {
    913                status = CAN_ModeStatus_Failed;
    914              }
    915              else
    916              {
    917                status = CAN_ModeStatus_Success;
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE016             B.N      ??CAN_OperatingModeRequest_4
    918              }
    919            }
    920            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
   \                     ??CAN_OperatingModeRequest_5: (+1)
   \   00000062   0x2A02             CMP      R2,#+2
   \   00000064   0xD114             BNE.N    ??CAN_OperatingModeRequest_4
    921            {
    922              /* Request Sleep mode */
    923              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000066   0x6802             LDR      R2,[R0, #+0]
   \   00000068   0x0852             LSRS     R2,R2,#+1
   \   0000006A   0x0052             LSLS     R2,R2,#+1
   \   0000006C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000070   0x6002             STR      R2,[R0, #+0]
   \   00000072   0xE000             B.N      ??CAN_OperatingModeRequest_9
    924          
    925              /* Wait the acknowledge */
    926              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    927              {
    928                timeout--;
   \                     ??CAN_OperatingModeRequest_10: (+1)
   \   00000074   0x1E5B             SUBS     R3,R3,#+1
    929              }
   \                     ??CAN_OperatingModeRequest_9: (+1)
   \   00000076   0x6842             LDR      R2,[R0, #+4]
   \   00000078   0xF002 0x0203      AND      R2,R2,#0x3
   \   0000007C   0x2A02             CMP      R2,#+2
   \   0000007E   0xD001             BEQ.N    ??CAN_OperatingModeRequest_11
   \   00000080   0x2B00             CMP      R3,#+0
   \   00000082   0xD1F7             BNE.N    ??CAN_OperatingModeRequest_10
    930              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
   \                     ??CAN_OperatingModeRequest_11: (+1)
   \   00000084   0x6840             LDR      R0,[R0, #+4]
   \   00000086   0xF000 0x0003      AND      R0,R0,#0x3
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xD100             BNE.N    ??CAN_OperatingModeRequest_4
    931              {
    932                status = CAN_ModeStatus_Failed;
    933              }
    934              else
    935              {
    936                status = CAN_ModeStatus_Success;
   \   0000008E   0x2101             MOVS     R1,#+1
    937              }
    938            }
    939            else
    940            {
    941              status = CAN_ModeStatus_Failed;
    942            }
    943          
    944            return  (uint8_t) status;
   \                     ??CAN_OperatingModeRequest_4: (+1)
   \   00000090   0x4608             MOV      R0,R1
   \   00000092   0xBC10             POP      {R4}
   \   00000094   0x4770             BX       LR               ;; return
    945          }
    946          
    947          /**
    948            * @brief  Enters the Sleep (low power) mode.
    949            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    950            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    951            */

   \                                 In section .text, align 2, keep-with-next
    952          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    953          {
    954            uint8_t sleepstatus = CAN_Sleep_Failed;
   \                     CAN_Sleep: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    955            
    956            /* Check the parameters */
    957            assert_param(IS_CAN_ALL_PERIPH(CANx));
    958              
    959            /* Request Sleep mode */
    960             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    961             
    962            /* Sleep mode status */
    963            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD100             BNE.N    ??CAN_Sleep_0
    964            {
    965              /* Sleep mode not entered */
    966              sleepstatus =  CAN_Sleep_Ok;
   \   00000018   0x2101             MOVS     R1,#+1
    967            }
    968            /* return sleep mode status */
    969             return (uint8_t)sleepstatus;
   \                     ??CAN_Sleep_0: (+1)
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    970          }
    971          
    972          /**
    973            * @brief  Wakes up the CAN peripheral from sleep mode .
    974            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    975            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    976            */

   \                                 In section .text, align 2, keep-with-next
    977          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    978          {
    979            uint32_t wait_slak = SLAK_TIMEOUT;
   \                     CAN_WakeUp: (+1)
   \   00000000   0xF64F 0x72FF      MOVW     R2,#+65535
    980            uint8_t wakeupstatus = CAN_WakeUp_Failed;
   \   00000004   0x2100             MOVS     R1,#+0
    981            
    982            /* Check the parameters */
    983            assert_param(IS_CAN_ALL_PERIPH(CANx));
    984              
    985            /* Wake up request */
    986            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000000C   0x6003             STR      R3,[R0, #+0]
   \   0000000E   0xE000             B.N      ??CAN_WakeUp_0
    987              
    988            /* Sleep mode status */
    989            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    990            {
    991             wait_slak--;
   \                     ??CAN_WakeUp_1: (+1)
   \   00000010   0x1E52             SUBS     R2,R2,#+1
    992            }
   \                     ??CAN_WakeUp_0: (+1)
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x079B             LSLS     R3,R3,#+30
   \   00000016   0xD501             BPL.N    ??CAN_WakeUp_2
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD1F9             BNE.N    ??CAN_WakeUp_1
    993            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_2: (+1)
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x0780             LSLS     R0,R0,#+30
   \   00000020   0xD400             BMI.N    ??CAN_WakeUp_3
    994            {
    995             /* wake up done : Sleep mode exited */
    996              wakeupstatus = CAN_WakeUp_Ok;
   \   00000022   0x2101             MOVS     R1,#+1
    997            }
    998            /* return wakeup status */
    999            return (uint8_t)wakeupstatus;
   \                     ??CAN_WakeUp_3: (+1)
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0x4770             BX       LR               ;; return
   1000          }
   1001          /**
   1002            * @}
   1003            */
   1004          
   1005          
   1006          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1007           *  @brief    CAN Bus Error management functions 
   1008           *
   1009          @verbatim    
   1010           ===============================================================================
   1011                          ##### CAN Bus Error management functions #####
   1012           ===============================================================================  
   1013              [..] This section provides functions allowing to 
   1014                (+) Return the CANx's last error code (LEC)
   1015                (+) Return the CANx Receive Error Counter (REC)
   1016                (+) Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1017             
   1018                -@- If TEC is greater than 255, The CAN is in bus-off state.
   1019                -@- if REC or TEC are greater than 96, an Error warning flag occurs.
   1020                -@- if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1021                                  
   1022          @endverbatim
   1023            * @{
   1024            */
   1025            
   1026          /**
   1027            * @brief  Returns the CANx's last error code (LEC).
   1028            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1029            * @retval Error code: 
   1030            *          - CAN_ERRORCODE_NoErr: No Error  
   1031            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1032            *          - CAN_ERRORCODE_FormErr: Form Error
   1033            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1034            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1035            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1036            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1037            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1038            */

   \                                 In section .text, align 2, keep-with-next
   1039          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1040          {
   1041            uint8_t errorcode=0;
   1042            
   1043            /* Check the parameters */
   1044            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1045            
   1046            /* Get the error code*/
   1047            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   \                     CAN_GetLastErrorCode: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0xF000 0x0070      AND      R0,R0,#0x70
   1048            
   1049            /* Return the error code*/
   1050            return errorcode;
   \   00000006   0x4770             BX       LR               ;; return
   1051          }
   1052          
   1053          /**
   1054            * @brief  Returns the CANx Receive Error Counter (REC).
   1055            * @note   In case of an error during reception, this counter is incremented 
   1056            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1057            *         standard. After every successful reception, the counter is 
   1058            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1059            *         When the counter value exceeds 127, the CAN controller enters the 
   1060            *         error passive state.  
   1061            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.  
   1062            * @retval CAN Receive Error Counter. 
   1063            */

   \                                 In section .text, align 2, keep-with-next
   1064          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1065          {
   1066            uint8_t counter=0;
   1067            
   1068            /* Check the parameters */
   1069            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1070            
   1071            /* Get the Receive Error Counter*/
   1072            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   \                     CAN_GetReceiveErrorCounter: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x0E00             LSRS     R0,R0,#+24
   1073            
   1074            /* Return the Receive Error Counter*/
   1075            return counter;
   \   00000004   0x4770             BX       LR               ;; return
   1076          }
   1077          
   1078          
   1079          /**
   1080            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1081            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1082            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1083            */

   \                                 In section .text, align 2, keep-with-next
   1084          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1085          {
   1086            uint8_t counter=0;
   1087            
   1088            /* Check the parameters */
   1089            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1090            
   1091            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1092            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   \                     CAN_GetLSBTransmitErrorCounter: (+1)
   \   00000000   0x6980             LDR      R0,[R0, #+24]
   \   00000002   0x0C00             LSRS     R0,R0,#+16
   1093            
   1094            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1095            return counter;
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x4770             BX       LR               ;; return
   1096          }
   1097          /**
   1098            * @}
   1099            */
   1100          
   1101          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1102           *  @brief   Interrupts and flags management functions
   1103           *
   1104          @verbatim   
   1105           ===============================================================================
   1106                        ##### Interrupts and flags management functions #####
   1107           ===============================================================================  
   1108          
   1109               [..] This section provides functions allowing to configure the CAN Interrupts 
   1110                    and to get the status and clear flags and Interrupts pending bits.
   1111            
   1112                    The CAN provides 14 Interrupts sources and 15 Flags:
   1113          
   1114             
   1115            *** Flags ***
   1116            =============
   1117              [..] The 15 flags can be divided on 4 groups: 
   1118          
   1119                (+) Transmit Flags
   1120                  (++) CAN_FLAG_RQCP0, 
   1121                  (++) CAN_FLAG_RQCP1, 
   1122                  (++) CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1123                                         Set when the last request (transmit or abort)
   1124                                         has been performed. 
   1125          
   1126                (+) Receive Flags
   1127          
   1128          
   1129                  (++) CAN_FLAG_FMP0,
   1130                  (++) CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1131                                         set to signal that messages are pending in the receive 
   1132                                         FIFO.
   1133                                         These Flags are cleared only by hardware. 
   1134          
   1135                  (++) CAN_FLAG_FF0,
   1136                  (++) CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1137                                         set when three messages are stored in the selected 
   1138                                         FIFO.                        
   1139          
   1140                  (++) CAN_FLAG_FOV0              
   1141                  (++) CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1142                                         set when a new message has been received and passed 
   1143                                         the filter while the FIFO was full.         
   1144          
   1145                (+) Operating Mode Flags
   1146          
   1147                  (++) CAN_FLAG_WKU    : Wake up Flag
   1148                                         set to signal that a SOF bit has been detected while 
   1149                                         the CAN hardware was in Sleep mode. 
   1150                  
   1151                  (++) CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1152                                         Set to signal that the CAN has entered Sleep Mode. 
   1153              
   1154                (+) Error Flags
   1155          
   1156                  (++) CAN_FLAG_EWG    : Error Warning Flag
   1157                                         Set when the warning limit has been reached (Receive 
   1158                                         Error Counter or Transmit Error Counter greater than 96). 
   1159                                         This Flag is cleared only by hardware.
   1160                                      
   1161                  (++) CAN_FLAG_EPV    : Error Passive Flag
   1162                                         Set when the Error Passive limit has been reached 
   1163                                         (Receive Error Counter or Transmit Error Counter 
   1164                                         greater than 127).
   1165                                         This Flag is cleared only by hardware.
   1166                                       
   1167                  (++) CAN_FLAG_BOF    : Bus-Off Flag
   1168                                         set when CAN enters the bus-off state. The bus-off 
   1169                                         state is entered on TEC overflow, greater than 255.
   1170                                         This Flag is cleared only by hardware.
   1171                                             
   1172                  (++) CAN_FLAG_LEC    : Last error code Flag
   1173                                         set If a message has been transferred (reception or
   1174                                         transmission) with error, and the error code is hold.              
   1175                                     
   1176            *** Interrupts ***
   1177            ==================
   1178              [..] The 14 interrupts can be divided on 4 groups: 
   1179            
   1180                (+) Transmit interrupt
   1181            
   1182                  (++) CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1183                                       if enabled, this interrupt source is pending when 
   1184                                       no transmit request are pending for Tx mailboxes.      
   1185          
   1186                (+) Receive Interrupts
   1187                   
   1188                  (++) CAN_IT_FMP0,
   1189                  (++) CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1190                                         if enabled, these interrupt sources are pending 
   1191                                         when messages are pending in the receive FIFO.
   1192                                         The corresponding interrupt pending bits are cleared 
   1193                                         only by hardware.
   1194                          
   1195                  (++) CAN_IT_FF0,              
   1196                  (++) CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1197                                         if enabled, these interrupt sources are pending 
   1198                                         when three messages are stored in the selected FIFO.
   1199                  
   1200                  (++) CAN_IT_FOV0,        
   1201                  (++) CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1202                                         if enabled, these interrupt sources are pending 
   1203                                         when a new message has been received and passed 
   1204                                         the filter while the FIFO was full.
   1205          
   1206                (+) Operating Mode Interrupts
   1207                   
   1208                  (++) CAN_IT_WKU     :  Wake-up Interrupt
   1209                                         if enabled, this interrupt source is pending when 
   1210                                         a SOF bit has been detected while the CAN hardware 
   1211                                         was in Sleep mode.
   1212                                            
   1213                  (++) CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1214                                         if enabled, this interrupt source is pending when 
   1215                                         the CAN has entered Sleep Mode.       
   1216          
   1217                (+) Error Interrupts 
   1218                  
   1219                  (++) CAN_IT_EWG     :  Error warning Interrupt 
   1220                                         if enabled, this interrupt source is pending when
   1221                                         the warning limit has been reached (Receive Error 
   1222                                         Counter or Transmit Error Counter=96). 
   1223                                         
   1224                  (++) CAN_IT_EPV     :  Error passive Interrupt        
   1225                                         if enabled, this interrupt source is pending when
   1226                                         the Error Passive limit has been reached (Receive 
   1227                                         Error Counter or Transmit Error Counter>127).
   1228                                    
   1229                  (++) CAN_IT_BOF     :  Bus-off Interrupt
   1230                                         if enabled, this interrupt source is pending when
   1231                                         CAN enters the bus-off state. The bus-off state is 
   1232                                         entered on TEC overflow, greater than 255.
   1233                                         This Flag is cleared only by hardware.
   1234                                            
   1235                  (++) CAN_IT_LEC     :  Last error code Interrupt        
   1236                                         if enabled, this interrupt source is pending  when
   1237                                         a message has been transferred (reception or
   1238                                         transmission) with error, and the error code is hold.
   1239                                    
   1240                  (++) CAN_IT_ERR     :  Error Interrupt
   1241                                         if enabled, this interrupt source is pending when 
   1242                                         an error condition is pending.      
   1243                                
   1244              [..] Managing the CAN controller events :
   1245           
   1246                   The user should identify which mode will be used in his application to 
   1247                   manage the CAN controller events: Polling mode or Interrupt mode.
   1248            
   1249                (#) In the Polling Mode it is advised to use the following functions:
   1250                  (++) CAN_GetFlagStatus() : to check if flags events occur. 
   1251                  (++) CAN_ClearFlag()     : to clear the flags events.
   1252            
   1253          
   1254            
   1255                (#) In the Interrupt Mode it is advised to use the following functions:
   1256                  (++) CAN_ITConfig()       : to enable or disable the interrupt source.
   1257                  (++) CAN_GetITStatus()    : to check if Interrupt occurs.
   1258                  (++) CAN_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1259                      (corresponding Flag).
   1260                  -@@-  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1261                       pending bits since there are cleared only by hardware. 
   1262            
   1263          @endverbatim
   1264            * @{
   1265            */ 
   1266          /**
   1267            * @brief  Enables or disables the specified CANx interrupts.
   1268            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1269            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1270            *          This parameter can be: 
   1271            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1272            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1273            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1274            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1275            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1276            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1277            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1278            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1279            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1280            *            @arg CAN_IT_EWG: Error warning Interrupt
   1281            *            @arg CAN_IT_EPV: Error passive Interrupt
   1282            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1283            *            @arg CAN_IT_LEC: Last error code Interrupt
   1284            *            @arg CAN_IT_ERR: Error Interrupt
   1285            * @param  NewState: new state of the CAN interrupts.
   1286            *          This parameter can be: ENABLE or DISABLE.
   1287            * @retval None
   1288            */

   \                                 In section .text, align 2, keep-with-next
   1289          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1290          {
   1291            /* Check the parameters */
   1292            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1293            assert_param(IS_CAN_IT(CAN_IT));
   1294            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1295          
   1296            if (NewState != DISABLE)
   \                     CAN_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6942             LDR      R2,[R0, #+20]
   \   00000004   0xD002             BEQ.N    ??CAN_ITConfig_0
   1297            {
   1298              /* Enable the selected CANx interrupt */
   1299              CANx->IER |= CAN_IT;
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6141             STR      R1,[R0, #+20]
   \   0000000A   0x4770             BX       LR
   1300            }
   1301            else
   1302            {
   1303              /* Disable the selected CANx interrupt */
   1304              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0: (+1)
   \   0000000C   0xEA22 0x0101      BIC      R1,R2,R1
   \   00000010   0x6141             STR      R1,[R0, #+20]
   1305            }
   1306          }
   \   00000012   0x4770             BX       LR               ;; return
   1307          /**
   1308            * @brief  Checks whether the specified CAN flag is set or not.
   1309            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1310            * @param  CAN_FLAG: specifies the flag to check.
   1311            *          This parameter can be one of the following values:
   1312            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1313            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1314            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1315            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1316            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1317            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1318            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1319            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1320            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1321            *            @arg CAN_FLAG_WKU: Wake up Flag
   1322            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1323            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1324            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1325            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1326            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1327            * @retval The new state of CAN_FLAG (SET or RESET).
   1328            */

   \                                 In section .text, align 2, keep-with-next
   1329          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1330          {
   \                     CAN_GetFlagStatus: (+1)
   \   00000000   0x4602             MOV      R2,R0
   1331            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   1332            
   1333            /* Check the parameters */
   1334            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1335            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1336            
   1337          
   1338            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   \   00000004   0xF411 0x0F70      TST      R1,#0xF00000
   \   00000008   0xD005             BEQ.N    ??CAN_GetFlagStatus_0
   1339            { 
   1340              /* Check the status of the specified CAN flag */
   1341              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000000A   0x6992             LDR      R2,[R2, #+24]
   \   0000000C   0x4011             ANDS     R1,R1,R2
   \   0000000E   0x0309             LSLS     R1,R1,#+12
   \   00000010   0xD01E             BEQ.N    ??CAN_GetFlagStatus_1
   1342              { 
   1343                /* CAN_FLAG is set */
   1344                bitstatus = SET;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4770             BX       LR
   1345              }
   1346              else
   1347              { 
   1348                /* CAN_FLAG is reset */
   1349                bitstatus = RESET;
   1350              }
   1351            }
   1352            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_0: (+1)
   \   00000016   0x01CB             LSLS     R3,R1,#+7
   \   00000018   0xD505             BPL.N    ??CAN_GetFlagStatus_2
   1353            { 
   1354              /* Check the status of the specified CAN flag */
   1355              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000001A   0x6852             LDR      R2,[R2, #+4]
   \   0000001C   0x4011             ANDS     R1,R1,R2
   \   0000001E   0x0309             LSLS     R1,R1,#+12
   \   00000020   0xD016             BEQ.N    ??CAN_GetFlagStatus_1
   1356              { 
   1357                /* CAN_FLAG is set */
   1358                bitstatus = SET;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x4770             BX       LR
   1359              }
   1360              else
   1361              { 
   1362                /* CAN_FLAG is reset */
   1363                bitstatus = RESET;
   1364              }
   1365            }
   1366            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_2: (+1)
   \   00000026   0x010B             LSLS     R3,R1,#+4
   \   00000028   0xD505             BPL.N    ??CAN_GetFlagStatus_3
   1367            { 
   1368              /* Check the status of the specified CAN flag */
   1369              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000002A   0x6892             LDR      R2,[R2, #+8]
   \   0000002C   0x4011             ANDS     R1,R1,R2
   \   0000002E   0x0309             LSLS     R1,R1,#+12
   \   00000030   0xD00E             BEQ.N    ??CAN_GetFlagStatus_1
   1370              { 
   1371                /* CAN_FLAG is set */
   1372                bitstatus = SET;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x4770             BX       LR
   1373              }
   1374              else
   1375              { 
   1376                /* CAN_FLAG is reset */
   1377                bitstatus = RESET;
   1378              }
   1379            }
   1380            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_3: (+1)
   \   00000036   0x018B             LSLS     R3,R1,#+6
   \   00000038   0xD505             BPL.N    ??CAN_GetFlagStatus_4
   1381            { 
   1382              /* Check the status of the specified CAN flag */
   1383              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \   0000003A   0x68D2             LDR      R2,[R2, #+12]
   \   0000003C   0x4011             ANDS     R1,R1,R2
   \   0000003E   0x0309             LSLS     R1,R1,#+12
   \   00000040   0xD006             BEQ.N    ??CAN_GetFlagStatus_1
   1384              { 
   1385                /* CAN_FLAG is set */
   1386                bitstatus = SET;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x4770             BX       LR
   1387              }
   1388              else
   1389              { 
   1390                /* CAN_FLAG is reset */
   1391                bitstatus = RESET;
   1392              }
   1393            }
   1394            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1395            { 
   1396              /* Check the status of the specified CAN flag */
   1397              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_4: (+1)
   \   00000046   0x6912             LDR      R2,[R2, #+16]
   \   00000048   0x4011             ANDS     R1,R1,R2
   \   0000004A   0x0309             LSLS     R1,R1,#+12
   \   0000004C   0xD000             BEQ.N    ??CAN_GetFlagStatus_1
   1398              { 
   1399                /* CAN_FLAG is set */
   1400                bitstatus = SET;
   \   0000004E   0x2001             MOVS     R0,#+1
   1401              }
   1402              else
   1403              { 
   1404                /* CAN_FLAG is reset */
   1405                bitstatus = RESET;
   1406              }
   1407            }
   1408            /* Return the CAN_FLAG status */
   1409            return  bitstatus;
   \                     ??CAN_GetFlagStatus_1: (+1)
   \   00000050   0x4770             BX       LR               ;; return
   1410          }
   1411          
   1412          /**
   1413            * @brief  Clears the CAN's pending flags.
   1414            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1415            * @param  CAN_FLAG: specifies the flag to clear.
   1416            *          This parameter can be one of the following values:
   1417            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1418            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1419            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1420            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1421            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1422            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1423            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1424            *            @arg CAN_FLAG_WKU: Wake up Flag
   1425            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1426            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1427            * @retval None
   1428            */

   \                                 In section .text, align 2, keep-with-next
   1429          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1430          {
   1431            uint32_t flagtmp=0;
   1432            /* Check the parameters */
   1433            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1434            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1435            
   1436            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   \                     CAN_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable6_7  ;; 0x30f00070
   \   00000002   0x4291             CMP      R1,R2
   \   00000004   0xD102             BNE.N    ??CAN_ClearFlag_0
   1437            {
   1438              /* Clear the selected CAN flags */
   1439              CANx->ESR = (uint32_t)RESET;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6181             STR      R1,[R0, #+24]
   \   0000000A   0x4770             BX       LR
   1440            }
   1441            else /* MSR or TSR or RF0R or RF1R */
   1442            {
   1443              flagtmp = CAN_FLAG & 0x000FFFFF;
   \                     ??CAN_ClearFlag_0: (+1)
   \   0000000C   0xF3C1 0x0213      UBFX     R2,R1,#+0,#+20
   1444          
   1445              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   \   00000010   0x018B             LSLS     R3,R1,#+6
   \   00000012   0xD501             BPL.N    ??CAN_ClearFlag_1
   1446              {
   1447                /* Receive Flags */
   1448                CANx->RF0R = (uint32_t)(flagtmp);
   \   00000014   0x60C2             STR      R2,[R0, #+12]
   \   00000016   0x4770             BX       LR
   1449              }
   1450              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_1: (+1)
   \   00000018   0x014B             LSLS     R3,R1,#+5
   \   0000001A   0xD501             BPL.N    ??CAN_ClearFlag_2
   1451              {
   1452                /* Receive Flags */
   1453                CANx->RF1R = (uint32_t)(flagtmp);
   \   0000001C   0x6102             STR      R2,[R0, #+16]
   \   0000001E   0x4770             BX       LR
   1454              }
   1455              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_2: (+1)
   \   00000020   0x0109             LSLS     R1,R1,#+4
   \   00000022   0xD501             BPL.N    ??CAN_ClearFlag_3
   1456              {
   1457                /* Transmit Flags */
   1458                CANx->TSR = (uint32_t)(flagtmp);
   \   00000024   0x6082             STR      R2,[R0, #+8]
   \   00000026   0x4770             BX       LR
   1459              }
   1460              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1461              {
   1462                /* Operating mode Flags */
   1463                CANx->MSR = (uint32_t)(flagtmp);
   \                     ??CAN_ClearFlag_3: (+1)
   \   00000028   0x6042             STR      R2,[R0, #+4]
   1464              }
   1465            }
   1466          }
   \   0000002A   0x4770             BX       LR               ;; return
   1467          
   1468          /**
   1469            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1470            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1471            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1472            *          This parameter can be one of the following values:
   1473            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1474            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1475            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1476            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1477            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1478            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1479            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1480            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1481            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1482            *            @arg CAN_IT_EWG: Error warning Interrupt
   1483            *            @arg CAN_IT_EPV: Error passive Interrupt
   1484            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1485            *            @arg CAN_IT_LEC: Last error code Interrupt
   1486            *            @arg CAN_IT_ERR: Error Interrupt
   1487            * @retval The current state of CAN_IT (SET or RESET).
   1488            */

   \                                 In section .text, align 2, keep-with-next
   1489          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1490          {
   \                     CAN_GetITStatus: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1491            ITStatus itstatus = RESET;
   \   00000002   0x2200             MOVS     R2,#+0
   1492            /* Check the parameters */
   1493            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1494            assert_param(IS_CAN_IT(CAN_IT));
   1495            
   1496            /* check the interrupt enable bit */
   1497           if((CANx->IER & CAN_IT) != RESET)
   \   00000004   0x6943             LDR      R3,[R0, #+20]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD076             BEQ.N    ??CAN_GetITStatus_0
   1498           {
   1499             /* in case the Interrupt is enabled, .... */
   1500              switch (CAN_IT)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD021             BEQ.N    ??CAN_GetITStatus_1
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD025             BEQ.N    ??CAN_GetITStatus_2
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD029             BEQ.N    ??CAN_GetITStatus_3
   \   00000016   0x2908             CMP      R1,#+8
   \   00000018   0xD02D             BEQ.N    ??CAN_GetITStatus_4
   \   0000001A   0x2910             CMP      R1,#+16
   \   0000001C   0xD031             BEQ.N    ??CAN_GetITStatus_5
   \   0000001E   0x2920             CMP      R1,#+32
   \   00000020   0xD035             BEQ.N    ??CAN_GetITStatus_6
   \   00000022   0x2940             CMP      R1,#+64
   \   00000024   0xD039             BEQ.N    ??CAN_GetITStatus_7
   \   00000026   0xF5B1 0x7F80      CMP      R1,#+256
   \   0000002A   0xD048             BEQ.N    ??CAN_GetITStatus_8
   \   0000002C   0xF5B1 0x7F00      CMP      R1,#+512
   \   00000030   0xD04B             BEQ.N    ??CAN_GetITStatus_9
   \   00000032   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000036   0xD04E             BEQ.N    ??CAN_GetITStatus_10
   \   00000038   0xF5B1 0x6F00      CMP      R1,#+2048
   \   0000003C   0xD051             BEQ.N    ??CAN_GetITStatus_11
   \   0000003E   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000042   0xD054             BEQ.N    ??CAN_GetITStatus_12
   \   00000044   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000048   0xD02D             BEQ.N    ??CAN_GetITStatus_13
   \   0000004A   0xF5B1 0x3F00      CMP      R1,#+131072
   \   0000004E   0xD030             BEQ.N    ??CAN_GetITStatus_14
   \   00000050   0xE052             B.N      ??CAN_GetITStatus_0
   1501              {
   1502                case CAN_IT_TME:
   1503                  /* Check CAN_TSR_RQCPx bits */
   1504                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   \                     ??CAN_GetITStatus_1: (+1)
   \   00000052   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10101
   \   00000054   0x6880             LDR      R0,[R0, #+8]
   \   00000056   0x.... 0x....      BL       CheckITStatus
   \   0000005A   0x4602             MOV      R2,R0
   1505                  break;
   \   0000005C   0xE04C             B.N      ??CAN_GetITStatus_0
   1506                case CAN_IT_FMP0:
   1507                  /* Check CAN_RF0R_FMP0 bit */
   1508                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   \                     ??CAN_GetITStatus_2: (+1)
   \   0000005E   0x2103             MOVS     R1,#+3
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0x.... 0x....      BL       CheckITStatus
   \   00000066   0x4602             MOV      R2,R0
   1509                  break;
   \   00000068   0xE046             B.N      ??CAN_GetITStatus_0
   1510                case CAN_IT_FF0:
   1511                  /* Check CAN_RF0R_FULL0 bit */
   1512                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   \                     ??CAN_GetITStatus_3: (+1)
   \   0000006A   0x2108             MOVS     R1,#+8
   \   0000006C   0x68C0             LDR      R0,[R0, #+12]
   \   0000006E   0x.... 0x....      BL       CheckITStatus
   \   00000072   0x4602             MOV      R2,R0
   1513                  break;
   \   00000074   0xE040             B.N      ??CAN_GetITStatus_0
   1514                case CAN_IT_FOV0:
   1515                  /* Check CAN_RF0R_FOVR0 bit */
   1516                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   \                     ??CAN_GetITStatus_4: (+1)
   \   00000076   0x2110             MOVS     R1,#+16
   \   00000078   0x68C0             LDR      R0,[R0, #+12]
   \   0000007A   0x.... 0x....      BL       CheckITStatus
   \   0000007E   0x4602             MOV      R2,R0
   1517                  break;
   \   00000080   0xE03A             B.N      ??CAN_GetITStatus_0
   1518                case CAN_IT_FMP1:
   1519                  /* Check CAN_RF1R_FMP1 bit */
   1520                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   \                     ??CAN_GetITStatus_5: (+1)
   \   00000082   0x2103             MOVS     R1,#+3
   \   00000084   0x6900             LDR      R0,[R0, #+16]
   \   00000086   0x.... 0x....      BL       CheckITStatus
   \   0000008A   0x4602             MOV      R2,R0
   1521                  break;
   \   0000008C   0xE034             B.N      ??CAN_GetITStatus_0
   1522                case CAN_IT_FF1:
   1523                  /* Check CAN_RF1R_FULL1 bit */
   1524                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   \                     ??CAN_GetITStatus_6: (+1)
   \   0000008E   0x2108             MOVS     R1,#+8
   \   00000090   0x6900             LDR      R0,[R0, #+16]
   \   00000092   0x.... 0x....      BL       CheckITStatus
   \   00000096   0x4602             MOV      R2,R0
   1525                  break;
   \   00000098   0xE02E             B.N      ??CAN_GetITStatus_0
   1526                case CAN_IT_FOV1:
   1527                  /* Check CAN_RF1R_FOVR1 bit */
   1528                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   \                     ??CAN_GetITStatus_7: (+1)
   \   0000009A   0x2110             MOVS     R1,#+16
   \   0000009C   0x6900             LDR      R0,[R0, #+16]
   \   0000009E   0x.... 0x....      BL       CheckITStatus
   \   000000A2   0x4602             MOV      R2,R0
   1529                  break;
   \   000000A4   0xE028             B.N      ??CAN_GetITStatus_0
   1530                case CAN_IT_WKU:
   1531                  /* Check CAN_MSR_WKUI bit */
   1532                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   \                     ??CAN_GetITStatus_13: (+1)
   \   000000A6   0x2108             MOVS     R1,#+8
   \   000000A8   0x6840             LDR      R0,[R0, #+4]
   \   000000AA   0x.... 0x....      BL       CheckITStatus
   \   000000AE   0x4602             MOV      R2,R0
   1533                  break;
   \   000000B0   0xE022             B.N      ??CAN_GetITStatus_0
   1534                case CAN_IT_SLK:
   1535                  /* Check CAN_MSR_SLAKI bit */
   1536                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   \                     ??CAN_GetITStatus_14: (+1)
   \   000000B2   0x2110             MOVS     R1,#+16
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0x.... 0x....      BL       CheckITStatus
   \   000000BA   0x4602             MOV      R2,R0
   1537                  break;
   \   000000BC   0xE01C             B.N      ??CAN_GetITStatus_0
   1538                case CAN_IT_EWG:
   1539                  /* Check CAN_ESR_EWGF bit */
   1540                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   \                     ??CAN_GetITStatus_8: (+1)
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x6980             LDR      R0,[R0, #+24]
   \   000000C2   0x.... 0x....      BL       CheckITStatus
   \   000000C6   0x4602             MOV      R2,R0
   1541                  break;
   \   000000C8   0xE016             B.N      ??CAN_GetITStatus_0
   1542                case CAN_IT_EPV:
   1543                  /* Check CAN_ESR_EPVF bit */
   1544                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   \                     ??CAN_GetITStatus_9: (+1)
   \   000000CA   0x2102             MOVS     R1,#+2
   \   000000CC   0x6980             LDR      R0,[R0, #+24]
   \   000000CE   0x.... 0x....      BL       CheckITStatus
   \   000000D2   0x4602             MOV      R2,R0
   1545                  break;
   \   000000D4   0xE010             B.N      ??CAN_GetITStatus_0
   1546                case CAN_IT_BOF:
   1547                  /* Check CAN_ESR_BOFF bit */
   1548                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   \                     ??CAN_GetITStatus_10: (+1)
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0x6980             LDR      R0,[R0, #+24]
   \   000000DA   0x.... 0x....      BL       CheckITStatus
   \   000000DE   0x4602             MOV      R2,R0
   1549                  break;
   \   000000E0   0xE00A             B.N      ??CAN_GetITStatus_0
   1550                case CAN_IT_LEC:
   1551                  /* Check CAN_ESR_LEC bit */
   1552                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   \                     ??CAN_GetITStatus_11: (+1)
   \   000000E2   0x2170             MOVS     R1,#+112
   \   000000E4   0x6980             LDR      R0,[R0, #+24]
   \   000000E6   0x.... 0x....      BL       CheckITStatus
   \   000000EA   0x4602             MOV      R2,R0
   1553                  break;
   \   000000EC   0xE004             B.N      ??CAN_GetITStatus_0
   1554                case CAN_IT_ERR:
   1555                  /* Check CAN_MSR_ERRI bit */ 
   1556                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   \                     ??CAN_GetITStatus_12: (+1)
   \   000000EE   0x2104             MOVS     R1,#+4
   \   000000F0   0x6840             LDR      R0,[R0, #+4]
   \   000000F2   0x.... 0x....      BL       CheckITStatus
   \   000000F6   0x4602             MOV      R2,R0
   1557                  break;
   1558                default:
   1559                  /* in case of error, return RESET */
   1560                  itstatus = RESET;
   1561                  break;
   1562              }
   1563            }
   1564            else
   1565            {
   1566             /* in case the Interrupt is not enabled, return RESET */
   1567              itstatus  = RESET;
   1568            }
   1569            
   1570            /* Return the CAN_IT status */
   1571            return  itstatus;
   \                     ??CAN_GetITStatus_0: (+1)
   \   000000F8   0x4610             MOV      R0,R2
   \   000000FA   0xBD02             POP      {R1,PC}          ;; return
   1572          }
   1573          
   1574          /**
   1575            * @brief  Clears the CANx's interrupt pending bits.
   1576            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1577            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1578            *          This parameter can be one of the following values:
   1579            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1580            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1581            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1582            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1583            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1584            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1585            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1586            *            @arg CAN_IT_EWG: Error warning Interrupt
   1587            *            @arg CAN_IT_EPV: Error passive Interrupt
   1588            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1589            *            @arg CAN_IT_LEC: Last error code Interrupt
   1590            *            @arg CAN_IT_ERR: Error Interrupt 
   1591            * @retval None
   1592            */

   \                                 In section .text, align 2, keep-with-next
   1593          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1594          {
   1595            /* Check the parameters */
   1596            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1597            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1598          
   1599            switch (CAN_IT)
   \                     CAN_ClearITPendingBit: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD01D             BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xD01E             BEQ.N    ??CAN_ClearITPendingBit_1
   \   00000008   0x2908             CMP      R1,#+8
   \   0000000A   0xD01F             BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000C   0x2920             CMP      R1,#+32
   \   0000000E   0xD020             BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000010   0x2940             CMP      R1,#+64
   \   00000012   0xD021             BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000014   0xF5B1 0x7F80      CMP      R1,#+256
   \   00000018   0xD027             BEQ.N    ??CAN_ClearITPendingBit_5
   \   0000001A   0xF5B1 0x7F00      CMP      R1,#+512
   \   0000001E   0xD024             BEQ.N    ??CAN_ClearITPendingBit_5
   \   00000020   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000024   0xD021             BEQ.N    ??CAN_ClearITPendingBit_5
   \   00000026   0xF5B1 0x6F00      CMP      R1,#+2048
   \   0000002A   0xD021             BEQ.N    ??CAN_ClearITPendingBit_6
   \   0000002C   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000030   0xD01E             BEQ.N    ??CAN_ClearITPendingBit_6
   \   00000032   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000036   0xD012             BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000038   0xF5B1 0x3F00      CMP      R1,#+131072
   \   0000003C   0xD012             BEQ.N    ??CAN_ClearITPendingBit_8
   \   0000003E   0x4770             BX       LR
   1600            {
   1601              case CAN_IT_TME:
   1602                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1603                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   \                     ??CAN_ClearITPendingBit_0: (+1)
   \   00000040   0x....             LDR.N    R1,??DataTable6_8  ;; 0x10101
   \   00000042   0x6081             STR      R1,[R0, #+8]
   1604                break;
   \   00000044   0x4770             BX       LR
   1605              case CAN_IT_FF0:
   1606                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1607                CANx->RF0R = CAN_RF0R_FULL0; 
   \                     ??CAN_ClearITPendingBit_1: (+1)
   \   00000046   0x2108             MOVS     R1,#+8
   \   00000048   0x60C1             STR      R1,[R0, #+12]
   1608                break;
   \   0000004A   0x4770             BX       LR
   1609              case CAN_IT_FOV0:
   1610                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1611                CANx->RF0R = CAN_RF0R_FOVR0; 
   \                     ??CAN_ClearITPendingBit_2: (+1)
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0x60C1             STR      R1,[R0, #+12]
   1612                break;
   \   00000050   0x4770             BX       LR
   1613              case CAN_IT_FF1:
   1614                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1615                CANx->RF1R = CAN_RF1R_FULL1;  
   \                     ??CAN_ClearITPendingBit_3: (+1)
   \   00000052   0x2108             MOVS     R1,#+8
   \   00000054   0x6101             STR      R1,[R0, #+16]
   1616                break;
   \   00000056   0x4770             BX       LR
   1617              case CAN_IT_FOV1:
   1618                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1619                CANx->RF1R = CAN_RF1R_FOVR1; 
   \                     ??CAN_ClearITPendingBit_4: (+1)
   \   00000058   0x2110             MOVS     R1,#+16
   \   0000005A   0x6101             STR      R1,[R0, #+16]
   1620                break;
   \   0000005C   0x4770             BX       LR
   1621              case CAN_IT_WKU:
   1622                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1623                CANx->MSR = CAN_MSR_WKUI;  
   \                     ??CAN_ClearITPendingBit_7: (+1)
   \   0000005E   0x2108             MOVS     R1,#+8
   \   00000060   0x6041             STR      R1,[R0, #+4]
   1624                break;
   \   00000062   0x4770             BX       LR
   1625              case CAN_IT_SLK:
   1626                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1627                CANx->MSR = CAN_MSR_SLAKI;   
   \                     ??CAN_ClearITPendingBit_8: (+1)
   \   00000064   0x2110             MOVS     R1,#+16
   \   00000066   0x6041             STR      R1,[R0, #+4]
   1628                break;
   \   00000068   0x4770             BX       LR
   1629              case CAN_IT_EWG:
   1630                /* Clear CAN_MSR_ERRI (rc_w1) */
   1631                CANx->MSR = CAN_MSR_ERRI;
   1632                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1633                break;
   1634              case CAN_IT_EPV:
   1635                /* Clear CAN_MSR_ERRI (rc_w1) */
   1636                CANx->MSR = CAN_MSR_ERRI; 
   1637                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1638                break;
   1639              case CAN_IT_BOF:
   1640                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1641                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_5: (+1)
   \   0000006A   0x2104             MOVS     R1,#+4
   \   0000006C   0x6041             STR      R1,[R0, #+4]
   1642                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1643                 break;
   \   0000006E   0x4770             BX       LR
   1644              case CAN_IT_LEC:
   1645                /*  Clear LEC bits */
   1646                CANx->ESR = RESET; 
   1647                /* Clear CAN_MSR_ERRI (rc_w1) */
   1648                CANx->MSR = CAN_MSR_ERRI; 
   1649                break;
   1650              case CAN_IT_ERR:
   1651                /*Clear LEC bits */
   1652                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_6: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x6181             STR      R1,[R0, #+24]
   1653                /* Clear CAN_MSR_ERRI (rc_w1) */
   1654                CANx->MSR = CAN_MSR_ERRI; 
   \   00000074   0x2104             MOVS     R1,#+4
   \   00000076   0x6041             STR      R1,[R0, #+4]
   1655                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1656                 break;
   1657              default:
   1658                 break;
   1659             }
   1660          }
   \   00000078   0x4770             BX       LR               ;; return
   1661           /**
   1662            * @}
   1663            */
   1664          
   1665          /**
   1666            * @brief  Checks whether the CAN interrupt has occurred or not.
   1667            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1668            * @param  It_Bit: specifies the interrupt source bit to check.
   1669            * @retval The new state of the CAN Interrupt (SET or RESET).
   1670            */

   \                                 In section .text, align 2, keep-with-next
   1671          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1672          {
   1673            ITStatus pendingbitstatus = RESET;
   \                     CheckITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   1674            
   1675            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD000             BEQ.N    ??CheckITStatus_0
   1676            {
   1677              /* CAN_IT is set */
   1678              pendingbitstatus = SET;
   \   00000006   0x2201             MOVS     R2,#+1
   1679            }
   1680            else
   1681            {
   1682              /* CAN_IT is reset */
   1683              pendingbitstatus = RESET;
   1684            }
   1685            return pendingbitstatus;
   \                     ??CheckITStatus_0: (+1)
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0x4770             BX       LR               ;; return
   1686          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40006400         DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40006600         DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40006640         DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0xFFFFC0F1         DC32     0xffffc0f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x04000003         DC32     0x4000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x08000300         DC32     0x8000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x10030000         DC32     0x10030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x30F00070         DC32     0x30f00070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x00010101         DC32     0x10101
   1687          
   1688          /**
   1689            * @}
   1690            */
   1691          
   1692          /**
   1693            * @}
   1694            */
   1695          
   1696          /**
   1697            * @}
   1698            */
   1699          
   1700          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         0   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
      12   CAN_FilterInit
       0   CAN_GetFlagStatus
       8   CAN_GetITStatus
         8   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
       4   CAN_Init
       0   CAN_MessagePending
       4   CAN_OperatingModeRequest
       4   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
      12   CAN_Transmit
       0   CAN_TransmitStatus
       0   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
      42  CAN_CancelTransmit
      44  CAN_ClearFlag
     122  CAN_ClearITPendingBit
      22  CAN_DBGFreeze
      58  CAN_DeInit
      24  CAN_FIFORelease
     188  CAN_FilterInit
      82  CAN_GetFlagStatus
     252  CAN_GetITStatus
       8  CAN_GetLSBTransmitErrorCounter
       8  CAN_GetLastErrorCode
       6  CAN_GetReceiveErrorCounter
      20  CAN_ITConfig
     264  CAN_Init
      28  CAN_MessagePending
     150  CAN_OperatingModeRequest
     126  CAN_Receive
      40  CAN_SlaveStartBank
      30  CAN_Sleep
      32  CAN_StructInit
      76  CAN_TTComModeCmd
     174  CAN_Transmit
      90  CAN_TransmitStatus
      40  CAN_WakeUp
      12  CheckITStatus

 
 1 974 bytes in section .text
 
 1 974 bytes of CODE memory

Errors: none
Warnings: none
