###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:29
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948MPUFifoControl.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948MPUFifoControl.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\Icm20948MPUFifoControl.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\Icm20948MPUFifoControl.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948MPUFifoControl.c
      1          /*
      2          * ________________________________________________________________________________________________________
      3          * Copyright © 2014-2015 InvenSense Inc. Portions Copyright © 2014-2015 Movea. All rights reserved.
      4          * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      5          * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright and
      6          * other intellectual property rights laws.
      7          * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
      8          * and any use, reproduction, disclosure or distribution of the Software without an express license
      9          * agreement from InvenSense is strictly prohibited.
     10          * ________________________________________________________________________________________________________
     11          */
     12          
     13          #include "Icm20948.h"
     14          #include "Icm20948MPUFifoControl.h"
     15          
     16          #include "Icm20948Defs.h"
     17          #include "Icm20948DataBaseControl.h"
     18          #include "Icm20948DataConverter.h"
     19          
     20          #include "Icm20948AuxCompassAkm.h"
     21          
     22          struct inv_fifo_decoded_t fd;
     23          
     24          static void inv_decode_3_16bit_elements(short *out_data, const unsigned char *in_data);
     25          static void inv_decode_3_32bit_elements(long *out_data, const unsigned char *in_data);
     26          

   \                                 In section .text, align 2, keep-with-next
     27          int inv_icm20948_mpu_set_FIFO_RST_Diamond(struct inv_icm20948 * s, unsigned char value)
     28          {
   \                     inv_icm20948_mpu_set_FIFO_RST_Diamond: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
     29          	int result = 0;
     30          	unsigned char reg;
     31          
     32          	result |= inv_icm20948_read_mems_reg(s, REG_FIFO_RST, 1, &reg);
   \   00000008   0x466B             MOV      R3,SP
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x2168             MOVS     R1,#+104
   \   0000000E   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   00000012   0x4606             MOV      R6,R0
     33              
     34          	reg &= 0xe0;
     35          	reg |= value;
   \   00000014   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000018   0xF000 0x00E0      AND      R0,R0,#0xE0
   \   0000001C   0x4328             ORRS     R0,R5,R0
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     36          	result |= inv_icm20948_write_mems_reg(s, REG_FIFO_RST, 1, &reg);
   \   00000022   0x466B             MOV      R3,SP
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2168             MOVS     R1,#+104
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   0000002E   0x4330             ORRS     R0,R0,R6
     37              
     38          	return result;
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
     39          }
     40          

   \                                 In section .text, align 2, keep-with-next
     41          int inv_icm20948_identify_interrupt(struct inv_icm20948 * s, short *int_read)
     42          {
   \                     inv_icm20948_identify_interrupt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     43          	unsigned char int_status;
     44              int result=0 ;
     45              
     46              if(int_read)
   \   00000006   0xD001             BEQ.N    ??inv_icm20948_identify_interrupt_0
     47                  *int_read = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x8028             STRH     R0,[R5, #+0]
     48              
     49              result = inv_icm20948_read_mems_reg(s, REG_INT_STATUS, 1, &int_status);
   \                     ??inv_icm20948_identify_interrupt_0: (+1)
   \   0000000C   0x466B             MOV      R3,SP
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2119             MOVS     R1,#+25
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       inv_icm20948_read_mems_reg
     50              if(int_read)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD002             BEQ.N    ??inv_icm20948_identify_interrupt_1
     51                  *int_read = int_status;
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x8028             STRH     R0,[R5, #+0]
     52          
     53              result = inv_icm20948_read_mems_reg(s, REG_DMP_INT_STATUS, 1, &int_status); // DMP_INT_STATUS
   \                     ??inv_icm20948_identify_interrupt_1: (+1)
   \   00000022   0x466B             MOV      R3,SP
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2118             MOVS     R1,#+24
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       inv_icm20948_read_mems_reg
     54          	if(int_read)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD005             BEQ.N    ??inv_icm20948_identify_interrupt_2
     55          		*int_read |= (int_status << 8);
   \   00000032   0x8829             LDRH     R1,[R5, #+0]
   \   00000034   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000038   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000003C   0x8029             STRH     R1,[R5, #+0]
     56              
     57              /*if(wake_on_motion_enabled) {
     58                  result = inv_icm20948_read_mems_reg(s, REG_INT_STATUS, 1, &int_status);//INT_STATUS
     59                  if(result)
     60                      return result;
     61                  *int_read |= reg_data[1];
     62              }*/
     63              /*
     64               * We do not need to handle FIFO overflow here. 
     65               * When we read FIFO_SIZE we can determine if FIFO overflow has occured.
     66               */
     67              //result = inv_icm20948_read_mems_reg(s, 0x1B, 1, &int_status);
     68              
     69          	return result;
   \                     ??inv_icm20948_identify_interrupt_2: (+1)
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     70          }
     71          
     72          /**
     73          * @internal
     74          * @brief   Get the length from the fifo
     75          *
     76          * @param[out] len amount of data currently stored in the fifo.
     77          *
     78          * @return MPU_SUCCESS or non-zero error code.
     79          **/

   \                                 In section .text, align 2, keep-with-next
     80          static int dmp_get_fifo_length(struct inv_icm20948 * s, uint_fast16_t * len )
     81          {
   \                     dmp_get_fifo_length: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x000C             MOVS     R4,R1
     82          	unsigned char fifoBuf[2];
     83          	int result = 0;
     84              
     85          	if (NULL == len)
   \   00000006   0xD102             BNE.N    ??dmp_get_fifo_length_0
     86          		return -1;
   \   00000008   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
     87              
     88          	/*---- read the 2 'count' registers and
     89          	burst read the data from the FIFO ----*/
     90          	result = inv_icm20948_read_mems_reg(s, REG_FIFO_COUNT_H, 2, fifoBuf);
   \                     ??dmp_get_fifo_length_0: (+1)
   \   0000000E   0x466B             MOV      R3,SP
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x2170             MOVS     R1,#+112
   \   00000014   0x.... 0x....      BL       inv_icm20948_read_mems_reg
     91          	if (result) 
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ.N    ??dmp_get_fifo_length_1
     92          	{
     93          		s->fifo_info.fifoError = -1;
   \   0000001C   0xF04F 0x31FF      MOV      R1,#-1
   \   00000020   0xF8C5 0x1098      STR      R1,[R5, #+152]
     94          		*len = 0;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6021             STR      R1,[R4, #+0]
     95          		return result;
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
     96          	}
     97              
     98          	*len = (uint_fast16_t) (fifoBuf[0] << 8);
   \                     ??dmp_get_fifo_length_1: (+1)
   \   0000002A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002E   0x0200             LSLS     R0,R0,#+8
   \   00000030   0x6020             STR      R0,[R4, #+0]
     99          	*len += (uint_fast16_t) (fifoBuf[1]);
   \   00000032   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000036   0x1840             ADDS     R0,R0,R1
   \   00000038   0x6020             STR      R0,[R4, #+0]
    100          
    101          	return result;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    102          }
    103          
    104          /**
    105          *  @internal
    106          *  @brief  Clears the FIFO status and its content.
    107          *  @note   Halt the DMP writing into the FIFO for the time
    108          *          needed to reset the FIFO.
    109          *  @return MPU_SUCCESS if successful, a non-zero error code otherwise.
    110          */

   \                                 In section .text, align 2, keep-with-next
    111          static int dmp_reset_fifo(struct inv_icm20948 * s)
    112          {
   \                     dmp_reset_fifo: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    113              uint_fast16_t len = HARDWARE_FIFO_SIZE;
   \   00000006   0xF44F 0x6080      MOV      R0,#+1024
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    114          	unsigned char tries = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
    115          	int result = 0;
   \   0000000E   0x462E             MOV      R6,R5
   \   00000010   0xE000             B.N      ??dmp_reset_fifo_0
    116              
    117          	while (len != 0 && tries < 6) 
    118          	{ 
    119          		s->base_state.user_ctrl &= (~BIT_FIFO_EN);
    120          		s->base_state.user_ctrl &= (~BIT_DMP_EN);
    121          		result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
    122          		result |= inv_icm20948_mpu_set_FIFO_RST_Diamond(s, 0x1f);
    123          		result |= inv_icm20948_mpu_set_FIFO_RST_Diamond(s, 0x1e);
    124                  
    125          		// Reset overflow flag
    126          		s->fifo_info.fifo_overflow = 0;
    127                  
    128          		result |= dmp_get_fifo_length(s, &len);
    129          		if (result) 
    130          			return result;
    131                  
    132          		tries++;
   \                     ??dmp_reset_fifo_1: (+1)
   \   00000012   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dmp_reset_fifo_0: (+1)
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD023             BEQ.N    ??dmp_reset_fifo_2
   \   0000001A   0xB2ED             UXTB     R5,R5
   \   0000001C   0x2D06             CMP      R5,#+6
   \   0000001E   0xDA20             BGE.N    ??dmp_reset_fifo_2
   \   00000020   0x7F20             LDRB     R0,[R4, #+28]
   \   00000022   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000026   0x7720             STRB     R0,[R4, #+28]
   \   00000028   0xF000 0x027F      AND      R2,R0,#0x7F
   \   0000002C   0x7722             STRB     R2,[R4, #+28]
   \   0000002E   0x2103             MOVS     R1,#+3
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   00000036   0x4306             ORRS     R6,R0,R6
   \   00000038   0x211F             MOVS     R1,#+31
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       inv_icm20948_mpu_set_FIFO_RST_Diamond
   \   00000040   0x4306             ORRS     R6,R0,R6
   \   00000042   0x211E             MOVS     R1,#+30
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       inv_icm20948_mpu_set_FIFO_RST_Diamond
   \   0000004A   0x4306             ORRS     R6,R0,R6
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF884 0x009C      STRB     R0,[R4, #+156]
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       dmp_get_fifo_length
   \   0000005A   0x4306             ORRS     R6,R0,R6
   \   0000005C   0xD0D9             BEQ.N    ??dmp_reset_fifo_1
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0xBD76             POP      {R1,R2,R4-R6,PC}
    133          	}
    134              
    135          	s->base_state.user_ctrl |= BIT_FIFO_EN;
   \                     ??dmp_reset_fifo_2: (+1)
   \   00000062   0x7F20             LDRB     R0,[R4, #+28]
   \   00000064   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000068   0x7720             STRB     R0,[R4, #+28]
    136          	s->base_state.user_ctrl |= BIT_DMP_EN;
   \   0000006A   0xF040 0x0280      ORR      R2,R0,#0x80
   \   0000006E   0x7722             STRB     R2,[R4, #+28]
    137          	result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
   \   00000070   0x2103             MOVS     R1,#+3
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   00000078   0x4306             ORRS     R6,R0,R6
    138              
    139          	return result;
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    140          }
    141          
    142          /**
    143          *  @internal
    144          *  @brief  Read data from the fifo
    145          *
    146          *  @param[out] data Location to store the date read from the fifo
    147          *  @param[in] len   Amount of data to read out of the fifo
    148          *
    149          *  @return MPU_SUCCESS or non-zero error code
    150          **/

   \                                 In section .text, align 2, keep-with-next
    151          static int dmp_read_fifo(struct inv_icm20948 * s, unsigned char *data, uint_fast16_t len)
    152          {
   \                     dmp_read_fifo: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    153          	int result;
    154              uint_fast16_t bytesRead = 0;
   \   0000000A   0xF04F 0x0800      MOV      R8,#+0
   \   0000000E   0xE000             B.N      ??dmp_read_fifo_0
    155          
    156              while (bytesRead<len) 
    157              {
    158                  unsigned short thisLen = min(INV_MAX_SERIAL_READ, len-bytesRead);
    159                  
    160                  result = inv_icm20948_read_mems_reg(s, REG_FIFO_R_W, thisLen, &data[bytesRead]);
    161                  if (result)
    162          		{
    163          			dmp_reset_fifo(s);
    164          			s->fifo_info.fifoError = -1;
    165          			return result;
    166          		}
    167                  
    168                  bytesRead += thisLen;
   \                     ??dmp_read_fifo_1: (+1)
   \   00000010   0x44C8             ADD      R8,R9,R8
   \                     ??dmp_read_fifo_0: (+1)
   \   00000012   0x45B0             CMP      R8,R6
   \   00000014   0xD21C             BCS.N    ??dmp_read_fifo_2
   \   00000016   0xEBA6 0x0008      SUB      R0,R6,R8
   \   0000001A   0x2811             CMP      R0,#+17
   \   0000001C   0xD302             BCC.N    ??dmp_read_fifo_3
   \   0000001E   0xF04F 0x0910      MOV      R9,#+16
   \   00000022   0xE001             B.N      ??dmp_read_fifo_4
   \                     ??dmp_read_fifo_3: (+1)
   \   00000024   0xEBA6 0x0908      SUB      R9,R6,R8
   \                     ??dmp_read_fifo_4: (+1)
   \   00000028   0xFA1F 0xF989      UXTH     R9,R9
   \   0000002C   0xEB05 0x0308      ADD      R3,R5,R8
   \   00000030   0x464A             MOV      R2,R9
   \   00000032   0x2172             MOVS     R1,#+114
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0xD0E8             BEQ.N    ??dmp_read_fifo_1
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       dmp_reset_fifo
   \   00000044   0xF04F 0x30FF      MOV      R0,#-1
   \   00000048   0xF8C4 0x0098      STR      R0,[R4, #+152]
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0xE000             B.N      ??dmp_read_fifo_5
    169              }
    170          
    171          	return result;
   \                     ??dmp_read_fifo_2: (+1)
   \   00000050   0x4638             MOV      R0,R7
   \                     ??dmp_read_fifo_5: (+1)
   \   00000052   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    172          }
    173          
    174          /**
    175          *  @internal
    176          *  @brief  used to get the FIFO data.
    177          *  @param  length
    178          *              Max number of bytes to read from the FIFO that buffer is still able to sustain.
    179          *  @param  buffer Reads up to length into the buffer.
    180          *
    181          *  @return number of bytes of read.
    182          **/

   \                                 In section .text, align 2, keep-with-next
    183          static uint_fast16_t dmp_get_fifo_all(struct inv_icm20948 * s, uint_fast16_t length, unsigned char *buffer, int *reset)
    184          {
   \                     dmp_get_fifo_all: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x001C             MOVS     R4,R3
    185          	int result;
    186          	uint_fast16_t in_fifo;
    187              
    188          	if(reset)
   \   0000000A   0xD001             BEQ.N    ??dmp_get_fifo_all_0
    189          		*reset = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6020             STR      R0,[R4, #+0]
    190             
    191          	result = dmp_get_fifo_length(s, &in_fifo);
   \                     ??dmp_get_fifo_all_0: (+1)
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       dmp_get_fifo_length
    192          	if (result) {
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD118             BNE.N    ??dmp_get_fifo_all_1
    193          		s->fifo_info.fifoError = result;
    194          		return 0;
    195          	}
    196              
    197          	// Nothing to read
    198          	if (in_fifo == 0)
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00C             BEQ.N    ??dmp_get_fifo_all_2
    199          		return 0;
    200              
    201          	/* Check if buffer is able to be filled in with in_fifo bytes */
    202          	if (in_fifo > length) {
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xD20C             BCS.N    ??dmp_get_fifo_all_3
    203          		dmp_reset_fifo(s);
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       dmp_reset_fifo
    204          		s->fifo_info.fifoError = -1;
   \   0000002C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000030   0xF8C5 0x0098      STR      R0,[R5, #+152]
    205          		if(reset)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD001             BEQ.N    ??dmp_get_fifo_all_2
    206          			*reset = 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6020             STR      R0,[R4, #+0]
    207          		return 0;
   \                     ??dmp_get_fifo_all_2: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
    208          	}
    209          
    210          	result = dmp_read_fifo(s, buffer, in_fifo);
   \                     ??dmp_get_fifo_all_3: (+1)
   \   00000040   0x4602             MOV      R2,R0
   \   00000042   0x4639             MOV      R1,R7
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       dmp_read_fifo
    211          	if (result) {
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD003             BEQ.N    ??dmp_get_fifo_all_4
    212          		s->fifo_info.fifoError = result;
   \                     ??dmp_get_fifo_all_1: (+1)
   \   0000004E   0xF8C5 0x0098      STR      R0,[R5, #+152]
    213          		return 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}
    214          	}
    215          	return in_fifo;
   \                     ??dmp_get_fifo_all_4: (+1)
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    216          }
    217          
    218          /** Determines the packet size by decoding the header. Both header and header2 are set. header2 is set to zero
    219          *   if it doesn't exist. sample_cnt_array is filled in if not null with number of samples expected for each sensor
    220          */

   \                                 In section .text, align 2, keep-with-next
    221          static uint_fast16_t get_packet_size_and_samplecnt(unsigned char *data, unsigned short *header, unsigned short *header2, unsigned short * sample_cnt_array)
    222          {
   \                     get_packet_size_and_samplecnt: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    223          	int sz = HEADER_SZ; // 2 for header
   \   00000002   0x2402             MOVS     R4,#+2
    224              
    225          	*header = (((unsigned short)data[0])<<8) | data[1];
   \   00000004   0x7805             LDRB     R5,[R0, #+0]
   \   00000006   0x7846             LDRB     R6,[R0, #+1]
   \   00000008   0xEA46 0x2605      ORR      R6,R6,R5, LSL #+8
   \   0000000C   0x800E             STRH     R6,[R1, #+0]
    226          
    227          	if (*header & ACCEL_SET) {
   \   0000000E   0x1C9D             ADDS     R5,R3,#+2
   \   00000010   0x0436             LSLS     R6,R6,#+16
   \   00000012   0xD50C             BPL.N    ??get_packet_size_and_samplecnt_0
    228          		sz += ACCEL_DATA_SZ;
   \   00000014   0x2408             MOVS     R4,#+8
    229          		if (sample_cnt_array)
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_1
    230          			sample_cnt_array[ANDROID_SENSOR_ACCELEROMETER]++;
   \   0000001A   0x882E             LDRH     R6,[R5, #+0]
   \   0000001C   0x1C76             ADDS     R6,R6,#+1
   \   0000001E   0x802E             STRH     R6,[R5, #+0]
    231          		if (sample_cnt_array)
   \                     ??get_packet_size_and_samplecnt_1: (+1)
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD004             BEQ.N    ??get_packet_size_and_samplecnt_0
    232          			sample_cnt_array[ANDROID_SENSOR_RAW_ACCELEROMETER]++;
   \   00000024   0xF103 0x0654      ADD      R6,R3,#+84
   \   00000028   0x8837             LDRH     R7,[R6, #+0]
   \   0000002A   0x1C7F             ADDS     R7,R7,#+1
   \   0000002C   0x8037             STRH     R7,[R6, #+0]
    233          	}
    234              
    235          	if (*header & GYRO_SET) {
   \                     ??get_packet_size_and_samplecnt_0: (+1)
   \   0000002E   0x880E             LDRH     R6,[R1, #+0]
   \   00000030   0x0476             LSLS     R6,R6,#+17
   \   00000032   0xD512             BPL.N    ??get_packet_size_and_samplecnt_2
    236          		sz += GYRO_DATA_SZ;
   \   00000034   0x1DA4             ADDS     R4,R4,#+6
    237          		if (sample_cnt_array)
   \   00000036   0x2B00             CMP      R3,#+0
   \   00000038   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_3
    238          			sample_cnt_array[ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED]++;
   \   0000003A   0x8BEE             LDRH     R6,[R5, #+30]
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \   0000003E   0x83EE             STRH     R6,[R5, #+30]
    239          		sz += GYRO_BIAS_DATA_SZ;
   \                     ??get_packet_size_and_samplecnt_3: (+1)
   \   00000040   0x1DA4             ADDS     R4,R4,#+6
    240          		if (sample_cnt_array)
   \   00000042   0x2B00             CMP      R3,#+0
   \   00000044   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_4
    241          			sample_cnt_array[ANDROID_SENSOR_GYROSCOPE]++;
   \   00000046   0x88EE             LDRH     R6,[R5, #+6]
   \   00000048   0x1C76             ADDS     R6,R6,#+1
   \   0000004A   0x80EE             STRH     R6,[R5, #+6]
    242          		if (sample_cnt_array)
   \                     ??get_packet_size_and_samplecnt_4: (+1)
   \   0000004C   0x2B00             CMP      R3,#+0
   \   0000004E   0xD004             BEQ.N    ??get_packet_size_and_samplecnt_2
    243          			sample_cnt_array[ANDROID_SENSOR_RAW_GYROSCOPE]++;
   \   00000050   0xF103 0x0654      ADD      R6,R3,#+84
   \   00000054   0x8877             LDRH     R7,[R6, #+2]
   \   00000056   0x1C7F             ADDS     R7,R7,#+1
   \   00000058   0x8077             STRH     R7,[R6, #+2]
    244          	}
    245           
    246          	if (*header & CPASS_SET) {
   \                     ??get_packet_size_and_samplecnt_2: (+1)
   \   0000005A   0x880E             LDRH     R6,[R1, #+0]
   \   0000005C   0x04B6             LSLS     R6,R6,#+18
   \   0000005E   0xD505             BPL.N    ??get_packet_size_and_samplecnt_5
    247          		sz += CPASS_DATA_SZ;
   \   00000060   0x1DA4             ADDS     R4,R4,#+6
    248          		if (sample_cnt_array)
   \   00000062   0x2B00             CMP      R3,#+0
   \   00000064   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_5
    249          			sample_cnt_array[ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED]++;
   \   00000066   0x8B6E             LDRH     R6,[R5, #+26]
   \   00000068   0x1C76             ADDS     R6,R6,#+1
   \   0000006A   0x836E             STRH     R6,[R5, #+26]
    250          	}
    251              
    252          	if (*header & ALS_SET) {
   \                     ??get_packet_size_and_samplecnt_5: (+1)
   \   0000006C   0x880E             LDRH     R6,[R1, #+0]
   \   0000006E   0x04F6             LSLS     R6,R6,#+19
   \   00000070   0xD505             BPL.N    ??get_packet_size_and_samplecnt_6
    253          		sz += ALS_DATA_SZ;
   \   00000072   0x3408             ADDS     R4,R4,#+8
    254          		if (sample_cnt_array)
   \   00000074   0x2B00             CMP      R3,#+0
   \   00000076   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_6
    255          			sample_cnt_array[ANDROID_SENSOR_LIGHT]++;
   \   00000078   0x892E             LDRH     R6,[R5, #+8]
   \   0000007A   0x1C76             ADDS     R6,R6,#+1
   \   0000007C   0x812E             STRH     R6,[R5, #+8]
    256          	}
    257          
    258          	if (*header & QUAT6_SET) {
   \                     ??get_packet_size_and_samplecnt_6: (+1)
   \   0000007E   0x880E             LDRH     R6,[R1, #+0]
   \   00000080   0x0536             LSLS     R6,R6,#+20
   \   00000082   0xD505             BPL.N    ??get_packet_size_and_samplecnt_7
    259          		sz += QUAT6_DATA_SZ;
   \   00000084   0x340C             ADDS     R4,R4,#+12
    260          		if (sample_cnt_array)
   \   00000086   0x2B00             CMP      R3,#+0
   \   00000088   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_7
    261          			sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR]++;
   \   0000008A   0x8BAE             LDRH     R6,[R5, #+28]
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   \   0000008E   0x83AE             STRH     R6,[R5, #+28]
    262          	}
    263          
    264          	if (*header & QUAT9_SET) {
   \                     ??get_packet_size_and_samplecnt_7: (+1)
   \   00000090   0x880E             LDRH     R6,[R1, #+0]
   \   00000092   0x0576             LSLS     R6,R6,#+21
   \   00000094   0xD505             BPL.N    ??get_packet_size_and_samplecnt_8
    265          		sz += QUAT9_DATA_SZ;
   \   00000096   0x340E             ADDS     R4,R4,#+14
    266          		if (sample_cnt_array)
   \   00000098   0x2B00             CMP      R3,#+0
   \   0000009A   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_8
    267          			sample_cnt_array[ANDROID_SENSOR_ROTATION_VECTOR]++;
   \   0000009C   0x8AAE             LDRH     R6,[R5, #+20]
   \   0000009E   0x1C76             ADDS     R6,R6,#+1
   \   000000A0   0x82AE             STRH     R6,[R5, #+20]
    268          	}
    269          
    270          	if (*header & PQUAT6_SET) 
   \                     ??get_packet_size_and_samplecnt_8: (+1)
   \   000000A2   0x880E             LDRH     R6,[R1, #+0]
   \   000000A4   0x05B7             LSLS     R7,R6,#+22
   \   000000A6   0xD500             BPL.N    ??get_packet_size_and_samplecnt_9
    271          		sz += PQUAT6_DATA_SZ;
   \   000000A8   0x1DA4             ADDS     R4,R4,#+6
    272              
    273          	if (*header & GEOMAG_SET) {
   \                     ??get_packet_size_and_samplecnt_9: (+1)
   \   000000AA   0x05F6             LSLS     R6,R6,#+23
   \   000000AC   0xD505             BPL.N    ??get_packet_size_and_samplecnt_10
    274          		sz += GEOMAG_DATA_SZ;
   \   000000AE   0x340E             ADDS     R4,R4,#+14
    275          		if (sample_cnt_array)
   \   000000B0   0x2B00             CMP      R3,#+0
   \   000000B2   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_10
    276          			sample_cnt_array[ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR]++;
   \   000000B4   0x8CEE             LDRH     R6,[R5, #+38]
   \   000000B6   0x1C76             ADDS     R6,R6,#+1
   \   000000B8   0x84EE             STRH     R6,[R5, #+38]
    277          	}
    278              
    279          	if (*header & CPASS_CALIBR_SET) {
   \                     ??get_packet_size_and_samplecnt_10: (+1)
   \   000000BA   0x780E             LDRB     R6,[R1, #+0]
   \   000000BC   0x06B6             LSLS     R6,R6,#+26
   \   000000BE   0xD505             BPL.N    ??get_packet_size_and_samplecnt_11
    280          		sz += CPASS_CALIBR_DATA_SZ;
   \   000000C0   0x340C             ADDS     R4,R4,#+12
    281          		if (sample_cnt_array)
   \   000000C2   0x2B00             CMP      R3,#+0
   \   000000C4   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_11
    282          			sample_cnt_array[ANDROID_SENSOR_GEOMAGNETIC_FIELD]++;
   \   000000C6   0x886E             LDRH     R6,[R5, #+2]
   \   000000C8   0x1C76             ADDS     R6,R6,#+1
   \   000000CA   0x806E             STRH     R6,[R5, #+2]
    283          	}
    284          
    285          	if (*header & PED_STEPDET_SET) {
   \                     ??get_packet_size_and_samplecnt_11: (+1)
   \   000000CC   0x780E             LDRB     R6,[R1, #+0]
   \   000000CE   0x06F6             LSLS     R6,R6,#+27
   \   000000D0   0xD505             BPL.N    ??get_packet_size_and_samplecnt_12
    286          		sz += PED_STEPDET_TIMESTAMP_SZ;
   \   000000D2   0x1D24             ADDS     R4,R4,#+4
    287          		if (sample_cnt_array)
   \   000000D4   0x2B00             CMP      R3,#+0
   \   000000D6   0xD002             BEQ.N    ??get_packet_size_and_samplecnt_12
    288          			sample_cnt_array[ANDROID_SENSOR_STEP_DETECTOR]++;
   \   000000D8   0x8C6E             LDRH     R6,[R5, #+34]
   \   000000DA   0x1C76             ADDS     R6,R6,#+1
   \   000000DC   0x846E             STRH     R6,[R5, #+34]
    289          	}
    290          
    291          	if (*header & HEADER2_SET) {
   \                     ??get_packet_size_and_samplecnt_12: (+1)
   \   000000DE   0x7809             LDRB     R1,[R1, #+0]
   \   000000E0   0x0709             LSLS     R1,R1,#+28
   \   000000E2   0xD506             BPL.N    ??get_packet_size_and_samplecnt_13
    292          		*header2 = (((unsigned short)data[2])<<8) | data[3];
   \   000000E4   0x7881             LDRB     R1,[R0, #+2]
   \   000000E6   0x78C0             LDRB     R0,[R0, #+3]
   \   000000E8   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000000EC   0x8010             STRH     R0,[R2, #+0]
    293          		sz += HEADER2_SZ;
   \   000000EE   0x1CA4             ADDS     R4,R4,#+2
   \   000000F0   0xE001             B.N      ??get_packet_size_and_samplecnt_14
    294          	} else {
    295          		*header2 = 0;
   \                     ??get_packet_size_and_samplecnt_13: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x8010             STRH     R0,[R2, #+0]
    296          	}
    297              
    298          	if (*header2 & ACCEL_ACCURACY_SET) {
   \                     ??get_packet_size_and_samplecnt_14: (+1)
   \   000000F6   0x8810             LDRH     R0,[R2, #+0]
   \   000000F8   0x0441             LSLS     R1,R0,#+17
   \   000000FA   0xD500             BPL.N    ??get_packet_size_and_samplecnt_15
    299          		sz += ACCEL_ACCURACY_SZ;
   \   000000FC   0x1CA4             ADDS     R4,R4,#+2
    300          	}
    301          	if (*header2 & GYRO_ACCURACY_SET) {
   \                     ??get_packet_size_and_samplecnt_15: (+1)
   \   000000FE   0x0481             LSLS     R1,R0,#+18
   \   00000100   0xD500             BPL.N    ??get_packet_size_and_samplecnt_16
    302          		sz += GYRO_ACCURACY_SZ;
   \   00000102   0x1CA4             ADDS     R4,R4,#+2
    303          	}
    304          	if (*header2 & CPASS_ACCURACY_SET) {
   \                     ??get_packet_size_and_samplecnt_16: (+1)
   \   00000104   0x04C1             LSLS     R1,R0,#+19
   \   00000106   0xD500             BPL.N    ??get_packet_size_and_samplecnt_17
    305          		sz += CPASS_ACCURACY_SZ;
   \   00000108   0x1CA4             ADDS     R4,R4,#+2
    306          	}
    307          	if (*header2 & FLIP_PICKUP_SET) {
   \                     ??get_packet_size_and_samplecnt_17: (+1)
   \   0000010A   0x0540             LSLS     R0,R0,#+21
   \   0000010C   0xD507             BPL.N    ??get_packet_size_and_samplecnt_18
    308          		sz += FLIP_PICKUP_SZ;
   \   0000010E   0x1CA4             ADDS     R4,R4,#+2
    309          		if (sample_cnt_array)
   \   00000110   0x2B00             CMP      R3,#+0
   \   00000112   0xD004             BEQ.N    ??get_packet_size_and_samplecnt_18
    310          			sample_cnt_array[ANDROID_SENSOR_FLIP_PICKUP]++;
   \   00000114   0xF103 0x0654      ADD      R6,R3,#+84
   \   00000118   0x8930             LDRH     R0,[R6, #+8]
   \   0000011A   0x1C40             ADDS     R0,R0,#+1
   \   0000011C   0x8130             STRH     R0,[R6, #+8]
    311          	}
    312          	if (*header2 & ACT_RECOG_SET) {
   \                     ??get_packet_size_and_samplecnt_18: (+1)
   \   0000011E   0x7810             LDRB     R0,[R2, #+0]
   \   00000120   0x0600             LSLS     R0,R0,#+24
   \   00000122   0xD507             BPL.N    ??get_packet_size_and_samplecnt_19
    313          		sz += ACT_RECOG_SZ;
   \   00000124   0x1DA4             ADDS     R4,R4,#+6
    314          		if (sample_cnt_array)
   \   00000126   0x2B00             CMP      R3,#+0
   \   00000128   0xD004             BEQ.N    ??get_packet_size_and_samplecnt_19
    315          			sample_cnt_array[ANDROID_SENSOR_ACTIVITY_CLASSIFICATON]++;
   \   0000012A   0xF103 0x0654      ADD      R6,R3,#+84
   \   0000012E   0x8970             LDRH     R0,[R6, #+10]
   \   00000130   0x1C40             ADDS     R0,R0,#+1
   \   00000132   0x8170             STRH     R0,[R6, #+10]
    316          	}
    317          	sz += ODR_CNT_GYRO_SZ;
    318          
    319          	return sz;
   \                     ??get_packet_size_and_samplecnt_19: (+1)
   \   00000134   0x1CA0             ADDS     R0,R4,#+2
   \   00000136   0xBCF0             POP      {R4-R7}
   \   00000138   0x4770             BX       LR               ;; return
    320          }
    321          

   \                                 In section .text, align 2, keep-with-next
    322          static int check_fifo_decoded_headers(unsigned short header, unsigned short header2)
    323          {
    324          	unsigned short header_bit_mask = 0;
    325          	unsigned short header2_bit_mask = 0;
    326          	
    327          	// at least 1 bit must be set
    328          	if (header == 0)
   \                     check_fifo_decoded_headers: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   \   00000002   0xD00A             BEQ.N    ??check_fifo_decoded_headers_0
    329          		return -1;
    330          	
    331          	header_bit_mask |= ACCEL_SET;
    332          	header_bit_mask |= GYRO_SET;
    333          	header_bit_mask |= CPASS_SET;
    334          	header_bit_mask |= ALS_SET;
    335          	header_bit_mask |= QUAT6_SET;
    336          	header_bit_mask |= QUAT9_SET;
    337          	header_bit_mask |= PQUAT6_SET;
    338          	header_bit_mask |= GEOMAG_SET;
    339          	header_bit_mask |= GYRO_CALIBR_SET;
    340          	header_bit_mask |= CPASS_CALIBR_SET;
    341          	header_bit_mask |= PED_STEPDET_SET;
    342          	header_bit_mask |= HEADER2_SET;
    343          	
    344          	if (header & ~header_bit_mask)
   \   00000004   0x2287             MOVS     R2,#+135
   \   00000006   0x4210             TST      R0,R2
   \   00000008   0xD107             BNE.N    ??check_fifo_decoded_headers_0
    345          		return -1;
    346          	
    347          	// at least 1 bit must be set if header 2 is set
    348          	if (header & HEADER2_SET) {
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0xD508             BPL.N    ??check_fifo_decoded_headers_1
    349          		header2_bit_mask |= ACCEL_ACCURACY_SET;
    350          		header2_bit_mask |= GYRO_ACCURACY_SET;
    351          		header2_bit_mask |= CPASS_ACCURACY_SET;
    352          		header2_bit_mask |= FLIP_PICKUP_SET;
    353          		header2_bit_mask |= ACT_RECOG_SET;
    354          		if (header2 == 0)
   \   0000000E   0x0008             MOVS     R0,R1
   \   00000010   0xD003             BEQ.N    ??check_fifo_decoded_headers_0
    355          			return -1;
    356          		if (header2 & ~header2_bit_mask)
   \   00000012   0xF648 0x307F      MOVW     R0,#+35711
   \   00000016   0x4201             TST      R1,R0
   \   00000018   0xD002             BEQ.N    ??check_fifo_decoded_headers_1
    357          			return -1;
   \                     ??check_fifo_decoded_headers_0: (+1)
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0x4770             BX       LR
    358          	}
    359          
    360              return 0;
   \                     ??check_fifo_decoded_headers_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    361          }

   \                                 In section .bss, align 4
   \                     fd:
   \   00000000                      DS8 164
   \   000000A4                      DS8 1024
    362          
    363          /** Software FIFO, mirror of DMP HW FIFO, hence of max HARDWARE_FIFO_SIZE */
    364          static unsigned char fifo_data[HARDWARE_FIFO_SIZE];
    365              
    366          /** Determine number of samples present in SW FIFO fifo_data containing fifo_size bytes to be analyzed. Total number
    367          * of samples filled in total_sample_cnt, number of samples per sensor filled in sample_cnt_array array
    368          */

   \                                 In section .text, align 2, keep-with-next
    369          static int extract_sample_cnt(struct inv_icm20948 * s, int fifo_size, unsigned short * total_sample_cnt, unsigned short * sample_cnt_array)
    370          {
   \                     extract_sample_cnt: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    371          	// Next SW FIFO index to be parsed
    372          	int fifo_idx = 0;
   \   0000000C   0xF04F 0x0800      MOV      R8,#+0
   \   00000010   0xE003             B.N      ??extract_sample_cnt_0
    373          	
    374          	while (fifo_idx < fifo_size) {
    375          		unsigned short header;
    376          		unsigned short header2;
    377          		int need_sz = get_packet_size_and_samplecnt(&fifo_data[fifo_idx], &header, &header2, sample_cnt_array);
    378          		
    379          		// Guarantee there is a full packet before continuing to decode the FIFO packet
    380          		if (fifo_size-fifo_idx < need_sz)
    381          			goto endSuccess;
    382          		
    383          		// Decode any error
    384          		if (check_fifo_decoded_headers(header, header2)) {
    385          			// in that case, stop processing, we might have overflowed so following bytes are non sense
    386          			dmp_reset_fifo(s);
    387          			return -1;
    388          		}
    389          		
    390          		fifo_idx += need_sz;
   \                     ??extract_sample_cnt_1: (+1)
   \   00000012   0x44C8             ADD      R8,R9,R8
    391          		
    392          		// One sample found, increment total sample counter
    393          		(*total_sample_cnt)++;
   \   00000014   0x8830             LDRH     R0,[R6, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x8030             STRH     R0,[R6, #+0]
   \                     ??extract_sample_cnt_0: (+1)
   \   0000001A   0x45A8             CMP      R8,R5
   \   0000001C   0xDA1C             BGE.N    ??extract_sample_cnt_2
   \   0000001E   0x463B             MOV      R3,R7
   \   00000020   0x466A             MOV      R2,SP
   \   00000022   0xF10D 0x0102      ADD      R1,SP,#+2
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000002A   0x4440             ADD      R0,R0,R8
   \   0000002C   0x30A4             ADDS     R0,R0,#+164
   \   0000002E   0x.... 0x....      BL       get_packet_size_and_samplecnt
   \   00000032   0x4681             MOV      R9,R0
   \   00000034   0xEBA5 0x0008      SUB      R0,R5,R8
   \   00000038   0x4548             CMP      R0,R9
   \   0000003A   0xDB0D             BLT.N    ??extract_sample_cnt_2
   \   0000003C   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   00000040   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000044   0x.... 0x....      BL       check_fifo_decoded_headers
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD0E2             BEQ.N    ??extract_sample_cnt_1
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       dmp_reset_fifo
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xE00E             B.N      ??extract_sample_cnt_3
    394          	}
    395          
    396          endSuccess:
    397          	// Augmented sensors are not part of DMP FIFO, they are computed by DMP driver based on GRV or RV presence in DMP FIFO
    398          	// So their sample counts must rely on GRV and RV sample counts
    399          	if (sample_cnt_array) {
   \                     ??extract_sample_cnt_2: (+1)
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xD00B             BEQ.N    ??extract_sample_cnt_4
    400          		sample_cnt_array[ANDROID_SENSOR_GRAVITY] += sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR];
   \   0000005C   0x8A78             LDRH     R0,[R7, #+18]
   \   0000005E   0x8BF9             LDRH     R1,[R7, #+30]
   \   00000060   0x1808             ADDS     R0,R1,R0
   \   00000062   0x8278             STRH     R0,[R7, #+18]
    401          		sample_cnt_array[ANDROID_SENSOR_LINEAR_ACCELERATION] += sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR];
   \   00000064   0x8AB8             LDRH     R0,[R7, #+20]
   \   00000066   0x8BF9             LDRH     R1,[R7, #+30]
   \   00000068   0x1808             ADDS     R0,R1,R0
   \   0000006A   0x82B8             STRH     R0,[R7, #+20]
    402          		sample_cnt_array[ANDROID_SENSOR_ORIENTATION] += sample_cnt_array[ANDROID_SENSOR_ROTATION_VECTOR];
   \   0000006C   0x88F8             LDRH     R0,[R7, #+6]
   \   0000006E   0x8AF9             LDRH     R1,[R7, #+22]
   \   00000070   0x1808             ADDS     R0,R1,R0
   \   00000072   0x80F8             STRH     R0,[R7, #+6]
    403          	}
    404          
    405          	return 0;
   \                     ??extract_sample_cnt_4: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??extract_sample_cnt_3: (+1)
   \   00000076   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    406          }
    407          

   \                                 In section .text, align 2, keep-with-next
    408          int inv_icm20948_fifo_swmirror(struct inv_icm20948 * s, int *fifo_sw_size, unsigned short * total_sample_cnt, unsigned short * sample_cnt_array)
    409          {
   \                     inv_icm20948_fifo_swmirror: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    410          	int reset=0; 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    411          
    412          	*total_sample_cnt = 0;
   \   0000000E   0x8030             STRH     R0,[R6, #+0]
    413          
    414          	// Mirror HW FIFO into local SW FIFO, taking into account remaining *fifo_sw_size bytes still present in SW FIFO
    415          	if (*fifo_sw_size < HARDWARE_FIFO_SIZE ) {
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000016   0xDA10             BGE.N    ??inv_icm20948_fifo_swmirror_0
    416          		*fifo_sw_size += dmp_get_fifo_all(s, (HARDWARE_FIFO_SIZE - *fifo_sw_size),&fifo_data[*fifo_sw_size],&reset);
   \   00000018   0x466B             MOV      R3,SP
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000001E   0x4401             ADD      R1,R1,R0
   \   00000020   0xF101 0x02A4      ADD      R2,R1,#+164
   \   00000024   0xF5C0 0x6180      RSB      R1,R0,#+1024
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       dmp_get_fifo_all
   \   0000002E   0x6829             LDR      R1,[R5, #+0]
   \   00000030   0x1840             ADDS     R0,R0,R1
   \   00000032   0x6028             STR      R0,[R5, #+0]
    417          
    418          		if (reset)
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD109             BNE.N    ??inv_icm20948_fifo_swmirror_1
    419          			goto error;
    420          	}
    421          
    422          	// SW FIFO is mirror, we can now parse it to extract total number of samples and number of samples per sensor
    423          	if (extract_sample_cnt(s, *fifo_sw_size, total_sample_cnt, sample_cnt_array))
   \                     ??inv_icm20948_fifo_swmirror_0: (+1)
   \   0000003A   0x463B             MOV      R3,R7
   \   0000003C   0x4632             MOV      R2,R6
   \   0000003E   0x6829             LDR      R1,[R5, #+0]
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       extract_sample_cnt
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD101             BNE.N    ??inv_icm20948_fifo_swmirror_1
    424          			goto error;
    425          
    426          	return MPU_SUCCESS;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBDF2             POP      {R1,R4-R7,PC}
    427          	
    428          error:
    429          	*fifo_sw_size = 0;
   \                     ??inv_icm20948_fifo_swmirror_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6028             STR      R0,[R5, #+0]
    430          	return -1;
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    431          	
    432          }
    433          

   \                                 In section .text, align 2, keep-with-next
    434          int inv_icm20948_fifo_pop(struct inv_icm20948 * s, unsigned short *user_header, unsigned short *user_header2, int *fifo_sw_size)  
    435          {
   \                     inv_icm20948_fifo_pop: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
    436          	int need_sz=0; // size in bytes of packet to be analyzed from FIFO
    437          	unsigned char *fifo_ptr = fifo_data; // pointer to next byte in SW FIFO to be parsed
    438              
    439          	if (*fifo_sw_size > 3) {
   \   0000000C   0x6830             LDR      R0,[R6, #+0]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xDB31             BLT.N    ??inv_icm20948_fifo_pop_0
    440          		// extract headers and number of bytes requested by next sample present in FIFO
    441          		need_sz = get_packet_size_and_samplecnt(fifo_data, &fd.header, &fd.header2, 0);
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable19
   \   00000016   0xF107 0x08A4      ADD      R8,R7,#+164
   \   0000001A   0xF107 0x099A      ADD      R9,R7,#+154
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0xF107 0x029C      ADD      R2,R7,#+156
   \   00000024   0x4649             MOV      R1,R9
   \   00000026   0x4640             MOV      R0,R8
   \   00000028   0x.... 0x....      BL       get_packet_size_and_samplecnt
   \   0000002C   0x4682             MOV      R10,R0
    442          
    443          		// Guarantee there is a full packet before continuing to decode the FIFO packet
    444          		if (*fifo_sw_size < need_sz) {
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x4550             CMP      R0,R10
   \   00000032   0xDA02             BGE.N    ??inv_icm20948_fifo_pop_1
    445          		    return s->fifo_info.fifoError;
   \   00000034   0xF8DB 0x0098      LDR      R0,[R11, #+152]
   \   00000038   0xE01E             B.N      ??inv_icm20948_fifo_pop_2
    446          		}
    447          
    448          		fifo_ptr += HEADER_SZ;        
   \                     ??inv_icm20948_fifo_pop_1: (+1)
   \   0000003A   0xF107 0x02A6      ADD      R2,R7,#+166
    449          		if (fd.header & HEADER2_SET)
   \   0000003E   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000042   0x0700             LSLS     R0,R0,#+28
   \   00000044   0xD501             BPL.N    ??inv_icm20948_fifo_pop_3
    450          			fifo_ptr += HEADER2_SZ;        
   \   00000046   0xF107 0x02A8      ADD      R2,R7,#+168
    451          
    452          		// extract payload data from SW FIFO
    453          		fifo_ptr += inv_icm20948_inv_decode_one_ivory_fifo_packet(s, &fd, fifo_ptr);        
   \                     ??inv_icm20948_fifo_pop_3: (+1)
   \   0000004A   0x4639             MOV      R1,R7
   \   0000004C   0x4658             MOV      R0,R11
   \   0000004E   0x.... 0x....      BL       inv_icm20948_inv_decode_one_ivory_fifo_packet
    454          
    455          		// remove first need_sz bytes from SW FIFO
    456          		*fifo_sw_size -= need_sz;
   \   00000052   0x6830             LDR      R0,[R6, #+0]
   \   00000054   0xEBB0 0x020A      SUBS     R2,R0,R10
   \   00000058   0x6032             STR      R2,[R6, #+0]
    457          		if(*fifo_sw_size)
   \   0000005A   0xD006             BEQ.N    ??inv_icm20948_fifo_pop_4
    458          			memmove(fifo_data, &fifo_data[need_sz], *fifo_sw_size);// Data left in FIFO
   \   0000005C   0xEB07 0x000A      ADD      R0,R7,R10
   \   00000060   0xF100 0x01A4      ADD      R1,R0,#+164
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0x.... 0x....      BL       __aeabi_memmove
    459          
    460          		*user_header = fd.header;
   \                     ??inv_icm20948_fifo_pop_4: (+1)
   \   0000006A   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   0000006E   0x8020             STRH     R0,[R4, #+0]
    461          		*user_header2 = fd.header2;
   \   00000070   0xF8B9 0x0002      LDRH     R0,[R9, #+2]
   \   00000074   0x8028             STRH     R0,[R5, #+0]
    462          	}
    463          
    464          	return MPU_SUCCESS;
   \                     ??inv_icm20948_fifo_pop_0: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??inv_icm20948_fifo_pop_2: (+1)
   \   00000078   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    465          }
    466          

   \                                 In section .text, align 2, keep-with-next
    467          int inv_icm20948_dmp_process_fifo(struct inv_icm20948 * s, int *left_in_fifo, unsigned short *user_header, unsigned short *user_header2, long long *time_stamp)  
    468          {
   \                     inv_icm20948_dmp_process_fifo: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
    469              int result = MPU_SUCCESS;
    470              int reset=0; 
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    471              int need_sz=0;
    472              unsigned char *fifo_ptr = fifo_data;
    473          
    474              long long ts=0;
    475          
    476              if(!left_in_fifo)
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD102             BNE.N    ??inv_icm20948_dmp_process_fifo_0
    477                  return -1;
   \   00000014   0xF04F 0x30FF      MOV      R0,#-1
   \   00000018   0xE06F             B.N      ??inv_icm20948_dmp_process_fifo_1
    478              
    479              if (*left_in_fifo < HARDWARE_FIFO_SIZE ) 
   \                     ??inv_icm20948_dmp_process_fifo_0: (+1)
   \   0000001A   0x6838             LDR      R0,[R7, #+0]
   \   0000001C   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000020   0xDA15             BGE.N    ??inv_icm20948_dmp_process_fifo_2
    480              {
    481                  *left_in_fifo += dmp_get_fifo_all(s, (HARDWARE_FIFO_SIZE - *left_in_fifo),&fifo_data[*left_in_fifo],&reset);
   \   00000022   0x466B             MOV      R3,SP
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000028   0x4401             ADD      R1,R1,R0
   \   0000002A   0xF101 0x02A4      ADD      R2,R1,#+164
   \   0000002E   0xF5C0 0x6180      RSB      R1,R0,#+1024
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       dmp_get_fifo_all
   \   00000038   0x6839             LDR      R1,[R7, #+0]
   \   0000003A   0x1840             ADDS     R0,R0,R1
   \   0000003C   0x6038             STR      R0,[R7, #+0]
    482                  //sprintf(test_str, "Left in FIFO: %d\r\n",*left_in_fifo);
    483                  //print_command_console(test_str);
    484                  if (reset) 
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD004             BEQ.N    ??inv_icm20948_dmp_process_fifo_2
    485                  {
    486                      *left_in_fifo = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6038             STR      R0,[R7, #+0]
    487                      return -1;
   \   00000048   0xF04F 0x30FF      MOV      R0,#-1
   \   0000004C   0xE055             B.N      ??inv_icm20948_dmp_process_fifo_1
    488                  }
    489              }
    490              
    491              if (*left_in_fifo > 3) {
   \                     ??inv_icm20948_dmp_process_fifo_2: (+1)
   \   0000004E   0x6838             LDR      R0,[R7, #+0]
   \   00000050   0x2804             CMP      R0,#+4
   \   00000052   0xDB51             BLT.N    ??inv_icm20948_dmp_process_fifo_3
    492          	// no need to extract number of sample per sensor for current function, so provide 0 as last parameter
    493                  need_sz = get_packet_size_and_samplecnt(fifo_data, &fd.header, &fd.header2, 0);
   \   00000054   0x.... 0x....      LDR.W    R8,??DataTable19
   \   00000058   0xF108 0x09A4      ADD      R9,R8,#+164
   \   0000005C   0xF108 0x0B9A      ADD      R11,R8,#+154
   \   00000060   0x2300             MOVS     R3,#+0
   \   00000062   0xF108 0x029C      ADD      R2,R8,#+156
   \   00000066   0x4659             MOV      R1,R11
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0x.... 0x....      BL       get_packet_size_and_samplecnt
   \   0000006E   0x4682             MOV      R10,R0
    494                  
    495                  // Guarantee there is a full packet before continuing to decode the FIFO packet
    496                  if (*left_in_fifo < need_sz) {
   \   00000070   0x6838             LDR      R0,[R7, #+0]
   \   00000072   0x4550             CMP      R0,R10
   \   00000074   0xDA05             BGE.N    ??inv_icm20948_dmp_process_fifo_4
    497                      result = s->fifo_info.fifoError;
   \   00000076   0xF8D6 0x0098      LDR      R0,[R6, #+152]
    498                      s->fifo_info.fifoError = 0;
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0xF8C6 0x1098      STR      R1,[R6, #+152]
    499                      return result;
   \   00000080   0xE03B             B.N      ??inv_icm20948_dmp_process_fifo_1
    500                  }
    501          
    502                  if(user_header)
   \                     ??inv_icm20948_dmp_process_fifo_4: (+1)
   \   00000082   0x2C00             CMP      R4,#+0
   \   00000084   0xD002             BEQ.N    ??inv_icm20948_dmp_process_fifo_5
    503                      *user_header = fd.header;
   \   00000086   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \   0000008A   0x8020             STRH     R0,[R4, #+0]
    504                  
    505                  if(user_header2)
   \                     ??inv_icm20948_dmp_process_fifo_5: (+1)
   \   0000008C   0x2D00             CMP      R5,#+0
   \   0000008E   0xD002             BEQ.N    ??inv_icm20948_dmp_process_fifo_6
    506                      *user_header2 = fd.header2;
   \   00000090   0xF8BB 0x0002      LDRH     R0,[R11, #+2]
   \   00000094   0x8028             STRH     R0,[R5, #+0]
    507                  
    508                  if (check_fifo_decoded_headers(fd.header, fd.header2)) { 
   \                     ??inv_icm20948_dmp_process_fifo_6: (+1)
   \   00000096   0xF8BB 0x4000      LDRH     R4,[R11, #+0]
   \   0000009A   0xF8BB 0x1002      LDRH     R1,[R11, #+2]
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       check_fifo_decoded_headers
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD007             BEQ.N    ??inv_icm20948_dmp_process_fifo_7
    509                      // Decode error
    510                      dmp_reset_fifo(s);
   \   000000A8   0x4630             MOV      R0,R6
   \   000000AA   0x.... 0x....      BL       dmp_reset_fifo
    511                      *left_in_fifo = 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x6038             STR      R0,[R7, #+0]
    512                      return -1;
   \   000000B2   0xF04F 0x30FF      MOV      R0,#-1
   \   000000B6   0xE020             B.N      ??inv_icm20948_dmp_process_fifo_1
    513                  }
    514                  
    515                  fifo_ptr += HEADER_SZ;
   \                     ??inv_icm20948_dmp_process_fifo_7: (+1)
   \   000000B8   0xF108 0x0BA6      ADD      R11,R8,#+166
    516                  
    517                  if (fd.header & HEADER2_SET)
   \   000000BC   0x0720             LSLS     R0,R4,#+28
   \   000000BE   0xD501             BPL.N    ??inv_icm20948_dmp_process_fifo_8
    518                      fifo_ptr += HEADER2_SZ;        
   \   000000C0   0xF108 0x0BA8      ADD      R11,R8,#+168
    519                  
    520                  //time stamp 
    521                  ts = inv_icm20948_get_tick_count();
   \                     ??inv_icm20948_dmp_process_fifo_8: (+1)
   \   000000C4   0x.... 0x....      BL       inv_icm20948_get_tick_count
   \   000000C8   0x4604             MOV      R4,R0
   \   000000CA   0x17C5             ASRS     R5,R0,#+31
    522                  
    523                  fifo_ptr += inv_icm20948_inv_decode_one_ivory_fifo_packet(s, &fd, fifo_ptr);
   \   000000CC   0x465A             MOV      R2,R11
   \   000000CE   0x4641             MOV      R1,R8
   \   000000D0   0x4630             MOV      R0,R6
   \   000000D2   0x.... 0x....      BL       inv_icm20948_inv_decode_one_ivory_fifo_packet
   \   000000D6   0x980A             LDR      R0,[SP, #+40]
    524          
    525                  if(time_stamp)
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD001             BEQ.N    ??inv_icm20948_dmp_process_fifo_9
    526                      *time_stamp = ts;
   \   000000DC   0xE9C0 0x4500      STRD     R4,R5,[R0, #+0]
    527                  
    528                  /* Parse the data in the fifo, in the order of the data control register, starting with the MSB(accel)
    529                  */
    530                  
    531                  
    532                  *left_in_fifo -= need_sz;
   \                     ??inv_icm20948_dmp_process_fifo_9: (+1)
   \   000000E0   0x6838             LDR      R0,[R7, #+0]
   \   000000E2   0xEBB0 0x020A      SUBS     R2,R0,R10
   \   000000E6   0x603A             STR      R2,[R7, #+0]
    533                  if (*left_in_fifo) 
   \   000000E8   0xD006             BEQ.N    ??inv_icm20948_dmp_process_fifo_3
    534                      memmove(fifo_data, &fifo_data[need_sz], *left_in_fifo);// Data left in FIFO
   \   000000EA   0xEB08 0x000A      ADD      R0,R8,R10
   \   000000EE   0xF100 0x01A4      ADD      R1,R0,#+164
   \   000000F2   0x4648             MOV      R0,R9
   \   000000F4   0x.... 0x....      BL       __aeabi_memmove
    535              }
    536          
    537              return result;
   \                     ??inv_icm20948_dmp_process_fifo_3: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \                     ??inv_icm20948_dmp_process_fifo_1: (+1)
   \   000000FA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    538          }
    539          

   \                                 In section .text, align 2, keep-with-next
    540          static void inv_decode_3_32bit_elements(long *out_data, const unsigned char *in_data)
    541          {
    542              out_data[0] = ((long)(0xff & in_data[0]) << 24) | ((long)(0xff & in_data[1]) << 16) | ((long)(0xff & in_data[2]) << 8) | (0xff & in_data[3]);
   \                     inv_decode_3_32bit_elements: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x784B             LDRB     R3,[R1, #+1]
   \   00000004   0x041B             LSLS     R3,R3,#+16
   \   00000006   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   0000000A   0x788B             LDRB     R3,[R1, #+2]
   \   0000000C   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000010   0x78CB             LDRB     R3,[R1, #+3]
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x6002             STR      R2,[R0, #+0]
    543              out_data[1] = ((long)(0xff & in_data[4]) << 24) | ((long)(0xff & in_data[5]) << 16) | ((long)(0xff & in_data[6]) << 8) | (0xff & in_data[7]);
   \   00000016   0x790A             LDRB     R2,[R1, #+4]
   \   00000018   0x794B             LDRB     R3,[R1, #+5]
   \   0000001A   0x041B             LSLS     R3,R3,#+16
   \   0000001C   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   00000020   0x798B             LDRB     R3,[R1, #+6]
   \   00000022   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000026   0x79CB             LDRB     R3,[R1, #+7]
   \   00000028   0x431A             ORRS     R2,R3,R2
   \   0000002A   0x6042             STR      R2,[R0, #+4]
    544              out_data[2] = ((long)(0xff & in_data[8]) << 24) | ((long)(0xff & in_data[9]) << 16) | ((long)(0xff & in_data[10]) << 8) | (0xff & in_data[11]);
   \   0000002C   0x7A0A             LDRB     R2,[R1, #+8]
   \   0000002E   0x7A4B             LDRB     R3,[R1, #+9]
   \   00000030   0x041B             LSLS     R3,R3,#+16
   \   00000032   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   00000036   0x7A8B             LDRB     R3,[R1, #+10]
   \   00000038   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000003C   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000003E   0x4311             ORRS     R1,R1,R2
   \   00000040   0x6081             STR      R1,[R0, #+8]
    545          }
   \   00000042   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    546          static void inv_decode_3_16bit_elements(short *out_data, const unsigned char *in_data)
    547          {
    548              out_data[0] = ((short)(0xff & in_data[0]) << 8) | (0xff & in_data[1]);
   \                     inv_decode_3_16bit_elements: (+1)
   \   00000000   0x780A             LDRB     R2,[R1, #+0]
   \   00000002   0x784B             LDRB     R3,[R1, #+1]
   \   00000004   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \   00000008   0x8002             STRH     R2,[R0, #+0]
    549              out_data[1] = ((short)(0xff & in_data[2]) << 8) | (0xff & in_data[3]);
   \   0000000A   0x788A             LDRB     R2,[R1, #+2]
   \   0000000C   0x78CB             LDRB     R3,[R1, #+3]
   \   0000000E   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \   00000012   0x8042             STRH     R2,[R0, #+2]
    550              out_data[2] = ((short)(0xff & in_data[4]) << 8) | (0xff & in_data[5]);
   \   00000014   0x790A             LDRB     R2,[R1, #+4]
   \   00000016   0x7949             LDRB     R1,[R1, #+5]
   \   00000018   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000001C   0x8081             STRH     R1,[R0, #+4]
    551          }
   \   0000001E   0x4770             BX       LR               ;; return
    552          
    553          /** Decodes one packet of data from Ivory FIFO
    554          * @param[in] fd Structure to be filled out with data. Assumes header and header2 are already set inside.
    555          * @param[in] fifo_ptr FIFO data, points to just after any header information
    556          * @return Returns the number of bytes consumed in FIFO data.
    557          */

   \                                 In section .text, align 2, keep-with-next
    558          int inv_icm20948_inv_decode_one_ivory_fifo_packet(struct inv_icm20948 * s, struct inv_fifo_decoded_t *fd, const unsigned char *fifo_ptr)
    559          {
   \                     inv_icm20948_inv_decode_one_ivory_fifo_packet: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4617             MOV      R7,R2
    560              const unsigned char *fifo_ptr_start = fifo_ptr;  
   \   0000000A   0x463D             MOV      R5,R7
    561          	short odr_cntr;
    562              if (fd->header & ACCEL_SET) {
   \   0000000C   0xF104 0x0680      ADD      R6,R4,#+128
   \   00000010   0x8B70             LDRH     R0,[R6, #+26]
   \   00000012   0x0400             LSLS     R0,R0,#+16
   \   00000014   0xD513             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_0
    563                  // do not cast data here, do that when you use it
    564                  inv_decode_3_16bit_elements(fd->accel_s, fifo_ptr);
   \   00000016   0x4639             MOV      R1,R7
   \   00000018   0xF104 0x002C      ADD      R0,R4,#+44
   \   0000001C   0x.... 0x....      BL       inv_decode_3_16bit_elements
    565                  fd->accel[0] = fd->accel_s[0] << 15;
   \   00000020   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000024   0xF9B0 0x1014      LDRSH    R1,[R0, #+20]
   \   00000028   0x03C9             LSLS     R1,R1,#+15
   \   0000002A   0x61C1             STR      R1,[R0, #+28]
    566                  fd->accel[1] = fd->accel_s[1] << 15;
   \   0000002C   0xF9B0 0x1016      LDRSH    R1,[R0, #+22]
   \   00000030   0x03C9             LSLS     R1,R1,#+15
   \   00000032   0x6201             STR      R1,[R0, #+32]
    567                  fd->accel[2] = fd->accel_s[2] << 15;
   \   00000034   0xF9B0 0x1018      LDRSH    R1,[R0, #+24]
   \   00000038   0x03C9             LSLS     R1,R1,#+15
   \   0000003A   0x6241             STR      R1,[R0, #+36]
    568                  fifo_ptr += ACCEL_DATA_SZ;
   \   0000003C   0x1DBF             ADDS     R7,R7,#+6
    569              }
    570          
    571              if (fd->header & GYRO_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_0: (+1)
   \   0000003E   0x8B70             LDRH     R0,[R6, #+26]
   \   00000040   0x0440             LSLS     R0,R0,#+17
   \   00000042   0xD50B             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_1
    572                  inv_decode_3_16bit_elements(fd->gyro, fifo_ptr);
   \   00000044   0x4639             MOV      R1,R7
   \   00000046   0xF104 0x0040      ADD      R0,R4,#+64
   \   0000004A   0x.... 0x....      BL       inv_decode_3_16bit_elements
    573                  fifo_ptr += GYRO_DATA_SZ;
   \   0000004E   0x1DBF             ADDS     R7,R7,#+6
    574                  inv_decode_3_16bit_elements(fd->gyro_bias, fifo_ptr);
   \   00000050   0x4639             MOV      R1,R7
   \   00000052   0xF104 0x0046      ADD      R0,R4,#+70
   \   00000056   0x.... 0x....      BL       inv_decode_3_16bit_elements
    575                  fifo_ptr += GYRO_BIAS_DATA_SZ;
   \   0000005A   0x1DBF             ADDS     R7,R7,#+6
    576              }
    577          
    578              if (fd->header & CPASS_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_1: (+1)
   \   0000005C   0x8B70             LDRH     R0,[R6, #+26]
   \   0000005E   0x0480             LSLS     R0,R0,#+18
   \   00000060   0xD512             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_2
    579                  inv_decode_3_16bit_elements(fd->cpass_raw_data, fifo_ptr);
   \   00000062   0x4639             MOV      R1,R7
   \   00000064   0xF104 0x0074      ADD      R0,R4,#+116
   \   00000068   0x.... 0x....      BL       inv_decode_3_16bit_elements
    580                  inv_icm20948_apply_raw_compass_matrix(s, fd->cpass_raw_data, fd->compass);
   \   0000006C   0xF104 0x0258      ADD      R2,R4,#+88
   \   00000070   0xF104 0x0174      ADD      R1,R4,#+116
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0x.... 0x....      BL       inv_icm20948_apply_raw_compass_matrix
    581                  memcpy( fd->cpass_calibr_6chars, fifo_ptr, 6*sizeof(unsigned char));
   \   0000007A   0x2206             MOVS     R2,#+6
   \   0000007C   0x4639             MOV      R1,R7
   \   0000007E   0xF104 0x0094      ADD      R0,R4,#+148
   \   00000082   0x.... 0x....      BL       __aeabi_memcpy
    582                  fifo_ptr += CPASS_DATA_SZ;
   \   00000086   0x1DBF             ADDS     R7,R7,#+6
    583              }
    584          
    585              if(fd->header & ALS_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_2: (+1)
   \   00000088   0x8B70             LDRH     R0,[R6, #+26]
   \   0000008A   0x04C1             LSLS     R1,R0,#+19
   \   0000008C   0xD500             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_3
    586                  fifo_ptr += ALS_DATA_SZ;
   \   0000008E   0x3708             ADDS     R7,R7,#+8
    587              }
    588          
    589              if (fd->header & QUAT6_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_3: (+1)
   \   00000090   0x0500             LSLS     R0,R0,#+20
   \   00000092   0xD504             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_4
    590                  inv_decode_3_32bit_elements(fd->dmp_3e_6quat, fifo_ptr);
   \   00000094   0x4639             MOV      R1,R7
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0x.... 0x....      BL       inv_decode_3_32bit_elements
    591                  fifo_ptr += QUAT6_DATA_SZ;
   \   0000009C   0x370C             ADDS     R7,R7,#+12
    592              }
    593          
    594              if (fd->header & QUAT9_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_4: (+1)
   \   0000009E   0x8B70             LDRH     R0,[R6, #+26]
   \   000000A0   0x0540             LSLS     R0,R0,#+21
   \   000000A2   0xD50B             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_5
    595                  inv_decode_3_32bit_elements(fd->dmp_3e_9quat, fifo_ptr);
   \   000000A4   0x4639             MOV      R1,R7
   \   000000A6   0xF104 0x000C      ADD      R0,R4,#+12
   \   000000AA   0x.... 0x....      BL       inv_decode_3_32bit_elements
    596                  fd->dmp_rv_accuracyQ29 = ((0xff & fifo_ptr[12]) << 24) | ((0xff & fifo_ptr[13]) << 16);
   \   000000AE   0x7B38             LDRB     R0,[R7, #+12]
   \   000000B0   0x7B79             LDRB     R1,[R7, #+13]
   \   000000B2   0x0409             LSLS     R1,R1,#+16
   \   000000B4   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000000B8   0x61A0             STR      R0,[R4, #+24]
    597                  fifo_ptr += QUAT9_DATA_SZ;
   \   000000BA   0x370E             ADDS     R7,R7,#+14
    598              }
    599          
    600              if (fd->header & PED_STEPDET_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_5: (+1)
   \   000000BC   0x7EB0             LDRB     R0,[R6, #+26]
   \   000000BE   0x06C0             LSLS     R0,R0,#+27
   \   000000C0   0xD50D             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_6
    601                  fd->ped_step_det_ts = ((0xff & fifo_ptr[0]) << 24) | ((0xff & fifo_ptr[1]) << 16) | ((0xff & fifo_ptr[2]) << 8) | (0xff & fifo_ptr[3]);
   \   000000C2   0x7838             LDRB     R0,[R7, #+0]
   \   000000C4   0x7879             LDRB     R1,[R7, #+1]
   \   000000C6   0x0409             LSLS     R1,R1,#+16
   \   000000C8   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000000CC   0x78B9             LDRB     R1,[R7, #+2]
   \   000000CE   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000000D2   0x78F9             LDRB     R1,[R7, #+3]
   \   000000D4   0x4308             ORRS     R0,R1,R0
   \   000000D6   0xF104 0x0118      ADD      R1,R4,#+24
   \   000000DA   0x6588             STR      R0,[R1, #+88]
    602                  fifo_ptr += PED_STEPDET_TIMESTAMP_SZ;
   \   000000DC   0x1D3F             ADDS     R7,R7,#+4
    603              }
    604          
    605              if (fd->header & GEOMAG_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_6: (+1)
   \   000000DE   0x8B70             LDRH     R0,[R6, #+26]
   \   000000E0   0x05C0             LSLS     R0,R0,#+23
   \   000000E2   0xD50D             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_7
    606                  inv_decode_3_32bit_elements(fd->dmp_3e_geomagquat, fifo_ptr);
   \   000000E4   0x4639             MOV      R1,R7
   \   000000E6   0xF104 0x001C      ADD      R0,R4,#+28
   \   000000EA   0x.... 0x....      BL       inv_decode_3_32bit_elements
    607                  fd->dmp_geomag_accuracyQ29 = ((0xff & fifo_ptr[12]) << 24) | ((0xff & fifo_ptr[13]) << 16);
   \   000000EE   0x7B38             LDRB     R0,[R7, #+12]
   \   000000F0   0x7B79             LDRB     R1,[R7, #+13]
   \   000000F2   0x0409             LSLS     R1,R1,#+16
   \   000000F4   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000000F8   0xF104 0x0118      ADD      R1,R4,#+24
   \   000000FC   0x6108             STR      R0,[R1, #+16]
    608                  fifo_ptr += GEOMAG_DATA_SZ;
   \   000000FE   0x370E             ADDS     R7,R7,#+14
    609              }
    610          
    611              if(fd->header & PRESSURE_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_7: (+1)
   \   00000100   0x8B70             LDRH     R0,[R6, #+26]
   \   00000102   0x0601             LSLS     R1,R0,#+24
   \   00000104   0xD500             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_8
    612                  fifo_ptr += PRESSURE_DATA_SZ;
   \   00000106   0x1DBF             ADDS     R7,R7,#+6
    613              }
    614              if (fd->header & CPASS_CALIBR_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_8: (+1)
   \   00000108   0x0680             LSLS     R0,R0,#+26
   \   0000010A   0xD50B             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_9
    615                  inv_decode_3_32bit_elements(fd->cpass_calibr, fifo_ptr);
   \   0000010C   0x4639             MOV      R1,R7
   \   0000010E   0xF104 0x0064      ADD      R0,R4,#+100
   \   00000112   0x.... 0x....      BL       inv_decode_3_32bit_elements
    616                  memcpy( fd->cpass_calibr_12chars, fifo_ptr, 12*sizeof(unsigned char));
   \   00000116   0x220C             MOVS     R2,#+12
   \   00000118   0x4639             MOV      R1,R7
   \   0000011A   0xF104 0x0088      ADD      R0,R4,#+136
   \   0000011E   0x.... 0x....      BL       __aeabi_memcpy
    617                  fifo_ptr += CPASS_CALIBR_DATA_SZ;
   \   00000122   0x370C             ADDS     R7,R7,#+12
    618              }
    619          
    620              if (fd->header2 & ACCEL_ACCURACY_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_9: (+1)
   \   00000124   0x8BB0             LDRH     R0,[R6, #+28]
   \   00000126   0x0440             LSLS     R0,R0,#+17
   \   00000128   0xD506             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_10
    621                  fd->accel_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
   \   0000012A   0x7838             LDRB     R0,[R7, #+0]
   \   0000012C   0x7879             LDRB     R1,[R7, #+1]
   \   0000012E   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000132   0xF8A4 0x007A      STRH     R0,[R4, #+122]
    622                  fifo_ptr += ACCEL_ACCURACY_SZ;
   \   00000136   0x1CBF             ADDS     R7,R7,#+2
    623              }
    624                  
    625              if (fd->header2 & GYRO_ACCURACY_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_10: (+1)
   \   00000138   0x8BB0             LDRH     R0,[R6, #+28]
   \   0000013A   0x0480             LSLS     R0,R0,#+18
   \   0000013C   0xD507             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_11
    626                  fd->gyro_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
   \   0000013E   0x7838             LDRB     R0,[R7, #+0]
   \   00000140   0x7879             LDRB     R1,[R7, #+1]
   \   00000142   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000146   0xF104 0x017A      ADD      R1,R4,#+122
   \   0000014A   0x8048             STRH     R0,[R1, #+2]
    627                  fifo_ptr += GYRO_ACCURACY_SZ;
   \   0000014C   0x1CBF             ADDS     R7,R7,#+2
    628              }
    629           
    630              if (fd->header2 & CPASS_ACCURACY_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_11: (+1)
   \   0000014E   0x8BB0             LDRH     R0,[R6, #+28]
   \   00000150   0x04C0             LSLS     R0,R0,#+19
   \   00000152   0xD507             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_12
    631                  fd->cpass_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
   \   00000154   0x7838             LDRB     R0,[R7, #+0]
   \   00000156   0x7879             LDRB     R1,[R7, #+1]
   \   00000158   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   0000015C   0xF104 0x017A      ADD      R1,R4,#+122
   \   00000160   0x8088             STRH     R0,[R1, #+4]
    632                  fifo_ptr += CPASS_ACCURACY_SZ;
   \   00000162   0x1CBF             ADDS     R7,R7,#+2
    633              }
    634          
    635          	if (fd->header2 & FLIP_PICKUP_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_12: (+1)
   \   00000164   0x8BB0             LDRH     R0,[R6, #+28]
   \   00000166   0x0540             LSLS     R0,R0,#+21
   \   00000168   0xD505             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_13
    636          		fd->flip_pickup = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
   \   0000016A   0x7838             LDRB     R0,[R7, #+0]
   \   0000016C   0x7879             LDRB     R1,[R7, #+1]
   \   0000016E   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000172   0x80F0             STRH     R0,[R6, #+6]
    637          		fifo_ptr += FLIP_PICKUP_SZ;
   \   00000174   0x1CBF             ADDS     R7,R7,#+2
    638          	}
    639          	
    640          	if (fd->header2 & ACT_RECOG_SET) {
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_13: (+1)
   \   00000176   0x7F30             LDRB     R0,[R6, #+28]
   \   00000178   0x0600             LSLS     R0,R0,#+24
   \   0000017A   0xD510             BPL.N    ??inv_icm20948_inv_decode_one_ivory_fifo_packet_14
    641          		fd->bac_state = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
   \   0000017C   0x7838             LDRB     R0,[R7, #+0]
   \   0000017E   0x7879             LDRB     R1,[R7, #+1]
   \   00000180   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000184   0x80B0             STRH     R0,[R6, #+4]
    642          		fd->bac_ts     = ((0xff & fifo_ptr[2]) << 24) | ((0xff & fifo_ptr[3]) << 16) | ((0xff & fifo_ptr[4]) << 8) | (0xff & fifo_ptr[5]);
   \   00000186   0x78B8             LDRB     R0,[R7, #+2]
   \   00000188   0x78F9             LDRB     R1,[R7, #+3]
   \   0000018A   0x0409             LSLS     R1,R1,#+16
   \   0000018C   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000190   0x7939             LDRB     R1,[R7, #+4]
   \   00000192   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000196   0x7979             LDRB     R1,[R7, #+5]
   \   00000198   0x4308             ORRS     R0,R1,R0
   \   0000019A   0x6030             STR      R0,[R6, #+0]
    643          		fifo_ptr += ACT_RECOG_SZ;
   \   0000019C   0x1DBF             ADDS     R7,R7,#+6
    644          	}
    645          
    646          	odr_cntr = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
    647          	// odr_cntr_gyro is odr_cntr & 0xfff
    648          	// 9KHz cnt is odr_cntr >> 12
    649          	// not used for now, needed only for FSYNC purpose
    650          	(void)odr_cntr;
    651          	fifo_ptr += FOOTER_SZ;
    652          
    653              fd->new_data = 1; // Record a new data set
   \                     ??inv_icm20948_inv_decode_one_ivory_fifo_packet_14: (+1)
   \   0000019E   0x2001             MOVS     R0,#+1
   \   000001A0   0x6230             STR      R0,[R6, #+32]
    654          
    655              return fifo_ptr-fifo_ptr_start;
   \   000001A2   0x1CB8             ADDS     R0,R7,#+2
   \   000001A4   0x1B40             SUBS     R0,R0,R5
   \   000001A6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    656          }
    657          

   \                                 In section .text, align 2, keep-with-next
    658          int inv_icm20948_dmp_get_accel(long acl[3])
    659          {
   \                     inv_icm20948_dmp_get_accel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    660              if(!acl) return -1;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_accel_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    661              memcpy( acl, fd.accel, 3*sizeof(long));
   \                     ??inv_icm20948_dmp_get_accel_0: (+1)
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x....             LDR.N    R1,??DataTable19_1
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    662              return MPU_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    663          } 
    664          

   \                                 In section .text, align 2, keep-with-next
    665          int inv_icm20948_dmp_get_raw_gyro(short raw_gyro[3])
    666          {
    667              if(!raw_gyro) return -1;
   \                     inv_icm20948_dmp_get_raw_gyro: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD102             BNE.N    ??inv_icm20948_dmp_get_raw_gyro_0
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0x4770             BX       LR
    668              raw_gyro[0] = fd.gyro[0];
   \                     ??inv_icm20948_dmp_get_raw_gyro_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable19
   \   0000000C   0xF8B1 0x2040      LDRH     R2,[R1, #+64]
   \   00000010   0x8002             STRH     R2,[R0, #+0]
    669              raw_gyro[1] = fd.gyro[1];
   \   00000012   0xF8B1 0x2042      LDRH     R2,[R1, #+66]
   \   00000016   0x8042             STRH     R2,[R0, #+2]
    670              raw_gyro[2] = fd.gyro[2];
   \   00000018   0xF8B1 0x1044      LDRH     R1,[R1, #+68]
   \   0000001C   0x8081             STRH     R1,[R0, #+4]
    671              return MPU_SUCCESS;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR               ;; return
    672          }
    673          
    674          

   \                                 In section .text, align 2, keep-with-next
    675          int inv_icm20948_dmp_get_gyro_bias(short gyro_bias[3])
    676          {
   \                     inv_icm20948_dmp_get_gyro_bias: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    677              if(!gyro_bias) return -1;  
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_gyro_bias_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    678              memcpy(gyro_bias, fd.gyro_bias, 3*sizeof(short)); 
   \                     ??inv_icm20948_dmp_get_gyro_bias_0: (+1)
   \   0000000C   0x2206             MOVS     R2,#+6
   \   0000000E   0x....             LDR.N    R1,??DataTable19_2
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy
    679              return MPU_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    680          }
    681          
    682          

   \                                 In section .text, align 2, keep-with-next
    683          int inv_icm20948_dmp_get_calibrated_gyro(signed long calibratedData[3], signed long raw[3], signed long bias[3])
    684          {
   \                     inv_icm20948_dmp_get_calibrated_gyro: (+1)
   \   00000000   0xB410             PUSH     {R4}
    685              if(!calibratedData) return -1;  
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_calibrated_gyro_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xE016             B.N      ??inv_icm20948_dmp_get_calibrated_gyro_1
    686              if(!raw) return -1;  
   \                     ??inv_icm20948_dmp_get_calibrated_gyro_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??inv_icm20948_dmp_get_calibrated_gyro_2
   \   00000010   0xF04F 0x30FF      MOV      R0,#-1
   \   00000014   0xE011             B.N      ??inv_icm20948_dmp_get_calibrated_gyro_1
    687              if(!bias) return -1;  
   \                     ??inv_icm20948_dmp_get_calibrated_gyro_2: (+1)
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD102             BNE.N    ??inv_icm20948_dmp_get_calibrated_gyro_3
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0xE00C             B.N      ??inv_icm20948_dmp_get_calibrated_gyro_1
    688              
    689              calibratedData[0] = raw[0] - bias[0];
   \                     ??inv_icm20948_dmp_get_calibrated_gyro_3: (+1)
   \   00000020   0x680B             LDR      R3,[R1, #+0]
   \   00000022   0x6814             LDR      R4,[R2, #+0]
   \   00000024   0x1B1B             SUBS     R3,R3,R4
   \   00000026   0x6003             STR      R3,[R0, #+0]
    690              calibratedData[1] = raw[1] - bias[1];
   \   00000028   0x684B             LDR      R3,[R1, #+4]
   \   0000002A   0x6854             LDR      R4,[R2, #+4]
   \   0000002C   0x1B1B             SUBS     R3,R3,R4
   \   0000002E   0x6043             STR      R3,[R0, #+4]
    691              calibratedData[2] = raw[2] - bias[2];
   \   00000030   0x6889             LDR      R1,[R1, #+8]
   \   00000032   0x6892             LDR      R2,[R2, #+8]
   \   00000034   0x1A89             SUBS     R1,R1,R2
   \   00000036   0x6081             STR      R1,[R0, #+8]
    692              
    693              return MPU_SUCCESS;
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??inv_icm20948_dmp_get_calibrated_gyro_1: (+1)
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
    694          }
    695          

   \                                 In section .text, align 2, keep-with-next
    696          int inv_icm20948_dmp_get_6quaternion(long quat[3])
    697          {
   \                     inv_icm20948_dmp_get_6quaternion: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    698              if(!quat) return -1;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_6quaternion_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    699              memcpy( quat, fd.dmp_3e_6quat, sizeof(fd.dmp_3e_6quat));            
   \                     ??inv_icm20948_dmp_get_6quaternion_0: (+1)
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x....             LDR.N    R1,??DataTable19
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    700              return MPU_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    701          }
    702          

   \                                 In section .text, align 2, keep-with-next
    703          int inv_icm20948_dmp_get_9quaternion(long quat[3])
    704          {
   \                     inv_icm20948_dmp_get_9quaternion: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    705              if(!quat) return -1;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_9quaternion_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    706              memcpy( quat, fd.dmp_3e_9quat, sizeof(fd.dmp_3e_9quat));            
   \                     ??inv_icm20948_dmp_get_9quaternion_0: (+1)
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x....             LDR.N    R1,??DataTable19_3
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    707              return MPU_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    708          }
    709          

   \                                 In section .text, align 2, keep-with-next
    710          int inv_icm20948_dmp_get_gmrvquaternion(long quat[3])
    711          {
   \                     inv_icm20948_dmp_get_gmrvquaternion: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    712              if(!quat) return -1;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_gmrvquaternion_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    713              memcpy( quat, fd.dmp_3e_geomagquat, sizeof(fd.dmp_3e_geomagquat));            
   \                     ??inv_icm20948_dmp_get_gmrvquaternion_0: (+1)
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x....             LDR.N    R1,??DataTable19_4
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    714              return MPU_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    715          }
    716          

   \                                 In section .text, align 2, keep-with-next
    717          int inv_icm20948_dmp_get_raw_compass(long raw_compass[3])
    718          {
   \                     inv_icm20948_dmp_get_raw_compass: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    719              if(!raw_compass) return -1;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_raw_compass_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    720              memcpy( raw_compass, fd.compass, 3*sizeof(long)); 
   \                     ??inv_icm20948_dmp_get_raw_compass_0: (+1)
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x....             LDR.N    R1,??DataTable19_5
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    721              return MPU_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    722          }
    723          

   \                                 In section .text, align 2, keep-with-next
    724          int inv_icm20948_dmp_get_calibrated_compass(long cal_compass[3])
    725          {
   \                     inv_icm20948_dmp_get_calibrated_compass: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    726              if(!cal_compass) return -1;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??inv_icm20948_dmp_get_calibrated_compass_0
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    727              memcpy( cal_compass, fd.cpass_calibr, 3*sizeof(long));  
   \                     ??inv_icm20948_dmp_get_calibrated_compass_0: (+1)
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x....             LDR.N    R1,??DataTable19_6
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
    728              return MPU_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    729          }
    730          

   \                                 In section .text, align 2, keep-with-next
    731          int inv_icm20948_dmp_get_bac_state(uint16_t *bac_state)
    732          {
    733          	if(!bac_state) return -1;
   \                     inv_icm20948_dmp_get_bac_state: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD102             BNE.N    ??inv_icm20948_dmp_get_bac_state_0
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0x4770             BX       LR
    734          	*bac_state = fd.bac_state;
   \                     ??inv_icm20948_dmp_get_bac_state_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable19
   \   0000000C   0xF8B1 0x1084      LDRH     R1,[R1, #+132]
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    735          	return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    736          }
    737          

   \                                 In section .text, align 2, keep-with-next
    738          int inv_icm20948_dmp_get_bac_ts(long *bac_ts)
    739          {
    740          	if(!bac_ts) return -1;
   \                     inv_icm20948_dmp_get_bac_ts: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD102             BNE.N    ??inv_icm20948_dmp_get_bac_ts_0
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0x4770             BX       LR
    741          	*bac_ts = fd.bac_ts;
   \                     ??inv_icm20948_dmp_get_bac_ts_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable19
   \   0000000C   0xF8D1 0x1080      LDR      R1,[R1, #+128]
   \   00000010   0x6001             STR      R1,[R0, #+0]
    742          	return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    743          }
    744          

   \                                 In section .text, align 2, keep-with-next
    745          int inv_icm20948_dmp_get_flip_pickup_state(uint16_t *flip_pickup)
    746          {
    747          	if(!flip_pickup) return -1;
   \                     inv_icm20948_dmp_get_flip_pickup_state: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD102             BNE.N    ??inv_icm20948_dmp_get_flip_pickup_state_0
   \   00000004   0xF04F 0x30FF      MOV      R0,#-1
   \   00000008   0x4770             BX       LR
    748          	*flip_pickup = fd.flip_pickup;
   \                     ??inv_icm20948_dmp_get_flip_pickup_state_0: (+1)
   \   0000000A   0x....             LDR.N    R1,??DataTable19
   \   0000000C   0xF8B1 0x1086      LDRH     R1,[R1, #+134]
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    749          	return 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    750          }
    751          
    752          /** Returns accuracy of accel.
    753           * @return Accuracy of accel with 0 being not accurate, and 3 being most accurate.
    754          */

   \                                 In section .text, align 2, keep-with-next
    755          int inv_icm20948_get_accel_accuracy(void)
    756          {
    757          	return fd.accel_accuracy;
   \                     inv_icm20948_get_accel_accuracy: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19
   \   00000002   0xF9B0 0x007A      LDRSH    R0,[R0, #+122]
   \   00000006   0x4770             BX       LR               ;; return
    758          }
    759          
    760          /** Returns accuracy of gyro.
    761           * @return Accuracy of gyro with 0 being not accurate, and 3 being most accurate.
    762          */

   \                                 In section .text, align 2, keep-with-next
    763          int inv_icm20948_get_gyro_accuracy(void)
    764          {
    765          	return fd.gyro_accuracy;
   \                     inv_icm20948_get_gyro_accuracy: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19
   \   00000002   0xF9B0 0x007C      LDRSH    R0,[R0, #+124]
   \   00000006   0x4770             BX       LR               ;; return
    766          }
    767          
    768          /** Returns accuracy of compass.
    769           * @return Accuracy of compass with 0 being not accurate, and 3 being most accurate.
    770          */

   \                                 In section .text, align 2, keep-with-next
    771          int inv_icm20948_get_mag_accuracy(void)
    772          {
    773          	return fd.cpass_accuracy;
   \                     inv_icm20948_get_mag_accuracy: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19
   \   00000002   0xF9B0 0x007E      LDRSH    R0,[R0, #+126]
   \   00000006   0x4770             BX       LR               ;; return
    774          }
    775          
    776          /** Returns accuracy of geomagnetic rotation vector.
    777           * @return Accuracy of GMRV in Q29.
    778          */

   \                                 In section .text, align 2, keep-with-next
    779          int inv_icm20948_get_gmrv_accuracy(void)
    780          {
    781          	return fd.dmp_geomag_accuracyQ29;
   \                     inv_icm20948_get_gmrv_accuracy: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19
   \   00000002   0x6A80             LDR      R0,[R0, #+40]
   \   00000004   0x4770             BX       LR               ;; return
    782          }
    783          
    784          /** Returns accuracy of rotation vector.
    785           * @return Accuracy of RV in Q29.
    786          */

   \                                 In section .text, align 2, keep-with-next
    787          int inv_icm20948_get_rv_accuracy(void)
    788          {
    789          	return fd.dmp_rv_accuracyQ29;
   \                     inv_icm20948_get_rv_accuracy: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19
   \   00000002   0x6980             LDR      R0,[R0, #+24]
   \   00000004   0x4770             BX       LR               ;; return
    790          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     fd+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     fd+0x46

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     fd+0xC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x........         DC32     fd+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     fd+0x58

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x........         DC32     fd+0x64

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   check_fifo_decoded_headers
      24   dmp_get_fifo_all
        24   -> dmp_get_fifo_length
        24   -> dmp_read_fifo
        24   -> dmp_reset_fifo
      16   dmp_get_fifo_length
        16   -> inv_icm20948_read_mems_reg
      32   dmp_read_fifo
        32   -> dmp_reset_fifo
        32   -> inv_icm20948_read_mems_reg
      24   dmp_reset_fifo
        24   -> dmp_get_fifo_length
        24   -> inv_icm20948_mpu_set_FIFO_RST_Diamond
        24   -> inv_icm20948_write_single_mems_reg
      32   extract_sample_cnt
        32   -> check_fifo_decoded_headers
        32   -> dmp_reset_fifo
        32   -> get_packet_size_and_samplecnt
      16   get_packet_size_and_samplecnt
       0   inv_decode_3_16bit_elements
       0   inv_decode_3_32bit_elements
       8   inv_icm20948_dmp_get_6quaternion
         8   -> __aeabi_memcpy4
       8   inv_icm20948_dmp_get_9quaternion
         8   -> __aeabi_memcpy4
       8   inv_icm20948_dmp_get_accel
         8   -> __aeabi_memcpy4
       0   inv_icm20948_dmp_get_bac_state
       0   inv_icm20948_dmp_get_bac_ts
       8   inv_icm20948_dmp_get_calibrated_compass
         8   -> __aeabi_memcpy4
       4   inv_icm20948_dmp_get_calibrated_gyro
       0   inv_icm20948_dmp_get_flip_pickup_state
       8   inv_icm20948_dmp_get_gmrvquaternion
         8   -> __aeabi_memcpy4
       8   inv_icm20948_dmp_get_gyro_bias
         8   -> __aeabi_memcpy
       8   inv_icm20948_dmp_get_raw_compass
         8   -> __aeabi_memcpy4
       0   inv_icm20948_dmp_get_raw_gyro
      40   inv_icm20948_dmp_process_fifo
        40   -> __aeabi_memmove
        40   -> check_fifo_decoded_headers
        40   -> dmp_get_fifo_all
        40   -> dmp_reset_fifo
        40   -> get_packet_size_and_samplecnt
        40   -> inv_icm20948_get_tick_count
        40   -> inv_icm20948_inv_decode_one_ivory_fifo_packet
      40   inv_icm20948_fifo_pop
        40   -> __aeabi_memmove
        40   -> get_packet_size_and_samplecnt
        40   -> inv_icm20948_inv_decode_one_ivory_fifo_packet
      24   inv_icm20948_fifo_swmirror
        24   -> dmp_get_fifo_all
        24   -> extract_sample_cnt
       0   inv_icm20948_get_accel_accuracy
       0   inv_icm20948_get_gmrv_accuracy
       0   inv_icm20948_get_gyro_accuracy
       0   inv_icm20948_get_mag_accuracy
       0   inv_icm20948_get_rv_accuracy
      16   inv_icm20948_identify_interrupt
        16   -> inv_icm20948_read_mems_reg
      24   inv_icm20948_inv_decode_one_ivory_fifo_packet
        24   -> __aeabi_memcpy
        24   -> inv_decode_3_16bit_elements
        24   -> inv_decode_3_32bit_elements
        24   -> inv_icm20948_apply_raw_compass_matrix
      24   inv_icm20948_mpu_set_FIFO_RST_Diamond
        24   -> inv_icm20948_read_mems_reg
        24   -> inv_icm20948_write_mems_reg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
      36  check_fifo_decoded_headers
      90  dmp_get_fifo_all
      62  dmp_get_fifo_length
      86  dmp_read_fifo
     126  dmp_reset_fifo
     122  extract_sample_cnt
    1188  fd
          fifo_data
     314  get_packet_size_and_samplecnt
      32  inv_decode_3_16bit_elements
      68  inv_decode_3_32bit_elements
      24  inv_icm20948_dmp_get_6quaternion
      24  inv_icm20948_dmp_get_9quaternion
      24  inv_icm20948_dmp_get_accel
      22  inv_icm20948_dmp_get_bac_state
      22  inv_icm20948_dmp_get_bac_ts
      24  inv_icm20948_dmp_get_calibrated_compass
      62  inv_icm20948_dmp_get_calibrated_gyro
      22  inv_icm20948_dmp_get_flip_pickup_state
      24  inv_icm20948_dmp_get_gmrvquaternion
      24  inv_icm20948_dmp_get_gyro_bias
      24  inv_icm20948_dmp_get_raw_compass
      34  inv_icm20948_dmp_get_raw_gyro
     254  inv_icm20948_dmp_process_fifo
     124  inv_icm20948_fifo_pop
      88  inv_icm20948_fifo_swmirror
       8  inv_icm20948_get_accel_accuracy
       6  inv_icm20948_get_gmrv_accuracy
       8  inv_icm20948_get_gyro_accuracy
       8  inv_icm20948_get_mag_accuracy
       6  inv_icm20948_get_rv_accuracy
      64  inv_icm20948_identify_interrupt
     426  inv_icm20948_inv_decode_one_ivory_fifo_packet
      50  inv_icm20948_mpu_set_FIFO_RST_Diamond

 
 1 188 bytes in section .bss
 2 336 bytes in section .text
 
 2 336 bytes of CODE memory
 1 188 bytes of DATA memory

Errors: none
Warnings: none
