###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataBaseDriver.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataBaseDriver.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\Icm20948DataBaseDriver.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\Icm20948DataBaseDriver.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataBaseDriver.c
      1          /*
      2          * ________________________________________________________________________________________________________
      3          * Copyright © 2014-2015 InvenSense Inc. Portions Copyright © 2014-2015 Movea. All rights reserved.
      4          * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      5          * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright and
      6          * other intellectual property rights laws.
      7          * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
      8          * and any use, reproduction, disclosure or distribution of the Software without an express license
      9          * agreement from InvenSense is strictly prohibited.
     10          * ________________________________________________________________________________________________________
     11          */
     12          
     13          #include "Icm20948.h"
     14          #include "Icm20948DataBaseDriver.h"
     15          
     16          #include "Icm20948Defs.h"
     17          #include "Icm20948DataBaseControl.h"
     18          
     19          #include "Icm20948AuxCompassAkm.h"
     20          #include "Icm20948AuxTransport.h"
     21          #include "Icm20948Dmp3Driver.h"
     22          
     23          static unsigned char inv_is_gyro_enabled(struct inv_icm20948 * s);
     24          

   \                                 In section .text, align 2, keep-with-next
     25          void inv_icm20948_prevent_lpen_control(struct inv_icm20948 * s)
     26          {
     27          	s->sAllowLpEn = 0;
   \                     inv_icm20948_prevent_lpen_control: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x10B8      STRB     R1,[R0, #+184]
     28          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     29          void inv_icm20948_allow_lpen_control(struct inv_icm20948 * s)
     30          {
     31          	s->sAllowLpEn = 1;
   \                     inv_icm20948_allow_lpen_control: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF880 0x10B8      STRB     R1,[R0, #+184]
     32          	inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x....             B.N      inv_icm20948_set_chip_power_state
     33          }

   \                                 In section .text, align 2, keep-with-next
     34          static uint8_t inv_icm20948_get_lpen_control(struct inv_icm20948 * s)
     35          {
     36          	return s->sAllowLpEn;
   \                     inv_icm20948_get_lpen_control: (+1)
   \   00000000   0xF890 0x00B8      LDRB     R0,[R0, #+184]
   \   00000004   0x4770             BX       LR               ;; return
     37          }
     38          
     39          /*!
     40           ******************************************************************************
     41           *   @brief     This function sets the power state of the Ivory chip 
     42           *				loop
     43           *   @param[in] Function - CHIP_AWAKE, CHIP_LP_ENABLE
     44           *   @param[in] On/Off - The functions are enabled if previously disabled and 
     45                          disabled if previously enabled based on the value of On/Off.
     46           ******************************************************************************
     47           */ 

   \                                 In section .text, align 2, keep-with-next
     48          int inv_icm20948_set_chip_power_state(struct inv_icm20948 * s, unsigned char func, unsigned char on_off)
     49          {
   \                     inv_icm20948_set_chip_power_state: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
     50          	int status = 0;
   \   00000004   0x2600             MOVS     R6,#+0
     51          
     52          	switch(func) {
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD002             BEQ.N    ??inv_icm20948_set_chip_power_state_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD02B             BEQ.N    ??inv_icm20948_set_chip_power_state_1
   \   0000000E   0xE05A             B.N      ??inv_icm20948_set_chip_power_state_2
     53          
     54          		case CHIP_AWAKE:    
     55          			if(on_off){
   \                     ??inv_icm20948_set_chip_power_state_0: (+1)
   \   00000010   0xF104 0x0518      ADD      R5,R4,#+24
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD012             BEQ.N    ??inv_icm20948_set_chip_power_state_3
     56          				if((s->base_state.wake_state & CHIP_AWAKE) == 0) {// undo sleep_en
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD453             BMI.N    ??inv_icm20948_set_chip_power_state_2
     57          					s->base_state.pwr_mgmt_1 &= ~BIT_SLEEP;
   \   0000001E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000020   0xF000 0x02BF      AND      R2,R0,#0xBF
   \   00000024   0x70AA             STRB     R2,[R5, #+2]
     58          					status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
   \   00000026   0x2106             MOVS     R1,#+6
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg_core
   \   0000002E   0x4606             MOV      R6,R0
     59          					s->base_state.wake_state |= CHIP_AWAKE;
   \   00000030   0x7828             LDRB     R0,[R5, #+0]
   \   00000032   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000036   0x7028             STRB     R0,[R5, #+0]
     60          					inv_icm20948_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x.... 0x....      BL       inv_icm20948_sleep_100us
   \   0000003E   0xE042             B.N      ??inv_icm20948_set_chip_power_state_2
     61          				}
     62          			} else {
     63          				if(s->base_state.wake_state & CHIP_AWAKE) {// set sleep_en
   \                     ??inv_icm20948_set_chip_power_state_3: (+1)
   \   00000040   0x07C0             LSLS     R0,R0,#+31
   \   00000042   0xD540             BPL.N    ??inv_icm20948_set_chip_power_state_2
     64          					s->base_state.pwr_mgmt_1 |= BIT_SLEEP;
   \   00000044   0x78A8             LDRB     R0,[R5, #+2]
   \   00000046   0xF040 0x0240      ORR      R2,R0,#0x40
   \   0000004A   0x70AA             STRB     R2,[R5, #+2]
     65          					status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
   \   0000004C   0x2106             MOVS     R1,#+6
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg_core
   \   00000054   0x4606             MOV      R6,R0
     66          					s->base_state.wake_state &= ~CHIP_AWAKE;
   \   00000056   0x7828             LDRB     R0,[R5, #+0]
   \   00000058   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000005C   0x7028             STRB     R0,[R5, #+0]
     67          					inv_icm20948_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x.... 0x....      BL       inv_icm20948_sleep_100us
   \   00000064   0xE02F             B.N      ??inv_icm20948_set_chip_power_state_2
     68          				}
     69          			}
     70          		break;
     71          
     72          		case CHIP_LP_ENABLE:
     73          			if(s->base_state.lp_en_support == 1) {
   \                     ??inv_icm20948_set_chip_power_state_1: (+1)
   \   00000066   0xF104 0x0518      ADD      R5,R4,#+24
   \   0000006A   0x7BA8             LDRB     R0,[R5, #+14]
   \   0000006C   0x07C0             LSLS     R0,R0,#+31
   \   0000006E   0xD52A             BPL.N    ??inv_icm20948_set_chip_power_state_2
     74          				if(on_off) {
   \   00000070   0x2A00             CMP      R2,#+0
   \   00000072   0xD015             BEQ.N    ??inv_icm20948_set_chip_power_state_4
     75          					if( (inv_icm20948_get_lpen_control(s)) && ((s->base_state.wake_state & CHIP_LP_ENABLE) == 0)){
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       inv_icm20948_get_lpen_control
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD023             BEQ.N    ??inv_icm20948_set_chip_power_state_2
   \   0000007E   0x7828             LDRB     R0,[R5, #+0]
   \   00000080   0x0780             LSLS     R0,R0,#+30
   \   00000082   0xD420             BMI.N    ??inv_icm20948_set_chip_power_state_2
     76          						s->base_state.pwr_mgmt_1 |= BIT_LP_EN; // lp_en ON
   \   00000084   0x78A8             LDRB     R0,[R5, #+2]
   \   00000086   0xF040 0x0220      ORR      R2,R0,#0x20
   \   0000008A   0x70AA             STRB     R2,[R5, #+2]
     77          						status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
   \   0000008C   0x2106             MOVS     R1,#+6
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg_core
   \   00000094   0x4606             MOV      R6,R0
     78          						s->base_state.wake_state |= CHIP_LP_ENABLE;
   \   00000096   0x7828             LDRB     R0,[R5, #+0]
   \   00000098   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000009C   0x7028             STRB     R0,[R5, #+0]
   \   0000009E   0xE012             B.N      ??inv_icm20948_set_chip_power_state_2
     79          					}
     80          				} else {
     81          					if(s->base_state.wake_state & CHIP_LP_ENABLE){
   \                     ??inv_icm20948_set_chip_power_state_4: (+1)
   \   000000A0   0x7828             LDRB     R0,[R5, #+0]
   \   000000A2   0x0780             LSLS     R0,R0,#+30
   \   000000A4   0xD50F             BPL.N    ??inv_icm20948_set_chip_power_state_2
     82          						s->base_state.pwr_mgmt_1 &= ~BIT_LP_EN; // lp_en off
   \   000000A6   0x78A8             LDRB     R0,[R5, #+2]
   \   000000A8   0xF000 0x02DF      AND      R2,R0,#0xDF
   \   000000AC   0x70AA             STRB     R2,[R5, #+2]
     83          						status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
   \   000000AE   0x2106             MOVS     R1,#+6
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg_core
   \   000000B6   0x4606             MOV      R6,R0
     84          						s->base_state.wake_state &= ~CHIP_LP_ENABLE;
   \   000000B8   0x7828             LDRB     R0,[R5, #+0]
   \   000000BA   0xF000 0x00FD      AND      R0,R0,#0xFD
   \   000000BE   0x7028             STRB     R0,[R5, #+0]
     85          						inv_icm20948_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x.... 0x....      BL       inv_icm20948_sleep_100us
     86          					}
     87          				}
     88          			}
     89          		break;
     90          
     91          		default:
     92          		break;
     93          
     94          	}// end switch
     95          
     96          	return status;
   \                     ??inv_icm20948_set_chip_power_state_2: (+1)
   \   000000C6   0x4630             MOV      R0,R6
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
     97          }
     98          
     99          /*!
    100           ******************************************************************************
    101           *   @return    Current wake status of the Ivory chip.
    102           ******************************************************************************
    103           */

   \                                 In section .text, align 2, keep-with-next
    104          uint8_t inv_icm20948_get_chip_power_state(struct inv_icm20948 * s)
    105          {
    106          	return s->base_state.wake_state;
   \                     inv_icm20948_get_chip_power_state: (+1)
   \   00000000   0x7E00             LDRB     R0,[R0, #+24]
   \   00000002   0x4770             BX       LR               ;; return
    107          }
    108          
    109          /** Wakes up DMP3 (SMARTSENSOR).
    110          */

   \                                 In section .text, align 2, keep-with-next
    111          int inv_icm20948_wakeup_mems(struct inv_icm20948 * s)
    112          {
   \                     inv_icm20948_wakeup_mems: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    113          	unsigned char data;
    114          	int result = 0;
    115          
    116          	result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x4611             MOV      R1,R2
   \   0000000A   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   0000000E   0x4606             MOV      R6,R0
    117          
    118          	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
   \   00000010   0xF104 0x051C      ADD      R5,R4,#+28
   \   00000014   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD107             BNE.N    ??inv_icm20948_wakeup_mems_0
    119          		s->base_state.user_ctrl |= BIT_I2C_IF_DIS;
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0xF040 0x0210      ORR      R2,R0,#0x10
   \   00000020   0x702A             STRB     R2,[R5, #+0]
    120          		inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);  
   \   00000022   0x2103             MOVS     R1,#+3
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
    121          	}
    122          
    123          	data = 0x47;	// FIXME, should set up according to sensor/engines enabled.
   \                     ??inv_icm20948_wakeup_mems_0: (+1)
   \   0000002A   0x2047             MOVS     R0,#+71
   \   0000002C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    124          	result |= inv_icm20948_write_mems_reg(s, REG_PWR_MGMT_2, 1, &data);
   \   00000030   0x466B             MOV      R3,SP
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x2107             MOVS     R1,#+7
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   0000003C   0x4306             ORRS     R6,R0,R6
    125          
    126          	if(s->base_state.firmware_loaded == 1) {
   \   0000003E   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000040   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD008             BEQ.N    ??inv_icm20948_wakeup_mems_1
    127          		s->base_state.user_ctrl |= BIT_DMP_EN | BIT_FIFO_EN;
   \   00000048   0x7828             LDRB     R0,[R5, #+0]
   \   0000004A   0xF040 0x02C0      ORR      R2,R0,#0xC0
   \   0000004E   0x702A             STRB     R2,[R5, #+0]
    128          		result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);  
   \   00000050   0x2103             MOVS     R1,#+3
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   00000058   0x4306             ORRS     R6,R0,R6
    129          	}
    130          
    131          	result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
   \                     ??inv_icm20948_wakeup_mems_1: (+1)
   \   0000005A   0x2201             MOVS     R2,#+1
   \   0000005C   0x2102             MOVS     R1,#+2
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000064   0x4330             ORRS     R0,R0,R6
    132          	return result;
   \   00000066   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    133          }
    134          
    135          /** Puts DMP3 (SMARTSENSOR) into the lowest power state. Assumes sensors are all off.
    136          */

   \                                 In section .text, align 2, keep-with-next
    137          int inv_icm20948_sleep_mems(struct inv_icm20948 * s)
    138          {
   \                     inv_icm20948_sleep_mems: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    139          	int result;
    140          	unsigned char data;
    141          
    142          	data = 0x7F;
   \   00000004   0x207F             MOVS     R0,#+127
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    143          	result = inv_icm20948_write_mems_reg(s, REG_PWR_MGMT_2, 1, &data);
   \   0000000A   0x466B             MOV      R3,SP
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x2107             MOVS     R1,#+7
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000016   0x4605             MOV      R5,R0
    144          
    145          	result |= inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 0);
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
   \   00000022   0x4328             ORRS     R0,R0,R5
    146          
    147          	return result;
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    148          }
    149          

   \                                 In section .text, align 2, keep-with-next
    150          int inv_icm20948_set_dmp_address(struct inv_icm20948 * s)
    151          {
   \                     inv_icm20948_set_dmp_address: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    152          	int result;
    153          	unsigned char dmp_cfg[2] = {0};
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    154          	unsigned short config;
    155          
    156          	// Write DMP Start address
    157          	inv_icm20948_get_dmp_start_address(s, &config);
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       inv_icm20948_get_dmp_start_address
    158          	/* setup DMP start address and firmware */
    159          	dmp_cfg[0] = (unsigned char)((config >> 8) & 0xff);
   \   00000014   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000018   0x0A00             LSRS     R0,R0,#+8
   \   0000001A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    160          	dmp_cfg[1] = (unsigned char)(config & 0xff);
   \   0000001E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000022   0xF88D 0x0003      STRB     R0,[SP, #+3]
    161          
    162          	result = inv_icm20948_write_mems_reg(s, REG_PRGM_START_ADDRH, 2, dmp_cfg);
    163          	return result;
   \   00000026   0xF10D 0x0302      ADD      R3,SP,#+2
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0xF44F 0x71A8      MOV      R1,#+336
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000036   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    164          }
    165          
    166          /**
    167          *  @brief      Set up the secondary I2C bus on 20630.
    168          *  @param[in]  MPU state varible
    169          *  @return     0 if successful.
    170          */
    171          

   \                                 In section .text, align 2, keep-with-next
    172          int inv_icm20948_set_secondary(struct inv_icm20948 * s)
    173          {
   \                     inv_icm20948_set_secondary: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    174          	int r = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    175          	static uint8_t lIsInited = 0;
    176          
    177          	if(lIsInited == 0) {
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable6
   \   0000000A   0x7829             LDRB     R1,[R5, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD10F             BNE.N    ??inv_icm20948_set_secondary_0
    178          		r  = inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_CTRL, BIT_I2C_MST_P_NSR);
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0xF240 0x1181      MOVW     R1,#+385
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   0000001C   0x4606             MOV      R6,R0
    179          		r |= inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, MIN_MST_ODR_CONFIG);
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0xF44F 0x71C0      MOV      R1,#+384
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   0000002A   0x4330             ORRS     R0,R0,R6
    180          
    181          		lIsInited = 1;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x7029             STRB     R1,[R5, #+0]
    182          	}
    183          	return r;
   \                     ??inv_icm20948_set_secondary_0: (+1)
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    184          }

   \                                 In section .bss, align 1
   \                     `inv_icm20948_set_secondary::lIsInited`:
   \   00000000                      DS8 1
    185          

   \                                 In section .text, align 2, keep-with-next
    186          int inv_icm20948_enter_duty_cycle_mode(struct inv_icm20948 * s)
    187          {
   \                     inv_icm20948_enter_duty_cycle_mode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    188          	/* secondary cycle mode should be set all the time */
    189          	unsigned char data  = BIT_I2C_MST_CYCLE|BIT_ACCEL_CYCLE|BIT_GYRO_CYCLE;
   \   00000002   0x2170             MOVS     R1,#+112
   \   00000004   0xF88D 0x1000      STRB     R1,[SP, #+0]
    190          
    191          	s->base_state.chip_lp_ln_mode = CHIP_LOW_POWER_ICM20948;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7641             STRB     R1,[R0, #+25]
    192          	return inv_icm20948_write_mems_reg(s, REG_LP_CONFIG, 1, &data);
   \   0000000C   0x466B             MOV      R3,SP
   \   0000000E   0x460A             MOV      R2,R1
   \   00000010   0x2105             MOVS     R1,#+5
   \   00000012   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    193          }
    194          

   \                                 In section .text, align 2, keep-with-next
    195          int inv_icm20948_enter_low_noise_mode(struct inv_icm20948 * s)
    196          {
   \                     inv_icm20948_enter_low_noise_mode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    197          	/* secondary cycle mode should be set all the time */
    198          	unsigned char data  = BIT_I2C_MST_CYCLE;
   \   00000002   0x2140             MOVS     R1,#+64
   \   00000004   0xF88D 0x1000      STRB     R1,[SP, #+0]
    199          
    200          	s->base_state.chip_lp_ln_mode = CHIP_LOW_NOISE_ICM20948;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7641             STRB     R1,[R0, #+25]
    201          	return inv_icm20948_write_mems_reg(s, REG_LP_CONFIG, 1, &data);
   \   0000000C   0x466B             MOV      R3,SP
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2105             MOVS     R1,#+5
   \   00000012   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    202          }
    203          
    204          /** Should be called once on power up. Loads DMP3, initializes internal variables needed 
    205          *   for other lower driver functions.
    206          */

   \                                 In section .text, align 2, keep-with-next
    207          int inv_icm20948_initialize_lower_driver(struct inv_icm20948 * s, enum SMARTSENSOR_SERIAL_INTERFACE type, 
    208          	const uint8_t *dmp3_image, uint32_t dmp3_image_size)
    209          {
   \                     inv_icm20948_initialize_lower_driver: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
    210          	int result = 0;
    211          	static unsigned char data;
    212          	// set static variable
    213          	s->sAllowLpEn = 1;
   \   0000000C   0xF104 0x00B8      ADD      R0,R4,#+184
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    214          	s->s_compass_available = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7041             STRB     R1,[R0, #+1]
    215          	// ICM20948 do not support the proximity sensor for the moment.
    216          	// s_proximity_available variable is nerver changes
    217          	s->s_proximity_available = 0;
   \   00000018   0x7081             STRB     R1,[R0, #+2]
    218          
    219          	// Set varialbes to default values
    220          	memset(&s->base_state, 0, sizeof(s->base_state));
   \   0000001A   0x460A             MOV      R2,R1
   \   0000001C   0x2112             MOVS     R1,#+18
   \   0000001E   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000022   0x.... 0x....      BL       __aeabi_memset4
    221          	s->base_state.pwr_mgmt_1 = BIT_CLK_PLL;
   \   00000026   0xF104 0x071A      ADD      R7,R4,#+26
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x7038             STRB     R0,[R7, #+0]
    222          	s->base_state.pwr_mgmt_2 = BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY | BIT_PWR_PRESSURE_STBY;
   \   0000002E   0x207F             MOVS     R0,#+127
   \   00000030   0x7078             STRB     R0,[R7, #+1]
    223          	s->base_state.serial_interface = type;
   \   00000032   0xF887 0x800D      STRB     R8,[R7, #+13]
    224          	result |= inv_icm20948_read_mems_reg(s, REG_USER_CTRL, 1, &s->base_state.user_ctrl);
   \   00000036   0xF104 0x031C      ADD      R3,R4,#+28
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x2103             MOVS     R1,#+3
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   00000044   0x4680             MOV      R8,R0
    225          
    226          	result |= inv_icm20948_wakeup_mems(s);
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       inv_icm20948_wakeup_mems
   \   0000004C   0xEA40 0x0908      ORR      R9,R0,R8
    227          
    228          	result |= inv_icm20948_read_mems_reg(s, REG_WHO_AM_I, 1, &data);
   \   00000050   0x.... 0x....      LDR.W    R8,??DataTable6_1
   \   00000054   0x4643             MOV      R3,R8
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   00000060   0xEA40 0x0909      ORR      R9,R0,R9
    229          
    230          	/* secondary cycle mode should be set all the time */
    231          	data = BIT_I2C_MST_CYCLE|BIT_ACCEL_CYCLE|BIT_GYRO_CYCLE;
   \   00000064   0x2070             MOVS     R0,#+112
   \   00000066   0xF888 0x0000      STRB     R0,[R8, #+0]
    232          
    233          	// Set default mode to low power mode
    234          	result |= inv_icm20948_set_lowpower_or_highperformance(s, 0);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       inv_icm20948_set_lowpower_or_highperformance
   \   00000072   0xEA40 0x0909      ORR      R9,R0,R9
    235          	
    236          	// Disable Ivory DMP.
    237          	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI)   
   \   00000076   0x7B78             LDRB     R0,[R7, #+13]
   \   00000078   0x2802             CMP      R0,#+2
   \   0000007A   0xD102             BNE.N    ??inv_icm20948_initialize_lower_driver_0
    238          		s->base_state.user_ctrl = BIT_I2C_IF_DIS;
   \   0000007C   0x2010             MOVS     R0,#+16
   \   0000007E   0x70B8             STRB     R0,[R7, #+2]
   \   00000080   0xE001             B.N      ??inv_icm20948_initialize_lower_driver_1
    239          	else
    240          		s->base_state.user_ctrl = 0;
   \                     ??inv_icm20948_initialize_lower_driver_0: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x70B8             STRB     R0,[R7, #+2]
    241          
    242          	result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
   \                     ??inv_icm20948_initialize_lower_driver_1: (+1)
   \   00000086   0x78BA             LDRB     R2,[R7, #+2]
   \   00000088   0x2103             MOVS     R1,#+3
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   00000090   0xEA40 0x0909      ORR      R9,R0,R9
    243          
    244          	//Setup Ivory DMP.
    245          	result |= inv_icm20948_load_firmware(s, dmp3_image, dmp3_image_size);
   \   00000094   0x4632             MOV      R2,R6
   \   00000096   0x4629             MOV      R1,R5
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       inv_icm20948_load_firmware
   \   0000009E   0xEA50 0x0009      ORRS     R0,R0,R9
    246          	if(result)
   \   000000A2   0xF040 0x8080      BNE.W    ??inv_icm20948_initialize_lower_driver_2
    247          		return result;
    248          	else
    249          		s->base_state.firmware_loaded = 1;
   \   000000A6   0x7B38             LDRB     R0,[R7, #+12]
   \   000000A8   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000AC   0x7338             STRB     R0,[R7, #+12]
    250          	result |= inv_icm20948_set_dmp_address(s);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       inv_icm20948_set_dmp_address
   \   000000B4   0x4605             MOV      R5,R0
    251          	// Turn off all sensors on DMP by default.
    252          	//result |= dmp_set_data_output_control1(0);   // FIXME in DMP, these should be off by default.
    253          	result |= dmp_icm20948_reset_control_registers(s);
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       dmp_icm20948_reset_control_registers
   \   000000BC   0x4305             ORRS     R5,R0,R5
    254          	
    255          	// set FIFO watermark to 80% of actual FIFO size
    256          	result |= dmp_icm20948_set_FIFO_watermark(s, 800);
   \   000000BE   0xF44F 0x7148      MOV      R1,#+800
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       dmp_icm20948_set_FIFO_watermark
   \   000000C8   0x4305             ORRS     R5,R0,R5
    257          
    258          	// Enable Interrupts.
    259          	data = 0x2;
   \   000000CA   0x2002             MOVS     R0,#+2
   \   000000CC   0xF888 0x0000      STRB     R0,[R8, #+0]
    260          	result |= inv_icm20948_write_mems_reg(s, REG_INT_ENABLE, 1, &data); // Enable DMP Interrupt
   \   000000D0   0x4643             MOV      R3,R8
   \   000000D2   0x2201             MOVS     R2,#+1
   \   000000D4   0x2110             MOVS     R1,#+16
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   000000DC   0x4305             ORRS     R5,R0,R5
    261          	data = 0x1;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0xF888 0x0000      STRB     R0,[R8, #+0]
    262          	result |= inv_icm20948_write_mems_reg(s, REG_INT_ENABLE_2, 1, &data); // Enable FIFO Overflow Interrupt
   \   000000E4   0x4643             MOV      R3,R8
   \   000000E6   0x4602             MOV      R2,R0
   \   000000E8   0x2112             MOVS     R1,#+18
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   000000F0   0x4305             ORRS     R5,R0,R5
    263          
    264          	// TRACKING : To have accelerometers datas and the interrupt without gyro enables.
    265          	data = 0XE4;
   \   000000F2   0x20E4             MOVS     R0,#+228
   \   000000F4   0xF888 0x0000      STRB     R0,[R8, #+0]
    266          	result |= inv_icm20948_write_mems_reg(s, REG_SINGLE_FIFO_PRIORITY_SEL, 1, &data);
   \   000000F8   0x4643             MOV      R3,R8
   \   000000FA   0x2201             MOVS     R2,#+1
   \   000000FC   0x2126             MOVS     R1,#+38
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000104   0x4305             ORRS     R5,R0,R5
    267          
    268          	// Disable HW temp fix
    269          	inv_icm20948_read_mems_reg(s, REG_HW_FIX_DISABLE,1,&data);
   \   00000106   0x4643             MOV      R3,R8
   \   00000108   0x2201             MOVS     R2,#+1
   \   0000010A   0x2175             MOVS     R1,#+117
   \   0000010C   0x4620             MOV      R0,R4
   \   0000010E   0x.... 0x....      BL       inv_icm20948_read_mems_reg
    270          	data |= 0x08;
   \   00000112   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000116   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000011A   0xF888 0x0000      STRB     R0,[R8, #+0]
    271          	inv_icm20948_write_mems_reg(s, REG_HW_FIX_DISABLE,1,&data);
   \   0000011E   0x4643             MOV      R3,R8
   \   00000120   0x2201             MOVS     R2,#+1
   \   00000122   0x2175             MOVS     R1,#+117
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       inv_icm20948_write_mems_reg
    272          
    273          	// Setup MEMs properties.
    274          	s->base_state.accel_averaging = 1; //Change this value if higher sensor sample avergaing is required.
   \   0000012A   0x2001             MOVS     R0,#+1
   \   0000012C   0x7278             STRB     R0,[R7, #+9]
    275          	s->base_state.gyro_averaging = 1;  //Change this value if higher sensor sample avergaing is required.
   \   0000012E   0x7238             STRB     R0,[R7, #+8]
    276          	inv_icm20948_set_gyro_divider(s, FIFO_DIVIDER);       //Initial sampling rate 1125Hz/19+1 = 56Hz.
   \   00000130   0x2113             MOVS     R1,#+19
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       inv_icm20948_set_gyro_divider
    277          	inv_icm20948_set_accel_divider(s, FIFO_DIVIDER);      //Initial sampling rate 1125Hz/19+1 = 56Hz.
   \   00000138   0x2113             MOVS     R1,#+19
   \   0000013A   0x4620             MOV      R0,R4
   \   0000013C   0x.... 0x....      BL       inv_icm20948_set_accel_divider
    278          
    279          	// Init the sample rate to 56 Hz for BAC,STEPC and B2S
    280          	dmp_icm20948_set_bac_rate(s, DMP_ALGO_FREQ_56);
   \   00000140   0x2138             MOVS     R1,#+56
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0x.... 0x....      BL       dmp_icm20948_set_bac_rate
    281          	dmp_icm20948_set_b2s_rate(s, DMP_ALGO_FREQ_56);
   \   00000148   0x2138             MOVS     R1,#+56
   \   0000014A   0x4620             MOV      R0,R4
   \   0000014C   0x.... 0x....      BL       dmp_icm20948_set_b2s_rate
    282          
    283          	// FIFO Setup.
    284          	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_CFG, BIT_SINGLE_FIFO_CFG); // FIFO Config. fixme do once? burst write?
   \   00000150   0x2200             MOVS     R2,#+0
   \   00000152   0x2176             MOVS     R1,#+118
   \   00000154   0x4620             MOV      R0,R4
   \   00000156   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   0000015A   0x4305             ORRS     R5,R0,R5
    285          	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_RST, 0x1f); // Reset all FIFOs.
   \   0000015C   0x221F             MOVS     R2,#+31
   \   0000015E   0x2168             MOVS     R1,#+104
   \   00000160   0x4620             MOV      R0,R4
   \   00000162   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   00000166   0x4305             ORRS     R5,R0,R5
    286          	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_RST, 0x1e); // Keep all but Gyro FIFO in reset.
   \   00000168   0x221E             MOVS     R2,#+30
   \   0000016A   0x2168             MOVS     R1,#+104
   \   0000016C   0x4620             MOV      R0,R4
   \   0000016E   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   00000172   0x4305             ORRS     R5,R0,R5
    287          	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_EN, 0x0); // Slave FIFO turned off.
   \   00000174   0x2200             MOVS     R2,#+0
   \   00000176   0x2166             MOVS     R1,#+102
   \   00000178   0x4620             MOV      R0,R4
   \   0000017A   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   0000017E   0x4305             ORRS     R5,R0,R5
    288          	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_EN_2, 0x0); // Hardware FIFO turned off.
   \   00000180   0x2200             MOVS     R2,#+0
   \   00000182   0x2167             MOVS     R1,#+103
   \   00000184   0x4620             MOV      R0,R4
   \   00000186   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   0000018A   0x4305             ORRS     R5,R0,R5
    289              
    290          	s->base_state.lp_en_support = 1;
   \   0000018C   0x7B38             LDRB     R0,[R7, #+12]
   \   0000018E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000192   0x7338             STRB     R0,[R7, #+12]
    291          	
    292          	if(s->base_state.lp_en_support == 1)
    293          		inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
   \   00000194   0x2201             MOVS     R2,#+1
   \   00000196   0x2102             MOVS     R1,#+2
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       inv_icm20948_set_chip_power_state
    294          
    295          	result |= inv_icm20948_sleep_mems(s);   
   \   0000019E   0x4620             MOV      R0,R4
   \   000001A0   0x.... 0x....      BL       inv_icm20948_sleep_mems
   \   000001A4   0x4328             ORRS     R0,R0,R5
    296                  
    297          	return result;
   \                     ??inv_icm20948_initialize_lower_driver_2: (+1)
   \   000001A6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    298          }

   \                                 In section .bss, align 1
   \                     `inv_icm20948_initialize_lower_driver::data`:
   \   00000000                      DS8 1
    299          

   \                                 In section .text, align 2, keep-with-next
    300          static void activate_compass(struct inv_icm20948 * s)
    301          {
    302          	s->s_compass_available = 1;
   \                     activate_compass: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF880 0x10B9      STRB     R1,[R0, #+185]
    303          }
   \   00000006   0x4770             BX       LR               ;; return
    304          

   \                                 In section .text, align 2, keep-with-next
    305          static void desactivate_compass(struct inv_icm20948 * s)
    306          {
    307          	s->s_compass_available = 0;
   \                     desactivate_compass: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x10B9      STRB     R1,[R0, #+185]
    308          }
   \   00000006   0x4770             BX       LR               ;; return
    309          

   \                                 In section .text, align 2, keep-with-next
    310          int inv_icm20948_get_compass_availability(struct inv_icm20948 * s)
    311          {
    312          	return s->s_compass_available;
   \                     inv_icm20948_get_compass_availability: (+1)
   \   00000000   0xF890 0x00B9      LDRB     R0,[R0, #+185]
   \   00000004   0x4770             BX       LR               ;; return
    313          }
    314          
    315          // return true 1 if gyro was enabled, otherwise false 0

   \                                 In section .text, align 2, keep-with-next
    316          static unsigned char inv_is_gyro_enabled(struct inv_icm20948 * s)
    317          {
    318          	if ((s->inv_androidSensorsOn_mask[0] & INV_NEEDS_GYRO_MASK) || (s->inv_androidSensorsOn_mask[1] & INV_NEEDS_GYRO_MASK1))
   \                     inv_is_gyro_enabled: (+1)
   \   00000000   0xF44F 0x71B0      MOV      R1,#+352
   \   00000004   0x4408             ADD      R0,R0,R1
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x....             LDR.N    R2,??DataTable6_2  ;; 0xe6018e18
   \   0000000A   0x4211             TST      R1,R2
   \   0000000C   0xD104             BNE.N    ??inv_is_gyro_enabled_0
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0xF640 0x0118      MOVW     R1,#+2072
   \   00000014   0x4208             TST      R0,R1
   \   00000016   0xD001             BEQ.N    ??inv_is_gyro_enabled_1
    319          		return 1;
   \                     ??inv_is_gyro_enabled_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR
    320          	return 0;
   \                     ??inv_is_gyro_enabled_1: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
    321          }
    322          

   \                                 In section .text, align 2, keep-with-next
    323          int inv_icm20948_get_proximity_availability(struct inv_icm20948 * s)
    324          {
    325          	return s->s_proximity_available;
   \                     inv_icm20948_get_proximity_availability: (+1)
   \   00000000   0xF890 0x00BA      LDRB     R0,[R0, #+186]
   \   00000004   0x4770             BX       LR               ;; return
    326          }
    327          

   \                                 In section .text, align 2, keep-with-next
    328          int inv_icm20948_set_slave_compass_id(struct inv_icm20948 * s, int id)
    329          {
   \                     inv_icm20948_set_slave_compass_id: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    330          	int result = 0;
    331          	(void)id;
    332          
    333          	//result = inv_icm20948_wakeup_mems(s);
    334          	//if (result)
    335          	//	return result;
    336          		
    337          	inv_icm20948_prevent_lpen_control(s);
   \   00000004   0x.... 0x....      BL       inv_icm20948_prevent_lpen_control
    338          	activate_compass(s);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       activate_compass
    339          	
    340          	inv_icm20948_init_secondary(s);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       inv_icm20948_init_secondary
    341          
    342          	// Set up the secondary I2C bus on 20630.
    343          	inv_icm20948_set_secondary(s);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       inv_icm20948_set_secondary
    344          
    345          	//Setup Compass
    346          	result = inv_icm20948_setup_compass_akm(s);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       inv_icm20948_setup_compass_akm
   \   00000020   0x4605             MOV      R5,R0
    347          
    348          	//Setup Compass mounting matrix into DMP
    349          	result |= inv_icm20948_compass_dmp_cal(s, s->mounting_matrix, s->mounting_matrix_secondary_compass);
   \   00000022   0xF204 0x227D      ADDW     R2,R4,#+637
   \   00000026   0xF44F 0x701D      MOV      R0,#+628
   \   0000002A   0x1821             ADDS     R1,R4,R0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       inv_icm20948_compass_dmp_cal
   \   00000032   0x4305             ORRS     R5,R0,R5
    350          	
    351          	if (result)
   \   00000034   0xD002             BEQ.N    ??inv_icm20948_set_slave_compass_id_0
    352          		desactivate_compass(s);
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       desactivate_compass
    353          
    354          	//result = inv_icm20948_sleep_mems(s);
    355          	inv_icm20948_allow_lpen_control(s);
   \                     ??inv_icm20948_set_slave_compass_id_0: (+1)
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       inv_icm20948_allow_lpen_control
    356          	return result;
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    357          }
    358          

   \                                 In section .text, align 2, keep-with-next
    359          int inv_icm20948_set_gyro_divider(struct inv_icm20948 * s, unsigned char div)
    360          {
   \                     inv_icm20948_set_gyro_divider: (+1)
   \   00000000   0xB502             PUSH     {R1,LR}
    361          	s->base_state.gyro_div = div;
   \   00000002   0x7741             STRB     R1,[R0, #+29]
    362          	return inv_icm20948_write_mems_reg(s, REG_GYRO_SMPLRT_DIV, 1, &div);
   \   00000004   0x466B             MOV      R3,SP
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF44F 0x7180      MOV      R1,#+256
   \   0000000C   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    363          }
    364          

   \                                 In section .text, align 2, keep-with-next
    365          unsigned char inv_icm20948_get_gyro_divider(struct inv_icm20948 * s)
    366          {
    367          	return s->base_state.gyro_div;
   \                     inv_icm20948_get_gyro_divider: (+1)
   \   00000000   0x7F40             LDRB     R0,[R0, #+29]
   \   00000002   0x4770             BX       LR               ;; return
    368          }
    369          

   \                                 In section .text, align 2, keep-with-next
    370          int inv_icm20948_set_secondary_divider(struct inv_icm20948 * s, unsigned char div)
    371          {
    372          	s->base_state.secondary_div = 1UL<<div;
   \                     inv_icm20948_set_secondary_divider: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x408A             LSLS     R2,R2,R1
   \   00000004   0x83C2             STRH     R2,[R0, #+30]
    373          	return inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, div);
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0xF44F 0x71C0      MOV      R1,#+384
   \   0000000C   0x.... 0x....      B.W      inv_icm20948_write_single_mems_reg
    374          }
    375          

   \                                 In section .text, align 2, keep-with-next
    376          unsigned short inv_icm20948_get_secondary_divider(struct inv_icm20948 * s)
    377          {
    378          	return s->base_state.secondary_div;
   \                     inv_icm20948_get_secondary_divider: (+1)
   \   00000000   0x8BC0             LDRH     R0,[R0, #+30]
   \   00000002   0x4770             BX       LR               ;; return
    379          }
    380          

   \                                 In section .text, align 2, keep-with-next
    381          int inv_icm20948_set_accel_divider(struct inv_icm20948 * s, short div)
    382          {
   \                     inv_icm20948_set_accel_divider: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    383          	unsigned char data[2] = {0};
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    384          
    385          	s->base_state.accel_div = div;
   \   00000008   0x8401             STRH     R1,[R0, #+32]
    386          	data[0] = (unsigned char)(div >> 8);
   \   0000000A   0x120A             ASRS     R2,R1,#+8
   \   0000000C   0xF88D 0x2000      STRB     R2,[SP, #+0]
    387          	data[1] = (unsigned char)(div & 0xff);
   \   00000010   0xF88D 0x1001      STRB     R1,[SP, #+1]
    388          
    389          	return inv_icm20948_write_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, 2, data);
   \   00000014   0x466B             MOV      R3,SP
   \   00000016   0x2202             MOVS     R2,#+2
   \   00000018   0xF44F 0x7188      MOV      R1,#+272
   \   0000001C   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
    390          }
    391          

   \                                 In section .text, align 2, keep-with-next
    392          short inv_icm20948_get_accel_divider(struct inv_icm20948 * s)
    393          {
    394          	return s->base_state.accel_div;
   \                     inv_icm20948_get_accel_divider: (+1)
   \   00000000   0xF9B0 0x0020      LDRSH    R0,[R0, #+32]
   \   00000004   0x4770             BX       LR               ;; return
    395          }
    396          
    397          /*
    398           You can obtain the real odr in Milliseconds, Micro Seconds or Ticks.
    399           Use the enum values: ODR_IN_Ms, ODR_IN_Us or ODR_IN_Ticks,
    400           when calling inv_icm20948_get_odr_in_units().
    401          */

   \                                 In section .text, align 2, keep-with-next
    402          uint32_t inv_icm20948_get_odr_in_units(struct inv_icm20948 * s, unsigned short odrInDivider, unsigned char odr_units )
    403          {
   \                     inv_icm20948_get_odr_in_units: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4614             MOV      R4,R2
    404          	unsigned long odr=0;
   \   0000000A   0x2500             MOVS     R5,#+0
    405          	unsigned long Us=0;
    406          	unsigned char PLL=0, gyro_is_on=0;
    407          
    408          	if(s->base_state.timebase_correction_pll == 0)
   \   0000000C   0xF898 0x0028      LDRB     R0,[R8, #+40]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD106             BNE.N    ??inv_icm20948_get_odr_in_units_0
    409          		inv_icm20948_read_mems_reg(s, REG_TIMEBASE_CORRECTION_PLL, 1, &s->base_state.timebase_correction_pll);
   \   00000014   0xF108 0x0328      ADD      R3,R8,#+40
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x21A8             MOVS     R1,#+168
   \   0000001C   0x4640             MOV      R0,R8
   \   0000001E   0x.... 0x....      BL       inv_icm20948_read_mems_reg
    410          	
    411          	PLL = s->base_state.timebase_correction_pll;
   \                     ??inv_icm20948_get_odr_in_units_0: (+1)
   \   00000022   0xF898 0x6028      LDRB     R6,[R8, #+40]
    412          
    413          	// check if Gyro is currently enabled
    414          	gyro_is_on = inv_is_gyro_enabled(s);
   \   00000026   0x4640             MOV      R0,R8
   \   00000028   0x.... 0x....      BL       inv_is_gyro_enabled
    415          
    416          	if( PLL < 0x80 ) { // correction positive
   \   0000002C   0x2E80             CMP      R6,#+128
   \   0000002E   0xDA10             BGE.N    ??inv_icm20948_get_odr_in_units_1
    417          		// In Micro Seconds
    418          		Us = (odrInDivider*1000000L/1125L) * (1270L)/(1270L+ (gyro_is_on ? PLL : 0));
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD100             BNE.N    ??inv_icm20948_get_odr_in_units_2
   \   00000034   0x462E             MOV      R6,R5
   \                     ??inv_icm20948_get_odr_in_units_2: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable6_3  ;; 0xf4240
   \   00000038   0x4378             MULS     R0,R0,R7
   \   0000003A   0xF240 0x4165      MOVW     R1,#+1125
   \   0000003E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000042   0xF240 0x41F6      MOVW     R1,#+1270
   \   00000046   0x4348             MULS     R0,R1,R0
   \   00000048   0xF206 0x41F6      ADDW     R1,R6,#+1270
   \   0000004C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000050   0xE011             B.N      ??inv_icm20948_get_odr_in_units_3
    419          	} 
    420          	else {
    421          		PLL &= 0x7F;
    422          
    423          		// In Micro Seconds 
    424          		Us = (odrInDivider*1000000L/1125L) * (1270L)/(1270L-(gyro_is_on ? PLL : 0));
   \                     ??inv_icm20948_get_odr_in_units_1: (+1)
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD002             BEQ.N    ??inv_icm20948_get_odr_in_units_4
   \   00000056   0xF006 0x007F      AND      R0,R6,#0x7F
   \   0000005A   0xE000             B.N      ??inv_icm20948_get_odr_in_units_5
   \                     ??inv_icm20948_get_odr_in_units_4: (+1)
   \   0000005C   0x4628             MOV      R0,R5
   \                     ??inv_icm20948_get_odr_in_units_5: (+1)
   \   0000005E   0x....             LDR.N    R1,??DataTable6_3  ;; 0xf4240
   \   00000060   0x4379             MULS     R1,R1,R7
   \   00000062   0xF240 0x4265      MOVW     R2,#+1125
   \   00000066   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000006A   0xF240 0x42F6      MOVW     R2,#+1270
   \   0000006E   0x4351             MULS     R1,R2,R1
   \   00000070   0x1A10             SUBS     R0,R2,R0
   \   00000072   0xFB91 0xF0F0      SDIV     R0,R1,R0
    425          	}
    426          
    427          	switch( odr_units ) {
   \                     ??inv_icm20948_get_odr_in_units_3: (+1)
   \   00000076   0x2C00             CMP      R4,#+0
   \   00000078   0xD003             BEQ.N    ??inv_icm20948_get_odr_in_units_6
   \   0000007A   0x2C02             CMP      R4,#+2
   \   0000007C   0xD008             BEQ.N    ??inv_icm20948_get_odr_in_units_7
   \   0000007E   0xD305             BCC.N    ??inv_icm20948_get_odr_in_units_8
   \   00000080   0xE00D             B.N      ??inv_icm20948_get_odr_in_units_9
    428          		// ret in Milliseconds 
    429          		case ODR_IN_Ms:
    430          			odr = Us/1000;
   \                     ??inv_icm20948_get_odr_in_units_6: (+1)
   \   00000082   0xF44F 0x717A      MOV      R1,#+1000
   \   00000086   0xFBB0 0xF5F1      UDIV     R5,R0,R1
    431          			break;
   \   0000008A   0xE008             B.N      ??inv_icm20948_get_odr_in_units_9
    432          
    433          		// ret in Micro
    434          		case ODR_IN_Us:
    435          			odr = Us;
   \                     ??inv_icm20948_get_odr_in_units_8: (+1)
   \   0000008C   0x4605             MOV      R5,R0
    436          			break;
   \   0000008E   0xE006             B.N      ??inv_icm20948_get_odr_in_units_9
    437          
    438          		// ret in Ticks
    439          		case ODR_IN_Ticks:
    440          			odr = (Us/1000) * (32768/1125);// According to Mars
   \                     ??inv_icm20948_get_odr_in_units_7: (+1)
   \   00000090   0xF44F 0x717A      MOV      R1,#+1000
   \   00000094   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000098   0x211D             MOVS     R1,#+29
   \   0000009A   0xFB01 0xF500      MUL      R5,R1,R0
    441          			break;
    442          	}
    443          
    444          	return odr;
   \                     ??inv_icm20948_get_odr_in_units_9: (+1)
   \   0000009E   0x4628             MOV      R0,R5
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    445          }
    446           
    447          /**
    448          * Sets the DMP for a particular gyro configuration.
    449          * @param[in] gyro_div Value written to GYRO_SMPLRT_DIV register, where
    450          *            0=1125Hz sample rate, 1=562.5Hz sample rate, ... 4=225Hz sample rate, ...
    451          *            10=102.2727Hz sample rate, ... etc.
    452          * @param[in] gyro_level 0=250 dps, 1=500 dps, 2=1000 dps, 3=2000 dps
    453          */

   \                                 In section .text, align 2, keep-with-next
    454          int inv_icm20948_set_gyro_sf(struct inv_icm20948 * s, unsigned char div, int gyro_level)
    455          {
   \                     inv_icm20948_set_gyro_sf: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    456          	long gyro_sf;
    457          	static long lLastGyroSf = 0;
    458          	int result = 0;
   \   00000008   0x2400             MOVS     R4,#+0
    459          
    460          	if(s->base_state.timebase_correction_pll == 0)
   \   0000000A   0xF895 0x0028      LDRB     R0,[R5, #+40]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD107             BNE.N    ??inv_icm20948_set_gyro_sf_0
    461          		result |= inv_icm20948_read_mems_reg(s, REG_TIMEBASE_CORRECTION_PLL, 1, &s->base_state.timebase_correction_pll);
   \   00000012   0xF105 0x0328      ADD      R3,R5,#+40
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x21A8             MOVS     R1,#+168
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   00000020   0x4604             MOV      R4,R0
   \                     ??inv_icm20948_set_gyro_sf_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x463A             MOV      R2,R7
   \   00000028   0x.... 0x....      BL       __aeabi_llsl
   \   0000002C   0x1C72             ADDS     R2,R6,#+1
   \   0000002E   0x17D3             ASRS     R3,R2,#+31
   \   00000030   0xFBA2 0x6700      UMULL    R6,R7,R2,R0
   \   00000034   0xFB02 0x7701      MLA      R7,R2,R1,R7
   \   00000038   0xFB03 0x7700      MLA      R7,R3,R0,R7
   \   0000003C   0x....             LDR.N    R2,??DataTable6_4  ;; 0x566675af
   \   0000003E   0xF24F 0x0383      MOVW     R3,#+61571
   \   00000042   0xFBA2 0x0106      UMULL    R0,R1,R2,R6
   \   00000046   0xFB02 0x1107      MLA      R1,R2,R7,R1
   \   0000004A   0xFB03 0x1106      MLA      R1,R3,R6,R1
   \   0000004E   0xF895 0x2028      LDRB     R2,[R5, #+40]
   \   00000052   0x0613             LSLS     R3,R2,#+24
   \   00000054   0xD50C             BPL.N    ??inv_icm20948_set_gyro_sf_1
    462          
    463          	{
    464          		unsigned long long const MagicConstant = 264446880937391LL;
    465          		unsigned long long const MagicConstantScale = 100000LL;
    466          		unsigned long long ResultLL;
    467          
    468          		if (s->base_state.timebase_correction_pll & 0x80) {
    469          			ResultLL = (MagicConstant * (long long)(1ULL << gyro_level) * (1 + div) / (1270 - (s->base_state.timebase_correction_pll & 0x7F)) / MagicConstantScale);
   \   00000056   0xF240 0x43F6      MOVW     R3,#+1270
   \   0000005A   0xF002 0x027F      AND      R2,R2,#0x7F
   \   0000005E   0x1A9A             SUBS     R2,R3,R2
   \   00000060   0x17D3             ASRS     R3,R2,#+31
   \   00000062   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000066   0x....             LDR.N    R2,??DataTable6_5  ;; 0x186a0
   \   00000068   0x2300             MOVS     R3,#+0
   \   0000006A   0x.... 0x....      BL       __aeabi_uldivmod
   \   0000006E   0xE008             B.N      ??inv_icm20948_set_gyro_sf_2
    470          		}
    471          		else {
    472          			ResultLL = (MagicConstant * (long long)(1ULL << gyro_level) * (1 + div) / (1270 + s->base_state.timebase_correction_pll) / MagicConstantScale);
   \                     ??inv_icm20948_set_gyro_sf_1: (+1)
   \   00000070   0xF202 0x42F6      ADDW     R2,R2,#+1270
   \   00000074   0x17D3             ASRS     R3,R2,#+31
   \   00000076   0x.... 0x....      BL       __aeabi_uldivmod
   \   0000007A   0x....             LDR.N    R2,??DataTable6_5  ;; 0x186a0
   \   0000007C   0x2300             MOVS     R3,#+0
   \   0000007E   0x.... 0x....      BL       __aeabi_uldivmod
    473          		}
    474          		/*
    475          		    In above deprecated FP version, worst case arguments can produce a result that overflows a signed long.
    476          		    Here, for such cases, we emulate the FP behavior of setting the result to the maximum positive value, as
    477          		    the compiler's conversion of a u64 to an s32 is simple truncation of the u64's high half, sadly....
    478          		*/
    479          		if  (ResultLL > 0x7FFFFFFF) 
   \                     ??inv_icm20948_set_gyro_sf_2: (+1)
   \   00000082   0xF04F 0x4200      MOV      R2,#-2147483648
   \   00000086   0x2300             MOVS     R3,#+0
   \   00000088   0x4299             CMP      R1,R3
   \   0000008A   0xD305             BCC.N    ??inv_icm20948_set_gyro_sf_3
   \   0000008C   0xD801             BHI.N    ??inv_icm20948_set_gyro_sf_4
   \   0000008E   0x4290             CMP      R0,R2
   \   00000090   0xD302             BCC.N    ??inv_icm20948_set_gyro_sf_3
    480          			gyro_sf = 0x7FFFFFFF;
   \                     ??inv_icm20948_set_gyro_sf_4: (+1)
   \   00000092   0xF06F 0x4600      MVN      R6,#-2147483648
   \   00000096   0xE000             B.N      ??inv_icm20948_set_gyro_sf_5
    481          		else
    482          			gyro_sf = (long)ResultLL;
   \                     ??inv_icm20948_set_gyro_sf_3: (+1)
   \   00000098   0x4606             MOV      R6,R0
    483          	}
    484          
    485          	if (gyro_sf != lLastGyroSf) {
   \                     ??inv_icm20948_set_gyro_sf_5: (+1)
   \   0000009A   0x....             LDR.N    R7,??DataTable6_6
   \   0000009C   0x6838             LDR      R0,[R7, #+0]
   \   0000009E   0x4286             CMP      R6,R0
   \   000000A0   0xD005             BEQ.N    ??inv_icm20948_set_gyro_sf_6
    486          		result |= dmp_icm20948_set_gyro_sf(s, gyro_sf);
   \   000000A2   0x4631             MOV      R1,R6
   \   000000A4   0x4628             MOV      R0,R5
   \   000000A6   0x.... 0x....      BL       dmp_icm20948_set_gyro_sf
   \   000000AA   0x4304             ORRS     R4,R0,R4
    487          		lLastGyroSf = gyro_sf;
   \   000000AC   0x603E             STR      R6,[R7, #+0]
    488          	}
    489          
    490          	return result;
   \                     ??inv_icm20948_set_gyro_sf_6: (+1)
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    491          }

   \                                 In section .bss, align 4
   \                     `inv_icm20948_set_gyro_sf::lLastGyroSf`:
   \   00000000                      DS8 4
    492          

   \                                 In section .text, align 2, keep-with-next
    493          int inv_icm20948_set_gyro_fullscale(struct inv_icm20948 * s, int level)
    494          {
   \                     inv_icm20948_set_gyro_fullscale: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    495          	int result;
    496          	s->base_state.gyro_fullscale = level;
   \   00000006   0xF104 0x061D      ADD      R6,R4,#+29
   \   0000000A   0x71F5             STRB     R5,[R6, #+7]
    497          	result = inv_icm20948_set_icm20948_gyro_fullscale(s, level);
   \   0000000C   0x.... 0x....      BL       inv_icm20948_set_icm20948_gyro_fullscale
   \   00000010   0x4607             MOV      R7,R0
    498          	result |= inv_icm20948_set_gyro_sf(s, s->base_state.gyro_div, level);
   \   00000012   0x462A             MOV      R2,R5
   \   00000014   0x7831             LDRB     R1,[R6, #+0]
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_set_gyro_sf
   \   0000001C   0x4338             ORRS     R0,R0,R7
    499          
    500          	return result;
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    501          }
    502          

   \                                 In section .text, align 2, keep-with-next
    503          uint8_t inv_icm20948_get_gyro_fullscale(struct inv_icm20948 * s)
    504          {
    505          	return s->base_state.gyro_fullscale;
   \                     inv_icm20948_get_gyro_fullscale: (+1)
   \   00000000   0xF890 0x0024      LDRB     R0,[R0, #+36]
   \   00000004   0x4770             BX       LR               ;; return
    506          }
    507          
    508          

   \                                 In section .text, align 2, keep-with-next
    509          int inv_icm20948_set_icm20948_gyro_fullscale(struct inv_icm20948 * s, int level)
    510          {
   \                     inv_icm20948_set_icm20948_gyro_fullscale: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
    511          	int result = 0;
    512          	unsigned char gyro_config_1_reg;
    513          	unsigned char gyro_config_2_reg;
    514          	unsigned char dec3_cfg;
    515          	if (level >= NUM_MPU_GFS)
   \   00000006   0x2F04             CMP      R7,#+4
   \   00000008   0xDB02             BLT.N    ??inv_icm20948_set_icm20948_gyro_fullscale_0
    516          		return -1;
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
    517          
    518          	result |= inv_icm20948_read_mems_reg(s, REG_GYRO_CONFIG_1, 1, &gyro_config_1_reg);
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_0: (+1)
   \   00000010   0xF240 0x1501      MOVW     R5,#+257
   \   00000014   0xF10D 0x0301      ADD      R3,SP,#+1
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   00000020   0x4606             MOV      R6,R0
    519          	gyro_config_1_reg &= 0xC0;
    520          	gyro_config_1_reg |= (level << 1) | 1;  //fchoice = 1, filter = 0.
   \   00000022   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000026   0xF000 0x00C0      AND      R0,R0,#0xC0
   \   0000002A   0xEA40 0x0047      ORR      R0,R0,R7, LSL #+1
   \   0000002E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000032   0xF88D 0x0001      STRB     R0,[SP, #+1]
    521          	result |= inv_icm20948_write_mems_reg(s, REG_GYRO_CONFIG_1, 1, &gyro_config_1_reg);
   \   00000036   0xF10D 0x0301      ADD      R3,SP,#+1
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   00000044   0xEA40 0x0506      ORR      R5,R0,R6
    522          
    523          	result |= inv_icm20948_read_mems_reg(s, REG_GYRO_CONFIG_2, 1, &gyro_config_2_reg);
   \   00000048   0x466B             MOV      R3,SP
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0xF44F 0x7181      MOV      R1,#+258
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   00000056   0x4305             ORRS     R5,R0,R5
    524          	gyro_config_2_reg &= 0xF8;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0xF000 0x00F8      AND      R0,R0,#0xF8
   \   00000060   0xF88D 0x0000      STRB     R0,[SP, #+0]
    525          	
    526          	switch(s->base_state.gyro_averaging) {
   \   00000064   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   00000068   0x2802             CMP      R0,#+2
   \   0000006A   0xD00C             BEQ.N    ??inv_icm20948_set_icm20948_gyro_fullscale_1
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD00C             BEQ.N    ??inv_icm20948_set_icm20948_gyro_fullscale_2
   \   00000070   0x2808             CMP      R0,#+8
   \   00000072   0xD00C             BEQ.N    ??inv_icm20948_set_icm20948_gyro_fullscale_3
   \   00000074   0x2810             CMP      R0,#+16
   \   00000076   0xD00C             BEQ.N    ??inv_icm20948_set_icm20948_gyro_fullscale_4
   \   00000078   0x2820             CMP      R0,#+32
   \   0000007A   0xD00C             BEQ.N    ??inv_icm20948_set_icm20948_gyro_fullscale_5
   \   0000007C   0x2840             CMP      R0,#+64
   \   0000007E   0xD00C             BEQ.N    ??inv_icm20948_set_icm20948_gyro_fullscale_6
   \   00000080   0x2880             CMP      R0,#+128
   \   00000082   0xD00C             BEQ.N    ??inv_icm20948_set_icm20948_gyro_fullscale_7
   \   00000084   0xE00D             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_8
    527          		case 1:
    528          			dec3_cfg = 0;
    529          			break;
    530          
    531          		case 2:
    532          			dec3_cfg = 1;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_1: (+1)
   \   00000086   0x2001             MOVS     R0,#+1
    533          			break;
   \   00000088   0xE00C             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_9
    534          
    535          		case 4:
    536          			dec3_cfg = 2;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_2: (+1)
   \   0000008A   0x2002             MOVS     R0,#+2
    537          			break;
   \   0000008C   0xE00A             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_9
    538          
    539          		case 8:
    540          			dec3_cfg = 3;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_3: (+1)
   \   0000008E   0x2003             MOVS     R0,#+3
    541          			break;
   \   00000090   0xE008             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_9
    542          
    543          		case 16:
    544          			dec3_cfg = 4;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_4: (+1)
   \   00000092   0x2004             MOVS     R0,#+4
    545          			break;
   \   00000094   0xE006             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_9
    546          
    547          		case 32:
    548          			dec3_cfg = 5;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_5: (+1)
   \   00000096   0x2005             MOVS     R0,#+5
    549          			break;
   \   00000098   0xE004             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_9
    550          
    551          		case 64:
    552          			dec3_cfg = 6;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_6: (+1)
   \   0000009A   0x2006             MOVS     R0,#+6
    553          			break;
   \   0000009C   0xE002             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_9
    554          
    555          		case 128:
    556          			dec3_cfg = 7;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_7: (+1)
   \   0000009E   0x2007             MOVS     R0,#+7
    557          			break;
   \   000000A0   0xE000             B.N      ??inv_icm20948_set_icm20948_gyro_fullscale_9
    558          
    559          		default:
    560          			dec3_cfg = 0;
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_8: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
    561          			break;
    562          	}
    563          	gyro_config_2_reg |= dec3_cfg;  
   \                     ??inv_icm20948_set_icm20948_gyro_fullscale_9: (+1)
   \   000000A4   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000A8   0x4308             ORRS     R0,R0,R1
   \   000000AA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    564          	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_CONFIG_2, gyro_config_2_reg);
   \   000000AE   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   000000B2   0xF44F 0x7181      MOV      R1,#+258
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   000000BC   0x4328             ORRS     R0,R0,R5
    565          	return result;
   \   000000BE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    566          }
    567          
    568          

   \                                 In section .text, align 2, keep-with-next
    569          int inv_icm20948_set_accel_fullscale(struct inv_icm20948 * s, int level)
    570          {
   \                     inv_icm20948_set_accel_fullscale: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    571          	int result;
    572          	s->base_state.accel_fullscale = level;
   \   00000006   0xF884 0x5025      STRB     R5,[R4, #+37]
    573          	result = inv_icm20948_set_icm20948_accel_fullscale(s, level);
   \   0000000A   0x.... 0x....      BL       inv_icm20948_set_icm20948_accel_fullscale
   \   0000000E   0x4606             MOV      R6,R0
    574          	result |= dmp_icm20948_set_accel_fsr(s, 2<<level);
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xFA00 0xF505      LSL      R5,R0,R5
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0xB209             SXTH     R1,R1
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       dmp_icm20948_set_accel_fsr
   \   00000020   0x4306             ORRS     R6,R0,R6
    575          	result |= dmp_icm20948_set_accel_scale2(s, 2<<level);
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB209             SXTH     R1,R1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       dmp_icm20948_set_accel_scale2
   \   0000002C   0x4330             ORRS     R0,R0,R6
    576          	return result;
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    577          }
    578          

   \                                 In section .text, align 2, keep-with-next
    579          uint8_t inv_icm20948_get_accel_fullscale(struct inv_icm20948 * s)
    580          {
    581          	return s->base_state.accel_fullscale;
   \                     inv_icm20948_get_accel_fullscale: (+1)
   \   00000000   0xF890 0x0025      LDRB     R0,[R0, #+37]
   \   00000004   0x4770             BX       LR               ;; return
    582          }
    583          
    584          

   \                                 In section .text, align 2, keep-with-next
    585          int inv_icm20948_set_icm20948_accel_fullscale(struct inv_icm20948 * s, int level)
    586          {
   \                     inv_icm20948_set_icm20948_accel_fullscale: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    587          	int result = 0;
    588          	unsigned char accel_config_1_reg;
    589          	unsigned char accel_config_2_reg;
    590          	unsigned char dec3_cfg;
    591          
    592          	if (level >= NUM_MPU_AFS)
   \   00000006   0x2E04             CMP      R6,#+4
   \   00000008   0xDB02             BLT.N    ??inv_icm20948_set_icm20948_accel_fullscale_0
    593          		return -1;
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
    594          
    595          	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_CONFIG, 1, &accel_config_1_reg);
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_0: (+1)
   \   00000010   0x466B             MOV      R3,SP
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xF44F 0x718A      MOV      R1,#+276
   \   00000018   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   0000001C   0x4605             MOV      R5,R0
    596          	accel_config_1_reg &= 0xC0;
   \   0000001E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000022   0xF000 0x00C0      AND      R0,R0,#0xC0
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
    597          
    598          	if(s->base_state.accel_averaging > 1)
   \   0000002A   0x0070             LSLS     R0,R6,#+1
   \   0000002C   0xF894 0x1023      LDRB     R1,[R4, #+35]
   \   00000030   0x2902             CMP      R1,#+2
   \   00000032   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000036   0xDB05             BLT.N    ??inv_icm20948_set_icm20948_accel_fullscale_1
    599          		accel_config_1_reg |= (7 << 3) | (level << 1) | 1;   //fchoice = 1, filter = 7.
   \   00000038   0xF040 0x0039      ORR      R0,R0,#0x39
   \   0000003C   0x4308             ORRS     R0,R0,R1
   \   0000003E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000042   0xE002             B.N      ??inv_icm20948_set_icm20948_accel_fullscale_2
    600          	else
    601          		accel_config_1_reg |= (level << 1) | 0;  //fchoice = 0, filter = 0.
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_1: (+1)
   \   00000044   0x4308             ORRS     R0,R0,R1
   \   00000046   0xF88D 0x0000      STRB     R0,[SP, #+0]
    602          	/* /!\ FCHOICE=0 considers we are in low power mode always and allows us to have correct values on raw data since not averaged,
    603          	in case low noise mode is to be supported for 20649, please reconsider this value and update base sample rate from 1125 to 4500...
    604          	*/
    605          	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG, accel_config_1_reg);
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_2: (+1)
   \   0000004A   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000004E   0xF44F 0x718A      MOV      R1,#+276
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   00000058   0xEA40 0x0605      ORR      R6,R0,R5
    606          
    607          	switch(s->base_state.accel_averaging) {
   \   0000005C   0xF894 0x0023      LDRB     R0,[R4, #+35]
   \   00000060   0x2808             CMP      R0,#+8
   \   00000062   0xD004             BEQ.N    ??inv_icm20948_set_icm20948_accel_fullscale_3
   \   00000064   0x2810             CMP      R0,#+16
   \   00000066   0xD004             BEQ.N    ??inv_icm20948_set_icm20948_accel_fullscale_4
   \   00000068   0x2820             CMP      R0,#+32
   \   0000006A   0xD004             BEQ.N    ??inv_icm20948_set_icm20948_accel_fullscale_5
   \   0000006C   0xE005             B.N      ??inv_icm20948_set_icm20948_accel_fullscale_6
    608          		case 1:
    609          			dec3_cfg = 0;
    610          			break;
    611          
    612          		case 4:
    613          			dec3_cfg = 0;
    614          			break;
    615          		
    616          		case 8:
    617          			dec3_cfg = 1;
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_3: (+1)
   \   0000006E   0x2701             MOVS     R7,#+1
    618          			break;
   \   00000070   0xE004             B.N      ??inv_icm20948_set_icm20948_accel_fullscale_7
    619          	
    620          		case 16:
    621          			dec3_cfg = 2;
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_4: (+1)
   \   00000072   0x2702             MOVS     R7,#+2
    622          			break;
   \   00000074   0xE002             B.N      ??inv_icm20948_set_icm20948_accel_fullscale_7
    623          		
    624          		case 32:
    625          			dec3_cfg = 3;
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_5: (+1)
   \   00000076   0x2703             MOVS     R7,#+3
    626          			break;
   \   00000078   0xE000             B.N      ??inv_icm20948_set_icm20948_accel_fullscale_7
    627          
    628          		default:
    629          			dec3_cfg = 0;
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_6: (+1)
   \   0000007A   0x2700             MOVS     R7,#+0
    630          			break;
    631          	}
    632          
    633          	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_CONFIG_2, 1, &accel_config_2_reg);
   \                     ??inv_icm20948_set_icm20948_accel_fullscale_7: (+1)
   \   0000007C   0xF240 0x1515      MOVW     R5,#+277
   \   00000080   0xF10D 0x0301      ADD      R3,SP,#+1
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x4629             MOV      R1,R5
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   0000008E   0x4306             ORRS     R6,R0,R6
    634          	accel_config_2_reg &= 0xFC;
    635          
    636          	accel_config_2_reg |=  dec3_cfg;
   \   00000090   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000094   0xF000 0x00FC      AND      R0,R0,#0xFC
   \   00000098   0x4338             ORRS     R0,R7,R0
   \   0000009A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    637          	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, accel_config_2_reg);
   \   0000009E   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000A2   0x4629             MOV      R1,R5
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   000000AA   0x4330             ORRS     R0,R0,R6
    638          
    639          	return result;
   \   000000AC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    640          }
    641          
    642          

   \                                 In section .text, align 2, keep-with-next
    643          int inv_icm20948_enable_hw_sensors(struct inv_icm20948 * s, int bit_mask)
    644          {
   \                     inv_icm20948_enable_hw_sensors: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    645          	int rc = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    646          
    647          	if ((s->base_state.pwr_mgmt_2 == (BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY | BIT_PWR_PRESSURE_STBY)) | (bit_mask & 0x80)) {
   \   00000008   0x7EE0             LDRB     R0,[R4, #+27]
   \   0000000A   0x287F             CMP      R0,#+127
   \   0000000C   0xD101             BNE.N    ??inv_icm20948_enable_hw_sensors_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??inv_icm20948_enable_hw_sensors_1
   \                     ??inv_icm20948_enable_hw_sensors_0: (+1)
   \   00000012   0x4630             MOV      R0,R6
   \                     ??inv_icm20948_enable_hw_sensors_1: (+1)
   \   00000014   0xF005 0x0180      AND      R1,R5,#0x80
   \   00000018   0x4308             ORRS     R0,R1,R0
   \   0000001A   0xD019             BEQ.N    ??inv_icm20948_enable_hw_sensors_2
    648          		// All sensors off, or override is on
    649          		s->base_state.pwr_mgmt_2 = 0; // Zero means all sensors are on
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x76E0             STRB     R0,[R4, #+27]
    650          		// Gyro and Accel were off
    651          		if ((bit_mask & 2) == 0) {
   \   00000020   0x07A8             LSLS     R0,R5,#+30
   \   00000022   0xD401             BMI.N    ??inv_icm20948_enable_hw_sensors_3
    652          			s->base_state.pwr_mgmt_2 = BIT_PWR_ACCEL_STBY; // Turn off accel
   \   00000024   0x2038             MOVS     R0,#+56
   \   00000026   0x76E0             STRB     R0,[R4, #+27]
    653          		}
    654          		if ((bit_mask & 1) == 0) {
   \                     ??inv_icm20948_enable_hw_sensors_3: (+1)
   \   00000028   0x07E8             LSLS     R0,R5,#+31
   \   0000002A   0xD403             BMI.N    ??inv_icm20948_enable_hw_sensors_4
    655          			s->base_state.pwr_mgmt_2 |= BIT_PWR_GYRO_STBY; // Turn off gyro
   \   0000002C   0x7EE0             LDRB     R0,[R4, #+27]
   \   0000002E   0xF040 0x0007      ORR      R0,R0,#0x7
   \   00000032   0x76E0             STRB     R0,[R4, #+27]
    656          		}
    657          		if ((bit_mask & 4) == 0) {
   \                     ??inv_icm20948_enable_hw_sensors_4: (+1)
   \   00000034   0x0768             LSLS     R0,R5,#+29
   \   00000036   0xD403             BMI.N    ??inv_icm20948_enable_hw_sensors_5
    658          			s->base_state.pwr_mgmt_2 |= BIT_PWR_PRESSURE_STBY; // Turn off pressure
   \   00000038   0x7EE0             LDRB     R0,[R4, #+27]
   \   0000003A   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000003E   0x76E0             STRB     R0,[R4, #+27]
    659          		}
    660          
    661          		rc |= inv_icm20948_write_mems_reg(s, REG_PWR_MGMT_2, 1, &s->base_state.pwr_mgmt_2);
   \                     ??inv_icm20948_enable_hw_sensors_5: (+1)
   \   00000040   0xF104 0x031B      ADD      R3,R4,#+27
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x2107             MOVS     R1,#+7
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       inv_icm20948_write_mems_reg
   \   0000004E   0x4606             MOV      R6,R0
    662          	}
    663          
    664          	if (bit_mask & SECONDARY_COMPASS_AVAILABLE) {
   \                     ??inv_icm20948_enable_hw_sensors_2: (+1)
   \   00000050   0x0728             LSLS     R0,R5,#+28
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0xD503             BPL.N    ??inv_icm20948_enable_hw_sensors_6
    665          		rc |= inv_icm20948_resume_akm(s);
   \   00000056   0x.... 0x....      BL       inv_icm20948_resume_akm
   \   0000005A   0x4330             ORRS     R0,R0,R6
   \   0000005C   0xBD70             POP      {R4-R6,PC}
    666          	} 
    667          	else {
    668          		rc |= inv_icm20948_suspend_akm(s);
   \                     ??inv_icm20948_enable_hw_sensors_6: (+1)
   \   0000005E   0x.... 0x....      BL       inv_icm20948_suspend_akm
   \   00000062   0x4330             ORRS     R0,R0,R6
    669          	}
    670          
    671          	return rc;
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    672          }
    673          

   \                                 In section .text, align 2, keep-with-next
    674          int inv_icm20948_set_serial_comm(struct inv_icm20948 * s, enum SMARTSENSOR_SERIAL_INTERFACE type)
    675          {
    676          	s->base_state.serial_interface = type;
   \                     inv_icm20948_set_serial_comm: (+1)
   \   00000000   0xF880 0x1027      STRB     R1,[R0, #+39]
    677          
    678          	return 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR               ;; return
    679          }
    680          
    681          

   \                                 In section .text, align 2, keep-with-next
    682          int inv_icm20948_set_int1_assertion(struct inv_icm20948 * s, int enable)
    683          {
   \                     inv_icm20948_set_int1_assertion: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
    684          	int   result = 0;
    685          	// unsigned char reg_pin_cfg;
    686          	unsigned char reg_int_enable;
    687          
    688          	// INT1 held until interrupt status is cleared
    689          	/*
    690          	result         |= inv_icm20948_read_mems_reg(s, REG_INT_PIN_CFG, 1, &reg_pin_cfg);
    691          	reg_pin_cfg    |= BIT_INT_LATCH_EN ;	// Latchen : BIT5 held the IT until register is read
    692          	result         |= inv_icm20948_write_single_mems_reg(s, REG_INT_PIN_CFG, reg_pin_cfg);
    693          	*/
    694          
    695          	// Set int1 enable
    696          	result |= inv_icm20948_read_mems_reg(s, REG_INT_ENABLE, 1, &reg_int_enable);
   \   00000008   0x466B             MOV      R3,SP
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x.... 0x....      BL       inv_icm20948_read_mems_reg
   \   00000012   0x4605             MOV      R5,R0
    697          
    698          	if(enable) { // Enable bit
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001A   0xD004             BEQ.N    ??inv_icm20948_set_int1_assertion_0
    699          		reg_int_enable |= BIT_DMP_INT_EN;
   \   0000001C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000024   0xE003             B.N      ??inv_icm20948_set_int1_assertion_1
    700          	}
    701          	else { // Disable bit
    702          		reg_int_enable &= ~BIT_DMP_INT_EN;
   \                     ??inv_icm20948_set_int1_assertion_0: (+1)
   \   00000026   0xF000 0x00FD      AND      R0,R0,#0xFD
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    703          	}
    704          
    705          	result |= inv_icm20948_write_single_mems_reg(s, REG_INT_ENABLE, reg_int_enable);
   \                     ??inv_icm20948_set_int1_assertion_1: (+1)
   \   0000002E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000032   0x2110             MOVS     R1,#+16
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
   \   0000003A   0x4328             ORRS     R0,R0,R5
    706          
    707          	return result;
   \   0000003C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    708          }
    709          
    710          
    711          /**
    712          *  @brief      Read accel data stored in hw reg
    713          *  @param[in]  level  See mpu_accel_fs
    714          *  @return     0 if successful
    715          */

   \                                 In section .text, align 2, keep-with-next
    716          int inv_icm20948_accel_read_hw_reg_data(struct inv_icm20948 * s, short accel_hw_reg_data[3])
    717          {
   \                     inv_icm20948_accel_read_hw_reg_data: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    718          	int result = 0;
    719          	uint8_t accel_data[6]; // Store 6 bytes for that
    720          
    721          	// read mem regs
    722          	result = inv_icm20948_read_mems_reg(s, REG_ACCEL_XOUT_H_SH, 6, (unsigned char *) &accel_data);
   \   00000004   0x466B             MOV      R3,SP
   \   00000006   0x2206             MOVS     R2,#+6
   \   00000008   0x212D             MOVS     R1,#+45
   \   0000000A   0x.... 0x....      BL       inv_icm20948_read_mems_reg
    723          
    724          	// Assign axys !
    725          	accel_hw_reg_data[0] = (accel_data[0] << 8) + accel_data[1];
   \   0000000E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000012   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000016   0xEB12 0x2101      ADDS     R1,R2,R1, LSL #+8
   \   0000001A   0x8021             STRH     R1,[R4, #+0]
    726          	accel_hw_reg_data[1] = (accel_data[2] << 8) + accel_data[3];
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x788A             LDRB     R2,[R1, #+2]
   \   00000020   0xF89D 0x3003      LDRB     R3,[SP, #+3]
   \   00000024   0xEB13 0x2202      ADDS     R2,R3,R2, LSL #+8
   \   00000028   0x8062             STRH     R2,[R4, #+2]
    727          	accel_hw_reg_data[2] = (accel_data[4] << 8) + accel_data[5];
   \   0000002A   0x7909             LDRB     R1,[R1, #+4]
   \   0000002C   0xF89D 0x2005      LDRB     R2,[SP, #+5]
   \   00000030   0xEB12 0x2101      ADDS     R1,R2,R1, LSL #+8
   \   00000034   0x80A1             STRH     R1,[R4, #+4]
    728          
    729          	return result;
   \   00000036   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    730          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     `inv_icm20948_set_secondary::lIsInited`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     `inv_icm20948_initialize_lower_driver::data`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0xE6018E18         DC32     0xe6018e18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x566675AF         DC32     0x566675af

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     `inv_icm20948_set_gyro_sf::lLastGyroSf`

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_1:
   \   00000000   0x00 0x00          DC8 0, 0
    731          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   activate_compass
       0   desactivate_compass
      16   inv_icm20948_accel_read_hw_reg_data
        16   -> inv_icm20948_read_mems_reg
       0   inv_icm20948_allow_lpen_control
         0   -> inv_icm20948_set_chip_power_state
      16   inv_icm20948_enable_hw_sensors
        16   -> inv_icm20948_resume_akm
        16   -> inv_icm20948_suspend_akm
        16   -> inv_icm20948_write_mems_reg
       8   inv_icm20948_enter_duty_cycle_mode
         8   -> inv_icm20948_write_mems_reg
       8   inv_icm20948_enter_low_noise_mode
         8   -> inv_icm20948_write_mems_reg
       0   inv_icm20948_get_accel_divider
       0   inv_icm20948_get_accel_fullscale
       0   inv_icm20948_get_chip_power_state
       0   inv_icm20948_get_compass_availability
       0   inv_icm20948_get_gyro_divider
       0   inv_icm20948_get_gyro_fullscale
       0   inv_icm20948_get_lpen_control
      24   inv_icm20948_get_odr_in_units
        24   -> inv_icm20948_read_mems_reg
        24   -> inv_is_gyro_enabled
       0   inv_icm20948_get_proximity_availability
       0   inv_icm20948_get_secondary_divider
      32   inv_icm20948_initialize_lower_driver
        32   -> __aeabi_memset4
        32   -> dmp_icm20948_reset_control_registers
        32   -> dmp_icm20948_set_FIFO_watermark
        32   -> dmp_icm20948_set_b2s_rate
        32   -> dmp_icm20948_set_bac_rate
        32   -> inv_icm20948_load_firmware
        32   -> inv_icm20948_read_mems_reg
        32   -> inv_icm20948_set_accel_divider
        32   -> inv_icm20948_set_chip_power_state
        32   -> inv_icm20948_set_dmp_address
        32   -> inv_icm20948_set_gyro_divider
        32   -> inv_icm20948_set_lowpower_or_highperformance
        32   -> inv_icm20948_sleep_mems
        32   -> inv_icm20948_wakeup_mems
        32   -> inv_icm20948_write_mems_reg
        32   -> inv_icm20948_write_single_mems_reg
       0   inv_icm20948_prevent_lpen_control
       8   inv_icm20948_set_accel_divider
         8   -> inv_icm20948_write_mems_reg
      16   inv_icm20948_set_accel_fullscale
        16   -> dmp_icm20948_set_accel_fsr
        16   -> dmp_icm20948_set_accel_scale2
        16   -> inv_icm20948_set_icm20948_accel_fullscale
      16   inv_icm20948_set_chip_power_state
        16   -> inv_icm20948_get_lpen_control
        16   -> inv_icm20948_sleep_100us
        16   -> inv_icm20948_write_single_mems_reg_core
      16   inv_icm20948_set_dmp_address
        16   -> inv_icm20948_get_dmp_start_address
        16   -> inv_icm20948_write_mems_reg
       8   inv_icm20948_set_gyro_divider
         8   -> inv_icm20948_write_mems_reg
      24   inv_icm20948_set_gyro_fullscale
        24   -> inv_icm20948_set_gyro_sf
        24   -> inv_icm20948_set_icm20948_gyro_fullscale
      24   inv_icm20948_set_gyro_sf
        24   -> dmp_icm20948_set_gyro_sf
        24   -> inv_icm20948_read_mems_reg
        24 __aeabi_llsl
        24 __aeabi_uldivmod
      24   inv_icm20948_set_icm20948_accel_fullscale
        24   -> inv_icm20948_read_mems_reg
        24   -> inv_icm20948_write_single_mems_reg
      24   inv_icm20948_set_icm20948_gyro_fullscale
        24   -> inv_icm20948_read_mems_reg
        24   -> inv_icm20948_write_mems_reg
        24   -> inv_icm20948_write_single_mems_reg
      24   inv_icm20948_set_int1_assertion
        24   -> inv_icm20948_read_mems_reg
        24   -> inv_icm20948_write_single_mems_reg
      16   inv_icm20948_set_secondary
        16   -> inv_icm20948_write_single_mems_reg
       0   inv_icm20948_set_secondary_divider
         0   -> inv_icm20948_write_single_mems_reg
       0   inv_icm20948_set_serial_comm
      16   inv_icm20948_set_slave_compass_id
        16   -> activate_compass
        16   -> desactivate_compass
        16   -> inv_icm20948_allow_lpen_control
        16   -> inv_icm20948_compass_dmp_cal
        16   -> inv_icm20948_init_secondary
        16   -> inv_icm20948_prevent_lpen_control
        16   -> inv_icm20948_set_secondary
        16   -> inv_icm20948_setup_compass_akm
      16   inv_icm20948_sleep_mems
        16   -> inv_icm20948_set_chip_power_state
        16   -> inv_icm20948_write_mems_reg
      24   inv_icm20948_wakeup_mems
        24   -> inv_icm20948_set_chip_power_state
        24   -> inv_icm20948_write_mems_reg
        24   -> inv_icm20948_write_single_mems_reg
       0   inv_is_gyro_enabled


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       2  ?_0
       2  ?_1
       8  activate_compass
       1  data
       8  desactivate_compass
      56  inv_icm20948_accel_read_hw_reg_data
      12  inv_icm20948_allow_lpen_control
     102  inv_icm20948_enable_hw_sensors
      24  inv_icm20948_enter_duty_cycle_mode
      24  inv_icm20948_enter_low_noise_mode
       6  inv_icm20948_get_accel_divider
       6  inv_icm20948_get_accel_fullscale
       4  inv_icm20948_get_chip_power_state
       6  inv_icm20948_get_compass_availability
       4  inv_icm20948_get_gyro_divider
       6  inv_icm20948_get_gyro_fullscale
       6  inv_icm20948_get_lpen_control
     164  inv_icm20948_get_odr_in_units
       6  inv_icm20948_get_proximity_availability
       4  inv_icm20948_get_secondary_divider
     426  inv_icm20948_initialize_lower_driver
       8  inv_icm20948_prevent_lpen_control
      34  inv_icm20948_set_accel_divider
      48  inv_icm20948_set_accel_fullscale
     202  inv_icm20948_set_chip_power_state
      56  inv_icm20948_set_dmp_address
      18  inv_icm20948_set_gyro_divider
      32  inv_icm20948_set_gyro_fullscale
     178  inv_icm20948_set_gyro_sf
     174  inv_icm20948_set_icm20948_accel_fullscale
     192  inv_icm20948_set_icm20948_gyro_fullscale
      62  inv_icm20948_set_int1_assertion
      50  inv_icm20948_set_secondary
      16  inv_icm20948_set_secondary_divider
       8  inv_icm20948_set_serial_comm
      70  inv_icm20948_set_slave_compass_id
      38  inv_icm20948_sleep_mems
     104  inv_icm20948_wakeup_mems
      32  inv_is_gyro_enabled
       1  lIsInited
       4  lLastGyroSf

 
     6 bytes in section .bss
     4 bytes in section .rodata
 2 222 bytes in section .text
 
 2 222 bytes of CODE  memory
     4 bytes of CONST memory
     6 bytes of DATA  memory

Errors: none
Warnings: none
