###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:31
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\EmbUtils\InvScheduler.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\EmbUtils\InvScheduler.c -D
#        IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D NUCLEO
#        -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000 -D
#        STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\InvScheduler.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\InvScheduler.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\EmbUtils\InvScheduler.c
      1          /*
      2           *  Copyright (c) 2014-2015 InvenSense Inc.
      3           *  Portions Copyright (c) 2014-2015 Movea.
      4           *  All rights reserved.
      5           *
      6           *  This software, related documentation and any modifications thereto
      7           *  (collectively "Software") is subject to InvenSense and its licensors'
      8           *  intellectual property rights under U.S. and international copyright and
      9           *  other intellectual property rights laws.
     10           *
     11           *  InvenSense and its licensors retain all intellectual property and
     12           *  proprietary rights in and to the Software and any use, reproduction,
     13           *  disclosure or distribution of the Software without an express license
     14           *  agreement from InvenSense is strictly prohibited.
     15           */
     16          
     17          #include "InvScheduler.h"
     18          

   \                                 In section .text, align 2, keep-with-next
     19          static void InvScheduler_insertTask(InvScheduler * scheduler,
     20          		InvSchedulerTask *task)
     21          {
     22          	if(scheduler->queue == 0) {
   \                     InvScheduler_insertTask: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD104             BNE.N    ??InvScheduler_insertTask_0
     23          		task->prev = task;
   \   00000006   0x6209             STR      R1,[R1, #+32]
     24          		task->next = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x61CA             STR      R2,[R1, #+28]
     25          		scheduler->queue = task;
   \   0000000C   0x6041             STR      R1,[R0, #+4]
   \   0000000E   0x4770             BX       LR
     26          	} else {
     27          		task->prev = scheduler->queue->prev;
   \                     ??InvScheduler_insertTask_0: (+1)
   \   00000010   0x6A12             LDR      R2,[R2, #+32]
   \   00000012   0x620A             STR      R2,[R1, #+32]
     28          		task->next = 0;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x61CA             STR      R2,[R1, #+28]
     29          		scheduler->queue->prev->next = task;
   \   00000018   0x6842             LDR      R2,[R0, #+4]
   \   0000001A   0x6A12             LDR      R2,[R2, #+32]
   \   0000001C   0x61D1             STR      R1,[R2, #+28]
     30          		scheduler->queue->prev       = task;
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0x6201             STR      R1,[R0, #+32]
     31          	}
     32          }
   \   00000022   0x4770             BX       LR               ;; return
     33          

   \                                 In section .text, align 2, keep-with-next
     34          static inline void InvScheduler_removeTask(InvScheduler * scheduler,
     35          		InvSchedulerTask *task)
     36          {
     37          	if(scheduler->queue == task) {
   \                     InvScheduler_removeTask: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0x428A             CMP      R2,R1
   \   00000004   0xD102             BNE.N    ??InvScheduler_removeTask_0
     38          		scheduler->queue = task->next;
   \   00000006   0x69CA             LDR      R2,[R1, #+28]
   \   00000008   0x6042             STR      R2,[R0, #+4]
   \   0000000A   0xE007             B.N      ??InvScheduler_removeTask_1
     39          	} else {
     40          		if(scheduler->queue->prev == task)
   \                     ??InvScheduler_removeTask_0: (+1)
   \   0000000C   0x6A10             LDR      R0,[R2, #+32]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD101             BNE.N    ??InvScheduler_removeTask_2
     41          			scheduler->queue->prev = task->prev;
   \   00000012   0x6A08             LDR      R0,[R1, #+32]
   \   00000014   0x6210             STR      R0,[R2, #+32]
     42          		task->prev->next = task->next;
   \                     ??InvScheduler_removeTask_2: (+1)
   \   00000016   0x69C8             LDR      R0,[R1, #+28]
   \   00000018   0x6A0A             LDR      R2,[R1, #+32]
   \   0000001A   0x61D0             STR      R0,[R2, #+28]
     43          	}
     44          	if(task->next)
   \                     ??InvScheduler_removeTask_1: (+1)
   \   0000001C   0x69C8             LDR      R0,[R1, #+28]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??InvScheduler_removeTask_3
     45          		task->next->prev = task->prev;
   \   00000022   0x6A09             LDR      R1,[R1, #+32]
   \   00000024   0x6201             STR      R1,[R0, #+32]
     46          }
   \                     ??InvScheduler_removeTask_3: (+1)
   \   00000026   0x4770             BX       LR               ;; return
     47          

   \                                 In section .text, align 2, keep-with-next
     48          static InvSchedulerTask * InvScheduler_getTaskToSchedule(InvScheduler * scheduler,
     49          		uint32_t now)
     50          {
   \                     InvScheduler_getTaskToSchedule: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     51          	InvSchedulerTask * cur  = scheduler->queue;
   \   00000002   0x6842             LDR      R2,[R0, #+4]
     52          	InvSchedulerTask * task = 0;
   \   00000004   0x2000             MOVS     R0,#+0
     53          	uint32_t           max_diff = 0;
   \   00000006   0x4603             MOV      R3,R0
   \   00000008   0xE020             B.N      ??InvScheduler_getTaskToSchedule_0
     54          
     55          	while(cur) {
     56          		const uint32_t timeout = (cur->delay != 0) ? cur->delay : cur->period;
   \                     ??InvScheduler_getTaskToSchedule_1: (+1)
   \   0000000A   0x6914             LDR      R4,[R2, #+16]
     57          		uint32_t elpased;
     58          
     59          		/* initalize task states after it was started */
     60          		if(cur->state == INVSCHEDULER_TASK_STATE_STARTED) {
   \                     ??InvScheduler_getTaskToSchedule_2: (+1)
   \   0000000C   0xF992 0x5009      LDRSB    R5,[R2, #+9]
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xD109             BNE.N    ??InvScheduler_getTaskToSchedule_3
     61          			cur->state    = INVSCHEDULER_TASK_STATE_READY;
   \   00000014   0x2502             MOVS     R5,#+2
   \   00000016   0x7255             STRB     R5,[R2, #+9]
     62          			cur->lasttime = now;
   \   00000018   0x60D1             STR      R1,[R2, #+12]
     63          
     64          			if(cur->delay == 0) {
   \   0000001A   0x6955             LDR      R5,[R2, #+20]
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD103             BNE.N    ??InvScheduler_getTaskToSchedule_3
     65          				cur->lasttime -= cur->period; /* ensure task is run ASAP */
   \   00000020   0x460D             MOV      R5,R1
   \   00000022   0x6916             LDR      R6,[R2, #+16]
   \   00000024   0x1BAD             SUBS     R5,R5,R6
   \   00000026   0x60D5             STR      R5,[R2, #+12]
     66          			}
     67          		}
     68          
     69          		elpased = (now - cur->lasttime);
   \                     ??InvScheduler_getTaskToSchedule_3: (+1)
   \   00000028   0x68D5             LDR      R5,[R2, #+12]
   \   0000002A   0x1B4D             SUBS     R5,R1,R5
     70          
     71          		/* check timeout against elpased time */
     72          		if(elpased >= timeout) {
   \   0000002C   0x42A5             CMP      R5,R4
   \   0000002E   0xD30C             BCC.N    ??InvScheduler_getTaskToSchedule_4
     73          			const uint32_t diff = (elpased - timeout);
   \   00000030   0x1B2C             SUBS     R4,R5,R4
     74          
     75          			if(task == 0 || diff > max_diff ||
     76          					(diff == max_diff && cur->priority > task->priority)) {
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD007             BEQ.N    ??InvScheduler_getTaskToSchedule_5
   \   00000036   0x42A3             CMP      R3,R4
   \   00000038   0xD305             BCC.N    ??InvScheduler_getTaskToSchedule_5
   \   0000003A   0x429C             CMP      R4,R3
   \   0000003C   0xD105             BNE.N    ??InvScheduler_getTaskToSchedule_4
   \   0000003E   0x7A05             LDRB     R5,[R0, #+8]
   \   00000040   0x7A16             LDRB     R6,[R2, #+8]
   \   00000042   0x42B5             CMP      R5,R6
   \   00000044   0xD201             BCS.N    ??InvScheduler_getTaskToSchedule_4
     77          				task = cur;
   \                     ??InvScheduler_getTaskToSchedule_5: (+1)
   \   00000046   0x4610             MOV      R0,R2
     78          				max_diff = diff;
   \   00000048   0x4623             MOV      R3,R4
     79          			}
     80          		}
     81          
     82          		cur = cur->next;
   \                     ??InvScheduler_getTaskToSchedule_4: (+1)
   \   0000004A   0x69D2             LDR      R2,[R2, #+28]
   \                     ??InvScheduler_getTaskToSchedule_0: (+1)
   \   0000004C   0x2A00             CMP      R2,#+0
   \   0000004E   0xD003             BEQ.N    ??InvScheduler_getTaskToSchedule_6
   \   00000050   0x6954             LDR      R4,[R2, #+20]
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD0D9             BEQ.N    ??InvScheduler_getTaskToSchedule_1
   \   00000056   0xE7D9             B.N      ??InvScheduler_getTaskToSchedule_2
     83          	}
     84          
     85          	return task;
   \                     ??InvScheduler_getTaskToSchedule_6: (+1)
   \   00000058   0xBC70             POP      {R4-R6}
   \   0000005A   0x4770             BX       LR               ;; return
     86          }
     87          

   \                                 In section .text, align 2, keep-with-next
     88          int InvScheduler_getActiveTaskCountU(const InvScheduler *scheduler)
     89          {
     90          	int count = 0;
   \                     InvScheduler_getActiveTaskCountU: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
     91          	const InvSchedulerTask *cur;
     92          
     93          	/* /!\ RUNNING task is not in the queue hence ignored */
     94          	for(cur = scheduler->queue; cur != 0; cur = cur->next)
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0xE001             B.N      ??InvScheduler_getActiveTaskCountU_0
     95          		++count;
   \                     ??InvScheduler_getActiveTaskCountU_1: (+1)
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x69C0             LDR      R0,[R0, #+28]
   \                     ??InvScheduler_getActiveTaskCountU_0: (+1)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD1FB             BNE.N    ??InvScheduler_getActiveTaskCountU_1
     96          
     97          	return count;
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0x4770             BX       LR               ;; return
     98          }
     99          

   \                                 In section .text, align 2, keep-with-next
    100          uint32_t InvScheduler_getNextTimeU(const InvScheduler *scheduler)
    101          {
   \                     InvScheduler_getNextTimeU: (+1)
   \   00000000   0xB410             PUSH     {R4}
    102          	const uint32_t           now = scheduler->currentTime;
   \   00000002   0x6801             LDR      R1,[R0, #+0]
    103          	const InvSchedulerTask * cur = scheduler->queue;
   \   00000004   0x6842             LDR      R2,[R0, #+4]
    104          	uint32_t                 max_diff = UINT32_MAX;
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xE004             B.N      ??InvScheduler_getNextTimeU_0
    105          
    106          	for(; cur != 0; cur = cur->next ) {
    107          		if(cur->state == INVSCHEDULER_TASK_STATE_STARTED) {
    108          			return 0;
    109          		} else {
    110          			const uint32_t timeout = (cur->delay != 0) ? cur->delay : cur->period;
    111          			const uint32_t elpased = (now - cur->lasttime);
    112          
    113          			if(elpased >= timeout) {
    114          				return 0;
    115          			} else {
    116          				const uint32_t diff = timeout - elpased;
   \                     ??InvScheduler_getNextTimeU_1: (+1)
   \   0000000C   0x1B1B             SUBS     R3,R3,R4
    117          
    118          				if(diff < max_diff) {
   \   0000000E   0x4283             CMP      R3,R0
   \   00000010   0xD800             BHI.N    ??InvScheduler_getNextTimeU_2
   \   00000012   0x4618             MOV      R0,R3
    119          					max_diff = diff;
    120          				}
    121          			}
   \                     ??InvScheduler_getNextTimeU_2: (+1)
   \   00000014   0x69D2             LDR      R2,[R2, #+28]
   \                     ??InvScheduler_getNextTimeU_0: (+1)
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD00C             BEQ.N    ??InvScheduler_getNextTimeU_3
   \   0000001A   0xF992 0x3009      LDRSB    R3,[R2, #+9]
   \   0000001E   0x2B01             CMP      R3,#+1
   \   00000020   0xD007             BEQ.N    ??InvScheduler_getNextTimeU_4
   \   00000022   0x6953             LDR      R3,[R2, #+20]
   \   00000024   0x2B00             CMP      R3,#+0
   \   00000026   0xD100             BNE.N    ??InvScheduler_getNextTimeU_5
   \   00000028   0x6913             LDR      R3,[R2, #+16]
   \                     ??InvScheduler_getNextTimeU_5: (+1)
   \   0000002A   0x68D4             LDR      R4,[R2, #+12]
   \   0000002C   0x1B0C             SUBS     R4,R1,R4
   \   0000002E   0x429C             CMP      R4,R3
   \   00000030   0xD3EC             BCC.N    ??InvScheduler_getNextTimeU_1
   \                     ??InvScheduler_getNextTimeU_4: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
    122          		}
    123          	}
    124          
    125          	return max_diff;
   \                     ??InvScheduler_getNextTimeU_3: (+1)
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR               ;; return
    126          }
    127          

   \                                 In section .text, align 2, keep-with-next
    128          uint32_t InvScheduler_getMinPeriodU(const InvScheduler *scheduler)
    129          {
    130          	if(scheduler->queue) {
   \                     InvScheduler_getMinPeriodU: (+1)
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00A             BEQ.N    ??InvScheduler_getMinPeriodU_0
    131          		InvSchedulerTask *cur = scheduler->queue->next;
   \   00000006   0x69C1             LDR      R1,[R0, #+28]
    132          		uint32_t min = scheduler->queue->period;
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0xE004             B.N      ??InvScheduler_getMinPeriodU_1
    133          
    134          		/* /!\ RUNNING task is not in the queue hence ignored */
    135          		/* /!\ delay is not taken into account */
    136          
    137          		for(; cur != 0; cur = cur->next ) {
    138          			if(cur->period < min) {
   \                     ??InvScheduler_getMinPeriodU_2: (+1)
   \   0000000C   0x690A             LDR      R2,[R1, #+16]
   \   0000000E   0x4282             CMP      R2,R0
   \   00000010   0xD800             BHI.N    ??InvScheduler_getMinPeriodU_3
   \   00000012   0x4610             MOV      R0,R2
    139          				min = cur->period;
    140          			}
    141          		}
   \                     ??InvScheduler_getMinPeriodU_3: (+1)
   \   00000014   0x69C9             LDR      R1,[R1, #+28]
   \                     ??InvScheduler_getMinPeriodU_1: (+1)
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD1F8             BNE.N    ??InvScheduler_getMinPeriodU_2
    142          
    143          		return min;
   \   0000001A   0x4770             BX       LR
    144          	}
    145          
    146          	return UINT32_MAX;
   \                     ??InvScheduler_getMinPeriodU_0: (+1)
   \   0000001C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000020   0x4770             BX       LR               ;; return
    147          }
    148          

   \                                 In section .text, align 2, keep-with-next
    149          int InvScheduler_dispatchOneTask(InvScheduler *scheduler)
    150          {
   \                     InvScheduler_dispatchOneTask: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    151          	int run = 0;
   \   00000004   0x2600             MOVS     R6,#+0
    152          	const uint32_t now = scheduler->currentTime;
   \   00000006   0x6827             LDR      R7,[R4, #+0]
    153          	InvSchedulerTask * task;
    154          
    155          	InvScheduler_lock(scheduler->contextLock);
    156          
    157          	task = InvScheduler_getTaskToSchedule(scheduler, now);
   \   00000008   0x4639             MOV      R1,R7
   \   0000000A   0x.... 0x....      BL       InvScheduler_getTaskToSchedule
   \   0000000E   0x0005             MOVS     R5,R0
    158          
    159          	if(task) {
   \   00000010   0xD016             BEQ.N    ??InvScheduler_dispatchOneTask_0
    160          		/* update lastime and task state */
    161          		task->delay    = 0; /* clear delay */
   \   00000012   0x4630             MOV      R0,R6
   \   00000014   0x6168             STR      R0,[R5, #+20]
    162          		task->lasttime = now;
   \   00000016   0x60EF             STR      R7,[R5, #+12]
    163          		task->state    = INVSCHEDULER_TASK_STATE_RUNNING;
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x7268             STRB     R0,[R5, #+9]
    164          
    165          		InvScheduler_removeTask(scheduler, task);
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       InvScheduler_removeTask
    166          
    167          		InvScheduler_unlock(scheduler->contextLock);
    168          		InvScheduler_onTaskEnterHook(task, scheduler->currentTime);
    169          		task->func(task->arg); /* execute the task */
   \   00000024   0x6868             LDR      R0,[R5, #+4]
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x4788             BLX      R1
    170          		InvScheduler_onTaskExitHook(task, scheduler->currentTime);
    171          		InvScheduler_lock(scheduler->contextLock);
    172          
    173          		/* schedule task for next period */
    174          		if(task->state == INVSCHEDULER_TASK_STATE_RUNNING) {
   \   0000002A   0xF995 0x0009      LDRSB    R0,[R5, #+9]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD105             BNE.N    ??InvScheduler_dispatchOneTask_1
    175          			task->state = INVSCHEDULER_TASK_STATE_READY;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x7268             STRB     R0,[R5, #+9]
    176          			InvScheduler_insertTask(scheduler, task);
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       InvScheduler_insertTask
    177          		}
    178          
    179          		run = 1;
   \                     ??InvScheduler_dispatchOneTask_1: (+1)
   \   0000003E   0x2601             MOVS     R6,#+1
    180          	}
    181          
    182          	InvScheduler_unlock(scheduler->contextLock);
    183          
    184          	return run;
   \                     ??InvScheduler_dispatchOneTask_0: (+1)
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    185          }
    186          

   \                                 In section .text, align 2, keep-with-next
    187          int InvScheduler_dispatchTasks(InvScheduler *scheduler)
    188          {
   \                     InvScheduler_dispatchTasks: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    189          	int count = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE000             B.N      ??InvScheduler_dispatchTasks_0
    190          
    191          	while(InvScheduler_dispatchOneTask(scheduler))
    192          		++count;
   \                     ??InvScheduler_dispatchTasks_1: (+1)
   \   00000008   0x1C6D             ADDS     R5,R5,#+1
   \                     ??InvScheduler_dispatchTasks_0: (+1)
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       InvScheduler_dispatchOneTask
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD1F9             BNE.N    ??InvScheduler_dispatchTasks_1
    193          
    194          	return count;
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    195          }
    196          

   \                                 In section .text, align 2, keep-with-next
    197          void InvScheduler_initTaskDo(InvScheduler *scheduler, InvSchedulerTask *task,
    198          		void (*func)(void *), void *arg, uint8_t prio, uint32_t period)
    199          {
    200          	task->scheduler = scheduler;
   \                     InvScheduler_initTaskDo: (+1)
   \   00000000   0x6188             STR      R0,[R1, #+24]
    201          	task->func 		= func;
   \   00000002   0x600A             STR      R2,[R1, #+0]
    202          	task->arg 		= arg;
   \   00000004   0x604B             STR      R3,[R1, #+4]
    203          	task->priority 	= prio;
   \   00000006   0x9800             LDR      R0,[SP, #+0]
   \   00000008   0x7208             STRB     R0,[R1, #+8]
    204          	task->period 	= period;
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0x6108             STR      R0,[R1, #+16]
    205          	task->state		= INVSCHEDULER_TASK_STATE_STOP;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x7248             STRB     R0,[R1, #+9]
    206          #ifdef INVSCHEDULER_TASK_NAME
    207          	task->name 		= "";
    208          #endif
    209          }
   \   00000012   0x4770             BX       LR               ;; return
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void InvScheduler_startTaskU(InvSchedulerTask *task, uint32_t delay)
    212          {
   \                     InvScheduler_startTaskU: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    213          	if(task->state == INVSCHEDULER_TASK_STATE_STARTED ||
    214          			task->state == INVSCHEDULER_TASK_STATE_READY) {
   \   00000006   0xF994 0x0009      LDRSB    R0,[R4, #+9]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??InvScheduler_startTaskU_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD103             BNE.N    ??InvScheduler_startTaskU_1
    215          		InvScheduler_removeTask(task->scheduler, task);
   \                     ??InvScheduler_startTaskU_0: (+1)
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x69A0             LDR      R0,[R4, #+24]
   \   00000016   0x.... 0x....      BL       InvScheduler_removeTask
    216          	}
    217          	InvScheduler_insertTask(task->scheduler, task);
   \                     ??InvScheduler_startTaskU_1: (+1)
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0x69A0             LDR      R0,[R4, #+24]
   \   0000001E   0x.... 0x....      BL       InvScheduler_insertTask
    218          	task->delay = delay;
   \   00000022   0x6165             STR      R5,[R4, #+20]
    219          	task->state = INVSCHEDULER_TASK_STATE_STARTED;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7260             STRB     R0,[R4, #+9]
    220          }
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    221          

   \                                 In section .text, align 2, keep-with-next
    222          void InvScheduler_startTask(InvSchedulerTask *task, uint32_t delay)
    223          {
    224          	InvScheduler_lock(task->scheduler->contextLock);
    225          	InvScheduler_startTaskU(task, delay);
   \                     InvScheduler_startTask: (+1)
   \   00000000   0x....             B.N      InvScheduler_startTaskU
    226          	InvScheduler_unlock(task->scheduler->contextLock);
    227          }
    228          

   \                                 In section .text, align 2, keep-with-next
    229          void InvScheduler_stopTaskU(InvSchedulerTask *task)
    230          {
   \                     InvScheduler_stopTaskU: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    231          	if(task->state == INVSCHEDULER_TASK_STATE_STARTED ||
    232          			task->state == INVSCHEDULER_TASK_STATE_READY) {
   \   00000004   0xF994 0x0009      LDRSB    R0,[R4, #+9]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ.N    ??InvScheduler_stopTaskU_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD103             BNE.N    ??InvScheduler_stopTaskU_1
    233          		InvScheduler_removeTask(task->scheduler, task);
   \                     ??InvScheduler_stopTaskU_0: (+1)
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x69A0             LDR      R0,[R4, #+24]
   \   00000014   0x.... 0x....      BL       InvScheduler_removeTask
    234          	}
    235          	task->state = INVSCHEDULER_TASK_STATE_STOP;
   \                     ??InvScheduler_stopTaskU_1: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x7260             STRB     R0,[R4, #+9]
    236          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    237          

   \                                 In section .text, align 2, keep-with-next
    238          void InvScheduler_stopTask(InvSchedulerTask *task)
    239          {
    240          	InvScheduler_lock(task->scheduler->contextLock);
    241          	InvScheduler_stopTaskU(task);
   \                     InvScheduler_stopTask: (+1)
   \   00000000   0x....             B.N      InvScheduler_stopTaskU
    242          	InvScheduler_unlock(task->scheduler->contextLock);
    243          }
    244          
    245          /* Debugging functions ********************************************************/
    246          
    247          #ifndef NDEBUG
    248          

   \                                 In section .text, align 4, keep-with-next
    249          static const char *InvScheduler_taskState2Str(enum InvSchedulerTaskState state)
    250          {
    251          	switch(state) {
   \                     InvScheduler_taskState2Str: (+1)
   \   00000000   0x2803             CMP      R0,#+3
   \   00000002   0xD80F             BHI.N    ??InvScheduler_taskState2Str_1
   \   00000004   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??InvScheduler_taskState2Str_0:
   \   00000008   0x02 0x05          DC8      0x2,0x5,0x8,0xB
   \              0x08 0x0B    
    252          	case INVSCHEDULER_TASK_STATE_STOP:    return "STATE_STOP   ";
   \                     ??InvScheduler_taskState2Str_2: (+1)
   \   0000000C   0x.... 0x....      ADR.W    R0,?_0
   \   00000010   0x4770             BX       LR
    253          	case INVSCHEDULER_TASK_STATE_STARTED: return "STATE_STARTED";
   \                     ??InvScheduler_taskState2Str_3: (+1)
   \   00000012   0x.... 0x....      ADR.W    R0,?_1
   \   00000016   0x4770             BX       LR
    254          	case INVSCHEDULER_TASK_STATE_READY:   return "STATE_READY  ";
   \                     ??InvScheduler_taskState2Str_4: (+1)
   \   00000018   0x.... 0x....      ADR.W    R0,?_2
   \   0000001C   0x4770             BX       LR
    255          	case INVSCHEDULER_TASK_STATE_RUNNING: return "STATE_RUNNING";
   \                     ??InvScheduler_taskState2Str_5: (+1)
   \   0000001E   0x.... 0x....      ADR.W    R0,?_3
   \   00000022   0x4770             BX       LR
    256          	default:                              return "STATE_???    ";
   \                     ??InvScheduler_taskState2Str_1: (+1)
   \   00000024   0x.... 0x....      ADR.W    R0,?_4
   \   00000028   0x4770             BX       LR               ;; return
    257          	}
    258          }
    259          

   \                                 In section .text, align 2, keep-with-next
    260          void InvScheduler_printTask(const InvSchedulerTask *task,
    261          		int (*printf_cb)(const char *format, ...))
    262          {
   \                     InvScheduler_printTask: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    263          	printf_cb("[%p:%s]\n"
    264          			"    prio   = %-12u state  = %s \n"
    265          			"    period = %-12u delay = %-12u\n"
    266          			"    time   = %-12lu\n"
    267          			"    next   = %p prev   = %p\n",
    268          			(void *)task,
    269          #ifdef INVSCHEDULER_TASK_NAME
    270          			task->name,
    271          #else
    272          			"",
    273          #endif
    274          			(unsigned int)task->priority,
    275          			InvScheduler_taskState2Str(task->state), (unsigned int)task->period,
    276          			(unsigned int)task->delay, (unsigned long)task->lasttime,
    277          			(void *)task->next, (void *)task->prev
    278          	);
   \   00000008   0xF994 0x0009      LDRSB    R0,[R4, #+9]
   \   0000000C   0x.... 0x....      BL       InvScheduler_taskState2Str
   \   00000010   0x6A21             LDR      R1,[R4, #+32]
   \   00000012   0x9105             STR      R1,[SP, #+20]
   \   00000014   0x69E1             LDR      R1,[R4, #+28]
   \   00000016   0x9104             STR      R1,[SP, #+16]
   \   00000018   0x68E1             LDR      R1,[R4, #+12]
   \   0000001A   0x9103             STR      R1,[SP, #+12]
   \   0000001C   0x6961             LDR      R1,[R4, #+20]
   \   0000001E   0x9102             STR      R1,[SP, #+8]
   \   00000020   0x6921             LDR      R1,[R4, #+16]
   \   00000022   0x9101             STR      R1,[SP, #+4]
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x7A23             LDRB     R3,[R4, #+8]
   \   00000028   0x....             ADR.N    R2,??DataTable7  ;; ""
   \   0000002A   0x4621             MOV      R1,R4
   \   0000002C   0x.... 0x....      ADR.W    R0,?_5
   \   00000030   0x47A8             BLX      R5
    279          }
   \   00000032   0xB007             ADD      SP,SP,#+28
   \   00000034   0xBD30             POP      {R4,R5,PC}       ;; return
    280          

   \                                 In section .text, align 2, keep-with-next
    281          void InvScheduler_dumpTasks(const InvSchedulerTask * queue,
    282          		int (*printf_cb)(const char *format, ...))
    283          {
   \                     InvScheduler_dumpTasks: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    284          	const InvSchedulerTask *cur = queue;
   \   00000006   0xE004             B.N      ??InvScheduler_dumpTasks_0
    285          
    286          	for(; cur != 0; cur = cur->next) {
    287          		InvScheduler_printTask(cur, printf_cb);
   \                     ??InvScheduler_dumpTasks_1: (+1)
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       InvScheduler_printTask
    288          	}
   \   00000010   0x69E4             LDR      R4,[R4, #+28]
   \                     ??InvScheduler_dumpTasks_0: (+1)
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD1F8             BNE.N    ??InvScheduler_dumpTasks_1
    289          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_6:
   \   00000000   0x00               DC8 ""

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x53 0x54          DC8 "STATE_STOP   "
   \              0x41 0x54    
   \              0x45 0x5F    
   \              0x53 0x54    
   \              0x4F 0x50    
   \              0x20 0x20    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x53 0x54          DC8 "STATE_STARTED"
   \              0x41 0x54    
   \              0x45 0x5F    
   \              0x53 0x54    
   \              0x41 0x52    
   \              0x54 0x45    
   \              0x44 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x53 0x54          DC8 "STATE_READY  "
   \              0x41 0x54    
   \              0x45 0x5F    
   \              0x52 0x45    
   \              0x41 0x44    
   \              0x59 0x20    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x53 0x54          DC8 "STATE_RUNNING"
   \              0x41 0x54    
   \              0x45 0x5F    
   \              0x52 0x55    
   \              0x4E 0x4E    
   \              0x49 0x4E    
   \              0x47 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x53 0x54          DC8 "STATE_???    "
   \              0x41 0x54    
   \              0x45 0x5F    
   \              0x3F 0x3F    
   \              0x3F 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x5B 0x25          DC8 5BH, 25H, 70H, 3AH, 25H, 73H, 5DH, 0AH
   \              0x70 0x3A    
   \              0x25 0x73    
   \              0x5D 0x0A    
   \   00000008   0x20 0x20          DC8 20H, 20H, 20H, 20H, 70H, 72H, 69H, 6FH
   \              0x20 0x20    
   \              0x70 0x72    
   \              0x69 0x6F    
   \   00000010   0x20 0x20          DC8 20H, 20H, 20H, 3DH, 20H, 25H, 2DH, 31H
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x2D 0x31    
   \   00000018   0x32 0x75          DC8 32H, 75H, 20H, 73H, 74H, 61H, 74H, 65H
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x65    
   \   00000020   0x20 0x20          DC8 20H, 20H, 3DH, 20H, 25H, 73H, 20H, 0AH
   \              0x3D 0x20    
   \              0x25 0x73    
   \              0x20 0x0A    
   \   00000028   0x20 0x20          DC8 20H, 20H, 20H, 20H, 70H, 65H, 72H, 69H
   \              0x20 0x20    
   \              0x70 0x65    
   \              0x72 0x69    
   \   00000030   0x6F 0x64          DC8 6FH, 64H, 20H, 3DH, 20H, 25H, 2DH, 31H
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x2D 0x31    
   \   00000038   0x32 0x75          DC8 32H, 75H, 20H, 64H, 65H, 6CH, 61H, 79H
   \              0x20 0x64    
   \              0x65 0x6C    
   \              0x61 0x79    
   \   00000040   0x20 0x3D          DC8 20H, 3DH, 20H, 25H, 2DH, 31H, 32H, 75H
   \              0x20 0x25    
   \              0x2D 0x31    
   \              0x32 0x75    
   \   00000048   0x0A 0x20          DC8 0AH, 20H, 20H, 20H, 20H, 74H, 69H, 6DH
   \              0x20 0x20    
   \              0x20 0x74    
   \              0x69 0x6D    
   \   00000050   0x65 0x20          DC8 65H, 20H, 20H, 20H, 3DH, 20H, 25H, 2DH
   \              0x20 0x20    
   \              0x3D 0x20    
   \              0x25 0x2D    
   \   00000058   0x31 0x32          DC8 31H, 32H, 6CH, 75H, 0AH, 20H, 20H, 20H
   \              0x6C 0x75    
   \              0x0A 0x20    
   \              0x20 0x20    
   \   00000060   0x20 0x6E          DC8 20H, 6EH, 65H, 78H, 74H, 20H, 20H, 20H
   \              0x65 0x78    
   \              0x74 0x20    
   \              0x20 0x20    
   \   00000068   0x3D 0x20          DC8 3DH, 20H, 25H, 70H, 20H, 70H, 72H, 65H
   \              0x25 0x70    
   \              0x20 0x70    
   \              0x72 0x65    
   \   00000070   0x76 0x20          DC8 76H, 20H, 20H, 20H, 3DH, 20H, 25H, 70H
   \              0x20 0x20    
   \              0x3D 0x20    
   \              0x25 0x70    
   \   00000078   0x0A 0x00          DC8 0AH, 0
   \   0000007A   0x00 0x00          DC8 0, 0
    290          
    291          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   InvScheduler_dispatchOneTask
        24   -- Indirect call
        24   -> InvScheduler_getTaskToSchedule
        24   -> InvScheduler_insertTask
        24   -> InvScheduler_removeTask
      16   InvScheduler_dispatchTasks
        16   -> InvScheduler_dispatchOneTask
      16   InvScheduler_dumpTasks
        16   -> InvScheduler_printTask
       0   InvScheduler_getActiveTaskCountU
       0   InvScheduler_getMinPeriodU
       4   InvScheduler_getNextTimeU
      12   InvScheduler_getTaskToSchedule
       0   InvScheduler_initTaskDo
       0   InvScheduler_insertTask
      40   InvScheduler_printTask
        40   -- Indirect call
        40   -> InvScheduler_taskState2Str
       0   InvScheduler_removeTask
       0   InvScheduler_startTask
         0   -> InvScheduler_startTaskU
      16   InvScheduler_startTaskU
        16   -> InvScheduler_insertTask
        16   -> InvScheduler_removeTask
       0   InvScheduler_stopTask
         0   -> InvScheduler_stopTaskU
       8   InvScheduler_stopTaskU
         8   -> InvScheduler_removeTask
       0   InvScheduler_taskState2Str


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
      16  ?_0
      16  ?_1
      16  ?_2
      16  ?_3
      16  ?_4
     124  ?_5
       1  ?_6
      68  InvScheduler_dispatchOneTask
      24  InvScheduler_dispatchTasks
      24  InvScheduler_dumpTasks
      18  InvScheduler_getActiveTaskCountU
      34  InvScheduler_getMinPeriodU
      56  InvScheduler_getNextTimeU
      92  InvScheduler_getTaskToSchedule
      20  InvScheduler_initTaskDo
      36  InvScheduler_insertTask
      54  InvScheduler_printTask
      40  InvScheduler_removeTask
       2  InvScheduler_startTask
      42  InvScheduler_startTaskU
       2  InvScheduler_stopTask
      30  InvScheduler_stopTaskU
      42  InvScheduler_taskState2Str

 
   1 byte  in section .rodata
 792 bytes in section .text
 
 792 bytes of CODE  memory
   1 byte  of CONST memory

Errors: none
Warnings: none
