###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:29
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataConverter.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataConverter.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\Icm20948DataConverter.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\Icm20948DataConverter.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataConverter.c
      1          /*
      2          * ________________________________________________________________________________________________________
      3          * Copyright © 2014-2015 InvenSense Inc. Portions Copyright © 2014-2015 Movea. All rights reserved.
      4          * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      5          * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright and
      6          * other intellectual property rights laws.
      7          * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
      8          * and any use, reproduction, disclosure or distribution of the Software without an express license
      9          * agreement from InvenSense is strictly prohibited.
     10          * ________________________________________________________________________________________________________
     11          */
     12          
     13          #include "Icm20948.h"
     14          #include "Icm20948DataConverter.h"
     15          
     16          #include <string.h>
     17          #include <math.h>
     18          
     19          static void invn_convert_quat_invert_fxp(const long *quat_q30, long *invQuat_q30);
     20          

   \                                 In section .text, align 2, keep-with-next
     21          static void invn_convert_quat_mult_fxp(const long *quat1_q30, const long *quat2_q30, long *quatProd_q30)
     22          {
   \                     invn_convert_quat_mult_fxp: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     23              quatProd_q30[0] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[0]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[1]) -
     24                         inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[2]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[3]);
   \   00000008   0x6829             LDR      R1,[R5, #+0]
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0x6869             LDR      R1,[R5, #+4]
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000001A   0x1A3F             SUBS     R7,R7,R0
   \   0000001C   0x68A9             LDR      R1,[R5, #+8]
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000024   0x1A3F             SUBS     R7,R7,R0
   \   00000026   0x68E9             LDR      R1,[R5, #+12]
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000002E   0x1A38             SUBS     R0,R7,R0
   \   00000030   0x6030             STR      R0,[R6, #+0]
     25          
     26              quatProd_q30[1] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[1]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[0]) +
     27                         inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[3]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[2]);
   \   00000032   0x6869             LDR      R1,[R5, #+4]
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000003A   0x4607             MOV      R7,R0
   \   0000003C   0x6829             LDR      R1,[R5, #+0]
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000044   0x19C7             ADDS     R7,R0,R7
   \   00000046   0x68E9             LDR      R1,[R5, #+12]
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000004E   0x19C7             ADDS     R7,R0,R7
   \   00000050   0x68A9             LDR      R1,[R5, #+8]
   \   00000052   0x68E0             LDR      R0,[R4, #+12]
   \   00000054   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000058   0x1A38             SUBS     R0,R7,R0
   \   0000005A   0x6070             STR      R0,[R6, #+4]
     28          
     29              quatProd_q30[2] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[2]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[3]) +
     30                         inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[0]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[1]);
   \   0000005C   0x68A9             LDR      R1,[R5, #+8]
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000064   0x4607             MOV      R7,R0
   \   00000066   0x68E9             LDR      R1,[R5, #+12]
   \   00000068   0x6860             LDR      R0,[R4, #+4]
   \   0000006A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000006E   0x1A3F             SUBS     R7,R7,R0
   \   00000070   0x6829             LDR      R1,[R5, #+0]
   \   00000072   0x68A0             LDR      R0,[R4, #+8]
   \   00000074   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000078   0x19C7             ADDS     R7,R0,R7
   \   0000007A   0x6869             LDR      R1,[R5, #+4]
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000082   0x19C0             ADDS     R0,R0,R7
   \   00000084   0x60B0             STR      R0,[R6, #+8]
     31          
     32              quatProd_q30[3] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[3]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[2]) -
     33                         inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[1]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[0]);
   \   00000086   0x68E9             LDR      R1,[R5, #+12]
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000008E   0x4607             MOV      R7,R0
   \   00000090   0x68A9             LDR      R1,[R5, #+8]
   \   00000092   0x6860             LDR      R0,[R4, #+4]
   \   00000094   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000098   0x19C7             ADDS     R7,R0,R7
   \   0000009A   0x6869             LDR      R1,[R5, #+4]
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   000000A2   0x1A3F             SUBS     R7,R7,R0
   \   000000A4   0x6829             LDR      R1,[R5, #+0]
   \   000000A6   0x68E0             LDR      R0,[R4, #+12]
   \   000000A8   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   000000AC   0x19C0             ADDS     R0,R0,R7
   \   000000AE   0x60F0             STR      R0,[R6, #+12]
     34          }
   \   000000B0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     35          

   \                                 In section .text, align 2, keep-with-next
     36          static void invn_convert_quat_invert_fxp(const long *quat_q30, long *invQuat_q30)
     37          {
     38              invQuat_q30[0] = quat_q30[0];
   \                     invn_convert_quat_invert_fxp: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x600A             STR      R2,[R1, #+0]
     39              invQuat_q30[1] = -quat_q30[1];
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   \   00000006   0x4252             RSBS     R2,R2,#+0
   \   00000008   0x604A             STR      R2,[R1, #+4]
     40              invQuat_q30[2] = -quat_q30[2];
   \   0000000A   0x6882             LDR      R2,[R0, #+8]
   \   0000000C   0x4252             RSBS     R2,R2,#+0
   \   0000000E   0x608A             STR      R2,[R1, #+8]
     41              invQuat_q30[3] = -quat_q30[3];
   \   00000010   0x68C0             LDR      R0,[R0, #+12]
   \   00000012   0x4240             RSBS     R0,R0,#+0
   \   00000014   0x60C8             STR      R0,[R1, #+12]
     42          }
   \   00000016   0x4770             BX       LR               ;; return
     43          

   \                                 In section .text, align 2, keep-with-next
     44          void inv_icm20948_q_mult_q_qi(const long *q1, const long *q2, long *qProd)
     45          {
   \                     inv_icm20948_q_mult_q_qi: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     46              qProd[0] = inv_icm20948_convert_mult_q30_fxp(q1[0], q2[0]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[1]) +
     47                         inv_icm20948_convert_mult_q30_fxp(q1[2], q2[2]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[3]);
   \   00000008   0x6829             LDR      R1,[R5, #+0]
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0x6869             LDR      R1,[R5, #+4]
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000001A   0x19C7             ADDS     R7,R0,R7
   \   0000001C   0x68A9             LDR      R1,[R5, #+8]
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000024   0x19C7             ADDS     R7,R0,R7
   \   00000026   0x68E9             LDR      R1,[R5, #+12]
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \   0000002A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000002E   0x19C0             ADDS     R0,R0,R7
   \   00000030   0x6030             STR      R0,[R6, #+0]
     48          
     49              qProd[1] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[1]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[0]) -
     50                         inv_icm20948_convert_mult_q30_fxp(q1[2], q2[3]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[2]);
   \   00000032   0x6869             LDR      R1,[R5, #+4]
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000003A   0x4607             MOV      R7,R0
   \   0000003C   0x6829             LDR      R1,[R5, #+0]
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000044   0x1BC7             SUBS     R7,R0,R7
   \   00000046   0x68E9             LDR      R1,[R5, #+12]
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000004E   0x1A3F             SUBS     R7,R7,R0
   \   00000050   0x68A9             LDR      R1,[R5, #+8]
   \   00000052   0x68E0             LDR      R0,[R4, #+12]
   \   00000054   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000058   0x19C0             ADDS     R0,R0,R7
   \   0000005A   0x6070             STR      R0,[R6, #+4]
     51          
     52              qProd[2] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[2]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[3]) +
     53                         inv_icm20948_convert_mult_q30_fxp(q1[2], q2[0]) - inv_icm20948_convert_mult_q30_fxp(q1[3], q2[1]);
   \   0000005C   0x68A9             LDR      R1,[R5, #+8]
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000064   0x4607             MOV      R7,R0
   \   00000066   0x68E9             LDR      R1,[R5, #+12]
   \   00000068   0x6860             LDR      R0,[R4, #+4]
   \   0000006A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000006E   0x1BC7             SUBS     R7,R0,R7
   \   00000070   0x6829             LDR      R1,[R5, #+0]
   \   00000072   0x68A0             LDR      R0,[R4, #+8]
   \   00000074   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000078   0x19C7             ADDS     R7,R0,R7
   \   0000007A   0x6869             LDR      R1,[R5, #+4]
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000082   0x1A38             SUBS     R0,R7,R0
   \   00000084   0x60B0             STR      R0,[R6, #+8]
     54          
     55              qProd[3] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[3]) - inv_icm20948_convert_mult_q30_fxp(q1[1], q2[2]) +
     56                         inv_icm20948_convert_mult_q30_fxp(q1[2], q2[1]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[0]);
   \   00000086   0x68E9             LDR      R1,[R5, #+12]
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000008E   0x4247             RSBS     R7,R0,#+0
   \   00000090   0x68A9             LDR      R1,[R5, #+8]
   \   00000092   0x6860             LDR      R0,[R4, #+4]
   \   00000094   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000098   0x1A3F             SUBS     R7,R7,R0
   \   0000009A   0x6869             LDR      R1,[R5, #+4]
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   000000A2   0x19C7             ADDS     R7,R0,R7
   \   000000A4   0x6829             LDR      R1,[R5, #+0]
   \   000000A6   0x68E0             LDR      R0,[R4, #+12]
   \   000000A8   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   000000AC   0x19C0             ADDS     R0,R0,R7
   \   000000AE   0x60F0             STR      R0,[R6, #+12]
     57          }
   \   000000B0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void inv_icm20948_convert_quat_rotate_fxp(const long *quat_q30, const long *in, long *out)
     60          {
   \                     inv_icm20948_convert_quat_rotate_fxp: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
     61              long q_temp1[4], q_temp2[4];
     62              long in4[4], out4[4];
     63          
     64              // Fixme optimize
     65              in4[0] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
     66              memcpy(&in4[1], in, 3 * sizeof(long));
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
     67              invn_convert_quat_mult_fxp(quat_q30, in4, q_temp1);
   \   00000014   0xAA0C             ADD      R2,SP,#+48
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       invn_convert_quat_mult_fxp
     68              invn_convert_quat_invert_fxp(quat_q30, q_temp2);
   \   0000001E   0xA908             ADD      R1,SP,#+32
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       invn_convert_quat_invert_fxp
     69              invn_convert_quat_mult_fxp(q_temp1, q_temp2, out4);
   \   00000026   0xAA04             ADD      R2,SP,#+16
   \   00000028   0xA908             ADD      R1,SP,#+32
   \   0000002A   0xA80C             ADD      R0,SP,#+48
   \   0000002C   0x.... 0x....      BL       invn_convert_quat_mult_fxp
     70              memcpy(out, &out4[1], 3 * sizeof(long));
   \   00000030   0x220C             MOVS     R2,#+12
   \   00000032   0xA905             ADD      R1,SP,#+20
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       __aeabi_memcpy4
     71          }
   \   0000003A   0xB011             ADD      SP,SP,#+68
   \   0000003C   0xBD30             POP      {R4,R5,PC}       ;; return
     72          /** Set the transformation used for chip to body frame
     73          */

   \                                 In section .text, align 2, keep-with-next
     74          void inv_icm20948_set_chip_to_body(struct inv_icm20948 * s, long *quat)
     75          {
     76              memcpy(s->s_quat_chip_to_body, quat, sizeof(s->s_quat_chip_to_body));
   \                     inv_icm20948_set_chip_to_body: (+1)
   \   00000000   0x2210             MOVS     R2,#+16
   \   00000002   0x30A8             ADDS     R0,R0,#+168
   \   00000004   0x.... 0x....      B.W      __aeabi_memcpy4
     77          }
     78          
     79          /** Convert fixed point DMP rotation vector to floating point android notation
     80          * @param[in] quat 3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame
     81          * @param[out] values 4 element quaternion in Android format
     82          */

   \                                 In section .text, align 4, keep-with-next
     83          void inv_icm20948_convert_rotation_vector(struct inv_icm20948 * s, const long *quat, float *values)
     84          {
   \                     inv_icm20948_convert_rotation_vector: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4614             MOV      R4,R2
     85              long quat4[4];
     86              long quat_body_to_world[4];
     87          
     88              inv_icm20948_convert_compute_scalar_part_fxp(quat, quat4);
   \   0000000A   0xA904             ADD      R1,SP,#+16
   \   0000000C   0x.... 0x....      BL       inv_icm20948_convert_compute_scalar_part_fxp
     89              inv_icm20948_q_mult_q_qi(quat4, s->s_quat_chip_to_body, quat_body_to_world);
   \   00000010   0x466A             MOV      R2,SP
   \   00000012   0xF105 0x01A8      ADD      R1,R5,#+168
   \   00000016   0xA804             ADD      R0,SP,#+16
   \   00000018   0x.... 0x....      BL       inv_icm20948_q_mult_q_qi
     90              if (quat_body_to_world[0] >= 0) {
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x6841             LDR      R1,[R0, #+4]
   \   00000020   0xED9F 0x....      VLDR.W   S0,??DataTable4  ;; 0x30800000
   \   00000024   0x9A00             LDR      R2,[SP, #+0]
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD420             BMI.N    ??inv_icm20948_convert_rotation_vector_0
     91                  values[0] = quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
   \   0000002A   0xEE00 0x1A90      VMOV     S1,R1
   \   0000002E   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000032   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000036   0xEDC4 0x0A00      VSTR     S1,[R4, #0]
     92                  values[1] = quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
   \   0000003A   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   0000003E   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000042   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000046   0xEDC4 0x0A01      VSTR     S1,[R4, #+4]
     93                  values[2] = quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
   \   0000004A   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
   \   0000004E   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000052   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000056   0xEDC4 0x0A02      VSTR     S1,[R4, #+8]
     94                  values[3] = quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
   \   0000005A   0xEDDD 0x0A00      VLDR     S1,[SP, #+0]
   \   0000005E   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000062   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000066   0xED84 0x0A03      VSTR     S0,[R4, #+12]
   \   0000006A   0xE026             B.N      ??inv_icm20948_convert_rotation_vector_1
     95              } else {
     96                  values[0] = -quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
   \                     ??inv_icm20948_convert_rotation_vector_0: (+1)
   \   0000006C   0x4249             RSBS     R1,R1,#+0
   \   0000006E   0xEE00 0x1A90      VMOV     S1,R1
   \   00000072   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000076   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000007A   0xEDC4 0x0A00      VSTR     S1,[R4, #0]
     97                  values[1] = -quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
   \   0000007E   0x6881             LDR      R1,[R0, #+8]
   \   00000080   0x4249             RSBS     R1,R1,#+0
   \   00000082   0xEE00 0x1A90      VMOV     S1,R1
   \   00000086   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000008A   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000008E   0xEDC4 0x0A01      VSTR     S1,[R4, #+4]
     98                  values[2] = -quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
   \   00000092   0x68C0             LDR      R0,[R0, #+12]
   \   00000094   0x4240             RSBS     R0,R0,#+0
   \   00000096   0xEE00 0x0A90      VMOV     S1,R0
   \   0000009A   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000009E   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   000000A2   0xEDC4 0x0A02      VSTR     S1,[R4, #+8]
     99                  values[3] = -quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x4240             RSBS     R0,R0,#+0
   \   000000AA   0xEE00 0x0A90      VMOV     S1,R0
   \   000000AE   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   000000B2   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   000000B6   0xED84 0x0A03      VSTR     S0,[R4, #+12]
    100              }
    101          }
   \                     ??inv_icm20948_convert_rotation_vector_1: (+1)
   \   000000BA   0xB009             ADD      SP,SP,#+36
   \   000000BC   0xBD30             POP      {R4,R5,PC}       ;; return
    102          
    103          /** Convert 3 element fixed point DMP rotation vector to 4 element rotation vector in world frame
    104          * @param[in] quat 3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame
    105          * @param[out] values 4 element quaternion
    106          */

   \                                 In section .text, align 2, keep-with-next
    107          void inv_icm20948_convert_rotation_vector_2(struct inv_icm20948 * s, const long *quat, long *quat4_world)
    108          {
   \                     inv_icm20948_convert_rotation_vector_2: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4615             MOV      R5,R2
    109              long quat4[4];
    110              long quat_body_to_world[4];
    111          
    112              inv_icm20948_convert_compute_scalar_part_fxp(quat, quat4);
   \   0000000A   0xA904             ADD      R1,SP,#+16
   \   0000000C   0x.... 0x....      BL       inv_icm20948_convert_compute_scalar_part_fxp
    113              inv_icm20948_q_mult_q_qi(quat4, s->s_quat_chip_to_body, quat_body_to_world);
   \   00000010   0x466A             MOV      R2,SP
   \   00000012   0xF104 0x01A8      ADD      R1,R4,#+168
   \   00000016   0xA804             ADD      R0,SP,#+16
   \   00000018   0x.... 0x....      BL       inv_icm20948_q_mult_q_qi
    114              memcpy(quat4_world, quat_body_to_world, 4*sizeof(long));
   \   0000001C   0x2210             MOVS     R2,#+16
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy4
    115          }
   \   00000026   0xB009             ADD      SP,SP,#+36
   \   00000028   0xBD30             POP      {R4,R5,PC}       ;; return
    116          
    117          /** Convert 4 element rotation vector in world frame to floating point android notation
    118          * @param[in] quat 4 element rotation vector in World frame
    119          * @param[out] values in Android format
    120          */

   \                                 In section .text, align 4, keep-with-next
    121          void inv_icm20948_convert_rotation_vector_3(const long *quat4_world, float *values)
    122          {
    123              if (quat4_world[0] >= 0) {
   \                     inv_icm20948_convert_rotation_vector_3: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0xED9F 0x....      VLDR.W   S0,??DataTable4  ;; 0x30800000
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD420             BMI.N    ??inv_icm20948_convert_rotation_vector_3_0
    124                  values[0] = quat4_world[1] * INV_TWO_POWER_NEG_30;
   \   0000000C   0xEE00 0x2A90      VMOV     S1,R2
   \   00000010   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000014   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000018   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
    125                  values[1] = quat4_world[2] * INV_TWO_POWER_NEG_30;
   \   0000001C   0xEDD0 0x0A02      VLDR     S1,[R0, #+8]
   \   00000020   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000024   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000028   0xEDC1 0x0A01      VSTR     S1,[R1, #+4]
    126                  values[2] = quat4_world[3] * INV_TWO_POWER_NEG_30;
   \   0000002C   0xEDD0 0x0A03      VLDR     S1,[R0, #+12]
   \   00000030   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000034   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000038   0xEDC1 0x0A02      VSTR     S1,[R1, #+8]
    127                  values[3] = quat4_world[0] * INV_TWO_POWER_NEG_30;
   \   0000003C   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000040   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000044   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000048   0xED81 0x0A03      VSTR     S0,[R1, #+12]
   \   0000004C   0x4770             BX       LR
    128              } else {
    129                  values[0] = -quat4_world[1] * INV_TWO_POWER_NEG_30;
   \                     ??inv_icm20948_convert_rotation_vector_3_0: (+1)
   \   0000004E   0x4252             RSBS     R2,R2,#+0
   \   00000050   0xEE00 0x2A90      VMOV     S1,R2
   \   00000054   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000058   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   0000005C   0xEDC1 0x0A00      VSTR     S1,[R1, #0]
    130                  values[1] = -quat4_world[2] * INV_TWO_POWER_NEG_30;
   \   00000060   0x6882             LDR      R2,[R0, #+8]
   \   00000062   0x4252             RSBS     R2,R2,#+0
   \   00000064   0xEE00 0x2A90      VMOV     S1,R2
   \   00000068   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000006C   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000070   0xEDC1 0x0A01      VSTR     S1,[R1, #+4]
    131                  values[2] = -quat4_world[3] * INV_TWO_POWER_NEG_30;
   \   00000074   0x68C2             LDR      R2,[R0, #+12]
   \   00000076   0x4252             RSBS     R2,R2,#+0
   \   00000078   0xEE00 0x2A90      VMOV     S1,R2
   \   0000007C   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000080   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000084   0xEDC1 0x0A02      VSTR     S1,[R1, #+8]
    132                  values[3] = -quat4_world[0] * INV_TWO_POWER_NEG_30;
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x4240             RSBS     R0,R0,#+0
   \   0000008C   0xEE00 0x0A90      VMOV     S1,R0
   \   00000090   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   00000094   0xEE20 0x0A80      VMUL.F32 S0,S1,S0
   \   00000098   0xED81 0x0A03      VSTR     S0,[R1, #+12]
    133              }
    134          }
   \   0000009C   0x4770             BX       LR               ;; return
    135          

   \                                 In section .text, align 4, keep-with-next
    136          static void inv_rotation_to_quaternion(float Rcb[9], long Qcb_fp[4]) {	
   \                     inv_rotation_to_quaternion: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    137          	float q[4]; 
    138          	inv_icm20948_convert_matrix_to_quat_flt(Rcb, q); 
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x.... 0x....      BL       inv_icm20948_convert_matrix_to_quat_flt
    139          	INVN_CONVERT_FLT_TO_FXP(q, Qcb_fp, 4, 30); 
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE013             B.N      ??inv_rotation_to_quaternion_0
   \                     ??inv_rotation_to_quaternion_1: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   \                     ??inv_rotation_to_quaternion_2: (+1)
   \   00000010   0xEDDF 0x....      VLDR.W   S1,??DataTable6  ;; 0x4e800000
   \   00000014   0xEE01 0x1A10      VMOV     S2,R1
   \   00000018   0xEEB8 0x1A41      VCVT.F32.U32 S2,S2
   \   0000001C   0xEEFE 0x1A00      VMOV.F32 S3,#-0.5
   \   00000020   0xEE31 0x1A21      VADD.F32 S2,S2,S3
   \   00000024   0xEE00 0x1A20      VMLA.F32 S2,S0,S1
   \   00000028   0xEEBD 0x0AC1      VCVT.S32.F32 S0,S2
   \   0000002C   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \   00000030   0xED81 0x0A00      VSTR     S0,[R1, #0]
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_rotation_to_quaternion_0: (+1)
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xDA0B             BGE.N    ??inv_rotation_to_quaternion_3
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   00000040   0xED91 0x0A00      VLDR     S0,[R1, #0]
   \   00000044   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000048   0xEEF1 0xFA10      FMSTAT   
   \   0000004C   0xDBDF             BLT.N    ??inv_rotation_to_quaternion_1
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0xE7DE             B.N      ??inv_rotation_to_quaternion_2
    140          }
   \                     ??inv_rotation_to_quaternion_3: (+1)
   \   00000052   0xBD1F             POP      {R0-R4,PC}       ;; return
    141          

   \                                 In section .text, align 4, keep-with-next
    142          void inv_icm20948_set_chip_to_body_axis_quaternion(struct inv_icm20948 * s, signed char *accel_gyro_matrix, float angle)
    143          {
   \                     inv_icm20948_set_chip_to_body_axis_quaternion: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB096             SUB      SP,SP,#+88
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0xEEB0 0x8A40      VMOV.F32 S16,S0
    144              int i;
    145              float rot[9];
    146              long qcb[4],q_all[4];
    147              long q_adjust[4];
    148              for (i=0; i<9; i++) {
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE00A             B.N      ??inv_icm20948_set_chip_to_body_axis_quaternion_0
    149                  rot[i] = (float)accel_gyro_matrix[i];
   \                     ??inv_icm20948_set_chip_to_body_axis_quaternion_1: (+1)
   \   00000012   0x560A             LDRSB    R2,[R1, R0]
   \   00000014   0xEE00 0x2A10      VMOV     S0,R2
   \   00000018   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001C   0xAA0C             ADD      R2,SP,#+48
   \   0000001E   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \   00000022   0xED82 0x0A00      VSTR     S0,[R2, #0]
    150              }
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_set_chip_to_body_axis_quaternion_0: (+1)
   \   00000028   0x2809             CMP      R0,#+9
   \   0000002A   0xDBF2             BLT.N    ??inv_icm20948_set_chip_to_body_axis_quaternion_1
    151              // Convert Chip to Body transformation matrix to quaternion
    152              // inv_icm20948_convert_matrix_to_quat_fxp(rot, qcb);
    153          	inv_rotation_to_quaternion(rot, qcb);
   \   0000002C   0xA904             ADD      R1,SP,#+16
   \   0000002E   0xA80C             ADD      R0,SP,#+48
   \   00000030   0x.... 0x....      BL       inv_rotation_to_quaternion
    154          	
    155              // The quaterion generated is the inverse, take the inverse again.
    156              qcb[1] = -qcb[1];
   \   00000034   0xA804             ADD      R0,SP,#+16
   \   00000036   0x6841             LDR      R1,[R0, #+4]
   \   00000038   0x4249             RSBS     R1,R1,#+0
   \   0000003A   0x6041             STR      R1,[R0, #+4]
    157              qcb[2] = -qcb[2];
   \   0000003C   0x6881             LDR      R1,[R0, #+8]
   \   0000003E   0x4249             RSBS     R1,R1,#+0
   \   00000040   0x6081             STR      R1,[R0, #+8]
    158              qcb[3] = -qcb[3];
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0x4249             RSBS     R1,R1,#+0
   \   00000046   0x60C1             STR      R1,[R0, #+12]
    159          
    160              // Now rotate by angle, negate angle to rotate other way
    161              q_adjust[0] = (long)((1L<<30) * cosf(-angle*(float)M_PI/180.f/2.f));
   \   00000048   0xED9F 0x....      VLDR.W   S0,??DataTable6_1  ;; 0x40490fdb
   \   0000004C   0xEE28 0x0A00      VMUL.F32 S0,S16,S0
   \   00000050   0xEDDF 0x....      VLDR.W   S1,??DataTable6_2  ;; 0xc3b40000
   \   00000054   0xEE80 0x8A20      VDIV.F32 S16,S0,S1
   \   00000058   0xEDDF 0x....      VLDR.W   S17,??DataTable6  ;; 0x4e800000
   \   0000005C   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   00000060   0x.... 0x....      BL       cosf
   \   00000064   0xEE20 0x0A28      VMUL.F32 S0,S0,S17
   \   00000068   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000006C   0xED8D 0x0A00      VSTR     S0,[SP, #+0]
    162              q_adjust[1] = 0;
   \   00000070   0x466D             MOV      R5,SP
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6068             STR      R0,[R5, #+4]
    163              q_adjust[2] = (long)((1L<<30)*sinf(-angle*(float)M_PI/180.f/2.f));
   \   00000076   0xEEB0 0x0A48      VMOV.F32 S0,S16
   \   0000007A   0x.... 0x....      BL       sinf
   \   0000007E   0xEE20 0x0A28      VMUL.F32 S0,S0,S17
   \   00000082   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   00000086   0xED85 0x0A02      VSTR     S0,[R5, #+8]
    164              q_adjust[3] = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x60E8             STR      R0,[R5, #+12]
    165              invn_convert_quat_mult_fxp(q_adjust, qcb, q_all);
   \   0000008E   0xAA08             ADD      R2,SP,#+32
   \   00000090   0xA904             ADD      R1,SP,#+16
   \   00000092   0x4668             MOV      R0,SP
   \   00000094   0x.... 0x....      BL       invn_convert_quat_mult_fxp
    166              inv_icm20948_set_chip_to_body(s, q_all);
   \   00000098   0xA908             ADD      R1,SP,#+32
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       inv_icm20948_set_chip_to_body
    167          }
   \   000000A0   0xB016             ADD      SP,SP,#+88
   \   000000A2   0xECBD 0x8B02      VPOP     {D8}
   \   000000A6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    168          

   \                                 In section .text, align 2, keep-with-next
    169          void inv_icm20948_convert_dmp3_to_body(struct inv_icm20948 * s, const long *vec3, float scale, float *values)
    170          {
   \                     inv_icm20948_convert_dmp3_to_body: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB084             SUB      SP,SP,#+16
   \   00000008   0xEEB0 0x8A40      VMOV.F32 S16,S0
   \   0000000C   0x4614             MOV      R4,R2
    171              long out[3];
    172              inv_icm20948_convert_quat_rotate_fxp(s->s_quat_chip_to_body, vec3, out);
   \   0000000E   0x466A             MOV      R2,SP
   \   00000010   0x30A8             ADDS     R0,R0,#+168
   \   00000012   0x.... 0x....      BL       inv_icm20948_convert_quat_rotate_fxp
    173              values[0] = out[0] * scale;
   \   00000016   0xED9D 0x0A00      VLDR     S0,[SP, #+0]
   \   0000001A   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   0000001E   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   00000022   0xED84 0x0A00      VSTR     S0,[R4, #0]
    174              values[1] = out[1] * scale;
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0xED90 0x0A01      VLDR     S0,[R0, #+4]
   \   0000002C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000030   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   00000034   0xED84 0x0A01      VSTR     S0,[R4, #+4]
    175              values[2] = out[2] * scale;
   \   00000038   0xED90 0x0A02      VLDR     S0,[R0, #+8]
   \   0000003C   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   00000040   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   00000044   0xED84 0x0A02      VSTR     S0,[R4, #+8]
    176          }
   \   00000048   0xB004             ADD      SP,SP,#+16
   \   0000004A   0xECBD 0x8B02      VPOP     {D8}
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    177          
    178          /** Converts a 32-bit long to a little endian byte stream */

   \                                 In section .text, align 2, keep-with-next
    179          unsigned char *inv_icm20948_int32_to_little8(long x, unsigned char *little8)
    180          {
    181              little8[3] = (unsigned char)((x >> 24) & 0xff);
   \                     inv_icm20948_int32_to_little8: (+1)
   \   00000000   0x1602             ASRS     R2,R0,#+24
   \   00000002   0x70CA             STRB     R2,[R1, #+3]
    182              little8[2] = (unsigned char)((x >> 16) & 0xff);
   \   00000004   0x1402             ASRS     R2,R0,#+16
   \   00000006   0x708A             STRB     R2,[R1, #+2]
    183              little8[1] = (unsigned char)((x >> 8) & 0xff);
   \   00000008   0x1202             ASRS     R2,R0,#+8
   \   0000000A   0x704A             STRB     R2,[R1, #+1]
    184              little8[0] = (unsigned char)(x & 0xff);
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    185              return little8;
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0x4770             BX       LR               ;; return
    186          }
    187          

   \                                 In section .text, align 4, keep-with-next
    188          float inv_icm20948_convert_deg_to_rad(float deg_val)
    189          {
    190          	float rad_val;
    191              rad_val = deg_val*(float)M_PI / 180.f;
    192          	return rad_val;
   \                     inv_icm20948_convert_deg_to_rad: (+1)
   \   00000000   0xEDDF 0x....      VLDR.W   S1,??DataTable6_1  ;; 0x40490fdb
   \   00000004   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000008   0xEDDF 0x....      VLDR.W   S1,??DataTable6_3  ;; 0x43340000
   \   0000000C   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   00000010   0x4770             BX       LR               ;; return
    193          }
    194          

   \                                 In section .text, align 2, keep-with-next
    195          long inv_icm20948_convert_mult_q30_fxp(long a_q30, long b_q30)
    196          {
    197          	long long temp;
    198          	long result;
    199          	temp = (long long)a_q30 * b_q30;
    200          	result = (long)(temp >> 30);
    201          	return result;
   \                     inv_icm20948_convert_mult_q30_fxp: (+1)
   \   00000000   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   00000004   0x0F80             LSRS     R0,R0,#+30
   \   00000006   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   0000000A   0x4770             BX       LR               ;; return
    202          }
    203          

   \                                 In section .text, align 2, keep-with-next
    204          int inv_icm20948_convert_compute_scalar_part_fxp(const long * inQuat_q30, long* outQuat_q30)
    205          {
   \                     inv_icm20948_convert_compute_scalar_part_fxp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    206              long scalarPart = 0;
    207          
    208              scalarPart = inv_icm20948_convert_fast_sqrt_fxp((1L<<30) - inv_icm20948_convert_mult_q30_fxp(inQuat_q30[0], inQuat_q30[0])
    209                                                  - inv_icm20948_convert_mult_q30_fxp(inQuat_q30[1], inQuat_q30[1])
    210                                                  - inv_icm20948_convert_mult_q30_fxp(inQuat_q30[2], inQuat_q30[2]) );
    211              outQuat_q30[0] = scalarPart;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000000E   0x6861             LDR      R1,[R4, #+4]
   \   00000010   0xF1C0 0x4680      RSB      R6,R0,#+1073741824
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000001A   0x1A36             SUBS     R6,R6,R0
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x4601             MOV      R1,R0
   \   00000020   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000024   0x1A30             SUBS     R0,R6,R0
   \   00000026   0x.... 0x....      BL       inv_icm20948_convert_fast_sqrt_fxp
   \   0000002A   0x6028             STR      R0,[R5, #+0]
    212              outQuat_q30[1] = inQuat_q30[0];
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6068             STR      R0,[R5, #+4]
    213              outQuat_q30[2] = inQuat_q30[1];
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0x60A8             STR      R0,[R5, #+8]
    214              outQuat_q30[3] = inQuat_q30[2];
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x60E8             STR      R0,[R5, #+12]
    215          
    216              return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    217          }
    218          

   \                                 In section .text, align 2, keep-with-next
    219          long inv_icm20948_convert_fast_sqrt_fxp(long x0_q30)
    220          {
   \                     inv_icm20948_convert_fast_sqrt_fxp: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    221          
    222          	//% Square-Root with NR in the neighborhood of 1.3>x>=0.65 (log(2) <= x <= log(4) )
    223              // Two-variable NR iteration:
    224              // Initialize: a=x; c=x-1;  
    225              // 1st Newton Step:  a=a-a*c/2; ( or: a = x - x*(x-1)/2  )
    226              // Iterate: c = c*c*(c-3)/4
    227              //          a = a - a*c/2    --> reevaluating c at this step gives error of approximation
    228          
    229          	//% Seed equals 1. Works best in this region.
    230          	//xx0 = int32(1*2^30);
    231          
    232          	long sqrt2, oneoversqrt2, one_pt5;
    233          	long xx, cc;
    234          	int pow2, sq2scale, nr_iters;
    235          
    236          	// Return if input is zero. Negative should really error out. 
    237          	if (x0_q30 <= 0L) {
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xDA01             BGE.N    ??inv_icm20948_convert_fast_sqrt_fxp_0
    238          		return 0L;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBDFE             POP      {R1-R7,PC}
    239          	}
    240          
    241          	sqrt2 =1518500250L;
    242          	oneoversqrt2=759250125L;
    243          	one_pt5=1610612736L;
    244          
    245          	nr_iters = inv_icm20948_convert_test_limits_and_scale_fxp(&x0_q30, &pow2);
   \                     ??inv_icm20948_convert_fast_sqrt_fxp_0: (+1)
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x.... 0x....      BL       inv_icm20948_convert_test_limits_and_scale_fxp
   \   00000014   0x4604             MOV      R4,R0
    246          	
    247          	sq2scale = 0;
   \   00000016   0x2500             MOVS     R5,#+0
    248          	if (pow2 > 0) 
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xDB06             BLT.N    ??inv_icm20948_convert_fast_sqrt_fxp_1
    249          		sq2scale=pow2%2;  // Find remainder. Is it even or odd?
   \   0000001E   0x4601             MOV      R1,R0
   \   00000020   0x4602             MOV      R2,R0
   \   00000022   0xEB02 0x71D1      ADD      R1,R2,R1, LSR #+31
   \   00000026   0x1049             ASRS     R1,R1,#+1
   \   00000028   0xEBA0 0x0541      SUB      R5,R0,R1, LSL #+1
    250          	pow2 = pow2-sq2scale; // Now pow2 is even. Note we are adding because result is scaled with sqrt(2)
   \                     ??inv_icm20948_convert_fast_sqrt_fxp_1: (+1)
   \   0000002C   0x1B40             SUBS     R0,R0,R5
   \   0000002E   0x9000             STR      R0,[SP, #+0]
    251          
    252          	// Sqrt 1st NR iteration
    253          	cc = x0_q30 - (1L<<30);
   \   00000030   0x9802             LDR      R0,[SP, #+8]
   \   00000032   0xF100 0x4740      ADD      R7,R0,#-1073741824
    254          	xx = x0_q30 - (inv_icm20948_convert_mult_q30_fxp(x0_q30, cc)>>1);
   \   00000036   0x4606             MOV      R6,R0
   \   00000038   0x4639             MOV      R1,R7
   \   0000003A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000003E   0xEBA6 0x0660      SUB      R6,R6,R0, ASR #+1
    255           	if ( nr_iters>=2 ) {
   \   00000042   0x2C02             CMP      R4,#+2
   \   00000044   0xDB23             BLT.N    ??inv_icm20948_convert_fast_sqrt_fxp_2
    256          		// Sqrt second NR iteration
    257          		// cc = cc*cc*(cc-3)/4; = cc*cc*(cc/2 - 3/2)/2;
    258          		// cc = ( cc*cc*((cc>>1) - onePt5) ) >> 1
    259          		cc = inv_icm20948_convert_mult_q30_fxp( cc, inv_icm20948_convert_mult_q30_fxp(cc, (cc>>1) - one_pt5) ) >> 1;
   \   00000046   0x1078             ASRS     R0,R7,#+1
   \   00000048   0xF100 0x4120      ADD      R1,R0,#-1610612736
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000052   0x4601             MOV      R1,R0
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000005A   0x1047             ASRS     R7,R0,#+1
    260          		xx = xx - (inv_icm20948_convert_mult_q30_fxp(xx, cc)>>1);
   \   0000005C   0x4639             MOV      R1,R7
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000064   0xEBA6 0x0660      SUB      R6,R6,R0, ASR #+1
    261          		if ( nr_iters==3 ) {
   \   00000068   0x2C03             CMP      R4,#+3
   \   0000006A   0xD110             BNE.N    ??inv_icm20948_convert_fast_sqrt_fxp_2
    262          			// Sqrt third NR iteration
    263          			cc = inv_icm20948_convert_mult_q30_fxp( cc, inv_icm20948_convert_mult_q30_fxp(cc, (cc>>1) - one_pt5) ) >> 1;
   \   0000006C   0x1078             ASRS     R0,R7,#+1
   \   0000006E   0xF100 0x4120      ADD      R1,R0,#-1610612736
   \   00000072   0x4638             MOV      R0,R7
   \   00000074   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000078   0x4601             MOV      R1,R0
   \   0000007A   0x4638             MOV      R0,R7
   \   0000007C   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000080   0x1047             ASRS     R7,R0,#+1
    264          			xx = xx - (inv_icm20948_convert_mult_q30_fxp(xx, cc)>>1);
   \   00000082   0x4639             MOV      R1,R7
   \   00000084   0x4630             MOV      R0,R6
   \   00000086   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000008A   0xEBA6 0x0660      SUB      R6,R6,R0, ASR #+1
    265          		}
    266          	}
    267          	if (sq2scale)
   \                     ??inv_icm20948_convert_fast_sqrt_fxp_2: (+1)
   \   0000008E   0x2D00             CMP      R5,#+0
   \   00000090   0xD005             BEQ.N    ??inv_icm20948_convert_fast_sqrt_fxp_3
    268          		xx = inv_icm20948_convert_mult_q30_fxp(xx,oneoversqrt2);
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x2d413ccd
   \   00000096   0x4630             MOV      R0,R6
   \   00000098   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000009C   0x4606             MOV      R6,R0
    269          	// Scale the number with the half of the power of 2 scaling
    270          	if (pow2>0)
   \                     ??inv_icm20948_convert_fast_sqrt_fxp_3: (+1)
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x2801             CMP      R0,#+1
   \   000000A2   0xDB02             BLT.N    ??inv_icm20948_convert_fast_sqrt_fxp_4
    271          		xx = (xx >> (pow2>>1)); 
   \   000000A4   0x1040             ASRS     R0,R0,#+1
   \   000000A6   0x4106             ASRS     R6,R6,R0
   \   000000A8   0xE008             B.N      ??inv_icm20948_convert_fast_sqrt_fxp_5
    272          	else if (pow2 == -1)
   \                     ??inv_icm20948_convert_fast_sqrt_fxp_4: (+1)
   \   000000AA   0xF110 0x0F01      CMN      R0,#+1
   \   000000AE   0xD105             BNE.N    ??inv_icm20948_convert_fast_sqrt_fxp_5
    273          		xx = inv_icm20948_convert_mult_q30_fxp(xx,sqrt2);
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x5a82799a
   \   000000B4   0x4630             MOV      R0,R6
   \   000000B6   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   000000BA   0x4606             MOV      R6,R0
    274          	return xx;
   \                     ??inv_icm20948_convert_fast_sqrt_fxp_5: (+1)
   \   000000BC   0x4630             MOV      R0,R6
   \   000000BE   0xBDFE             POP      {R1-R7,PC}       ;; return
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          int inv_icm20948_convert_test_limits_and_scale_fxp(long *x0_q30, int *pow)
    278          {
   \                     inv_icm20948_convert_test_limits_and_scale_fxp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    279              long lowerlimit, upperlimit, oneiterlothr, oneiterhithr, zeroiterlothr, zeroiterhithr;
    280          
    281              // Lower Limit: ll = int32(log(2)*2^30);
    282              lowerlimit = 744261118L;
    283              //Upper Limit ul = int32(log(4)*2^30);
    284              upperlimit = 1488522236L;
    285              //  int32(0.9*2^30)
    286              oneiterlothr = 966367642L;
    287              // int32(1.1*2^30)
    288              oneiterhithr = 1181116006L;
    289              // int32(0.99*2^30)
    290              zeroiterlothr=1063004406L;
    291              //int32(1.01*2^30)
    292              zeroiterhithr=1084479242L;
    293          
    294              // Scale number such that Newton Raphson iteration works best:
    295              // Find the power of two scaling that leaves the number in the optimal range,
    296              // ll <= number <= ul. Note odd powers have special scaling further below
    297          	if (*x0_q30 > upperlimit) {
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x58b90bfd
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xDB05             BLT.N    ??inv_icm20948_convert_test_limits_and_scale_fx_0
    298          		// Halving the number will push it in the optimal range since largest value is 2
    299          		*x0_q30 = *x0_q30>>1;
   \   00000010   0x1040             ASRS     R0,R0,#+1
   \   00000012   0x6020             STR      R0,[R4, #+0]
    300          		*pow=-1;
   \   00000014   0xF04F 0x30FF      MOV      R0,#-1
   \   00000018   0x6028             STR      R0,[R5, #+0]
   \   0000001A   0xE01C             B.N      ??inv_icm20948_convert_test_limits_and_scale_fx_1
    301          	} else if (*x0_q30 < lowerlimit) {
   \                     ??inv_icm20948_convert_test_limits_and_scale_fx_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R6,??DataTable9_3  ;; 0x2c5c85fe
   \   00000020   0x42B0             CMP      R0,R6
   \   00000022   0xDA16             BGE.N    ??inv_icm20948_convert_test_limits_and_scale_fx_2
    302          		// Find position of highest bit, counting from left, and scale number 
    303          		*pow=inv_icm20948_convert_get_highest_bit_position((uint32_t*)x0_q30);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       inv_icm20948_convert_get_highest_bit_position
   \   0000002A   0x6028             STR      R0,[R5, #+0]
    304          		if (*x0_q30 >= upperlimit) {
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable9_4  ;; 0x58b90bfc
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xDB05             BLT.N    ??inv_icm20948_convert_test_limits_and_scale_fx_3
    305          			// Halving the number will push it in the optimal range
    306          			*x0_q30 = *x0_q30>>1;
   \   00000036   0x1040             ASRS     R0,R0,#+1
   \   00000038   0x6020             STR      R0,[R4, #+0]
    307          			*pow=*pow-1;
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x1E40             SUBS     R0,R0,#+1
   \   0000003E   0x6028             STR      R0,[R5, #+0]
   \   00000040   0xE009             B.N      ??inv_icm20948_convert_test_limits_and_scale_fx_1
    308          		}
    309          		else if (*x0_q30 < lowerlimit) {
   \                     ??inv_icm20948_convert_test_limits_and_scale_fx_3: (+1)
   \   00000042   0x42B0             CMP      R0,R6
   \   00000044   0xDA07             BGE.N    ??inv_icm20948_convert_test_limits_and_scale_fx_1
    310          			// Doubling the number will push it in the optimal range
    311          			*x0_q30 = *x0_q30<<1;
   \   00000046   0x0040             LSLS     R0,R0,#+1
   \   00000048   0x6020             STR      R0,[R4, #+0]
    312          			*pow=*pow+1;
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x6028             STR      R0,[R5, #+0]
   \   00000050   0xE001             B.N      ??inv_icm20948_convert_test_limits_and_scale_fx_1
    313          		}
    314          	} else {
    315          		*pow = 0;
   \                     ??inv_icm20948_convert_test_limits_and_scale_fx_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6028             STR      R0,[R5, #+0]
    316          	}
    317              
    318              if ( *x0_q30<oneiterlothr || *x0_q30>oneiterhithr )
   \                     ??inv_icm20948_convert_test_limits_and_scale_fx_1: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable9_5  ;; 0xc6666666
   \   0000005C   0x1809             ADDS     R1,R1,R0
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable9_6  ;; 0xccccccd
   \   00000062   0x4291             CMP      R1,R2
   \   00000064   0xD301             BCC.N    ??inv_icm20948_convert_test_limits_and_scale_fx_4
    319                  return 3; // 3 NR iterations
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0xBD70             POP      {R4-R6,PC}
    320              if ( *x0_q30<zeroiterlothr || *x0_q30>zeroiterhithr )
   \                     ??inv_icm20948_convert_test_limits_and_scale_fx_4: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable9_7  ;; 0xc0a3d70a
   \   0000006E   0x1808             ADDS     R0,R1,R0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable9_8  ;; 0x147ae15
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD301             BCC.N    ??inv_icm20948_convert_test_limits_and_scale_fx_5
    321                  return 2; // 2 NR iteration
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0xBD70             POP      {R4-R6,PC}
    322          
    323              return 1; // 1 NR iteration
   \                     ??inv_icm20948_convert_test_limits_and_scale_fx_5: (+1)
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
    324          }
    325          
    326          /** Auxiliary function used by testLimitsAndScale()
    327          * Find the highest nonzero bit in an unsigned 32 bit integer:
    328          * @param[in] value operand Dimension is 1.
    329          * @return highest bit position.
    330          * \note This function performs the log2 of an interger as well. 
    331          * \ingroup binary
    332          **/

   \                                 In section .text, align 2, keep-with-next
    333          int16_t inv_icm20948_convert_get_highest_bit_position(uint32_t *value)
    334          {
    335              int16_t position;
    336              position = 0;
   \                     inv_icm20948_convert_get_highest_bit_position: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    337              if (*value == 0) return 0;
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??inv_icm20948_convert_get_highest_bit_position_0
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x4770             BX       LR
    338          
    339              if ((*value & 0xFFFF0000) == 0) {
   \                     ??inv_icm20948_convert_get_highest_bit_position_0: (+1)
   \   0000000C   0x0C13             LSRS     R3,R2,#+16
   \   0000000E   0x041B             LSLS     R3,R3,#+16
   \   00000010   0xD102             BNE.N    ??inv_icm20948_convert_get_highest_bit_position_1
    340                  position += 16;
   \   00000012   0x2110             MOVS     R1,#+16
    341                  *value=*value<<16;
   \   00000014   0x0412             LSLS     R2,R2,#+16
   \   00000016   0x6002             STR      R2,[R0, #+0]
    342              }
    343              if ((*value & 0xFF000000) == 0) {
   \                     ??inv_icm20948_convert_get_highest_bit_position_1: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0xF012 0x4F7F      TST      R2,#0xFF000000
   \   0000001E   0xD102             BNE.N    ??inv_icm20948_convert_get_highest_bit_position_2
    344                  position += 8;
   \   00000020   0x3108             ADDS     R1,R1,#+8
    345                  *value=*value<<8;
   \   00000022   0x0212             LSLS     R2,R2,#+8
   \   00000024   0x6002             STR      R2,[R0, #+0]
    346              }
    347              if ((*value & 0xF0000000) == 0) {
   \                     ??inv_icm20948_convert_get_highest_bit_position_2: (+1)
   \   00000026   0x6802             LDR      R2,[R0, #+0]
   \   00000028   0xF012 0x4F70      TST      R2,#0xF0000000
   \   0000002C   0xD102             BNE.N    ??inv_icm20948_convert_get_highest_bit_position_3
    348                  position += 4;
   \   0000002E   0x1D09             ADDS     R1,R1,#+4
    349                  *value=*value<<4;
   \   00000030   0x0112             LSLS     R2,R2,#+4
   \   00000032   0x6002             STR      R2,[R0, #+0]
    350              }
    351              if ((*value & 0xC0000000) == 0) {
   \                     ??inv_icm20948_convert_get_highest_bit_position_3: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0xF012 0x4F40      TST      R2,#0xC0000000
   \   0000003A   0xD102             BNE.N    ??inv_icm20948_convert_get_highest_bit_position_4
    352                  position += 2;
   \   0000003C   0x1C89             ADDS     R1,R1,#+2
    353                  *value=*value<<2;
   \   0000003E   0x0092             LSLS     R2,R2,#+2
   \   00000040   0x6002             STR      R2,[R0, #+0]
    354              }
    355          
    356              // If we got too far into sign bit, shift back. Note we are using an
    357              // unsigned long here, so right shift is going to shift all the bits.
    358              if ((*value & 0x80000000)) { 
   \                     ??inv_icm20948_convert_get_highest_bit_position_4: (+1)
   \   00000042   0x6802             LDR      R2,[R0, #+0]
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD502             BPL.N    ??inv_icm20948_convert_get_highest_bit_position_5
    359                  position -= 1;
   \   00000048   0x1E49             SUBS     R1,R1,#+1
    360                  *value=*value>>1;
   \   0000004A   0x0852             LSRS     R2,R2,#+1
   \   0000004C   0x6002             STR      R2,[R0, #+0]
    361              }
    362              return position;
   \                     ??inv_icm20948_convert_get_highest_bit_position_5: (+1)
   \   0000004E   0x4608             MOV      R0,R1
   \   00000050   0xB200             SXTH     R0,R0
   \   00000052   0x4770             BX       LR               ;; return
    363          }
    364          

   \                                 In section .text, align 2, keep-with-next
    365          void inv_icm20948_convert_matrix_to_quat_fxp(long *Rcb_q30, long *Qcb_q30)
    366          {
   \                     inv_icm20948_convert_matrix_to_quat_fxp: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x460C             MOV      R4,R1
    367                   long r11,r12,r13, r21,r22,r23, r31,r32,r33;
    368                   long temp[3];
    369                   long tmp;
    370                   int pow2, shift;
    371          
    372                   r11 = Rcb_q30[0]>>1; //assume matrix is stored row wise first, that is rot[1] is row 1, col 2
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x1049             ASRS     R1,R1,#+1
    373                   r12 = Rcb_q30[1]>>1;
   \   0000000C   0x6842             LDR      R2,[R0, #+4]
   \   0000000E   0x1055             ASRS     R5,R2,#+1
    374                   r13 = Rcb_q30[2]>>1;
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0x1052             ASRS     R2,R2,#+1
   \   00000014   0x9201             STR      R2,[SP, #+4]
    375          
    376                   r21 = Rcb_q30[3]>>1;
   \   00000016   0x68C2             LDR      R2,[R0, #+12]
   \   00000018   0x1056             ASRS     R6,R2,#+1
    377                   r22 = Rcb_q30[4]>>1;
   \   0000001A   0x6902             LDR      R2,[R0, #+16]
   \   0000001C   0x1052             ASRS     R2,R2,#+1
    378                   r23 = Rcb_q30[5]>>1;
   \   0000001E   0x6943             LDR      R3,[R0, #+20]
   \   00000020   0x105F             ASRS     R7,R3,#+1
    379          
    380                   r31 = Rcb_q30[6]>>1;
   \   00000022   0x6983             LDR      R3,[R0, #+24]
   \   00000024   0xEA4F 0x0863      ASR      R8,R3,#+1
    381                   r32 = Rcb_q30[7]>>1;
   \   00000028   0x69C3             LDR      R3,[R0, #+28]
   \   0000002A   0xEA4F 0x0963      ASR      R9,R3,#+1
    382                   r33 = Rcb_q30[8]>>1;
   \   0000002E   0x6A00             LDR      R0,[R0, #+32]
   \   00000030   0x1040             ASRS     R0,R0,#+1
    383          
    384                   //Qcb[0] = (1.f + r11 + r22 + r33) / 4.f;
    385                   //Qcb[1] = (1.f + r11 - r22 - r33) / 4.f;
    386                   //Qcb[2] = (1.f - r11 + r22 - r33) / 4.f;
    387                   //Qcb[3] = (1.f - r11 - r22 + r33) / 4.f;
    388                   Qcb_q30[0] = (268435456L + (r11>>1) + (r22>>1) + (r33>>1)); // Effectively shifted by 2 bits, one above, one here
   \   00000032   0x1052             ASRS     R2,R2,#+1
   \   00000034   0x1049             ASRS     R1,R1,#+1
   \   00000036   0x1853             ADDS     R3,R2,R1
   \   00000038   0xEB13 0x0360      ADDS     R3,R3,R0, ASR #+1
   \   0000003C   0xF103 0x5380      ADD      R3,R3,#+268435456
   \   00000040   0x6023             STR      R3,[R4, #+0]
    389                   Qcb_q30[1] = (268435456L + (r11>>1) - (r22>>1) - (r33>>1));
   \   00000042   0xF101 0x5380      ADD      R3,R1,#+268435456
   \   00000046   0x1A9B             SUBS     R3,R3,R2
   \   00000048   0xEBB3 0x0360      SUBS     R3,R3,R0, ASR #+1
   \   0000004C   0x6063             STR      R3,[R4, #+4]
    390                   Qcb_q30[2] = (268435456L - (r11>>1) + (r22>>1) - (r33>>1));
   \   0000004E   0xF1C1 0x5180      RSB      R1,R1,#+268435456
   \   00000052   0x1853             ADDS     R3,R2,R1
   \   00000054   0xEBB3 0x0360      SUBS     R3,R3,R0, ASR #+1
   \   00000058   0x60A3             STR      R3,[R4, #+8]
    391                   Qcb_q30[3] = (268435456L - (r11>>1) - (r22>>1) + (r33>>1));
   \   0000005A   0x1A89             SUBS     R1,R1,R2
   \   0000005C   0xEB11 0x0060      ADDS     R0,R1,R0, ASR #+1
   \   00000060   0x60E0             STR      R0,[R4, #+12]
    392          
    393                   if(Qcb_q30[0] < 0L) Qcb_q30[0] = 0L;
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_fxp_0
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x6020             STR      R0,[R4, #+0]
    394                   if(Qcb_q30[1] < 0L) Qcb_q30[1] = 0L;
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_0: (+1)
   \   0000006C   0x6860             LDR      R0,[R4, #+4]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_fxp_1
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6060             STR      R0,[R4, #+4]
    395                   if(Qcb_q30[2] < 0L) Qcb_q30[2] = 0L;
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_1: (+1)
   \   00000076   0x68A0             LDR      R0,[R4, #+8]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_fxp_2
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x60A0             STR      R0,[R4, #+8]
    396                   if(Qcb_q30[3] < 0L) Qcb_q30[3] = 0L;
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_2: (+1)
   \   00000080   0x68E0             LDR      R0,[R4, #+12]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_fxp_3
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x60E0             STR      R0,[R4, #+12]
    397                   if (Qcb_q30[0] == 0L && Qcb_q30[1] == 0L && Qcb_q30[2] == 0L && Qcb_q30[3] == 0L) {
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_3: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD10C             BNE.N    ??inv_icm20948_convert_matrix_to_quat_fxp_4
   \   00000090   0x6861             LDR      R1,[R4, #+4]
   \   00000092   0x2900             CMP      R1,#+0
   \   00000094   0xD109             BNE.N    ??inv_icm20948_convert_matrix_to_quat_fxp_4
   \   00000096   0x68A1             LDR      R1,[R4, #+8]
   \   00000098   0x2900             CMP      R1,#+0
   \   0000009A   0xD106             BNE.N    ??inv_icm20948_convert_matrix_to_quat_fxp_4
   \   0000009C   0x68E1             LDR      R1,[R4, #+12]
   \   0000009E   0x2900             CMP      R1,#+0
   \   000000A0   0xD103             BNE.N    ??inv_icm20948_convert_matrix_to_quat_fxp_4
    398                       Qcb_q30[0] = 1L<<30;
   \   000000A2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000A6   0x6020             STR      R0,[R4, #+0]
    399                       return;
   \   000000A8   0xE05D             B.N      ??inv_icm20948_convert_matrix_to_quat_fxp_5
    400                   }
    401                   //Qcb[0] = sqrt(Qcb[0]);
    402                   //Qcb[1] = sqrt(Qcb[1]);
    403                   //Qcb[2] = sqrt(Qcb[2]);
    404                   //Qcb[3] = sqrt(Qcb[3]);
    405                   Qcb_q30[0] = inv_icm20948_convert_sqrt_q30_fxp(Qcb_q30[0]);
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_4: (+1)
   \   000000AA   0x.... 0x....      BL       inv_icm20948_convert_sqrt_q30_fxp
   \   000000AE   0x6020             STR      R0,[R4, #+0]
    406                   Qcb_q30[1] = inv_icm20948_convert_sqrt_q30_fxp(Qcb_q30[1]);
   \   000000B0   0x6860             LDR      R0,[R4, #+4]
   \   000000B2   0x.... 0x....      BL       inv_icm20948_convert_sqrt_q30_fxp
   \   000000B6   0x6060             STR      R0,[R4, #+4]
    407                   Qcb_q30[2] = inv_icm20948_convert_sqrt_q30_fxp(Qcb_q30[2]);
   \   000000B8   0x68A0             LDR      R0,[R4, #+8]
   \   000000BA   0x.... 0x....      BL       inv_icm20948_convert_sqrt_q30_fxp
   \   000000BE   0x60A0             STR      R0,[R4, #+8]
    408                   Qcb_q30[3] = inv_icm20948_convert_sqrt_q30_fxp(Qcb_q30[3]);
   \   000000C0   0x68E0             LDR      R0,[R4, #+12]
   \   000000C2   0x.... 0x....      BL       inv_icm20948_convert_sqrt_q30_fxp
   \   000000C6   0x60E0             STR      R0,[R4, #+12]
    409          
    410                   if(Qcb_q30[0] >= Qcb_q30[1] && Qcb_q30[0] >= Qcb_q30[2] && Qcb_q30[0] >= Qcb_q30[3]) //Qcb[0] is max
   \   000000C8   0xF8D4 0xC008      LDR      R12,[R4, #+8]
   \   000000CC   0x6863             LDR      R3,[R4, #+4]
   \   000000CE   0x6822             LDR      R2,[R4, #+0]
   \   000000D0   0x429A             CMP      R2,R3
   \   000000D2   0xDB4A             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_6
   \   000000D4   0x4562             CMP      R2,R12
   \   000000D6   0xDB48             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_6
   \   000000D8   0x4282             CMP      R2,R0
   \   000000DA   0xDB46             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_6
    411                   {
    412                          tmp = inv_icm20948_convert_inverse_q30_fxp(Qcb_q30[0], &pow2);
   \   000000DC   0x4669             MOV      R1,SP
   \   000000DE   0x4610             MOV      R0,R2
   \   000000E0   0x.... 0x....      BL       inv_icm20948_convert_inverse_q30_fxp
   \   000000E4   0x4682             MOV      R10,R0
    413                          shift = 30 - pow2 + 1;
   \   000000E6   0x9800             LDR      R0,[SP, #+0]
   \   000000E8   0xF1C0 0x0B1F      RSB      R11,R0,#+31
    414                          Qcb_q30[1] = (long)(((long long)(r23 - r32) * tmp) >> shift) ;
   \   000000EC   0xEBA7 0x0009      SUB      R0,R7,R9
   \   000000F0   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   000000F4   0x465A             MOV      R2,R11
   \   000000F6   0x.... 0x....      BL       __aeabi_lasr
   \   000000FA   0x6060             STR      R0,[R4, #+4]
    415                          Qcb_q30[2] = (long)(((long long)(r31 - r13) * tmp) >> shift) ;
   \   000000FC   0x9801             LDR      R0,[SP, #+4]
   \   000000FE   0xEBA8 0x0000      SUB      R0,R8,R0
   \   00000102   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   00000106   0x465A             MOV      R2,R11
   \   00000108   0x.... 0x....      BL       __aeabi_lasr
   \   0000010C   0x60A0             STR      R0,[R4, #+8]
    416                          Qcb_q30[3] = (long)(((long long)(r12 - r21) * tmp) >> shift) ;
   \   0000010E   0x1BA8             SUBS     R0,R5,R6
   \   00000110   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   00000114   0x465A             MOV      R2,R11
   \   00000116   0x.... 0x....      BL       __aeabi_lasr
   \   0000011A   0x60E0             STR      R0,[R4, #+12]
    417                           //Qcb[1] = (r23 - r32)/(4.f*Qcb[0]);
    418                           //Qcb[2] = (r31 - r13)/(4.f*Qcb[0]);
    419                           //Qcb[3] = (r12 - r21)/(4.f*Qcb[0]);
    420                   }
    421                   else if(Qcb_q30[1] >= Qcb_q30[0] && Qcb_q30[1] >= Qcb_q30[2] && Qcb_q30[1] >= Qcb_q30[3]) //Qcb[1] is max
    422                   {
    423                          tmp = inv_icm20948_convert_inverse_q30_fxp(Qcb_q30[1], &pow2);
    424                          shift = 30 - pow2 + 1;
    425          		        Qcb_q30[0] = (long)(((long long)(r23 - r32) * tmp) >> shift) ;
    426          		        Qcb_q30[2] = (long)(((long long)(r12 + r21) * tmp) >> shift) ;
    427          		        Qcb_q30[3] = (long)(((long long)(r31 + r13) * tmp) >> shift) ;
    428                          // Qcb[0] = (r23 - r32)/(4.f*Qcb[1]);
    429                          // Qcb[1] = Qcb[1];
    430                          // Qcb[2] = (r12 + r21)/(4.f*Qcb[1]);
    431                          // Qcb[3] = (r31 + r13)/(4.f*Qcb[1]);
    432                   }
    433                   else if(Qcb_q30[2] >= Qcb_q30[0] && Qcb_q30[2] >= Qcb_q30[1] && Qcb_q30[2] >= Qcb_q30[3]) //Qcb[2] is max
    434                   {
    435                          tmp = inv_icm20948_convert_inverse_q30_fxp(Qcb_q30[2], &pow2);
    436                          shift = 30 - pow2 + 1;
    437          		        Qcb_q30[0] = (long)(((long long)(r31 - r13) * tmp) >> shift) ;
    438          		        Qcb_q30[1] = (long)(((long long)(r12 + r21) * tmp) >> shift) ;
    439          		        Qcb_q30[3] = (long)(((long long)(r23 + r32) * tmp) >> shift) ;
    440                           //Qcb[0] = (r31 - r13)/(4.f*Qcb[2]);
    441                           //Qcb[1] = (r12 + r21)/(4.f*Qcb[2]);
    442                           //Qcb[2] = Qcb[2];
    443                           //Qcb[3] = (r23 + r32)/(4.f*Qcb[2]);
    444                   }
    445                   else if(Qcb_q30[3] >= Qcb_q30[0] && Qcb_q30[3] >= Qcb_q30[1] && Qcb_q30[3] >= Qcb_q30[2]) //Qcb[3] is max
    446                   {
    447                          tmp = inv_icm20948_convert_inverse_q30_fxp(Qcb_q30[3], &pow2);
    448                          shift = 30 - pow2 + 1;
    449          		        Qcb_q30[0] = (long)(((long long)(r12 - r21) * tmp) >> shift) ;
    450          		        Qcb_q30[1] = (long)(((long long)(r31 + r13) * tmp) >> shift) ;
    451          		        Qcb_q30[2] = (long)(((long long)(r23 + r32) * tmp) >> shift) ;
    452                           //Qcb[0] = (r12 - r21)/(4.f*Qcb[3]);
    453                           //Qcb[1] = (r31 + r13)/(4.f*Qcb[3]);
    454                           //Qcb[2] = (r23 + r32)/(4.f*Qcb[3]);
    455                           //Qcb[3] = Qcb[3];
    456                   }
    457                   else
    458                   {
    459                          // printf('coding error\n'); //error
    460                       Qcb_q30[0] = 1L<<30;
    461                       Qcb_q30[1] = 0L;
    462                       Qcb_q30[2] = 0L;
    463                       Qcb_q30[3] = 0L;
    464                       return;
    465                   }
    466          
    467                  // Normalize
    468                  // compute inverse square root, using first order taylor series
    469                  // Here temp aligns with row 8
    470                  temp[1] = (long)(((long long)Qcb_q30[0] * Qcb_q30[0] +
    471                                    (long long)Qcb_q30[1] * Qcb_q30[1] +
    472                                    (long long)Qcb_q30[2] * Qcb_q30[2] +
    473                                    (long long)Qcb_q30[3] * Qcb_q30[3]) >> 30);
    474                  temp[2] = temp[1] >> 1; // Multiply by 2^29
    475                  temp[0] = (1L<<30) + (1L<<29) - temp[2];
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_7: (+1)
   \   0000011C   0x68E0             LDR      R0,[R4, #+12]
   \   0000011E   0x68A5             LDR      R5,[R4, #+8]
   \   00000120   0x6862             LDR      R2,[R4, #+4]
   \   00000122   0x6821             LDR      R1,[R4, #+0]
   \   00000124   0xFB82 0x2302      SMULL    R2,R3,R2,R2
   \   00000128   0xFBC1 0x2301      SMLAL    R2,R3,R1,R1
   \   0000012C   0xFBC5 0x2305      SMLAL    R2,R3,R5,R5
   \   00000130   0xFBC0 0x2300      SMLAL    R2,R3,R0,R0
   \   00000134   0x0F92             LSRS     R2,R2,#+30
   \   00000136   0xEA42 0x0283      ORR      R2,R2,R3, LSL #+2
   \   0000013A   0x1050             ASRS     R0,R2,#+1
   \   0000013C   0xF1C0 0x45C0      RSB      R5,R0,#+1610612736
    476          
    477                  // Normalize
    478                  Qcb_q30[0] = inv_icm20948_convert_mult_q30_fxp(temp[0], Qcb_q30[0]);
   \   00000140   0x4628             MOV      R0,R5
   \   00000142   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000146   0x6020             STR      R0,[R4, #+0]
    479                  Qcb_q30[1] = inv_icm20948_convert_mult_q30_fxp(temp[0], Qcb_q30[1]);
   \   00000148   0x6861             LDR      R1,[R4, #+4]
   \   0000014A   0x4628             MOV      R0,R5
   \   0000014C   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000150   0x6060             STR      R0,[R4, #+4]
    480                  Qcb_q30[2] = inv_icm20948_convert_mult_q30_fxp(temp[0], Qcb_q30[2]);
   \   00000152   0x68A1             LDR      R1,[R4, #+8]
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000015A   0x60A0             STR      R0,[R4, #+8]
    481                  Qcb_q30[3] = inv_icm20948_convert_mult_q30_fxp(temp[0], Qcb_q30[3]);
   \   0000015C   0x68E1             LDR      R1,[R4, #+12]
   \   0000015E   0x4628             MOV      R0,R5
   \   00000160   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000164   0x60E0             STR      R0,[R4, #+12]
    482          }
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_5: (+1)
   \   00000166   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_6: (+1)
   \   0000016A   0x4293             CMP      R3,R2
   \   0000016C   0xDB23             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_8
   \   0000016E   0x4563             CMP      R3,R12
   \   00000170   0xDB21             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_8
   \   00000172   0x4283             CMP      R3,R0
   \   00000174   0xDB1F             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_8
   \   00000176   0x4669             MOV      R1,SP
   \   00000178   0x4618             MOV      R0,R3
   \   0000017A   0x.... 0x....      BL       inv_icm20948_convert_inverse_q30_fxp
   \   0000017E   0x4682             MOV      R10,R0
   \   00000180   0x9800             LDR      R0,[SP, #+0]
   \   00000182   0xF1C0 0x0B1F      RSB      R11,R0,#+31
   \   00000186   0xEBA7 0x0009      SUB      R0,R7,R9
   \   0000018A   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   0000018E   0x465A             MOV      R2,R11
   \   00000190   0x.... 0x....      BL       __aeabi_lasr
   \   00000194   0x6020             STR      R0,[R4, #+0]
   \   00000196   0x1970             ADDS     R0,R6,R5
   \   00000198   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   0000019C   0x465A             MOV      R2,R11
   \   0000019E   0x.... 0x....      BL       __aeabi_lasr
   \   000001A2   0x60A0             STR      R0,[R4, #+8]
   \   000001A4   0x9801             LDR      R0,[SP, #+4]
   \   000001A6   0x4440             ADD      R0,R0,R8
   \   000001A8   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   000001AC   0x465A             MOV      R2,R11
   \   000001AE   0x.... 0x....      BL       __aeabi_lasr
   \   000001B2   0x60E0             STR      R0,[R4, #+12]
   \   000001B4   0xE7B2             B.N      ??inv_icm20948_convert_matrix_to_quat_fxp_7
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_8: (+1)
   \   000001B6   0x4594             CMP      R12,R2
   \   000001B8   0xDB24             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_9
   \   000001BA   0x459C             CMP      R12,R3
   \   000001BC   0xDB22             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_9
   \   000001BE   0x4584             CMP      R12,R0
   \   000001C0   0xDB20             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_9
   \   000001C2   0x4669             MOV      R1,SP
   \   000001C4   0x4660             MOV      R0,R12
   \   000001C6   0x.... 0x....      BL       inv_icm20948_convert_inverse_q30_fxp
   \   000001CA   0x4682             MOV      R10,R0
   \   000001CC   0x9800             LDR      R0,[SP, #+0]
   \   000001CE   0xF1C0 0x0B1F      RSB      R11,R0,#+31
   \   000001D2   0x9801             LDR      R0,[SP, #+4]
   \   000001D4   0xEBA8 0x0000      SUB      R0,R8,R0
   \   000001D8   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   000001DC   0x465A             MOV      R2,R11
   \   000001DE   0x.... 0x....      BL       __aeabi_lasr
   \   000001E2   0x6020             STR      R0,[R4, #+0]
   \   000001E4   0x1970             ADDS     R0,R6,R5
   \   000001E6   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   000001EA   0x465A             MOV      R2,R11
   \   000001EC   0x.... 0x....      BL       __aeabi_lasr
   \   000001F0   0x6060             STR      R0,[R4, #+4]
   \   000001F2   0xEB09 0x0007      ADD      R0,R9,R7
   \   000001F6   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   000001FA   0x465A             MOV      R2,R11
   \   000001FC   0x.... 0x....      BL       __aeabi_lasr
   \   00000200   0x60E0             STR      R0,[R4, #+12]
   \   00000202   0xE78B             B.N      ??inv_icm20948_convert_matrix_to_quat_fxp_7
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_9: (+1)
   \   00000204   0x4290             CMP      R0,R2
   \   00000206   0xDB22             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_10
   \   00000208   0x4298             CMP      R0,R3
   \   0000020A   0xDB20             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_10
   \   0000020C   0x4560             CMP      R0,R12
   \   0000020E   0xDB1E             BLT.N    ??inv_icm20948_convert_matrix_to_quat_fxp_10
   \   00000210   0x4669             MOV      R1,SP
   \   00000212   0x.... 0x....      BL       inv_icm20948_convert_inverse_q30_fxp
   \   00000216   0x4682             MOV      R10,R0
   \   00000218   0x9800             LDR      R0,[SP, #+0]
   \   0000021A   0xF1C0 0x0B1F      RSB      R11,R0,#+31
   \   0000021E   0x1BA8             SUBS     R0,R5,R6
   \   00000220   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   00000224   0x465A             MOV      R2,R11
   \   00000226   0x.... 0x....      BL       __aeabi_lasr
   \   0000022A   0x6020             STR      R0,[R4, #+0]
   \   0000022C   0x9801             LDR      R0,[SP, #+4]
   \   0000022E   0x4440             ADD      R0,R0,R8
   \   00000230   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   00000234   0x465A             MOV      R2,R11
   \   00000236   0x.... 0x....      BL       __aeabi_lasr
   \   0000023A   0x6060             STR      R0,[R4, #+4]
   \   0000023C   0xEB09 0x0007      ADD      R0,R9,R7
   \   00000240   0xFB8A 0x0100      SMULL    R0,R1,R10,R0
   \   00000244   0x465A             MOV      R2,R11
   \   00000246   0x.... 0x....      BL       __aeabi_lasr
   \   0000024A   0x60A0             STR      R0,[R4, #+8]
   \   0000024C   0xE766             B.N      ??inv_icm20948_convert_matrix_to_quat_fxp_7
   \                     ??inv_icm20948_convert_matrix_to_quat_fxp_10: (+1)
   \   0000024E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000252   0x6020             STR      R0,[R4, #+0]
   \   00000254   0x2000             MOVS     R0,#+0
   \   00000256   0x6060             STR      R0,[R4, #+4]
   \   00000258   0x60A0             STR      R0,[R4, #+8]
   \   0000025A   0x60E0             STR      R0,[R4, #+12]
   \   0000025C   0xE783             B.N      ??inv_icm20948_convert_matrix_to_quat_fxp_5
    483          

   \                                 In section .text, align 2, keep-with-next
    484          long inv_icm20948_convert_sqrt_q30_fxp(long x_q30)
    485          {
   \                     inv_icm20948_convert_sqrt_q30_fxp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    486              long sqrtx;
    487              int pow2;
    488          
    489              if (x_q30 <= 0L) {
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xDA01             BGE.N    ??inv_icm20948_convert_sqrt_q30_fxp_0
    490                  sqrtx = 0L;
    491                  return sqrtx;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD16             POP      {R1,R2,R4,PC}
    492              }
    493              sqrtx = inv_icm20948_convert_inv_sqrt_q30_fxp(x_q30, &pow2); // invsqrtx
   \                     ??inv_icm20948_convert_sqrt_q30_fxp_0: (+1)
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x.... 0x....      BL       inv_icm20948_convert_inv_sqrt_q30_fxp
    494          
    495              sqrtx = inv_icm20948_convert_mult_q30_fxp(x_q30, sqrtx);
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000001C   0xE002             B.N      ??inv_icm20948_convert_sqrt_q30_fxp_1
    496          
    497          power_up:
    498              if (pow2 > 0) {
    499                  sqrtx = 2*sqrtx;
   \                     ??inv_icm20948_convert_sqrt_q30_fxp_2: (+1)
   \   0000001E   0x0040             LSLS     R0,R0,#+1
    500                  pow2=pow2-1;
   \   00000020   0x1E49             SUBS     R1,R1,#+1
   \   00000022   0x9100             STR      R1,[SP, #+0]
    501                  goto power_up;
    502              }
   \                     ??inv_icm20948_convert_sqrt_q30_fxp_1: (+1)
   \   00000024   0x9900             LDR      R1,[SP, #+0]
   \   00000026   0x2901             CMP      R1,#+1
   \   00000028   0xDAF9             BGE.N    ??inv_icm20948_convert_sqrt_q30_fxp_2
    503          power_down:
    504              if (pow2 < 0) {
   \                     ??inv_icm20948_convert_sqrt_q30_fxp_3: (+1)
   \   0000002A   0x9900             LDR      R1,[SP, #+0]
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD505             BPL.N    ??inv_icm20948_convert_sqrt_q30_fxp_4
    505                  sqrtx = sqrtx/2;
   \   00000030   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000034   0x1040             ASRS     R0,R0,#+1
    506                  pow2=pow2+1;
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \   00000038   0x9100             STR      R1,[SP, #+0]
    507                  goto power_down;
   \   0000003A   0xE7F6             B.N      ??inv_icm20948_convert_sqrt_q30_fxp_3
    508              }
    509          
    510              return sqrtx;
   \                     ??inv_icm20948_convert_sqrt_q30_fxp_4: (+1)
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    511          }
    512          

   \                                 In section .text, align 2, keep-with-next
    513          long inv_icm20948_convert_inv_sqrt_q30_fxp(long x_q30, int *pow2)
    514          {
   \                     inv_icm20948_convert_inv_sqrt_q30_fxp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    515              long oneoversqrt2 = 759250125L; // int32(2^30*1/sqrt(2))
    516              long oneandhalf = 1610612736L; // int32(1.5*2^30);
    517              long upperlimit = 1488522236; // int32(log(4)*2^30);
    518              long lowerlimit = 744261118; // int32(log(2)*2^30); 
    519              long xx, x0_2, invsqrtx;
    520          
    521              *pow2 = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6021             STR      R1,[R4, #+0]
    522          	if (x_q30 <= 0) {
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xDA02             BGE.N    ??inv_icm20948_convert_inv_sqrt_q30_fxp_0
    523                  return 1L<<30;
   \   0000000C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000010   0xBD70             POP      {R4-R6,PC}
    524          	}
    525          
    526              xx = x_q30;
    527              if (xx > upperlimit) {
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable9_2  ;; 0x58b90bfd
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xDB08             BLT.N    ??inv_icm20948_convert_inv_sqrt_q30_fxp_1
   \   0000001A   0xE005             B.N      ??inv_icm20948_convert_inv_sqrt_q30_fxp_2
    528          downscale:
    529                  if (xx > upperlimit) {
    530                      xx = xx/2;
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_3: (+1)
   \   0000001C   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000020   0x1040             ASRS     R0,R0,#+1
    531                      *pow2 = *pow2 - 1;
   \   00000022   0x6822             LDR      R2,[R4, #+0]
   \   00000024   0x1E52             SUBS     R2,R2,#+1
   \   00000026   0x6022             STR      R2,[R4, #+0]
    532                      goto downscale;
    533                  }
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_2: (+1)
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xDAF7             BGE.N    ??inv_icm20948_convert_inv_sqrt_q30_fxp_3
    534              }
    535          
    536              if (xx < lowerlimit) {
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_1: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable9_3  ;; 0x2c5c85fe
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xDA06             BGE.N    ??inv_icm20948_convert_inv_sqrt_q30_fxp_4
   \   00000034   0xE003             B.N      ??inv_icm20948_convert_inv_sqrt_q30_fxp_5
    537          upscale:
    538                  if (xx < lowerlimit) {
    539                      xx = xx*2;
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_6: (+1)
   \   00000036   0x0040             LSLS     R0,R0,#+1
    540                      *pow2 = *pow2 + 1;
   \   00000038   0x6822             LDR      R2,[R4, #+0]
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
   \   0000003C   0x6022             STR      R2,[R4, #+0]
    541                      goto upscale;
    542                  }
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_5: (+1)
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xDBF9             BLT.N    ??inv_icm20948_convert_inv_sqrt_q30_fxp_6
    543              }
    544          
    545              // 3 NR iterations. In some cases second and/or third iteration may not be needed, however
    546              // for code simplicity always iterate three times. Fourth iteration is below bit precision.
    547              x0_2 = xx >>1;
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_4: (+1)
   \   00000042   0x1045             ASRS     R5,R0,#+1
    548              xx = oneandhalf - x0_2;
   \   00000044   0xF1C5 0x46C0      RSB      R6,R5,#+1610612736
    549              xx = inv_icm20948_convert_mult_q30_fxp( xx, ( oneandhalf - inv_icm20948_convert_mult_q30_fxp(x0_2, inv_icm20948_convert_mult_q30_fxp(xx,xx) ) ) );
   \   00000048   0x4631             MOV      R1,R6
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000050   0x4601             MOV      R1,R0
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000058   0xF1C0 0x41C0      RSB      R1,R0,#+1610612736
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000062   0x4606             MOV      R6,R0
    550              xx = inv_icm20948_convert_mult_q30_fxp( xx, ( oneandhalf - inv_icm20948_convert_mult_q30_fxp(x0_2, inv_icm20948_convert_mult_q30_fxp(xx,xx) ) ) );
   \   00000064   0x4631             MOV      R1,R6
   \   00000066   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   00000072   0xF1C0 0x41C0      RSB      R1,R0,#+1610612736
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
    551          
    552              if (*pow2 & 1) { // This checks if the number is even or odd.
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x104A             ASRS     R2,R1,#+1
   \   00000080   0x07C9             LSLS     R1,R1,#+31
   \   00000082   0xD506             BPL.N    ??inv_icm20948_convert_inv_sqrt_q30_fxp_7
    553                  *pow2 = (*pow2>>1) + 1; // Account for sqrt(2) in denominator
   \   00000084   0x1C51             ADDS     R1,R2,#+1
   \   00000086   0x6021             STR      R1,[R4, #+0]
    554                  invsqrtx = (inv_icm20948_convert_mult_q30_fxp(xx,oneoversqrt2));
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x2d413ccd
   \   0000008C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000090   0x....             B.N      inv_icm20948_convert_mult_q30_fxp
    555              }
    556              else {
    557                  *pow2 = *pow2>>1;
   \                     ??inv_icm20948_convert_inv_sqrt_q30_fxp_7: (+1)
   \   00000092   0x6022             STR      R2,[R4, #+0]
    558                  invsqrtx =  xx;
    559              }
    560          
    561              return invsqrtx;
   \   00000094   0xBD70             POP      {R4-R6,PC}       ;; return
    562          }
    563          

   \                                 In section .text, align 2, keep-with-next
    564          long inv_icm20948_convert_inverse_q30_fxp(long x_q30, int *pow2)
    565          {
   \                     inv_icm20948_convert_inverse_q30_fxp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    566              long y;
    567              int negx;
    568          
    569          	if (x_q30 == 0) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD102             BNE.N    ??inv_icm20948_convert_inverse_q30_fxp_0
    570          		y = 0L;
    571                  *pow2 = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    572          		return y;
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    573          	}
    574          
    575              negx=0;
   \                     ??inv_icm20948_convert_inverse_q30_fxp_0: (+1)
   \   0000000E   0x2500             MOVS     R5,#+0
    576              if (x_q30 < 0 ) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD507             BPL.N    ??inv_icm20948_convert_inverse_q30_fxp_1
    577                  if (x_q30 == INT32_MIN)
   \   00000014   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   00000018   0xD102             BNE.N    ??inv_icm20948_convert_inverse_q30_fxp_2
    578                      x_q30 = INT32_MAX;
   \   0000001A   0xF06F 0x4000      MVN      R0,#-2147483648
   \   0000001E   0xE000             B.N      ??inv_icm20948_convert_inverse_q30_fxp_3
    579                  else
    580                      x_q30 = -x_q30;
   \                     ??inv_icm20948_convert_inverse_q30_fxp_2: (+1)
   \   00000020   0x4240             RSBS     R0,R0,#+0
    581                  negx = 1;
   \                     ??inv_icm20948_convert_inverse_q30_fxp_3: (+1)
   \   00000022   0x2501             MOVS     R5,#+1
    582              }
    583          
    584              y = inv_icm20948_convert_inv_sqrt_q30_fxp (x_q30, pow2); // sqrt(y)
   \                     ??inv_icm20948_convert_inverse_q30_fxp_1: (+1)
   \   00000024   0x.... 0x....      BL       inv_icm20948_convert_inv_sqrt_q30_fxp
   \   00000028   0x4601             MOV      R1,R0
    585              if (y > 1518500249L) // y > int32(sqrt(2) -1 : Largest number that won't overflow q30 multiplication of y*y
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x5a82799a
   \   0000002E   0x4281             CMP      R1,R0
   \   00000030   0xDB02             BLT.N    ??inv_icm20948_convert_inverse_q30_fxp_4
    586                  y = INT32_MAX;
   \   00000032   0xF06F 0x4000      MVN      R0,#-2147483648
   \   00000036   0xE002             B.N      ??inv_icm20948_convert_inverse_q30_fxp_5
    587              else
    588                  y = inv_icm20948_convert_mult_q30_fxp(y, y);
   \                     ??inv_icm20948_convert_inverse_q30_fxp_4: (+1)
   \   00000038   0x4608             MOV      R0,R1
   \   0000003A   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
    589              *pow2 = *pow2*2;  // Must double exponent due to multiply 
   \                     ??inv_icm20948_convert_inverse_q30_fxp_5: (+1)
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x6021             STR      R1,[R4, #+0]
    590          
    591              if (negx)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD000             BEQ.N    ??inv_icm20948_convert_inverse_q30_fxp_6
    592                  y=-y;
   \   00000048   0x4240             RSBS     R0,R0,#+0
    593              return y;
   \                     ??inv_icm20948_convert_inverse_q30_fxp_6: (+1)
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    594          }
    595          

   \                                 In section .text, align 2, keep-with-next
    596          void inv_icm20948_convert_matrix_to_quat_flt(float *R, float *q)
    597          {
   \                     inv_icm20948_convert_matrix_to_quat_flt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xED2D 0x8B06      VPUSH    {D8-D10}
   \   00000006   0x460C             MOV      R4,R1
    598          	float r11,r12,r13, r21,r22,r23, r31,r32,r33;
    599          
    600          	r11 = R[0]; //assume matrix is stored row wise first, that is rot[1] is row 1, col 2
   \   00000008   0xED90 0x0A00      VLDR     S0,[R0, #0]
    601          	r12 = R[1];
   \   0000000C   0xED90 0x8A01      VLDR     S16,[R0, #+4]
    602          	r13 = R[2];
   \   00000010   0xEDD0 0x8A02      VLDR     S17,[R0, #+8]
    603          
    604          	r21 = R[3];
   \   00000014   0xED90 0x9A03      VLDR     S18,[R0, #+12]
    605          	r22 = R[4];
   \   00000018   0xEDD0 0x0A04      VLDR     S1,[R0, #+16]
    606          	r23 = R[5];
   \   0000001C   0xEDD0 0x9A05      VLDR     S19,[R0, #+20]
    607          
    608          	r31 = R[6];
   \   00000020   0xED90 0xAA06      VLDR     S20,[R0, #+24]
    609          	r32 = R[7];
   \   00000024   0xEDD0 0xAA07      VLDR     S21,[R0, #+28]
    610          	r33 = R[8];
   \   00000028   0xED90 0x1A08      VLDR     S2,[R0, #+32]
    611          
    612          	q[0] = (1.f + r11 + r22 + r33) / 4.f;
   \   0000002C   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   00000030   0xEE70 0x1A21      VADD.F32 S3,S0,S3
   \   00000034   0xEEB5 0x2A00      VMOV.F32 S4,#0.25
   \   00000038   0xEE71 0x2AA0      VADD.F32 S5,S3,S1
   \   0000003C   0xEE72 0x2A81      VADD.F32 S5,S5,S2
   \   00000040   0xEE62 0x2A82      VMUL.F32 S5,S5,S4
   \   00000044   0xEDC4 0x2A00      VSTR     S5,[R4, #0]
    613          	q[1] = (1.f + r11 - r22 - r33) / 4.f;
   \   00000048   0xEE71 0x1AE0      VSUB.F32 S3,S3,S1
   \   0000004C   0xEE71 0x1AC1      VSUB.F32 S3,S3,S2
   \   00000050   0xEE61 0x1A82      VMUL.F32 S3,S3,S4
   \   00000054   0xEDC4 0x1A01      VSTR     S3,[R4, #+4]
    614          	q[2] = (1.f - r11 + r22 - r33) / 4.f;
   \   00000058   0xEEF7 0x1A00      VMOV.F32 S3,#1.0
   \   0000005C   0xEE31 0x0AC0      VSUB.F32 S0,S3,S0
   \   00000060   0xEE70 0x1A20      VADD.F32 S3,S0,S1
   \   00000064   0xEE71 0x1AC1      VSUB.F32 S3,S3,S2
   \   00000068   0xEE61 0x1A82      VMUL.F32 S3,S3,S4
   \   0000006C   0xEDC4 0x1A02      VSTR     S3,[R4, #+8]
    615          	q[3] = (1.f - r11 - r22 + r33) / 4.f;
   \   00000070   0xEE30 0x0A60      VSUB.F32 S0,S0,S1
   \   00000074   0xEE30 0x0A01      VADD.F32 S0,S0,S2
   \   00000078   0xEE20 0x0A02      VMUL.F32 S0,S0,S4
   \   0000007C   0xED84 0x0A03      VSTR     S0,[R4, #+12]
    616          
    617          	if(q[0] < 0.0f) q[0] = 0.0f;
   \   00000080   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   00000084   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000088   0xEEF1 0xFA10      FMSTAT   
   \   0000008C   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_flt_0
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x6020             STR      R0,[R4, #+0]
    618          	if(q[1] < 0.0f) q[1] = 0.0f;
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_0: (+1)
   \   00000092   0xED94 0x0A01      VLDR     S0,[R4, #+4]
   \   00000096   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000009A   0xEEF1 0xFA10      FMSTAT   
   \   0000009E   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_flt_1
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x6060             STR      R0,[R4, #+4]
    619          	if(q[2] < 0.0f) q[2] = 0.0f;
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_1: (+1)
   \   000000A4   0xED94 0x0A02      VLDR     S0,[R4, #+8]
   \   000000A8   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000AC   0xEEF1 0xFA10      FMSTAT   
   \   000000B0   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_flt_2
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x60A0             STR      R0,[R4, #+8]
    620          	if(q[3] < 0.0f) q[3] = 0.0f;
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_2: (+1)
   \   000000B6   0xED94 0x0A03      VLDR     S0,[R4, #+12]
   \   000000BA   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000BE   0xEEF1 0xFA10      FMSTAT   
   \   000000C2   0xD501             BPL.N    ??inv_icm20948_convert_matrix_to_quat_flt_3
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x60E0             STR      R0,[R4, #+12]
    621          	q[0] = sqrtf(q[0]);
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_3: (+1)
   \   000000C8   0xED94 0x0A00      VLDR     S0,[R4, #0]
   \   000000CC   0x.... 0x....      BL       sqrtf
   \   000000D0   0xED84 0x0A00      VSTR     S0,[R4, #0]
    622          	q[1] = sqrtf(q[1]);
   \   000000D4   0xED94 0x0A01      VLDR     S0,[R4, #+4]
   \   000000D8   0x.... 0x....      BL       sqrtf
   \   000000DC   0xED84 0x0A01      VSTR     S0,[R4, #+4]
    623          	q[2] = sqrtf(q[2]);
   \   000000E0   0xED94 0x0A02      VLDR     S0,[R4, #+8]
   \   000000E4   0x.... 0x....      BL       sqrtf
   \   000000E8   0xED84 0x0A02      VSTR     S0,[R4, #+8]
    624          	q[3] = sqrtf(q[3]);
   \   000000EC   0xED94 0x0A03      VLDR     S0,[R4, #+12]
   \   000000F0   0x.... 0x....      BL       sqrtf
   \   000000F4   0xEEF0 0x0A40      VMOV.F32 S1,S0
   \   000000F8   0xEDC4 0x0A03      VSTR     S1,[R4, #+12]
    625          
    626          	/* Above paragraph could be reduced in :
    627          	q[0] =(q[0] < 0.0f) ? q[0] = 0.0f : sqrtf(q[0]);
    628          	q[1] =(q[1] < 0.0f) ? q[1] = 0.0f : sqrtf(q[1]);
    629          	q[2] =(q[2] < 0.0f) ? q[2] = 0.0f : sqrtf(q[2]);
    630          	q[3] =(q[3] < 0.0f) ? q[3] = 0.0f : sqrtf(q[3]);
    631          	*/
    632          	
    633          	if(q[0] >= q[1] && q[0] >= q[2] && q[0] >= q[3]) //q[0] is max
   \   000000FC   0xED94 0x1A02      VLDR     S2,[R4, #+8]
   \   00000100   0xEDD4 0x1A01      VLDR     S3,[R4, #+4]
   \   00000104   0xED94 0x2A00      VLDR     S4,[R4, #0]
   \   00000108   0xEEB4 0x2A61      VCMP.F32 S4,S3
   \   0000010C   0xEEF1 0xFA10      FMSTAT   
   \   00000110   0xDB28             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_4
   \   00000112   0xEEB4 0x2A41      VCMP.F32 S4,S2
   \   00000116   0xEEF1 0xFA10      FMSTAT   
   \   0000011A   0xDB23             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_4
   \   0000011C   0xEEB4 0x2A60      VCMP.F32 S4,S1
   \   00000120   0xEEF1 0xFA10      FMSTAT   
   \   00000124   0xDB1E             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_4
    634          	{
    635          		 q[1] = (r23 - r32)/(4.f*q[0]);
   \   00000126   0xEEB1 0x0A00      VMOV.F32 S0,#4.0
   \   0000012A   0xEE79 0x0AEA      VSUB.F32 S1,S19,S21
   \   0000012E   0xEE22 0x1A00      VMUL.F32 S2,S4,S0
   \   00000132   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000136   0xEDC4 0x0A01      VSTR     S1,[R4, #+4]
    636          		 q[2] = (r31 - r13)/(4.f*q[0]);
   \   0000013A   0xEE7A 0x0A68      VSUB.F32 S1,S20,S17
   \   0000013E   0xED94 0x1A00      VLDR     S2,[R4, #0]
   \   00000142   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \   00000146   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   0000014A   0xEDC4 0x0A02      VSTR     S1,[R4, #+8]
    637          		 q[3] = (r12 - r21)/(4.f*q[0]);
   \   0000014E   0xEE78 0x0A49      VSUB.F32 S1,S16,S18
   \   00000152   0xED94 0x1A00      VLDR     S2,[R4, #0]
   \   00000156   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   0000015A   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   0000015E   0xED84 0x0A03      VSTR     S0,[R4, #+12]
   \   00000162   0xE088             B.N      ??inv_icm20948_convert_matrix_to_quat_flt_5
    638          	}
    639          	else if(q[1] >= q[0] && q[1] >= q[2] && q[1] >= q[3]) //q[1] is max
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_4: (+1)
   \   00000164   0xEEF4 0x1A42      VCMP.F32 S3,S4
   \   00000168   0xEEF1 0xFA10      FMSTAT   
   \   0000016C   0xDB28             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_6
   \   0000016E   0xEEF4 0x1A41      VCMP.F32 S3,S2
   \   00000172   0xEEF1 0xFA10      FMSTAT   
   \   00000176   0xDB23             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_6
   \   00000178   0xEEF4 0x1A60      VCMP.F32 S3,S1
   \   0000017C   0xEEF1 0xFA10      FMSTAT   
   \   00000180   0xDB1E             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_6
    640          	{
    641          		 q[0] = (r23 - r32)/(4.f*q[1]);
   \   00000182   0xEEB1 0x0A00      VMOV.F32 S0,#4.0
   \   00000186   0xEE79 0x0AEA      VSUB.F32 S1,S19,S21
   \   0000018A   0xEE21 0x1A80      VMUL.F32 S2,S3,S0
   \   0000018E   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000192   0xEDC4 0x0A00      VSTR     S1,[R4, #0]
    642          		 q[2] = (r12 + r21)/(4.f*q[1]);
   \   00000196   0xEE78 0x0A09      VADD.F32 S1,S16,S18
   \   0000019A   0xED94 0x1A01      VLDR     S2,[R4, #+4]
   \   0000019E   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \   000001A2   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   000001A6   0xEDC4 0x0A02      VSTR     S1,[R4, #+8]
    643          		 q[3] = (r31 + r13)/(4.f*q[1]);
   \   000001AA   0xEE7A 0x0A28      VADD.F32 S1,S20,S17
   \   000001AE   0xED94 0x1A01      VLDR     S2,[R4, #+4]
   \   000001B2   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   000001B6   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   000001BA   0xED84 0x0A03      VSTR     S0,[R4, #+12]
   \   000001BE   0xE05A             B.N      ??inv_icm20948_convert_matrix_to_quat_flt_5
    644          	}
    645          	else if(q[2] >= q[0] && q[2] >= q[1] && q[2] >= q[3]) //q[2] is max
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_6: (+1)
   \   000001C0   0xEEB4 0x1A42      VCMP.F32 S2,S4
   \   000001C4   0xEEF1 0xFA10      FMSTAT   
   \   000001C8   0xDB28             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_7
   \   000001CA   0xEEB4 0x1A61      VCMP.F32 S2,S3
   \   000001CE   0xEEF1 0xFA10      FMSTAT   
   \   000001D2   0xDB23             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_7
   \   000001D4   0xEEB4 0x1A60      VCMP.F32 S2,S1
   \   000001D8   0xEEF1 0xFA10      FMSTAT   
   \   000001DC   0xDB1E             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_7
    646          	{
    647          		 q[0] = (r31 - r13)/(4.f*q[2]);
   \   000001DE   0xEEB1 0x0A00      VMOV.F32 S0,#4.0
   \   000001E2   0xEE7A 0x0A68      VSUB.F32 S1,S20,S17
   \   000001E6   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \   000001EA   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   000001EE   0xEDC4 0x0A00      VSTR     S1,[R4, #0]
    648          		 q[1] = (r12 + r21)/(4.f*q[2]);
   \   000001F2   0xEE78 0x0A09      VADD.F32 S1,S16,S18
   \   000001F6   0xED94 0x1A02      VLDR     S2,[R4, #+8]
   \   000001FA   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \   000001FE   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000202   0xEDC4 0x0A01      VSTR     S1,[R4, #+4]
    649          		 q[3] = (r23 + r32)/(4.f*q[2]);
   \   00000206   0xEE79 0x0AAA      VADD.F32 S1,S19,S21
   \   0000020A   0xED94 0x1A02      VLDR     S2,[R4, #+8]
   \   0000020E   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   00000212   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   00000216   0xED84 0x0A03      VSTR     S0,[R4, #+12]
   \   0000021A   0xE02C             B.N      ??inv_icm20948_convert_matrix_to_quat_flt_5
    650          	}
    651          	else if(q[3] >= q[0] && q[3] >= q[1] && q[3] >= q[2]) //q[3] is max
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_7: (+1)
   \   0000021C   0xEEF4 0x0A42      VCMP.F32 S1,S4
   \   00000220   0xEEF1 0xFA10      FMSTAT   
   \   00000224   0xDB27             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_5
   \   00000226   0xEEF4 0x0A61      VCMP.F32 S1,S3
   \   0000022A   0xEEF1 0xFA10      FMSTAT   
   \   0000022E   0xDB22             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_5
   \   00000230   0xEEF4 0x0A41      VCMP.F32 S1,S2
   \   00000234   0xEEF1 0xFA10      FMSTAT   
   \   00000238   0xDB1D             BLT.N    ??inv_icm20948_convert_matrix_to_quat_flt_5
    652          	{
    653          		 q[0] = (r12 - r21)/(4.f*q[3]);
   \   0000023A   0xEEB1 0x0A00      VMOV.F32 S0,#4.0
   \   0000023E   0xEE38 0x1A49      VSUB.F32 S2,S16,S18
   \   00000242   0xEE60 0x0A80      VMUL.F32 S1,S1,S0
   \   00000246   0xEEC1 0x0A20      VDIV.F32 S1,S2,S1
   \   0000024A   0xEDC4 0x0A00      VSTR     S1,[R4, #0]
    654          		 q[1] = (r31 + r13)/(4.f*q[3]);
   \   0000024E   0xEE7A 0x0A28      VADD.F32 S1,S20,S17
   \   00000252   0xED94 0x1A03      VLDR     S2,[R4, #+12]
   \   00000256   0xEE21 0x1A00      VMUL.F32 S2,S2,S0
   \   0000025A   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   0000025E   0xEDC4 0x0A01      VSTR     S1,[R4, #+4]
    655          		 q[2] = (r23 + r32)/(4.f*q[3]);
   \   00000262   0xEE79 0x0AAA      VADD.F32 S1,S19,S21
   \   00000266   0xED94 0x1A03      VLDR     S2,[R4, #+12]
   \   0000026A   0xEE21 0x0A00      VMUL.F32 S0,S2,S0
   \   0000026E   0xEE80 0x0A80      VDIV.F32 S0,S1,S0
   \   00000272   0xED84 0x0A02      VSTR     S0,[R4, #+8]
    656          	}
    657          }
   \                     ??inv_icm20948_convert_matrix_to_quat_flt_5: (+1)
   \   00000276   0xECBD 0x8B06      VPOP     {D8-D10}
   \   0000027A   0xBD10             POP      {R4,PC}          ;; return
    658          

   \                                 In section .text, align 2, keep-with-next
    659          long inv_icm20948_convert_mult_qfix_fxp(long a, long b, unsigned char qfix)
    660          {
    661              long long temp;
    662              long result;
    663              temp = (long long)a * b;
    664              result = (long)(temp >> qfix);
    665              return result;
   \                     inv_icm20948_convert_mult_qfix_fxp: (+1)
   \   00000000   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   00000004   0x.... 0x....      B.W      __aeabi_lasr
    666          }
    667          

   \                                 In section .text, align 2, keep-with-next
    668          static long invn_convert_mult_q29_fxp(long a_q29, long b_q29)
    669          {
    670          	long long temp;
    671          	long result;
    672          	temp = (long long)a_q29 * b_q29;
    673          	result = (long)(temp >> 29);
    674          	return result;
   \                     invn_convert_mult_q29_fxp: (+1)
   \   00000000   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   00000004   0x0F40             LSRS     R0,R0,#+29
   \   00000006   0xEA40 0x00C1      ORR      R0,R0,R1, LSL #+3
   \   0000000A   0x4770             BX       LR               ;; return
    675          
    676          }
    677          

   \                                 In section .text, align 2, keep-with-next
    678          void inv_icm20948_convert_quat_to_col_major_matrix_fxp(const long *quat_q30, long *rot_q30)
    679          {
   \                     inv_icm20948_convert_quat_to_col_major_matrix_fxp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    680          	//Use q29 in order to skip a multiplication by 2
    681              rot_q30[0] =
    682                  invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[1]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
   \   00000006   0x6868             LDR      R0,[R5, #+4]
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   0000000E   0x4606             MOV      R6,R0
   \   00000010   0x6829             LDR      R1,[R5, #+0]
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   00000018   0x1980             ADDS     R0,R0,R6
   \   0000001A   0xF100 0x4040      ADD      R0,R0,#-1073741824
   \   0000001E   0x6020             STR      R0,[R4, #+0]
    683              rot_q30[1] =
    684                  invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[2]) - invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[0]);
   \   00000020   0x68A9             LDR      R1,[R5, #+8]
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   00000028   0x4606             MOV      R6,R0
   \   0000002A   0x6829             LDR      R1,[R5, #+0]
   \   0000002C   0x68E8             LDR      R0,[R5, #+12]
   \   0000002E   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   00000032   0x1A30             SUBS     R0,R6,R0
   \   00000034   0x6060             STR      R0,[R4, #+4]
    685              rot_q30[2] =
    686                  invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[0]);
   \   00000036   0x68E9             LDR      R1,[R5, #+12]
   \   00000038   0x6868             LDR      R0,[R5, #+4]
   \   0000003A   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   0000003E   0x4606             MOV      R6,R0
   \   00000040   0x6829             LDR      R1,[R5, #+0]
   \   00000042   0x68A8             LDR      R0,[R5, #+8]
   \   00000044   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   00000048   0x1980             ADDS     R0,R0,R6
   \   0000004A   0x60A0             STR      R0,[R4, #+8]
    687              rot_q30[3] =
    688                  invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[2]) + invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[0]);
   \   0000004C   0x68A9             LDR      R1,[R5, #+8]
   \   0000004E   0x6868             LDR      R0,[R5, #+4]
   \   00000050   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   00000054   0x4606             MOV      R6,R0
   \   00000056   0x6829             LDR      R1,[R5, #+0]
   \   00000058   0x68E8             LDR      R0,[R5, #+12]
   \   0000005A   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   0000005E   0x1980             ADDS     R0,R0,R6
   \   00000060   0x60E0             STR      R0,[R4, #+12]
    689              rot_q30[4] =
    690                  invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[2]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
   \   00000062   0x68A8             LDR      R0,[R5, #+8]
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   0000006A   0x4606             MOV      R6,R0
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x4601             MOV      R1,R0
   \   00000070   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   00000074   0x1980             ADDS     R0,R0,R6
   \   00000076   0xF100 0x4040      ADD      R0,R0,#-1073741824
   \   0000007A   0x6120             STR      R0,[R4, #+16]
    691              rot_q30[5] =
    692                  invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[3]) - invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[0]);
   \   0000007C   0x68E9             LDR      R1,[R5, #+12]
   \   0000007E   0x68A8             LDR      R0,[R5, #+8]
   \   00000080   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   00000084   0x4606             MOV      R6,R0
   \   00000086   0x6829             LDR      R1,[R5, #+0]
   \   00000088   0x6868             LDR      R0,[R5, #+4]
   \   0000008A   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   0000008E   0x1A30             SUBS     R0,R6,R0
   \   00000090   0x6160             STR      R0,[R4, #+20]
    693              rot_q30[6] =
    694                  invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[3]) - invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[0]);
   \   00000092   0x68E9             LDR      R1,[R5, #+12]
   \   00000094   0x6868             LDR      R0,[R5, #+4]
   \   00000096   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   0000009A   0x4606             MOV      R6,R0
   \   0000009C   0x6829             LDR      R1,[R5, #+0]
   \   0000009E   0x68A8             LDR      R0,[R5, #+8]
   \   000000A0   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   000000A4   0x1A30             SUBS     R0,R6,R0
   \   000000A6   0x61A0             STR      R0,[R4, #+24]
    695              rot_q30[7] =
    696                  invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[0]);
   \   000000A8   0x68E9             LDR      R1,[R5, #+12]
   \   000000AA   0x68A8             LDR      R0,[R5, #+8]
   \   000000AC   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   000000B0   0x4606             MOV      R6,R0
   \   000000B2   0x6829             LDR      R1,[R5, #+0]
   \   000000B4   0x6868             LDR      R0,[R5, #+4]
   \   000000B6   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   000000BA   0x1980             ADDS     R0,R0,R6
   \   000000BC   0x61E0             STR      R0,[R4, #+28]
    697              rot_q30[8] =
    698                  invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
   \   000000BE   0x68E8             LDR      R0,[R5, #+12]
   \   000000C0   0x4601             MOV      R1,R0
   \   000000C2   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   000000C6   0x4606             MOV      R6,R0
   \   000000C8   0x6828             LDR      R0,[R5, #+0]
   \   000000CA   0x4601             MOV      R1,R0
   \   000000CC   0x.... 0x....      BL       invn_convert_mult_q29_fxp
   \   000000D0   0x1980             ADDS     R0,R0,R6
   \   000000D2   0xF100 0x4040      ADD      R0,R0,#-1073741824
   \   000000D6   0x6220             STR      R0,[R4, #+32]
    699          }
   \   000000D8   0xBD70             POP      {R4-R6,PC}       ;; return
    700          

   \                                 In section .text, align 2, keep-with-next
    701          static long invn_convert_mult_q15_fxp(long a_q15, long b_q15)
    702          {
    703          	long out = (long)(((long long)a_q15 * (long long)b_q15) >> 15);
    704          	return out;
   \                     invn_convert_mult_q15_fxp: (+1)
   \   00000000   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   00000004   0x0BC0             LSRS     R0,R0,#+15
   \   00000006   0xEA40 0x4041      ORR      R0,R0,R1, LSL #+17
   \   0000000A   0x4770             BX       LR               ;; return
    705          }
    706          

   \                                 In section .text, align 2, keep-with-next
    707          static long invn_convert_inv_sqrt_q15_fxp(long x_q15)
    708          {
   \                     invn_convert_inv_sqrt_q15_fxp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    709              long oneoversqrt2 = 23170L; // int32(2^15*1/sqrt(2))
    710              long oneandhalf = 49152L; // int32(1.5*2^15);
    711              long upperlimit = 45426; // int32(log(4)*2^15);
    712              long lowerlimit = 22713; // int32(log(2)*2^15); 
    713              long xx, x0_2, invsqrtx;
    714              int pow2;
    715          
    716              if (x_q15 <= 0)
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xDA01             BGE.N    ??invn_convert_inv_sqrt_q15_fxp_0
    717                  return 0L;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD70             POP      {R4-R6,PC}
    718          
    719              pow2 = 0;
   \                     ??invn_convert_inv_sqrt_q15_fxp_0: (+1)
   \   0000000A   0x2400             MOVS     R4,#+0
    720              xx = x_q15;
    721              if (xx > upperlimit) {
   \   0000000C   0xF24B 0x1173      MOVW     R1,#+45427
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xDB06             BLT.N    ??invn_convert_inv_sqrt_q15_fxp_1
    722          downscale:
    723                  if (xx > upperlimit) {
   \                     ??invn_convert_inv_sqrt_q15_fxp_2: (+1)
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xDB0D             BLT.N    ??invn_convert_inv_sqrt_q15_fxp_3
    724                      xx = xx/2;
   \   00000018   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000001C   0x1040             ASRS     R0,R0,#+1
    725                      pow2 = pow2 - 1;
   \   0000001E   0x1E64             SUBS     R4,R4,#+1
    726                      goto downscale;
   \   00000020   0xE7F8             B.N      ??invn_convert_inv_sqrt_q15_fxp_2
    727                  }
    728                  goto newton_raphson;
    729              }
    730          
    731              if (xx < lowerlimit) {
   \                     ??invn_convert_inv_sqrt_q15_fxp_1: (+1)
   \   00000022   0xF645 0x01B9      MOVW     R1,#+22713
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xDA04             BGE.N    ??invn_convert_inv_sqrt_q15_fxp_3
   \   0000002A   0xE001             B.N      ??invn_convert_inv_sqrt_q15_fxp_4
    732          upscale:
    733                  if (xx < lowerlimit) {
    734                      xx = xx*2;
   \                     ??invn_convert_inv_sqrt_q15_fxp_5: (+1)
   \   0000002C   0x0040             LSLS     R0,R0,#+1
    735                      pow2 = pow2 + 1;
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
    736                      goto upscale;
    737                  }
   \                     ??invn_convert_inv_sqrt_q15_fxp_4: (+1)
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xDBFB             BLT.N    ??invn_convert_inv_sqrt_q15_fxp_5
    738                  goto newton_raphson;
    739              }
    740          
    741          newton_raphson:
    742              // 3 NR iterations. In some cases second and/or third iteration may not be needed, however
    743              // for code simplicity always iterate three times. Fourth iteration is below bit precision.
    744              x0_2 = xx >>1;
   \                     ??invn_convert_inv_sqrt_q15_fxp_3: (+1)
   \   00000034   0x1045             ASRS     R5,R0,#+1
    745              xx = oneandhalf - x0_2;
   \   00000036   0xF5C5 0x4640      RSB      R6,R5,#+49152
    746              xx = invn_convert_mult_q15_fxp( xx, ( oneandhalf - invn_convert_mult_q15_fxp(x0_2, invn_convert_mult_q15_fxp(xx,xx) ) ) );
   \   0000003A   0x4631             MOV      R1,R6
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   00000042   0x4601             MOV      R1,R0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   0000004A   0xF5C0 0x4140      RSB      R1,R0,#+49152
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   00000054   0x4606             MOV      R6,R0
    747              xx = invn_convert_mult_q15_fxp( xx, ( oneandhalf - invn_convert_mult_q15_fxp(x0_2, invn_convert_mult_q15_fxp(xx,xx) ) ) );
   \   00000056   0x4631             MOV      R1,R6
   \   00000058   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   00000064   0xF5C0 0x4140      RSB      R1,R0,#+49152
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0x.... 0x....      BL       invn_convert_mult_q15_fxp
    748          
    749              if (pow2 & 1) { // This checks if the number is even or odd.
   \   0000006E   0x1065             ASRS     R5,R4,#+1
   \   00000070   0x07E1             LSLS     R1,R4,#+31
   \   00000072   0xD504             BPL.N    ??invn_convert_inv_sqrt_q15_fxp_6
    750                  pow2 = (pow2>>1) + 1; // Account for sqrt(2) in denominator
   \   00000074   0x1C6D             ADDS     R5,R5,#+1
    751                  invsqrtx = (invn_convert_mult_q15_fxp(xx,oneoversqrt2));
   \   00000076   0xF645 0x2182      MOVW     R1,#+23170
   \   0000007A   0x.... 0x....      BL       invn_convert_mult_q15_fxp
    752              }
    753              else {
    754                  pow2 = pow2>>1;
    755                  invsqrtx =  xx;
    756              }
    757          
    758              if (pow2 < 0)
   \                     ??invn_convert_inv_sqrt_q15_fxp_6: (+1)
   \   0000007E   0x2D00             CMP      R5,#+0
   \   00000080   0xD503             BPL.N    ??invn_convert_inv_sqrt_q15_fxp_7
    759                  invsqrtx = invsqrtx>>ABS(pow2);
   \   00000082   0xD500             BPL.N    ??invn_convert_inv_sqrt_q15_fxp_8
   \   00000084   0x426D             RSBS     R5,R5,#+0
   \                     ??invn_convert_inv_sqrt_q15_fxp_8: (+1)
   \   00000086   0x4128             ASRS     R0,R0,R5
   \   00000088   0xBD70             POP      {R4-R6,PC}
    760              else if (pow2>0)
   \                     ??invn_convert_inv_sqrt_q15_fxp_7: (+1)
   \   0000008A   0x2D01             CMP      R5,#+1
   \   0000008C   0xDB00             BLT.N    ??invn_convert_inv_sqrt_q15_fxp_9
    761                  invsqrtx = invsqrtx <<pow2;
   \   0000008E   0x40A8             LSLS     R0,R0,R5
    762          
    763              return invsqrtx;
   \                     ??invn_convert_inv_sqrt_q15_fxp_9: (+1)
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
    764          }
    765          

   \                                 In section .text, align 2, keep-with-next
    766          static long invn_convert_inverse_q15_fxp(long x_q15)
    767          {
   \                     invn_convert_inverse_q15_fxp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    768              long y;
    769              int negx;
    770          
    771          	if (x_q15 == 0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??invn_convert_inverse_q15_fxp_0
    772          		y = 0L;
    773          		return y;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD10             POP      {R4,PC}
    774          	}
    775          
    776              negx=0;
   \                     ??invn_convert_inverse_q15_fxp_0: (+1)
   \   0000000A   0x2400             MOVS     R4,#+0
    777              if (x_q15 < 0 ) {
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD501             BPL.N    ??invn_convert_inverse_q15_fxp_1
    778                  x_q15 = -x_q15;
   \   00000010   0x4240             RSBS     R0,R0,#+0
    779                  negx = 1;
   \   00000012   0x2401             MOVS     R4,#+1
    780              }
    781          
    782          	if(x_q15 >= 1073741824L) { // 2^15 in Q15; underflow number
   \                     ??invn_convert_inverse_q15_fxp_1: (+1)
   \   00000014   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000018   0xDB06             BLT.N    ??invn_convert_inverse_q15_fxp_2
    783                  if (negx)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD002             BEQ.N    ??invn_convert_inverse_q15_fxp_3
    784                      y=-1L;
   \   0000001E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000022   0xBD10             POP      {R4,PC}
    785                  else
    786                      y = 1L;
   \                     ??invn_convert_inverse_q15_fxp_3: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD10             POP      {R4,PC}
    787          		return y;
    788          	}
    789          
    790              y = invn_convert_inv_sqrt_q15_fxp(x_q15); // sqrt(y)
   \                     ??invn_convert_inverse_q15_fxp_2: (+1)
   \   00000028   0x.... 0x....      BL       invn_convert_inv_sqrt_q15_fxp
    791              y = invn_convert_mult_q15_fxp(y, y);
   \   0000002C   0x4601             MOV      R1,R0
   \   0000002E   0x.... 0x....      BL       invn_convert_mult_q15_fxp
    792          
    793              if (negx)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD000             BEQ.N    ??invn_convert_inverse_q15_fxp_4
    794                  y=-y;
   \   00000036   0x4240             RSBS     R0,R0,#+0
    795              return y;
   \                     ??invn_convert_inverse_q15_fxp_4: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    796          }
    797          

   \                                 In section .text, align 2, keep-with-next
    798          long inv_icm20948_math_atan2_q15_fxp(long y_q15, long x_q15)
    799          {
   \                     inv_icm20948_math_atan2_q15_fxp: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    800              long absy, absx, maxABS, tmp, tmp2, tmp3, Z, angle;
    801              static long constA7[4] = {32740, -10503,  4751, -1254}; // int32(2^15*[0.999133448222780 -0.320533292381664 0.144982490144465,-0.038254464970299]); %7th order
    802              static long PI15 = 102944; // int32(2^15*pi): pi in Q15
    803          
    804              absx=ABS(x_q15);
   \   00000008   0x002E             MOVS     R6,R5
   \   0000000A   0xD500             BPL.N    ??inv_icm20948_math_atan2_q15_fxp_0
   \   0000000C   0x4276             RSBS     R6,R6,#+0
    805              absy=ABS(y_q15);
   \                     ??inv_icm20948_math_atan2_q15_fxp_0: (+1)
   \   0000000E   0x0027             MOVS     R7,R4
   \   00000010   0xD500             BPL.N    ??inv_icm20948_math_atan2_q15_fxp_1
   \   00000012   0x427F             RSBS     R7,R7,#+0
    806          
    807              maxABS=MAX(absx, absy);
   \                     ??inv_icm20948_math_atan2_q15_fxp_1: (+1)
   \   00000014   0x4638             MOV      R0,R7
   \   00000016   0x42B7             CMP      R7,R6
   \   00000018   0xDA0A             BGE.N    ??inv_icm20948_math_atan2_q15_fxp_2
   \   0000001A   0x4630             MOV      R0,R6
   \   0000001C   0xE008             B.N      ??inv_icm20948_math_atan2_q15_fxp_2
    808              // SCALE arguments down to protect from roundoff loss due to 1/x operation.
    809              //% Threshold for scaling found by numericaly simulating arguments
    810              //% to yield optimal (minimal) error of less than 0.01 deg through
    811              //% entire range (for Chebycheff order 7).
    812          //    while ( maxABS >> 13) {  --> Or it can be done this way if DMP code is more efficient
    813              while ( maxABS > 8192L) {
    814                      maxABS=maxABS/2;
   \                     ??inv_icm20948_math_atan2_q15_fxp_3: (+1)
   \   0000001E   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000022   0x1040             ASRS     R0,R0,#+1
    815                      absx=absx/2;
   \   00000024   0xEB06 0x71D6      ADD      R1,R6,R6, LSR #+31
   \   00000028   0x104E             ASRS     R6,R1,#+1
    816                      absy=absy/2;
   \   0000002A   0xEB07 0x71D7      ADD      R1,R7,R7, LSR #+31
   \   0000002E   0x104F             ASRS     R7,R1,#+1
    817              }
   \                     ??inv_icm20948_math_atan2_q15_fxp_2: (+1)
   \   00000030   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000034   0xDCF3             BGT.N    ??inv_icm20948_math_atan2_q15_fxp_3
    818          
    819              {
    820                  if (absx >= absy) // (0, pi/4]: tmp = abs(y)/abs(x);
   \   00000036   0x42BE             CMP      R6,R7
   \   00000038   0xDB08             BLT.N    ??inv_icm20948_math_atan2_q15_fxp_4
    821                      tmp = invn_convert_mult_q15_fxp(absy, invn_convert_inverse_q15_fxp(absx));
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       invn_convert_inverse_q15_fxp
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x4638             MOV      R0,R7
   \   00000044   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   00000048   0x4680             MOV      R8,R0
   \   0000004A   0xE007             B.N      ??inv_icm20948_math_atan2_q15_fxp_5
    822                  else             // (pi/4, pi/2): tmp = abs(x)/abs(y);
    823                      tmp = invn_convert_mult_q15_fxp(absx, invn_convert_inverse_q15_fxp(absy));
   \                     ??inv_icm20948_math_atan2_q15_fxp_4: (+1)
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0x.... 0x....      BL       invn_convert_inverse_q15_fxp
   \   00000052   0x4601             MOV      R1,R0
   \   00000054   0x4630             MOV      R0,R6
   \   00000056   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   0000005A   0x4680             MOV      R8,R0
    824          
    825                  tmp2=invn_convert_mult_q15_fxp(tmp, tmp);
   \                     ??inv_icm20948_math_atan2_q15_fxp_5: (+1)
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       invn_convert_mult_q15_fxp
   \   00000064   0x4681             MOV      R9,R0
    826                   // Alternatively:
    827                  tmp3 = invn_convert_mult_q15_fxp(constA7[3], tmp2);
   \   00000066   0x.... 0x....      LDR.W    R10,??DataTable9_9
   \   0000006A   0x4649             MOV      R1,R9
   \   0000006C   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000070   0x.... 0x....      BL       invn_convert_mult_q15_fxp
    828                  tmp3 = invn_convert_mult_q15_fxp(constA7[2] + tmp3, tmp2);
   \   00000074   0x4649             MOV      R1,R9
   \   00000076   0xF8DA 0x2008      LDR      R2,[R10, #+8]
   \   0000007A   0x1880             ADDS     R0,R0,R2
   \   0000007C   0x.... 0x....      BL       invn_convert_mult_q15_fxp
    829                  tmp3 = invn_convert_mult_q15_fxp(constA7[1] + tmp3, tmp2);
   \   00000080   0x4649             MOV      R1,R9
   \   00000082   0xF8DA 0x2004      LDR      R2,[R10, #+4]
   \   00000086   0x1880             ADDS     R0,R0,R2
   \   00000088   0x.... 0x....      BL       invn_convert_mult_q15_fxp
    830                  Z    = invn_convert_mult_q15_fxp(constA7[0] + tmp3, tmp);
   \   0000008C   0x4641             MOV      R1,R8
   \   0000008E   0xF8DA 0x2000      LDR      R2,[R10, #+0]
   \   00000092   0x1880             ADDS     R0,R0,R2
   \   00000094   0x.... 0x....      BL       invn_convert_mult_q15_fxp
    831          
    832                  if (absx < absy)
   \   00000098   0x42BE             CMP      R6,R7
   \   0000009A   0xDA05             BGE.N    ??inv_icm20948_math_atan2_q15_fxp_6
    833                      Z = PI15/2 - Z;
   \   0000009C   0xF8DA 0x1010      LDR      R1,[R10, #+16]
   \   000000A0   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   000000A4   0xEBC0 0x0061      RSB      R0,R0,R1, ASR #+1
    834          
    835                  if (x_q15 < 0) { // second and third quadrant
   \                     ??inv_icm20948_math_atan2_q15_fxp_6: (+1)
   \   000000A8   0x2D00             CMP      R5,#+0
   \   000000AA   0xD507             BPL.N    ??inv_icm20948_math_atan2_q15_fxp_7
    836                      if (y_q15 < 0)
   \   000000AC   0xF8DA 0x1010      LDR      R1,[R10, #+16]
   \   000000B0   0x2C00             CMP      R4,#+0
   \   000000B2   0xD501             BPL.N    ??inv_icm20948_math_atan2_q15_fxp_8
    837                          Z = -PI15 + Z;
   \   000000B4   0x1A40             SUBS     R0,R0,R1
   \   000000B6   0xE004             B.N      ??inv_icm20948_math_atan2_q15_fxp_9
    838                      else
    839                          Z = PI15 - Z;
   \                     ??inv_icm20948_math_atan2_q15_fxp_8: (+1)
   \   000000B8   0x1A08             SUBS     R0,R1,R0
   \   000000BA   0xE002             B.N      ??inv_icm20948_math_atan2_q15_fxp_9
    840                  }
    841                  else { // fourth quadrant
    842                      if (y_q15 < 0)
   \                     ??inv_icm20948_math_atan2_q15_fxp_7: (+1)
   \   000000BC   0x2C00             CMP      R4,#+0
   \   000000BE   0xD500             BPL.N    ??inv_icm20948_math_atan2_q15_fxp_9
    843                          Z = -Z;
   \   000000C0   0x4240             RSBS     R0,R0,#+0
    844                  }
    845                  angle = Z; // Note the result is angle in radians, expressed in Q15.
    846              }
    847              return angle;
   \                     ??inv_icm20948_math_atan2_q15_fxp_9: (+1)
   \   000000C2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    848          }

   \                                 In section .data, align 4
   \                     `inv_icm20948_math_atan2_q15_fxp::constA7`:
   \   00000000   0x00007FE4         DC32 32740, -10503, 4751, -1254
   \              0xFFFFD6F9   
   \              0x0000128F   
   \              0xFFFFFB1A   
   \   00000010   0x00019220         DC32 102944
    849          

   \                                 In section .text, align 2, keep-with-next
    850          uint8_t *inv_icm20948_convert_int16_to_big8(int16_t x, uint8_t *big8)
    851          {
    852              big8[0] = (uint8_t)((x >> 8) & 0xff);
   \                     inv_icm20948_convert_int16_to_big8: (+1)
   \   00000000   0x1202             ASRS     R2,R0,#+8
   \   00000002   0x700A             STRB     R2,[R1, #+0]
    853              big8[1] = (uint8_t)(x & 0xff);
   \   00000004   0x7048             STRB     R0,[R1, #+1]
    854              return big8;
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    855          }
    856          

   \                                 In section .text, align 2, keep-with-next
    857          uint8_t *inv_icm20948_convert_int32_to_big8(int32_t x, uint8_t *big8)
    858          {
    859              big8[0] = (uint8_t)((x >> 24) & 0xff);
   \                     inv_icm20948_convert_int32_to_big8: (+1)
   \   00000000   0x1602             ASRS     R2,R0,#+24
   \   00000002   0x700A             STRB     R2,[R1, #+0]
    860              big8[1] = (uint8_t)((x >> 16) & 0xff);
   \   00000004   0x1402             ASRS     R2,R0,#+16
   \   00000006   0x704A             STRB     R2,[R1, #+1]
    861              big8[2] = (uint8_t)((x >> 8) & 0xff);
   \   00000008   0x1202             ASRS     R2,R0,#+8
   \   0000000A   0x708A             STRB     R2,[R1, #+2]
    862              big8[3] = (uint8_t)(x & 0xff);
   \   0000000C   0x70C8             STRB     R0,[R1, #+3]
    863              return big8;
   \   0000000E   0x4608             MOV      R0,R1
   \   00000010   0x4770             BX       LR               ;; return
    864          }
    865          

   \                                 In section .text, align 2, keep-with-next
    866          int32_t inv_icm20948_convert_big8_to_int32(const uint8_t *big8)
    867          {
    868              int32_t x;
    869              x = ((int32_t)big8[0] << 24) | ((int32_t)big8[1] << 16) | ((int32_t)big8[2] << 8)
    870                  | ((int32_t)big8[3]);
    871              return x;
   \                     inv_icm20948_convert_big8_to_int32: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x7842             LDRB     R2,[R0, #+1]
   \   00000004   0x0412             LSLS     R2,R2,#+16
   \   00000006   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   0000000A   0x7882             LDRB     R2,[R0, #+2]
   \   0000000C   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000010   0x78C0             LDRB     R0,[R0, #+3]
   \   00000012   0x4308             ORRS     R0,R0,R1
   \   00000014   0x4770             BX       LR               ;; return
    872          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x30800000         DC32     0x30800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x4E800000         DC32     0x4e800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40490FDB         DC32     0x40490fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0xC3B40000         DC32     0xc3b40000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x43340000         DC32     0x43340000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x2D413CCD         DC32     0x2d413ccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x5A82799A         DC32     0x5a82799a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x58B90BFD         DC32     0x58b90bfd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x2C5C85FE         DC32     0x2c5c85fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x58B90BFC         DC32     0x58b90bfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0xC6666666         DC32     0xc6666666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x0CCCCCCD         DC32     0xccccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0xC0A3D70A         DC32     0xc0a3d70a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x0147AE15         DC32     0x147ae15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     `inv_icm20948_math_atan2_q15_fxp::constA7`

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   inv_icm20948_convert_big8_to_int32
      16   inv_icm20948_convert_compute_scalar_part_fxp
        16   -> inv_icm20948_convert_fast_sqrt_fxp
        16   -> inv_icm20948_convert_mult_q30_fxp
       0   inv_icm20948_convert_deg_to_rad
      32   inv_icm20948_convert_dmp3_to_body
        32   -> inv_icm20948_convert_quat_rotate_fxp
      32   inv_icm20948_convert_fast_sqrt_fxp
        32   -> inv_icm20948_convert_mult_q30_fxp
        32   -> inv_icm20948_convert_test_limits_and_scale_fxp
       0   inv_icm20948_convert_get_highest_bit_position
       0   inv_icm20948_convert_int16_to_big8
       0   inv_icm20948_convert_int32_to_big8
      16   inv_icm20948_convert_inv_sqrt_q30_fxp
         0   -> inv_icm20948_convert_mult_q30_fxp
        16   -> inv_icm20948_convert_mult_q30_fxp
      16   inv_icm20948_convert_inverse_q30_fxp
        16   -> inv_icm20948_convert_inv_sqrt_q30_fxp
        16   -> inv_icm20948_convert_mult_q30_fxp
      32   inv_icm20948_convert_matrix_to_quat_flt
        32   -> sqrtf
      48   inv_icm20948_convert_matrix_to_quat_fxp
        48   -> inv_icm20948_convert_inverse_q30_fxp
        48   -> inv_icm20948_convert_mult_q30_fxp
        48   -> inv_icm20948_convert_sqrt_q30_fxp
        48 __aeabi_lasr
       0   inv_icm20948_convert_mult_q30_fxp
       0   inv_icm20948_convert_mult_qfix_fxp
         0 __aeabi_lasr
      80   inv_icm20948_convert_quat_rotate_fxp
        80   -> __aeabi_memcpy4
        80   -> invn_convert_quat_invert_fxp
        80   -> invn_convert_quat_mult_fxp
      16   inv_icm20948_convert_quat_to_col_major_matrix_fxp
        16   -> invn_convert_mult_q29_fxp
      48   inv_icm20948_convert_rotation_vector
        48   -> inv_icm20948_convert_compute_scalar_part_fxp
        48   -> inv_icm20948_q_mult_q_qi
      48   inv_icm20948_convert_rotation_vector_2
        48   -> __aeabi_memcpy4
        48   -> inv_icm20948_convert_compute_scalar_part_fxp
        48   -> inv_icm20948_q_mult_q_qi
       0   inv_icm20948_convert_rotation_vector_3
      16   inv_icm20948_convert_sqrt_q30_fxp
        16   -> inv_icm20948_convert_inv_sqrt_q30_fxp
        16   -> inv_icm20948_convert_mult_q30_fxp
      16   inv_icm20948_convert_test_limits_and_scale_fxp
        16   -> inv_icm20948_convert_get_highest_bit_position
       0   inv_icm20948_int32_to_little8
      32   inv_icm20948_math_atan2_q15_fxp
        32   -> invn_convert_inverse_q15_fxp
        32   -> invn_convert_mult_q15_fxp
      24   inv_icm20948_q_mult_q_qi
        24   -> inv_icm20948_convert_mult_q30_fxp
       0   inv_icm20948_set_chip_to_body
         0   -> __aeabi_memcpy4
     112   inv_icm20948_set_chip_to_body_axis_quaternion
       112   -> cosf
       112   -> inv_icm20948_set_chip_to_body
       112   -> inv_rotation_to_quaternion
       112   -> invn_convert_quat_mult_fxp
       112   -> sinf
      24   inv_rotation_to_quaternion
        24   -> inv_icm20948_convert_matrix_to_quat_flt
      16   invn_convert_inv_sqrt_q15_fxp
        16   -> invn_convert_mult_q15_fxp
       8   invn_convert_inverse_q15_fxp
         8   -> invn_convert_inv_sqrt_q15_fxp
         8   -> invn_convert_mult_q15_fxp
       0   invn_convert_mult_q15_fxp
       0   invn_convert_mult_q29_fxp
       0   invn_convert_quat_invert_fxp
      24   invn_convert_quat_mult_fxp
        24   -> inv_icm20948_convert_mult_q30_fxp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      20  constA7
          PI15
      22  inv_icm20948_convert_big8_to_int32
      60  inv_icm20948_convert_compute_scalar_part_fxp
      18  inv_icm20948_convert_deg_to_rad
      80  inv_icm20948_convert_dmp3_to_body
     192  inv_icm20948_convert_fast_sqrt_fxp
      84  inv_icm20948_convert_get_highest_bit_position
      10  inv_icm20948_convert_int16_to_big8
      18  inv_icm20948_convert_int32_to_big8
     150  inv_icm20948_convert_inv_sqrt_q30_fxp
      76  inv_icm20948_convert_inverse_q30_fxp
     636  inv_icm20948_convert_matrix_to_quat_flt
     606  inv_icm20948_convert_matrix_to_quat_fxp
      12  inv_icm20948_convert_mult_q30_fxp
       8  inv_icm20948_convert_mult_qfix_fxp
      62  inv_icm20948_convert_quat_rotate_fxp
     218  inv_icm20948_convert_quat_to_col_major_matrix_fxp
     190  inv_icm20948_convert_rotation_vector
      42  inv_icm20948_convert_rotation_vector_2
     158  inv_icm20948_convert_rotation_vector_3
      62  inv_icm20948_convert_sqrt_q30_fxp
     128  inv_icm20948_convert_test_limits_and_scale_fxp
      18  inv_icm20948_int32_to_little8
     198  inv_icm20948_math_atan2_q15_fxp
     178  inv_icm20948_q_mult_q_qi
       8  inv_icm20948_set_chip_to_body
     168  inv_icm20948_set_chip_to_body_axis_quaternion
      84  inv_rotation_to_quaternion
     146  invn_convert_inv_sqrt_q15_fxp
      58  invn_convert_inverse_q15_fxp
      12  invn_convert_mult_q15_fxp
      12  invn_convert_mult_q29_fxp
      24  invn_convert_quat_invert_fxp
     178  invn_convert_quat_mult_fxp

 
    20 bytes in section .data
 3 976 bytes in section .text
 
 3 976 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none
