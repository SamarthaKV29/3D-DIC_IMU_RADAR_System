###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:35
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dcmi.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dcmi.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\stm32f4xx_dcmi.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\stm32f4xx_dcmi.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dcmi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dcmi.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    21-October-2015
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the DCMI peripheral:           
      9            *           + Initialization and Configuration
     10            *           + Image capture functions  
     11            *           + Interrupts and flags management
     12            *
     13           @verbatim          
     14           ===============================================================================
     15                                  ##### How to use this driver #####
     16           ===============================================================================  
     17              [..]       
     18                The sequence below describes how to use this driver to capture image
     19                from a camera module connected to the DCMI Interface.
     20                This sequence does not take into account the configuration of the  
     21                camera module, which should be made before to configure and enable
     22                the DCMI to capture images.
     23                       
     24                (#) Enable the clock for the DCMI and associated GPIOs using the following 
     25                    functions:
     26                    RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI, ENABLE);
     27                    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     28            
     29                (#) DCMI pins configuration 
     30                  (++) Connect the involved DCMI pins to AF13 using the following function 
     31                      GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_DCMI); 
     32                  (++) Configure these DCMI pins in alternate function mode by calling 
     33                      the function GPIO_Init();
     34                
     35                (#) Declare a DCMI_InitTypeDef structure, for example:
     36                    DCMI_InitTypeDef  DCMI_InitStructure;
     37                    and fill the DCMI_InitStructure variable with the allowed values
     38                    of the structure member.
     39              
     40                (#) Initialize the DCMI interface by calling the function
     41                    DCMI_Init(&DCMI_InitStructure); 
     42              
     43                (#) Configure the DMA2_Stream1 channel1 to transfer Data from DCMI DR
     44                    register to the destination memory buffer.
     45              
     46                (#) Enable DCMI interface using the function
     47                    DCMI_Cmd(ENABLE);
     48                             
     49                (#) Start the image capture using the function
     50                    DCMI_CaptureCmd(ENABLE);
     51                             
     52                (#) At this stage the DCMI interface waits for the first start of frame,
     53                    then a DMA request is generated continuously/once (depending on the
     54                    mode used, Continuous/Snapshot) to transfer the received data into
     55                    the destination memory. 
     56               
     57                -@-  If you need to capture only a rectangular window from the received
     58                     image, you have to use the DCMI_CROPConfig() function to configure 
     59                     the coordinates and size of the window to be captured, then enable 
     60                     the Crop feature using DCMI_CROPCmd(ENABLE);  
     61                     In this case, the Crop configuration should be made before to enable
     62                     and start the DCMI interface. 
     63          
     64           @endverbatim     
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     69            *
     70            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     71            * You may not use this file except in compliance with the License.
     72            * You may obtain a copy of the License at:
     73            *
     74            *        http://www.st.com/software_license_agreement_liberty_v2
     75            *
     76            * Unless required by applicable law or agreed to in writing, software 
     77            * distributed under the License is distributed on an "AS IS" BASIS, 
     78            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     79            * See the License for the specific language governing permissions and
     80            * limitations under the License.
     81            *
     82            ******************************************************************************
     83            */
     84          
     85          /* Includes ------------------------------------------------------------------*/
     86          #include "stm32f4xx_dcmi.h"
     87          #include "stm32f4xx_rcc.h"
     88          
     89          /** @addtogroup STM32F4xx_StdPeriph_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup DCMI 
     94            * @brief DCMI driver modules
     95            * @{
     96            */ 
     97          
     98          /* Private typedef -----------------------------------------------------------*/
     99          /* Private define ------------------------------------------------------------*/
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          /* Private function prototypes -----------------------------------------------*/
    103          /* Private functions ---------------------------------------------------------*/
    104          
    105          /** @defgroup DCMI_Private_Functions
    106            * @{
    107            */ 
    108          
    109          /** @defgroup DCMI_Group1 Initialization and Configuration functions
    110           *  @brief   Initialization and Configuration functions 
    111           *
    112          @verbatim   
    113           ===============================================================================
    114                        ##### Initialization and Configuration functions #####
    115           ===============================================================================  
    116          
    117          @endverbatim
    118            * @{
    119            */
    120          
    121          /**
    122            * @brief  Deinitializes the DCMI registers to their default reset values.
    123            * @param  None
    124            * @retval None
    125            */

   \                                 In section .text, align 2, keep-with-next
    126          void DCMI_DeInit(void)
    127          {
    128            DCMI->CR = 0x0;
   \                     DCMI_DeInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13  ;; 0x50050000
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    129            DCMI->IER = 0x0;
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    130            DCMI->ICR = 0x1F;
   \   00000008   0x211F             MOVS     R1,#+31
   \   0000000A   0x6141             STR      R1,[R0, #+20]
    131            DCMI->ESCR = 0x0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    132            DCMI->ESUR = 0x0;
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    133            DCMI->CWSTRTR = 0x0;
   \   00000012   0x6201             STR      R1,[R0, #+32]
    134            DCMI->CWSIZER = 0x0;
   \   00000014   0x6241             STR      R1,[R0, #+36]
    135          }
   \   00000016   0x4770             BX       LR               ;; return
    136          
    137          /**
    138            * @brief  Initializes the DCMI according to the specified parameters in the DCMI_InitStruct.
    139            * @param  DCMI_InitStruct: pointer to a DCMI_InitTypeDef structure that contains 
    140            *         the configuration information for the DCMI.
    141            * @retval None
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
    144          {
    145            uint32_t temp = 0x0;
    146            
    147            /* Check the parameters */
    148            assert_param(IS_DCMI_CAPTURE_MODE(DCMI_InitStruct->DCMI_CaptureMode));
    149            assert_param(IS_DCMI_SYNCHRO(DCMI_InitStruct->DCMI_SynchroMode));
    150            assert_param(IS_DCMI_PCKPOLARITY(DCMI_InitStruct->DCMI_PCKPolarity));
    151            assert_param(IS_DCMI_VSPOLARITY(DCMI_InitStruct->DCMI_VSPolarity));
    152            assert_param(IS_DCMI_HSPOLARITY(DCMI_InitStruct->DCMI_HSPolarity));
    153            assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
    154            assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));
    155          
    156            /* The DCMI configuration registers should be programmed correctly before 
    157            enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
    158            DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
   \                     DCMI_Init: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x....             LDR.N    R3,??DataTable13_1  ;; 0xffffbffe
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x600A             STR      R2,[R1, #+0]
    159             
    160            /* Reset the old DCMI configuration */
    161            temp = DCMI->CR;
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
    162            
    163            temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
    164                                DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
    165                                DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
    166                            
    167            /* Sets the new configuration of the DCMI peripheral */
    168            temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
    169                               DCMI_InitStruct->DCMI_SynchroMode |
    170                               DCMI_InitStruct->DCMI_PCKPolarity |
    171                               DCMI_InitStruct->DCMI_VSPolarity |
    172                               DCMI_InitStruct->DCMI_HSPolarity |
    173                               DCMI_InitStruct->DCMI_CaptureRate |
    174                               DCMI_InitStruct->DCMI_ExtendedDataMode);
    175          
    176            DCMI->CR = temp;                              
   \   0000000C   0x....             LDR.N    R3,??DataTable13_2  ;; 0xfffff00d
   \   0000000E   0x401A             ANDS     R2,R3,R2
   \   00000010   0x8803             LDRH     R3,[R0, #+0]
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x8843             LDRH     R3,[R0, #+2]
   \   00000016   0x431A             ORRS     R2,R3,R2
   \   00000018   0x8883             LDRH     R3,[R0, #+4]
   \   0000001A   0x431A             ORRS     R2,R3,R2
   \   0000001C   0x88C3             LDRH     R3,[R0, #+6]
   \   0000001E   0x431A             ORRS     R2,R3,R2
   \   00000020   0x8903             LDRH     R3,[R0, #+8]
   \   00000022   0x431A             ORRS     R2,R3,R2
   \   00000024   0x8943             LDRH     R3,[R0, #+10]
   \   00000026   0x431A             ORRS     R2,R3,R2
   \   00000028   0x8980             LDRH     R0,[R0, #+12]
   \   0000002A   0x4310             ORRS     R0,R0,R2
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    177          }
   \   0000002E   0x4770             BX       LR               ;; return
    178          
    179          /**
    180            * @brief  Fills each DCMI_InitStruct member with its default value.
    181            * @param  DCMI_InitStruct : pointer to a DCMI_InitTypeDef structure which will
    182            *         be initialized.
    183            * @retval None
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
    186          {
    187            /* Set the default configuration */
    188            DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
   \                     DCMI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    189            DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    190            DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    191            DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    192            DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
    193            DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
   \   0000000C   0x8141             STRH     R1,[R0, #+10]
    194            DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    195          }
   \   00000010   0x4770             BX       LR               ;; return
    196          
    197          /**
    198            * @brief  Initializes the DCMI peripheral CROP mode according to the specified
    199            *         parameters in the DCMI_CROPInitStruct.
    200            * @note   This function should be called before to enable and start the DCMI interface.   
    201            * @param  DCMI_CROPInitStruct:  pointer to a DCMI_CROPInitTypeDef structure that 
    202            *         contains the configuration information for the DCMI peripheral CROP mode.
    203            * @retval None
    204            */

   \                                 In section .text, align 2, keep-with-next
    205          void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
    206          {  
    207            /* Sets the CROP window coordinates */
    208            DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
    209                            ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
   \                     DCMI_CROPConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13_3  ;; 0x50050020
   \   00000002   0x8842             LDRH     R2,[R0, #+2]
   \   00000004   0x8803             LDRH     R3,[R0, #+0]
   \   00000006   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   0000000A   0x600A             STR      R2,[R1, #+0]
    210          
    211            /* Sets the CROP window size */
    212            DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
    213                            ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
   \   0000000C   0x88C2             LDRH     R2,[R0, #+6]
   \   0000000E   0x8880             LDRH     R0,[R0, #+4]
   \   00000010   0xEA42 0x4000      ORR      R0,R2,R0, LSL #+16
   \   00000014   0x6048             STR      R0,[R1, #+4]
    214          }
   \   00000016   0x4770             BX       LR               ;; return
    215          
    216          /**
    217            * @brief  Enables or disables the DCMI Crop feature.
    218            * @note   This function should be called before to enable and start the DCMI interface.
    219            * @param  NewState: new state of the DCMI Crop feature. 
    220            *          This parameter can be: ENABLE or DISABLE.
    221            * @retval None
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          void DCMI_CROPCmd(FunctionalState NewState)
    224          {
    225            /* Check the parameters */
    226            assert_param(IS_FUNCTIONAL_STATE(NewState));
    227              
    228            if (NewState != DISABLE)
   \                     DCMI_CROPCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DCMI_CROPCmd_0
    229            {
    230              /* Enable the DCMI Crop feature */
    231              DCMI->CR |= (uint32_t)DCMI_CR_CROP;
   \   00000008   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    232            }
    233            else
    234            {
    235              /* Disable the DCMI Crop feature */
    236              DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
   \                     ??DCMI_CROPCmd_0: (+1)
   \   00000010   0xF020 0x0004      BIC      R0,R0,#0x4
   \   00000014   0x6008             STR      R0,[R1, #+0]
    237            }
    238          }
   \   00000016   0x4770             BX       LR               ;; return
    239          
    240          /**
    241            * @brief  Sets the embedded synchronization codes
    242            * @param  DCMI_CodesInitTypeDef: pointer to a DCMI_CodesInitTypeDef structure that
    243            *         contains the embedded synchronization codes for the DCMI peripheral.
    244            * @retval None
    245            */

   \                                 In section .text, align 2, keep-with-next
    246          void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
    247          {
    248            DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
    249                                    ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
    250                                    ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
    251                                    ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
   \                     DCMI_SetEmbeddedSynchroCodes: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x7842             LDRB     R2,[R0, #+1]
   \   00000004   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000008   0x7882             LDRB     R2,[R0, #+2]
   \   0000000A   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000000E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000010   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000014   0x....             LDR.N    R1,??DataTable13_4  ;; 0x50050018
   \   00000016   0x6008             STR      R0,[R1, #+0]
    252          }
   \   00000018   0x4770             BX       LR               ;; return
    253          
    254          /**
    255            * @brief  Enables or disables the DCMI JPEG format.
    256            * @note   The Crop and Embedded Synchronization features cannot be used in this mode.  
    257            * @param  NewState: new state of the DCMI JPEG format. 
    258            *          This parameter can be: ENABLE or DISABLE.
    259            * @retval None
    260            */

   \                                 In section .text, align 2, keep-with-next
    261          void DCMI_JPEGCmd(FunctionalState NewState)
    262          {
    263            /* Check the parameters */
    264            assert_param(IS_FUNCTIONAL_STATE(NewState));
    265           
    266            if (NewState != DISABLE)
   \                     DCMI_JPEGCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DCMI_JPEGCmd_0
    267            {
    268              /* Enable the DCMI JPEG format */
    269              DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
   \   00000008   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    270            }
    271            else
    272            {
    273              /* Disable the DCMI JPEG format */
    274              DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
   \                     ??DCMI_JPEGCmd_0: (+1)
   \   00000010   0xF020 0x0008      BIC      R0,R0,#0x8
   \   00000014   0x6008             STR      R0,[R1, #+0]
    275            }
    276          }
   \   00000016   0x4770             BX       LR               ;; return
    277          /**
    278            * @}
    279            */
    280          
    281          /** @defgroup DCMI_Group2 Image capture functions
    282           *  @brief   Image capture functions
    283           *
    284          @verbatim   
    285           ===============================================================================
    286                              ##### Image capture functions #####
    287           ===============================================================================  
    288          
    289          @endverbatim
    290            * @{
    291            */
    292            
    293          /**
    294            * @brief  Enables or disables the DCMI interface.
    295            * @param  NewState: new state of the DCMI interface. 
    296            *          This parameter can be: ENABLE or DISABLE.
    297            * @retval None
    298            */

   \                                 In section .text, align 2, keep-with-next
    299          void DCMI_Cmd(FunctionalState NewState)
    300          {
    301            /* Check the parameters */
    302            assert_param(IS_FUNCTIONAL_STATE(NewState));
    303            
    304            if (NewState != DISABLE)
   \                     DCMI_Cmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DCMI_Cmd_0
    305            {
    306              /* Enable the DCMI by setting ENABLE bit */
    307              DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
   \   00000008   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    308            }
    309            else
    310            {
    311              /* Disable the DCMI by clearing ENABLE bit */
    312              DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
   \                     ??DCMI_Cmd_0: (+1)
   \   00000010   0xF420 0x4080      BIC      R0,R0,#0x4000
   \   00000014   0x6008             STR      R0,[R1, #+0]
    313            }
    314          }
   \   00000016   0x4770             BX       LR               ;; return
    315          
    316          /**
    317            * @brief  Enables or disables the DCMI Capture.
    318            * @param  NewState: new state of the DCMI capture. 
    319            *          This parameter can be: ENABLE or DISABLE.
    320            * @retval None
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          void DCMI_CaptureCmd(FunctionalState NewState)
    323          {
    324            /* Check the parameters */
    325            assert_param(IS_FUNCTIONAL_STATE(NewState));
    326              
    327            if (NewState != DISABLE)
   \                     DCMI_CaptureCmd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13  ;; 0x50050000
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DCMI_CaptureCmd_0
    328            {
    329              /* Enable the DCMI Capture */
    330              DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
   \   00000008   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    331            }
    332            else
    333            {
    334              /* Disable the DCMI Capture */
    335              DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
   \                     ??DCMI_CaptureCmd_0: (+1)
   \   00000010   0x0840             LSRS     R0,R0,#+1
   \   00000012   0x0040             LSLS     R0,R0,#+1
   \   00000014   0x6008             STR      R0,[R1, #+0]
    336            }
    337          }
   \   00000016   0x4770             BX       LR               ;; return
    338          
    339          /**
    340            * @brief  Reads the data stored in the DR register.
    341            * @param  None 
    342            * @retval Data register value
    343            */

   \                                 In section .text, align 2, keep-with-next
    344          uint32_t DCMI_ReadData(void)
    345          {
    346            return DCMI->DR;
   \                     DCMI_ReadData: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_5  ;; 0x50050028
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    347          }
    348          /**
    349            * @}
    350            */
    351          
    352          /** @defgroup DCMI_Group3 Interrupts and flags management functions
    353           *  @brief   Interrupts and flags management functions
    354           *
    355          @verbatim   
    356           ===============================================================================
    357                       ##### Interrupts and flags management functions #####
    358           ===============================================================================  
    359          
    360          @endverbatim
    361            * @{
    362            */
    363          
    364          /**
    365            * @brief  Enables or disables the DCMI interface interrupts.
    366            * @param  DCMI_IT: specifies the DCMI interrupt sources to be enabled or disabled. 
    367            *          This parameter can be any combination of the following values:
    368            *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
    369            *            @arg DCMI_IT_OVF: Overflow interrupt mask
    370            *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
    371            *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
    372            *            @arg DCMI_IT_LINE: Line interrupt mask
    373            * @param  NewState: new state of the specified DCMI interrupts.
    374            *          This parameter can be: ENABLE or DISABLE.
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState)
    378          {
    379            /* Check the parameters */
    380            assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
    381            assert_param(IS_FUNCTIONAL_STATE(NewState));
    382            
    383            if (NewState != DISABLE)
   \                     DCMI_ITConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable13_6  ;; 0x5005000c
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x6811             LDR      R1,[R2, #+0]
   \   00000006   0xD002             BEQ.N    ??DCMI_ITConfig_0
    384            {
    385              /* Enable the Interrupt sources */
    386              DCMI->IER |= DCMI_IT;
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x6010             STR      R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    387            }
    388            else
    389            {
    390              /* Disable the Interrupt sources */
    391              DCMI->IER &= (uint16_t)(~DCMI_IT);
   \                     ??DCMI_ITConfig_0: (+1)
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0xB280             UXTH     R0,R0
   \   00000012   0x4008             ANDS     R0,R0,R1
   \   00000014   0x6010             STR      R0,[R2, #+0]
    392            }  
    393          }
   \   00000016   0x4770             BX       LR               ;; return
    394          
    395          /**
    396            * @brief  Checks whether the  DCMI interface flag is set or not.
    397            * @param  DCMI_FLAG: specifies the flag to check.
    398            *          This parameter can be one of the following values:
    399            *            @arg DCMI_FLAG_FRAMERI: Frame capture complete Raw flag mask
    400            *            @arg DCMI_FLAG_OVFRI: Overflow Raw flag mask
    401            *            @arg DCMI_FLAG_ERRRI: Synchronization error Raw flag mask
    402            *            @arg DCMI_FLAG_VSYNCRI: VSYNC Raw flag mask
    403            *            @arg DCMI_FLAG_LINERI: Line Raw flag mask
    404            *            @arg DCMI_FLAG_FRAMEMI: Frame capture complete Masked flag mask
    405            *            @arg DCMI_FLAG_OVFMI: Overflow Masked flag mask
    406            *            @arg DCMI_FLAG_ERRMI: Synchronization error Masked flag mask
    407            *            @arg DCMI_FLAG_VSYNCMI: VSYNC Masked flag mask
    408            *            @arg DCMI_FLAG_LINEMI: Line Masked flag mask
    409            *            @arg DCMI_FLAG_HSYNC: HSYNC flag mask
    410            *            @arg DCMI_FLAG_VSYNC: VSYNC flag mask
    411            *            @arg DCMI_FLAG_FNE: Fifo not empty flag mask
    412            * @retval The new state of DCMI_FLAG (SET or RESET).
    413            */

   \                                 In section .text, align 2, keep-with-next
    414          FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG)
    415          {
    416            FlagStatus bitstatus = RESET;
   \                     DCMI_GetFlagStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    417            uint32_t dcmireg, tempreg = 0;
    418          
    419            /* Check the parameters */
    420            assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
    421            
    422            /* Get the DCMI register index */
    423            dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x0B12             LSRS     R2,R2,#+12
    424            
    425            if (dcmireg == 0x00) /* The FLAG is in RISR register */
   \   00000006   0x....             LDR.N    R3,??DataTable13_7  ;; 0x50050004
   \   00000008   0xD101             BNE.N    ??DCMI_GetFlagStatus_0
    426            {
    427              tempreg= DCMI->RISR;
   \   0000000A   0x685A             LDR      R2,[R3, #+4]
   \   0000000C   0xE004             B.N      ??DCMI_GetFlagStatus_1
    428            }
    429            else if (dcmireg == 0x02) /* The FLAG is in SR register */
   \                     ??DCMI_GetFlagStatus_0: (+1)
   \   0000000E   0x2A02             CMP      R2,#+2
   \   00000010   0xD101             BNE.N    ??DCMI_GetFlagStatus_2
    430            {
    431              tempreg = DCMI->SR;
   \   00000012   0x681A             LDR      R2,[R3, #+0]
   \   00000014   0xE000             B.N      ??DCMI_GetFlagStatus_1
    432            }
    433            else /* The FLAG is in MISR register */
    434            {
    435              tempreg = DCMI->MISR;
   \                     ??DCMI_GetFlagStatus_2: (+1)
   \   00000016   0x68DA             LDR      R2,[R3, #+12]
    436            }
    437            
    438            if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
   \                     ??DCMI_GetFlagStatus_1: (+1)
   \   00000018   0x4202             TST      R2,R0
   \   0000001A   0xD000             BEQ.N    ??DCMI_GetFlagStatus_3
    439            {
    440              bitstatus = SET;
   \   0000001C   0x2101             MOVS     R1,#+1
    441            }
    442            else
    443            {
    444              bitstatus = RESET;
    445            }
    446            /* Return the DCMI_FLAG status */
    447            return  bitstatus;
   \                     ??DCMI_GetFlagStatus_3: (+1)
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0x4770             BX       LR               ;; return
    448          }
    449          
    450          /**
    451            * @brief  Clears the DCMI's pending flags.
    452            * @param  DCMI_FLAG: specifies the flag to clear.
    453            *          This parameter can be any combination of the following values:
    454            *            @arg DCMI_FLAG_FRAMERI: Frame capture complete Raw flag mask
    455            *            @arg DCMI_FLAG_OVFRI: Overflow Raw flag mask
    456            *            @arg DCMI_FLAG_ERRRI: Synchronization error Raw flag mask
    457            *            @arg DCMI_FLAG_VSYNCRI: VSYNC Raw flag mask
    458            *            @arg DCMI_FLAG_LINERI: Line Raw flag mask
    459            * @retval None
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          void DCMI_ClearFlag(uint16_t DCMI_FLAG)
    462          {
    463            /* Check the parameters */
    464            assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
    465            
    466            /* Clear the flag by writing in the ICR register 1 in the corresponding 
    467            Flag position*/
    468            
    469            DCMI->ICR = DCMI_FLAG;
   \                     DCMI_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13_8  ;; 0x50050014
   \   00000002   0x6008             STR      R0,[R1, #+0]
    470          }
   \   00000004   0x4770             BX       LR               ;; return
    471          
    472          /**
    473            * @brief  Checks whether the DCMI interrupt has occurred or not.
    474            * @param  DCMI_IT: specifies the DCMI interrupt source to check.
    475            *          This parameter can be one of the following values:
    476            *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
    477            *            @arg DCMI_IT_OVF: Overflow interrupt mask
    478            *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
    479            *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
    480            *            @arg DCMI_IT_LINE: Line interrupt mask
    481            * @retval The new state of DCMI_IT (SET or RESET).
    482            */

   \                                 In section .text, align 2, keep-with-next
    483          ITStatus DCMI_GetITStatus(uint16_t DCMI_IT)
    484          {
    485            ITStatus bitstatus = RESET;
   \                     DCMI_GetITStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    486            uint32_t itstatus = 0;
    487            
    488            /* Check the parameters */
    489            assert_param(IS_DCMI_GET_IT(DCMI_IT));
    490            
    491            itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
   \   00000002   0x....             LDR.N    R2,??DataTable13_9  ;; 0x50050010
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x4010             ANDS     R0,R0,R2
    492            
    493            if ((itstatus != (uint16_t)RESET))
   \   00000008   0xD000             BEQ.N    ??DCMI_GetITStatus_0
    494            {
    495              bitstatus = SET;
   \   0000000A   0x2101             MOVS     R1,#+1
    496            }
    497            else
    498            {
    499              bitstatus = RESET;
    500            }
    501            return bitstatus;
   \                     ??DCMI_GetITStatus_0: (+1)
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    502          }
    503          
    504          /**
    505            * @brief  Clears the DCMI's interrupt pending bits.
    506            * @param  DCMI_IT: specifies the DCMI interrupt pending bit to clear.
    507            *          This parameter can be any combination of the following values:
    508            *            @arg DCMI_IT_FRAME: Frame capture complete interrupt mask
    509            *            @arg DCMI_IT_OVF: Overflow interrupt mask
    510            *            @arg DCMI_IT_ERR: Synchronization error interrupt mask
    511            *            @arg DCMI_IT_VSYNC: VSYNC interrupt mask
    512            *            @arg DCMI_IT_LINE: Line interrupt mask
    513            * @retval None
    514            */

   \                                 In section .text, align 2, keep-with-next
    515          void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
    516          {
    517            /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
    518            corresponding pending Bit position*/
    519            
    520            DCMI->ICR = DCMI_IT;
   \                     DCMI_ClearITPendingBit: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13_8  ;; 0x50050014
   \   00000002   0x6008             STR      R0,[R1, #+0]
    521          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x50050000         DC32     0x50050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xFFFFBFFE         DC32     0xffffbffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0xFFFFF00D         DC32     0xfffff00d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x50050020         DC32     0x50050020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x50050018         DC32     0x50050018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x50050028         DC32     0x50050028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x5005000C         DC32     0x5005000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x50050004         DC32     0x50050004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x50050014         DC32     0x50050014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x50050010         DC32     0x50050010
    522          /**
    523            * @}
    524            */ 
    525          
    526          /**
    527            * @}
    528            */ 
    529          
    530          /**
    531            * @}
    532            */ 
    533          
    534          /**
    535            * @}
    536            */ 
    537          
    538          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DCMI_CROPCmd
       0   DCMI_CROPConfig
       0   DCMI_CaptureCmd
       0   DCMI_ClearFlag
       0   DCMI_ClearITPendingBit
       0   DCMI_Cmd
       0   DCMI_DeInit
       0   DCMI_GetFlagStatus
       0   DCMI_GetITStatus
       0   DCMI_ITConfig
       0   DCMI_Init
       0   DCMI_JPEGCmd
       0   DCMI_ReadData
       0   DCMI_SetEmbeddedSynchroCodes
       0   DCMI_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      24  DCMI_CROPCmd
      24  DCMI_CROPConfig
      24  DCMI_CaptureCmd
       6  DCMI_ClearFlag
       6  DCMI_ClearITPendingBit
      24  DCMI_Cmd
      24  DCMI_DeInit
      34  DCMI_GetFlagStatus
      16  DCMI_GetITStatus
      24  DCMI_ITConfig
      48  DCMI_Init
      24  DCMI_JPEGCmd
       6  DCMI_ReadData
      26  DCMI_SetEmbeddedSynchroCodes
      18  DCMI_StructInit

 
 368 bytes in section .text
 
 368 bytes of CODE memory

Errors: none
Warnings: none
