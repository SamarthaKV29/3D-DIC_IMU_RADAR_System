###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:38
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_sai.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_sai.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\stm32f4xx_sai.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\stm32f4xx_sai.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_sai.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_sai.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    21-October-2015  
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial Audio Interface (SAI):
      9            *           + Initialization and Configuration
     10            *           + Data transfers functions
     11            *           + DMA transfers management
     12            *           + Interrupts and flags management 
     13            *           
     14            @verbatim
     15           ===============================================================================
     16                               ##### How to use this driver #####
     17           ===============================================================================
     18              [..] 
     19              
     20                 (#) Enable peripheral clock using the following functions 
     21                     RCC_APB2PeriphClockCmd(RCC_APB2Periph_SAI1, ENABLE) for SAI1
     22            
     23                 (#) For each SAI Block A/B enable SCK, SD, FS and MCLK GPIO clocks 
     24                     using RCC_AHB1PeriphClockCmd() function.
     25            
     26                 (#) Peripherals alternate function: 
     27                     (++) Connect the pin to the desired peripherals' Alternate 
     28                          Function (AF) using GPIO_PinAFConfig() function.
     29                     (++) Configure the desired pin in alternate function by:
     30                          GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     31                     (++) Select the type, pull-up/pull-down and output speed via 
     32                          GPIO_PuPd, GPIO_OType and GPIO_Speed members
     33                     (++) Call GPIO_Init() function
     34                     -@@- If an external clock source is used then the I2S CKIN pin should be 
     35                         also configured in Alternate function Push-pull pull-up mode.
     36                          
     37                (#) The SAI clock can be generated from different clock source :
     38                    PLL I2S, PLL SAI or external clock source.
     39                    (++) The PLL I2S is configured using the following functions RCC_PLLI2SConfig(), 
     40                         RCC_PLLI2SCmd(ENABLE), RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY) and 
     41                         RCC_SAIPLLI2SClkDivConfig() or;
     42                        
     43                    (++) The PLL SAI is configured using the following functions RCC_PLLSAIConfig(), 
     44                         RCC_PLLSAICmd(ENABLE), RCC_GetFlagStatus(RCC_FLAG_PLLSAIRDY) and 
     45                         RCC_SAIPLLSAIClkDivConfig()or;          
     46                        
     47                    (++) External clock source is configured using the function 
     48                         RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly the 
     49                         define constant I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file.      
     50                          
     51                (#) Each SAI Block A or B has its own clock generator to make these two blocks 
     52                    completely independent. The Clock generator is configured using RCC_SAIBlockACLKConfig() and 
     53                    RCC_SAIBlockBCLKConfig() functions.
     54                            
     55                (#) Each SAI Block A or B can be configured separately : 
     56                    (++) Program the Master clock divider, Audio mode, Protocol, Data Length, Clock Strobing Edge, 
     57                         Synchronous mode, Output drive and FIFO Thresold using SAI_Init() function.   
     58                         In case of master mode, program the Master clock divider (MCKDIV) using 
     59                         the following formula :  
     60                         (+++) MCLK_x = SAI_CK_x / (MCKDIV * 2) with MCLK_x = 256 * FS
     61                         (+++) FS = SAI_CK_x / (MCKDIV * 2) * 256
     62                         (+++) MCKDIV = SAI_CK_x / FS * 512
     63                   (++) Program the Frame Length, Frame active Length, FS Definition, FS Polarity, 
     64                        FS Offset using SAI_FrameInit() function.    
     65                   (++) Program the Slot First Bit Offset, Slot Size, Slot Number, Slot Active 
     66                        using SAI_SlotInit() function. 
     67                             
     68                (#) Enable the NVIC and the corresponding interrupt using the function 
     69                    SAI_ITConfig() if you need to use interrupt mode. 
     70            
     71                (#) When using the DMA mode 
     72                    (++) Configure the DMA using DMA_Init() function
     73                    (++) Active the needed channel Request using SAI_DMACmd() function
     74             
     75                (#) Enable the SAI using the SAI_Cmd() function.
     76             
     77                (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     78            
     79                (#) The SAI has some specific functions which can be useful depending 
     80                    on the audio protocol selected.  
     81                    (++) Enable Mute mode when the audio block is a transmitter using SAI_MuteModeCmd()
     82                         function and configure the value transmitted during mute using SAI_MuteValueConfig().  
     83                    (++) Detect the Mute mode when audio block is a receiver using SAI_MuteFrameCounterConfig().             
     84                    (++) Enable the MONO mode without any data preprocessing in memory when the number
     85                         of slot is equal to 2 using SAI_MonoModeConfig() function.
     86                    (++) Enable data companding algorithm (U law and A law) using SAI_CompandingModeConfig().
     87                    (++) Choose the behavior of the SD line in output when an inactive slot is sent 
     88                         on the data line using SAI_TRIStateConfig() function.   
     89            [..]               
     90             (@)    In master TX mode: enabling the audio block immediately generates the bit clock 
     91                    for the external slaves even if there is no data in the FIFO, However FS signal 
     92                    generation is conditioned by the presence of data in the FIFO.
     93                           
     94             (@)    In master RX mode: enabling the audio block immediately generates the bit clock 
     95                    and FS signal for the external slaves. 
     96                          
     97             (@)    It is mandatory to respect the following conditions in order to avoid bad SAI behavior: 
     98                      (+@)  First bit Offset <= (SLOT size - Data size)
     99                      (+@)  Data size <= SLOT size
    100                      (+@)  Number of SLOT x SLOT size = Frame length
    101                      (+@)  The number of slots should be even when bit FSDEF in the SAI_xFRCR is set.    
    102            
    103              @endverbatim  
    104          
    105            ******************************************************************************
    106            * @attention
    107            *
    108            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
    109            *
    110            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    111            * You may not use this file except in compliance with the License.
    112            * You may obtain a copy of the License at:
    113            *
    114            *        http://www.st.com/software_license_agreement_liberty_v2
    115            *
    116            * Unless required by applicable law or agreed to in writing, software 
    117            * distributed under the License is distributed on an "AS IS" BASIS, 
    118            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    119            * See the License for the specific language governing permissions and
    120            * limitations under the License.
    121            *
    122            ******************************************************************************
    123            */ 
    124          
    125          /* Includes ------------------------------------------------------------------*/
    126          #include "stm32f4xx_sai.h"
    127          #include "stm32f4xx_rcc.h"
    128          
    129          /** @addtogroup STM32F4xx_StdPeriph_Driver
    130            * @{
    131            */
    132          
    133          /** @defgroup SAI 
    134            * @brief SAI driver modules
    135            * @{
    136            */ 
    137          #if defined (STM32F40_41xxx) || defined (STM32F427_437xx) || defined (STM32F429_439xx) || \
    138              defined (STM32F401xx) || defined (STM32F411xE) || defined (STM32F446xx) || defined (STM32F469_479xx)
    139          
    140          /* Private typedef -----------------------------------------------------------*/
    141          /* Private define ------------------------------------------------------------*/
    142          
    143          /* *SAI registers Masks */
    144          #define CR1_CLEAR_MASK            ((uint32_t)0xFF07C010)
    145          #define FRCR_CLEAR_MASK           ((uint32_t)0xFFF88000)
    146          #define SLOTR_CLEAR_MASK          ((uint32_t)0x0000F020)
    147          
    148          /* Private macro -------------------------------------------------------------*/
    149          /* Private variables ---------------------------------------------------------*/
    150          /* Private function prototypes -----------------------------------------------*/
    151          /* Private functions ---------------------------------------------------------*/
    152          
    153          /** @defgroup SAI_Private_Functions
    154            * @{
    155            */
    156          
    157          /** @defgroup SAI_Group1 Initialization and Configuration functions
    158           *  @brief   Initialization and Configuration functions 
    159           *
    160          @verbatim   
    161           ===============================================================================
    162                      ##### Initialization and Configuration functions #####
    163           ===============================================================================  
    164            [..]
    165            This section provides a set of functions allowing to initialize the SAI Audio 
    166            Block Mode, Audio Protocol, Data size, Synchronization between audio block, 
    167            Master clock Divider, Fifo threshold, Frame configuration, slot configuration,
    168            Tristate mode, Companding mode and Mute mode.  
    169            [..] 
    170            The SAI_Init(), SAI_FrameInit() and SAI_SlotInit() functions follows the SAI Block
    171            configuration procedures for Master mode and Slave mode (details for these procedures 
    172            are available in reference manual(RM0090).
    173            
    174          @endverbatim
    175            * @{
    176            */
    177          
    178          /**
    179            * @brief  Deinitialize the SAIx peripheral registers to their default reset values.
    180            * @param  SAIx: To select the SAIx peripheral, where x can be the different instances 
    181            *                     
    182            * @retval None
    183            */

   \                                 In section .text, align 2, keep-with-next
    184          void SAI_DeInit(SAI_TypeDef* SAIx)
    185          {
   \                     SAI_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    186            /* Check the parameters */
    187            assert_param(IS_SAI_PERIPH(SAIx));
    188            
    189            if(SAIx == SAI1)
   \   00000002   0x....             LDR.N    R1,??DataTable2  ;; 0x40015800
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD10B             BNE.N    ??SAI_DeInit_0
    190            {
    191              /* Enable SAI1 reset state */
    192              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF44F 0x0080      MOV      R0,#+4194304
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    193              /* Release SAI1 from reset state */
    194              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI1, DISABLE); 
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF44F 0x0080      MOV      R0,#+4194304
   \   00000018   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001C   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    195            }
    196            else
    197            {
    198          #if defined(STM32F446xx)
    199            if(SAIx == SAI2)
    200              {
    201                /* Enable SAI2 reset state */
    202                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI2, ENABLE);
    203                /* Release SAI2 from reset state */
    204                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SAI2, DISABLE);   
    205              }
    206          #endif /* STM32F446xx */
    207            }
    208          }
   \                     ??SAI_DeInit_0: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    209          
    210          /**
    211            * @brief  Initializes the SAI Block x peripheral according to the specified 
    212            *         parameters in the SAI_InitStruct.
    213            *         
    214            * @note   SAI clock is generated from a specific output of the PLLSAI or a specific  
    215            *         output of the PLLI2S or from an alternate function bypassing the PLL I2S.
    216            *        
    217            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    218            * @param  SAI_InitStruct: pointer to a SAI_InitTypeDef structure that
    219            *         contains the configuration information for the specified SAI Block peripheral.             
    220            * @retval None
    221            */

   \                                 In section .text, align 2, keep-with-next
    222          void SAI_Init(SAI_Block_TypeDef* SAI_Block_x, SAI_InitTypeDef* SAI_InitStruct)
    223          {
    224            uint32_t tmpreg = 0;
    225            
    226            /* Check the parameters */
    227            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    228            
    229            /* Check the SAI Block parameters */
    230            assert_param(IS_SAI_BLOCK_MODE(SAI_InitStruct->SAI_AudioMode));
    231            assert_param(IS_SAI_BLOCK_PROTOCOL(SAI_InitStruct->SAI_Protocol));
    232            assert_param(IS_SAI_BLOCK_DATASIZE(SAI_InitStruct->SAI_DataSize));
    233            assert_param(IS_SAI_BLOCK_FIRST_BIT(SAI_InitStruct->SAI_FirstBit));
    234            assert_param(IS_SAI_BLOCK_CLOCK_STROBING(SAI_InitStruct->SAI_ClockStrobing));
    235            assert_param(IS_SAI_BLOCK_SYNCHRO(SAI_InitStruct->SAI_Synchro));
    236            assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(SAI_InitStruct->SAI_OUTDRIV));
    237            assert_param(IS_SAI_BLOCK_NODIVIDER(SAI_InitStruct->SAI_NoDivider));
    238            assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(SAI_InitStruct->SAI_MasterDivider));
    239            assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(SAI_InitStruct->SAI_FIFOThreshold));
    240          
    241            /* SAI Block_x CR1 Configuration */
    242            /* Get the SAI Block_x CR1 value */
    243            tmpreg = SAI_Block_x->CR1;
   \                     SAI_Init: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
    244            /* Clear MODE, PRTCFG, DS, LSBFIRST, CKSTR, SYNCEN, OUTDRIV, NODIV, and MCKDIV bits */
    245            tmpreg &= CR1_CLEAR_MASK;
    246            /* Configure SAI_Block_x: Audio mode, Protocol, Data Size, first transmitted bit, Clock strobing 
    247               edge, Synchronization mode, Output drive, Master Divider and FIFO level */  
    248            /* Set MODE bits according to SAI_AudioMode value       */
    249            /* Set PRTCFG bits according to SAI_Protocol value      */
    250            /* Set DS bits according to SAI_DataSize value          */
    251            /* Set LSBFIRST bit according to SAI_FirstBit value     */
    252            /* Set CKSTR bit according to SAI_ClockStrobing value   */
    253            /* Set SYNCEN bit according to SAI_Synchro value        */
    254            /* Set OUTDRIV bit according to SAI_OUTDRIV value       */
    255            /* Set NODIV bit according to SAI_NoDivider value       */
    256            /* Set MCKDIV bits according to SAI_MasterDivider value */
    257            tmpreg |= (uint32_t)(SAI_InitStruct->SAI_AudioMode     | SAI_InitStruct->SAI_Protocol  |
    258                                 SAI_InitStruct->SAI_DataSize      | SAI_InitStruct->SAI_FirstBit  |  
    259                                 SAI_InitStruct->SAI_ClockStrobing | SAI_InitStruct->SAI_Synchro   |  
    260                                 SAI_InitStruct->SAI_OUTDRIV       | SAI_InitStruct->SAI_NoDivider | 
    261                                 (uint32_t)((SAI_InitStruct->SAI_MasterDivider) << 20));
    262            /* Write to SAI_Block_x CR1 */
    263            SAI_Block_x->CR1 = tmpreg;
   \   00000002   0x....             LDR.N    R3,??DataTable2_1  ;; 0xff07c010
   \   00000004   0x401A             ANDS     R2,R3,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x688B             LDR      R3,[R1, #+8]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x68CB             LDR      R3,[R1, #+12]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x690B             LDR      R3,[R1, #+16]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x694B             LDR      R3,[R1, #+20]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x698B             LDR      R3,[R1, #+24]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x69CB             LDR      R3,[R1, #+28]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x6A0B             LDR      R3,[R1, #+32]
   \   00000028   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   0000002C   0x6002             STR      R2,[R0, #+0]
    264            
    265            /* SAI Block_x CR2 Configuration */
    266            /* Get the SAIBlock_x CR2 value */
    267            tmpreg = SAI_Block_x->CR2;
   \   0000002E   0x6842             LDR      R2,[R0, #+4]
    268            /* Clear FTH bits */
    269            tmpreg &= ~(SAI_xCR2_FTH);
    270            /* Configure the FIFO Level */
    271            /* Set FTH bits according to SAI_FIFOThreshold value */ 
    272            tmpreg |= (uint32_t)(SAI_InitStruct->SAI_FIFOThreshold);
    273            /* Write to SAI_Block_x CR2 */
    274            SAI_Block_x->CR2 = tmpreg;
   \   00000030   0x0892             LSRS     R2,R2,#+2
   \   00000032   0x6A49             LDR      R1,[R1, #+36]
   \   00000034   0xEA51 0x0182      ORRS     R1,R1,R2, LSL #+2
   \   00000038   0x6041             STR      R1,[R0, #+4]
    275          }
   \   0000003A   0x4770             BX       LR               ;; return
    276          
    277          /**
    278            * @brief  Initializes the SAI Block Audio frame according to the specified 
    279            *         parameters in the SAI_FrameInitStruct.
    280            *         
    281            * @note   this function has no meaning if the AC'97 or SPDIF audio protocol 
    282            *         are selected. 
    283            *               
    284            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    285            * @param  SAI_FrameInitStruct: pointer to an SAI_FrameInitTypeDef structure that
    286            *         contains the configuration of audio frame for a specified SAI Block                       
    287            * @retval None
    288            */

   \                                 In section .text, align 2, keep-with-next
    289          void SAI_FrameInit(SAI_Block_TypeDef* SAI_Block_x, SAI_FrameInitTypeDef* SAI_FrameInitStruct)
    290          {
    291            uint32_t tmpreg = 0;
    292            
    293            /* Check the parameters */
    294            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    295            
    296            /* Check the SAI Block frame parameters */
    297            assert_param(IS_SAI_BLOCK_FRAME_LENGTH(SAI_FrameInitStruct->SAI_FrameLength));
    298            assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(SAI_FrameInitStruct->SAI_ActiveFrameLength));
    299            assert_param(IS_SAI_BLOCK_FS_DEFINITION(SAI_FrameInitStruct->SAI_FSDefinition));
    300            assert_param(IS_SAI_BLOCK_FS_POLARITY(SAI_FrameInitStruct->SAI_FSPolarity));
    301            assert_param(IS_SAI_BLOCK_FS_OFFSET(SAI_FrameInitStruct->SAI_FSOffset));
    302          
    303            /* SAI Block_x FRCR Configuration */
    304            /* Get the SAI Block_x FRCR value */
    305            tmpreg = SAI_Block_x->FRCR;
   \                     SAI_FrameInit: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
    306            /* Clear FRL, FSALL, FSDEF, FSPOL, FSOFF bits */
    307            tmpreg &= FRCR_CLEAR_MASK;
    308            /* Configure SAI_Block_x Frame: Frame Length, Active Frame Length, Frame Synchronization
    309               Definition, Frame Synchronization Polarity and Frame Synchronization Polarity */
    310            /* Set FRL bits according to SAI_FrameLength value         */
    311            /* Set FSALL bits according to SAI_ActiveFrameLength value */
    312            /* Set FSDEF bit according to SAI_FSDefinition value       */
    313            /* Set FSPOL bit according to SAI_FSPolarity value         */
    314            /* Set FSOFF bit according to SAI_FSOffset value           */
    315            tmpreg |= (uint32_t)((uint32_t)(SAI_FrameInitStruct->SAI_FrameLength - 1)  | 
    316                                 SAI_FrameInitStruct->SAI_FSOffset     | 
    317                                 SAI_FrameInitStruct->SAI_FSDefinition |    
    318                                 SAI_FrameInitStruct->SAI_FSPolarity   |                        
    319                                 (uint32_t)((SAI_FrameInitStruct->SAI_ActiveFrameLength - 1) << 8));
    320                                 
    321            /* Write to SAI_Block_x FRCR */
    322            SAI_Block_x->FRCR = tmpreg;
   \   00000002   0x....             LDR.N    R3,??DataTable2_2  ;; 0xfff88000
   \   00000004   0x401A             ANDS     R2,R3,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x1E5B             SUBS     R3,R3,#+1
   \   0000000A   0x431A             ORRS     R2,R3,R2
   \   0000000C   0x690B             LDR      R3,[R1, #+16]
   \   0000000E   0x431A             ORRS     R2,R3,R2
   \   00000010   0x688B             LDR      R3,[R1, #+8]
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x68CB             LDR      R3,[R1, #+12]
   \   00000016   0x431A             ORRS     R2,R3,R2
   \   00000018   0x6849             LDR      R1,[R1, #+4]
   \   0000001A   0x1E49             SUBS     R1,R1,#+1
   \   0000001C   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000020   0x6081             STR      R1,[R0, #+8]
    323          }
   \   00000022   0x4770             BX       LR               ;; return
    324          
    325          /**
    326            * @brief  Initializes the SAI Block audio Slot according to the specified 
    327            *         parameters in the SAI_SlotInitStruct.
    328            *         
    329            * @note   this function has no meaning if the AC'97 or SPDIF audio protocol 
    330            *         are selected.
    331            *               
    332            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    333            * @param  SAI_SlotInitStruct: pointer to an SAI_SlotInitTypeDef structure that
    334            *         contains the configuration of audio slot for a specified SAI Block                      
    335            * @retval None
    336            */

   \                                 In section .text, align 2, keep-with-next
    337          void SAI_SlotInit(SAI_Block_TypeDef* SAI_Block_x, SAI_SlotInitTypeDef* SAI_SlotInitStruct)
    338          {
    339            uint32_t tmpreg = 0;
    340            
    341            /* Check the parameters */
    342            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    343            
    344            /* Check the SAI Block Slot parameters */
    345            assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(SAI_SlotInitStruct->SAI_FirstBitOffset));
    346            assert_param(IS_SAI_BLOCK_SLOT_SIZE(SAI_SlotInitStruct->SAI_SlotSize));
    347            assert_param(IS_SAI_BLOCK_SLOT_NUMBER(SAI_SlotInitStruct->SAI_SlotNumber));
    348            assert_param(IS_SAI_SLOT_ACTIVE(SAI_SlotInitStruct->SAI_SlotActive));
    349          
    350            /* SAI Block_x SLOTR Configuration */
    351            /* Get the SAI Block_x SLOTR value */
    352            tmpreg = SAI_Block_x->SLOTR;
   \                     SAI_SlotInit: (+1)
   \   00000000   0x68C2             LDR      R2,[R0, #+12]
    353            /* Clear FBOFF, SLOTSZ, NBSLOT, SLOTEN bits */
    354            tmpreg &= SLOTR_CLEAR_MASK;
    355            /* Configure SAI_Block_x Slot: First bit offset, Slot size, Number of Slot in  
    356               audio frame and slots activated in audio frame */
    357            /* Set FBOFF bits according to SAI_FirstBitOffset value  */
    358            /* Set SLOTSZ bits according to SAI_SlotSize value       */
    359            /* Set NBSLOT bits according to SAI_SlotNumber value     */
    360            /* Set SLOTEN bits according to SAI_SlotActive value     */
    361            tmpreg |= (uint32_t)(SAI_SlotInitStruct->SAI_FirstBitOffset | 
    362                                 SAI_SlotInitStruct->SAI_SlotSize       | 
    363                                 SAI_SlotInitStruct->SAI_SlotActive     |    
    364                                 (uint32_t)((SAI_SlotInitStruct->SAI_SlotNumber - 1) <<  8));
    365                                 
    366            /* Write to SAI_Block_x SLOTR */
    367            SAI_Block_x->SLOTR = tmpreg;
   \   00000002   0xF24F 0x0320      MOVW     R3,#+61472
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x680B             LDR      R3,[R1, #+0]
   \   0000000A   0x431A             ORRS     R2,R3,R2
   \   0000000C   0x684B             LDR      R3,[R1, #+4]
   \   0000000E   0x431A             ORRS     R2,R3,R2
   \   00000010   0x68CB             LDR      R3,[R1, #+12]
   \   00000012   0x431A             ORRS     R2,R3,R2
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x1E49             SUBS     R1,R1,#+1
   \   00000018   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   0000001C   0x60C1             STR      R1,[R0, #+12]
    368          }
   \   0000001E   0x4770             BX       LR               ;; return
    369          
    370          /**
    371            * @brief  Fills each SAI_InitStruct member with its default value.
    372            * @param  SAI_InitStruct: pointer to a SAI_InitTypeDef structure which will 
    373            *         be initialized.  
    374            * @retval None
    375            */

   \                                 In section .text, align 2, keep-with-next
    376          void SAI_StructInit(SAI_InitTypeDef* SAI_InitStruct)
    377          {
    378            /* Reset SAI init structure parameters values */
    379            /* Initialize the SAI_AudioMode member */
    380            SAI_InitStruct->SAI_AudioMode = SAI_Mode_MasterTx;
   \                     SAI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    381            /* Initialize the SAI_Protocol member */
    382            SAI_InitStruct->SAI_Protocol = SAI_Free_Protocol;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    383            /* Initialize the SAI_DataSize member */
    384            SAI_InitStruct->SAI_DataSize = SAI_DataSize_8b;
   \   00000006   0x2140             MOVS     R1,#+64
   \   00000008   0x6081             STR      R1,[R0, #+8]
    385            /* Initialize the SAI_FirstBit member */
    386            SAI_InitStruct->SAI_FirstBit = SAI_FirstBit_MSB;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    387            /* Initialize the SAI_ClockStrobing member */
    388            SAI_InitStruct->SAI_ClockStrobing = SAI_ClockStrobing_FallingEdge;
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    389            /* Initialize the SAI_Synchro member */
    390            SAI_InitStruct->SAI_Synchro = SAI_Asynchronous;
   \   00000010   0x6141             STR      R1,[R0, #+20]
    391            /* Initialize the SAI_OUTDRIV member */
    392            SAI_InitStruct->SAI_OUTDRIV = SAI_OutputDrive_Disabled;
   \   00000012   0x6181             STR      R1,[R0, #+24]
    393            /* Initialize the SAI_NoDivider member */
    394            SAI_InitStruct->SAI_NoDivider = SAI_MasterDivider_Enabled;
   \   00000014   0x61C1             STR      R1,[R0, #+28]
    395            /* Initialize the SAI_MasterDivider member */
    396            SAI_InitStruct->SAI_MasterDivider = 0;
   \   00000016   0x6201             STR      R1,[R0, #+32]
    397            /* Initialize the SAI_FIFOThreshold member */
    398            SAI_InitStruct->SAI_FIFOThreshold = SAI_Threshold_FIFOEmpty;
   \   00000018   0x6241             STR      R1,[R0, #+36]
    399          }
   \   0000001A   0x4770             BX       LR               ;; return
    400          
    401          /**
    402            * @brief  Fills each SAI_FrameInitStruct member with its default value.
    403            * @param  SAI_FrameInitStruct: pointer to a SAI_FrameInitTypeDef structure 
    404            *         which will be initialized.                     
    405            * @retval None
    406            */

   \                                 In section .text, align 2, keep-with-next
    407          void SAI_FrameStructInit(SAI_FrameInitTypeDef* SAI_FrameInitStruct)
    408          {
    409            /* Reset SAI Frame init structure parameters values */
    410            /* Initialize the SAI_FrameLength member */
    411            SAI_FrameInitStruct->SAI_FrameLength = 8;
   \                     SAI_FrameStructInit: (+1)
   \   00000000   0x2108             MOVS     R1,#+8
   \   00000002   0x6001             STR      R1,[R0, #+0]
    412            /* Initialize the SAI_ActiveFrameLength member */
    413            SAI_FrameInitStruct->SAI_ActiveFrameLength = 1;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x6041             STR      R1,[R0, #+4]
    414            /* Initialize the SAI_FSDefinition member */
    415            SAI_FrameInitStruct->SAI_FSDefinition = SAI_FS_StartFrame;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    416            /* Initialize the SAI_FSPolarity member */
    417            SAI_FrameInitStruct->SAI_FSPolarity = SAI_FS_ActiveLow;
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    418            /* Initialize the SAI_FSOffset member */
    419            SAI_FrameInitStruct->SAI_FSOffset = SAI_FS_FirstBit;
   \   0000000E   0x6101             STR      R1,[R0, #+16]
    420          }
   \   00000010   0x4770             BX       LR               ;; return
    421          
    422          /**
    423            * @brief  Fills each SAI_SlotInitStruct member with its default value.
    424            * @param  SAI_SlotInitStruct: pointer to a SAI_SlotInitTypeDef structure 
    425            *         which will be initialized.                     
    426            * @retval None
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          void SAI_SlotStructInit(SAI_SlotInitTypeDef* SAI_SlotInitStruct)
    429          {
    430            /* Reset SAI Slot init structure parameters values */
    431            /* Initialize the SAI_FirstBitOffset member */
    432            SAI_SlotInitStruct->SAI_FirstBitOffset = 0;
   \                     SAI_SlotStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    433            /* Initialize the SAI_SlotSize member */
    434            SAI_SlotInitStruct->SAI_SlotSize = SAI_SlotSize_DataSize;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    435            /* Initialize the SAI_SlotNumber member */
    436            SAI_SlotInitStruct->SAI_SlotNumber = 1;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x6081             STR      R1,[R0, #+8]
    437            /* Initialize the SAI_SlotActive member */
    438            SAI_SlotInitStruct->SAI_SlotActive = SAI_Slot_NotActive;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    439          
    440          }
   \   0000000E   0x4770             BX       LR               ;; return
    441          
    442          /**
    443            * @brief  Enables or disables the specified SAI Block peripheral.
    444            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    445            * @param  NewState: new state of the SAI_Block_x peripheral. 
    446            *          This parameter can be: ENABLE or DISABLE.
    447            * @retval None
    448            */

   \                                 In section .text, align 2, keep-with-next
    449          void SAI_Cmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
    450          {
    451            /* Check the parameters */
    452            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    453            assert_param(IS_FUNCTIONAL_STATE(NewState));
    454            if (NewState != DISABLE)
   \                     SAI_Cmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xD003             BEQ.N    ??SAI_Cmd_0
    455            {
    456              /* Enable the selected SAI peripheral */
    457              SAI_Block_x->CR1 |= SAI_xCR1_SAIEN;
   \   00000006   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    458            }
    459            else
    460            {
    461              /* Disable the selected SAI peripheral */
    462              SAI_Block_x->CR1 &= ~(SAI_xCR1_SAIEN);
   \                     ??SAI_Cmd_0: (+1)
   \   0000000E   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000012   0x6001             STR      R1,[R0, #+0]
    463            }
    464          }
   \   00000014   0x4770             BX       LR               ;; return
    465          
    466          /**
    467            * @brief  Configures the mono mode for the selected SAI block.
    468            * 
    469            * @note  This function has a meaning only when the number of slot is equal to 2. 
    470            *      
    471            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    472            * @param  SAI_MonoMode: specifies the SAI block mono mode.
    473            *          This parameter can be one of the following values:
    474            *            @arg SAI_MonoMode : Set mono audio mode
    475            *            @arg SAI_StreoMode : Set streo audio mode                       
    476            * @retval None
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          void SAI_MonoModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_Mono_StreoMode)
    479          {
    480            /* Check the parameters */
    481            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    482            assert_param(IS_SAI_BLOCK_MONO_STREO_MODE(SAI_MonoMode));
    483            /* Clear MONO bit */
    484            SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
   \                     SAI_MonoModeConfig: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   00000006   0x6001             STR      R1,[R0, #+0]
    485            /* Set new Mono Mode value */
    486            SAI_Block_x->CR1 |= SAI_MonoMode;
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    487          }
   \   00000010   0x4770             BX       LR               ;; return
    488          
    489          /**
    490            * @brief  Configures the TRIState management on data line for the selected SAI block.
    491            * 
    492            * @note  This function has a meaning only when the SAI block is configured in transmitter 
    493            *      
    494            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    495            * @param  SAI_TRIState: specifies the SAI block TRIState management.
    496            *          This parameter can be one of the following values:
    497            *            @arg SAI_Output_NotReleased : SD output line is still driven by the SAI.
    498            *            @arg SAI_Output_Released : SD output line is released (HI-Z)                       
    499            * @retval None
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          void SAI_TRIStateConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_TRIState)
    502          {
    503            /* Check the parameters */
    504            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    505            assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(SAI_TRIState));
    506            /* Clear MONO bit */
    507            SAI_Block_x->CR1 &= ~(SAI_xCR1_MONO);
   \                     SAI_TRIStateConfig: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   00000006   0x6001             STR      R1,[R0, #+0]
    508            /* Set new Mono Mode value */
    509            SAI_Block_x->CR1 |= SAI_MonoMode;  
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    510            
    511          }
   \   00000010   0x4770             BX       LR               ;; return
    512          
    513          /**
    514            * @brief  Configures the companding mode for the selected SAI block.
    515            * 
    516            * @note  The data expansion or data compression are determined by the state of
    517            *        SAI block selected (transmitter or receiver). 
    518          
    519            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.              
    520            * @param  SAI_CompandingMode: specifies the SAI block companding mode.
    521            *          This parameter can be one of the following values:
    522            *            @arg SAI_NoCompanding : no companding algorithm set
    523            *            @arg SAI_ULaw_1CPL_Companding : Set U law (algorithm 1's complement representation)
    524            *            @arg SAI_ALaw_1CPL_Companding : Set A law (algorithm 1's complement representation)  
    525            *            @arg SAI_ULaw_2CPL_Companding : Set U law (algorithm 2's complement representation)
    526            *            @arg SAI_ALaw_2CPL_Companding : Set A law (algorithm 2's complement representation)  
    527            * @retval None
    528            */

   \                                 In section .text, align 2, keep-with-next
    529          void SAI_CompandingModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_CompandingMode)
    530          {
    531            /* Check the parameters */
    532            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    533            assert_param(IS_SAI_BLOCK_COMPANDING_MODE(SAI_CompandingMode));
    534            /* Clear Companding Mode bits */
    535            SAI_Block_x->CR2 &= ~(SAI_xCR2_COMP);
   \                     SAI_CompandingModeConfig: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0xF422 0x4240      BIC      R2,R2,#0xC000
   \   00000006   0x6042             STR      R2,[R0, #+4]
    536            /* Set new Companding Mode value */
    537            SAI_Block_x->CR2 |= SAI_CompandingMode;
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x4311             ORRS     R1,R1,R2
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    538          }
   \   0000000E   0x4770             BX       LR               ;; return
    539          
    540          /**
    541            * @brief  Enables or disables the Mute mode for the selected SAI block.
    542            *    
    543            * @note   This function has a meaning only when the audio block is transmitter
    544            * @note   Mute mode is applied for an entire frame for all the valid slot
    545            *         It becomes active at the end of an audio frame when set somewhere in a frame. 
    546            *         Mute mode exit occurs at the end of the frame in which the bit MUTE has been set.
    547            *
    548            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    549            * @param  NewState: new state of the SAIx block. 
    550            *          This parameter can be: ENABLE or DISABLE.
    551            * @retval None
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          void SAI_MuteModeCmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
    554          {
    555            /* Check the parameters */
    556            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    557            assert_param(IS_FUNCTIONAL_STATE(NewState));
    558            if (NewState != DISABLE)
   \                     SAI_MuteModeCmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0xD003             BEQ.N    ??SAI_MuteModeCmd_0
    559            {
    560              /* Enable the selected SAI block mute mode */
    561              SAI_Block_x->CR2 |= SAI_xCR2_MUTE;
   \   00000006   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   \   0000000C   0x4770             BX       LR
    562            }
    563            else
    564            {
    565              /* Disable the selected SAI SS output */
    566              SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTE);
   \                     ??SAI_MuteModeCmd_0: (+1)
   \   0000000E   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000012   0x6041             STR      R1,[R0, #+4]
    567            }
    568          }
   \   00000014   0x4770             BX       LR               ;; return
    569          
    570          /**
    571            * @brief  Configure the mute value for the selected SAI block.
    572            *    
    573            * @note   This function has a meaning only when the audio block is transmitter
    574            * @note   the configuration last value sent during mute mode has only a meaning 
    575            *          when the number of slot is lower or equal to 2 and if the MUTE bit is set.
    576            *           
    577            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    578            * @param  SAI_MuteValue: specifies the SAI block mute value.
    579            *          This parameter can be one of the following values:
    580            *            @arg SAI_ZeroValue : bit value 0 is sent during Mute Mode
    581            *            @arg SAI_LastSentValue : Last value is sent during Mute Mode  
    582            * @retval None
    583            */

   \                                 In section .text, align 2, keep-with-next
    584          void SAI_MuteValueConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteValue)
    585          {
    586            /* Check the parameters */
    587            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    588            assert_param(IS_SAI_BLOCK_MUTE_VALUE(SAI_MuteValue));
    589            
    590            /* Clear Mute value bits */
    591            SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTEVAL);
   \                     SAI_MuteValueConfig: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000006   0x6042             STR      R2,[R0, #+4]
    592            /* Set new Mute value */
    593            SAI_Block_x->CR2 |= SAI_MuteValue;
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x4311             ORRS     R1,R1,R2
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    594          }
   \   0000000E   0x4770             BX       LR               ;; return
    595          
    596          /**
    597            * @brief  Enables or disables the Mute mode for the selected SAI block. 
    598            *
    599            * @note   This function has a meaning only when the audio block is Receiver
    600            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    601            * @param  SAI_MuteCounter: specifies the SAI block mute value.
    602            *         This parameter can be a number between 0 and 63.  
    603           
    604            * @retval None
    605            */

   \                                 In section .text, align 2, keep-with-next
    606          void SAI_MuteFrameCounterConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteCounter)
    607          {
    608            /* Check the parameters */
    609            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    610            assert_param(IS_SAI_BLOCK_MUTE_COUNTER(SAI_MuteCounter));
    611            
    612            /* Clear Mute value bits */
    613            SAI_Block_x->CR2 &= ~(SAI_xCR2_MUTECNT);
   \                     SAI_MuteFrameCounterConfig: (+1)
   \   00000000   0x6842             LDR      R2,[R0, #+4]
   \   00000002   0xF422 0x52FC      BIC      R2,R2,#0x1F80
   \   00000006   0x6042             STR      R2,[R0, #+4]
    614            /* Set new Mute value */
    615            SAI_Block_x->CR2 |= (SAI_MuteCounter << 7);
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0xEA42 0x11C1      ORR      R1,R2,R1, LSL #+7
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    616          }
   \   00000010   0x4770             BX       LR               ;; return
    617          
    618          /**
    619            * @brief  Reinitialize the FIFO pointer
    620            *   
    621            * @note   The FIFO pointers can be reinitialized at anytime The data present 
    622            *         into the FIFO, if it is not empty, will be lost. 
    623            * 
    624            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    625            * @param  NewState: new state of the selected SAI TI communication mode.
    626            *          This parameter can be: ENABLE or DISABLE.
    627            * @retval None
    628            */

   \                                 In section .text, align 2, keep-with-next
    629          void SAI_FlushFIFO(SAI_Block_TypeDef* SAI_Block_x)
    630          {
    631            /* Check the parameters */
    632            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    633          
    634            /* FIFO flush */
    635            SAI_Block_x->CR2 |= SAI_xCR2_FFLUSH;
   \                     SAI_FlushFIFO: (+1)
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000006   0x6041             STR      R1,[R0, #+4]
    636          }
   \   00000008   0x4770             BX       LR               ;; return
    637          
    638          /**
    639            * @}
    640            */
    641          
    642          /** @defgroup SAI_Group2 Data transfers functions
    643           *  @brief   Data transfers functions
    644           *
    645          @verbatim   
    646           ===============================================================================
    647                                 ##### Data transfers functions #####
    648           ===============================================================================  
    649            [..]
    650            This section provides a set of functions allowing to manage the SAI data transfers.
    651            [..]
    652            In reception, data are received and then stored into an internal FIFO while 
    653            In transmission, data are first stored into an internal FIFO before being 
    654            transmitted.
    655            [..]
    656            The read access of the SAI_xDR register can be done using the SAI_ReceiveData()
    657            function and returns the Rx buffered value. Whereas a write access to the SAI_DR 
    658            can be done using SAI_SendData() function and stores the written data into 
    659            Tx buffer.
    660          
    661          @endverbatim
    662            * @{
    663            */
    664          
    665          /**
    666            * @brief  Returns the most recent received data by the SAI block x peripheral. 
    667            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
    668            *         
    669            * @retval The value of the received data.
    670            */

   \                                 In section .text, align 2, keep-with-next
    671          uint32_t SAI_ReceiveData(SAI_Block_TypeDef* SAI_Block_x)
    672          {
    673            /* Check the parameters */
    674            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    675            
    676            /* Return the data in the DR register */
    677            return SAI_Block_x->DR;
   \                     SAI_ReceiveData: (+1)
   \   00000000   0x69C0             LDR      R0,[R0, #+28]
   \   00000002   0x4770             BX       LR               ;; return
    678          }
    679          
    680          /**
    681            * @brief  Transmits a Data through the SAI block x peripheral.
    682            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
    683            *        
    684            * @param  Data: Data to be transmitted.
    685            * @retval None
    686            */

   \                                 In section .text, align 2, keep-with-next
    687          void SAI_SendData(SAI_Block_TypeDef* SAI_Block_x, uint32_t Data)
    688          {
    689            /* Check the parameters */
    690            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    691            
    692            /* Write in the DR register the data to be sent */
    693            SAI_Block_x->DR = Data;
   \                     SAI_SendData: (+1)
   \   00000000   0x61C1             STR      R1,[R0, #+28]
    694          }
   \   00000002   0x4770             BX       LR               ;; return
    695          
    696          /**
    697            * @}
    698            */
    699          
    700          /** @defgroup SAI_Group3 DMA transfers management functions
    701           *  @brief   DMA transfers management functions
    702            *
    703          @verbatim   
    704           ===============================================================================
    705                            ##### DMA transfers management functions #####
    706           ===============================================================================  
    707          
    708          @endverbatim
    709            * @{
    710            */
    711          
    712          /**
    713            * @brief  Enables or disables the SAI Block x DMA interface.
    714            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
    715            * @param  NewState: new state of the selected SAI block DMA transfer request.
    716            *          This parameter can be: ENABLE or DISABLE.
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState)
    720          {
    721            /* Check the parameters */
    722            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    723            assert_param(IS_FUNCTIONAL_STATE(NewState));
    724            
    725            if (NewState != DISABLE)
   \                     SAI_DMACmd: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xD003             BEQ.N    ??SAI_DMACmd_0
    726            {
    727              /* Enable the selected SAI block mute mode */
    728              SAI_Block_x->CR1 |= SAI_xCR1_DMAEN;
   \   00000006   0xF441 0x3100      ORR      R1,R1,#0x20000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR
    729            }
    730            else
    731            {
    732              /* Disable the selected SAI SS output */
    733              SAI_Block_x->CR1 &= ~(SAI_xCR1_DMAEN);
   \                     ??SAI_DMACmd_0: (+1)
   \   0000000E   0xF421 0x3100      BIC      R1,R1,#0x20000
   \   00000012   0x6001             STR      R1,[R0, #+0]
    734            }
    735          }
   \   00000014   0x4770             BX       LR               ;; return
    736          
    737          /**
    738            * @}
    739            */
    740          
    741          /** @defgroup SAI_Group4 Interrupts and flags management functions
    742           *  @brief   Interrupts and flags management functions
    743            *
    744          @verbatim   
    745           ===============================================================================
    746                      ##### Interrupts and flags management functions #####
    747           ===============================================================================  
    748            [..]
    749            This section provides a set of functions allowing to configure the SAI Interrupts 
    750            sources and check or clear the flags or pending bits status.
    751            The user should identify which mode will be used in his application to manage 
    752            the communication: Polling mode, Interrupt mode or DMA mode. 
    753              
    754            *** Polling Mode ***
    755            ====================
    756            [..]
    757            In Polling Mode, the SAI communication can be managed by 7 flags:
    758               (#) SAI_FLAG_FREQ : to indicate if there is a FIFO Request to write or to read.
    759               (#) SAI_FLAG_MUTEDET : to indicate if a MUTE frame detected
    760               (#) SAI_FLAG_OVRUDR : to indicate if an Overrun or Underrun error occur
    761               (#) SAI_FLAG_AFSDET : to indicate if there is the detection of a audio frame 
    762                                    synchronisation (FS) earlier than expected
    763               (#) SAI_FLAG_LFSDET : to indicate if there is the detection of a audio frame 
    764                                    synchronisation (FS) later than expected              
    765               (#) SAI_FLAG_CNRDY : to indicate if  the codec is not ready to communicate during 
    766                                   the reception of the TAG 0 (slot0) of the AC97 audio frame 
    767               (#) SAI_FLAG_WCKCFG: to indicate if wrong clock configuration in master mode 
    768                                   error occurs.
    769            [..]
    770            In this Mode it is advised to use the following functions:
    771               (+) FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
    772               (+) void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
    773          
    774            *** Interrupt Mode ***
    775            ======================
    776            [..]
    777            In Interrupt Mode, the SAI communication can be managed by 7 interrupt sources
    778            and 7 pending bits: 
    779            (+) Pending Bits:
    780               (##) SAI_IT_FREQ : to indicate if there is a FIFO Request to write or to read.
    781               (##) SAI_IT_MUTEDET : to indicate if a MUTE frame detected.
    782               (##) SAI_IT_OVRUDR : to indicate if an Overrun or Underrun error occur.
    783               (##) SAI_IT_AFSDET : to indicate if there is the detection of a audio frame 
    784                                    synchronisation (FS) earlier than expected.
    785               (##) SAI_IT_LFSDET : to indicate if there is the detection of a audio frame 
    786                                    synchronisation (FS) later than expected.              
    787               (##) SAI_IT_CNRDY : to indicate if  the codec is not ready to communicate during 
    788                                   the reception of the TAG 0 (slot0) of the AC97 audio frame. 
    789               (##) SAI_IT_WCKCFG: to indicate if wrong clock configuration in master mode 
    790                                   error occurs.
    791          
    792            (+) Interrupt Source:
    793               (##) SAI_IT_FREQ : specifies the interrupt source for FIFO Request.
    794               (##) SAI_IT_MUTEDET : specifies the interrupt source for MUTE frame detected.
    795               (##) SAI_IT_OVRUDR : specifies the interrupt source for overrun or underrun error.
    796               (##) SAI_IT_AFSDET : specifies the interrupt source for anticipated frame synchronization
    797                                    detection interrupt.
    798               (##) SAI_IT_LFSDET : specifies the interrupt source for late frame synchronization
    799                                    detection interrupt.             
    800               (##) SAI_IT_CNRDY : specifies the interrupt source for codec not ready interrupt
    801               (##) SAI_IT_WCKCFG: specifies the interrupt source for wrong clock configuration
    802                                   interrupt.
    803            [..]                     
    804            In this Mode it is advised to use the following functions:
    805               (+) void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState);
    806               (+) ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
    807               (+) void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
    808          
    809            *** DMA Mode ***
    810            ================
    811            [..]
    812            In DMA Mode, each SAI audio block has an independent DMA interface in order to 
    813            read or to write into the SAI_xDR register (to hit the internal FIFO). 
    814            There is one DMA channel by audio block following basic DMA request/acknowledge 
    815            protocol.
    816            [..]
    817            In this Mode it is advised to use the following function:
    818              (+) void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
    819            [..]
    820            This section provides also functions allowing to
    821             (+) Check the SAI Block enable status
    822             (+)Check the FIFO status 
    823             
    824            *** SAI Block Enable status ***
    825            ===============================
    826            [..]
    827            After disabling a SAI Block, it is recommended to check (or wait until) the SAI Block 
    828            is effectively disabled. If a Block is disabled while an audio frame transfer is ongoing
    829            the current frame will be transferred and the block will be effectively disabled only at 
    830            the end of audio frame. 
    831            To monitor this state it is possible to use the following function:
    832              (+) FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x); 
    833           
    834            *** SAI Block FIFO status ***
    835            =============================
    836            [..]
    837            It is possible to monitor the FIFO status when a transfer is ongoing using the following 
    838            function:
    839              (+) uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x);
    840              
    841          @endverbatim
    842            * @{
    843            */
    844          
    845          /**
    846            * @brief  Enables or disables the specified SAI Block interrupts.
    847            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
    848            * @param  SAI_IT: specifies the SAI interrupt source to be enabled or disabled. 
    849            *          This parameter can be one of the following values:
    850            *            @arg SAI_IT_FREQ: FIFO Request interrupt mask
    851            *            @arg SAI_IT_MUTEDET: MUTE detection interrupt mask
    852            *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt mask
    853            *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection 
    854            *                                interrupt mask  
    855            *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt 
    856            *                                mask
    857            *            @arg SAI_IT_CNRDY: codec not ready interrupt mask
    858            *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt mask      
    859            * @param  NewState: new state of the specified SAI interrupt.
    860            *          This parameter can be: ENABLE or DISABLE.
    861            * @retval None
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState)
    864          { 
    865            /* Check the parameters */
    866            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    867            assert_param(IS_FUNCTIONAL_STATE(NewState));
    868            assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
    869          
    870            if (NewState != DISABLE)
   \                     SAI_ITConfig: (+1)
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6902             LDR      R2,[R0, #+16]
   \   00000004   0xD002             BEQ.N    ??SAI_ITConfig_0
    871            {
    872              /* Enable the selected SAI Block interrupt */
    873              SAI_Block_x->IMR |= SAI_IT;
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6101             STR      R1,[R0, #+16]
   \   0000000A   0x4770             BX       LR
    874            }
    875            else
    876            {
    877              /* Disable the selected SAI Block interrupt */
    878              SAI_Block_x->IMR &= ~(SAI_IT);
   \                     ??SAI_ITConfig_0: (+1)
   \   0000000C   0xEA22 0x0101      BIC      R1,R2,R1
   \   00000010   0x6101             STR      R1,[R0, #+16]
    879            }
    880          }
   \   00000012   0x4770             BX       LR               ;; return
    881          
    882          /**
    883            * @brief  Checks whether the specified SAI block x flag is set or not.
    884            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
    885            * @param  SAI_FLAG: specifies the SAI block flag to check. 
    886            *          This parameter can be one of the following values:
    887            *            @arg SAI_FLAG_FREQ: FIFO Request flag.  
    888            *            @arg SAI_FLAG_MUTEDET: MUTE detection flag.  
    889            *            @arg SAI_FLAG_OVRUDR: overrun/underrun flag.
    890            *            @arg SAI_FLAG_WCKCFG: wrong clock configuration flag.            
    891            *            @arg SAI_FLAG_CNRDY: codec not ready flag. 
    892            *            @arg SAI_FLAG_AFSDET: anticipated frame synchronization detection flag.
    893            *            @arg SAI_FLAG_LFSDET: late frame synchronization detection flag.
    894            * @retval The new state of SAI_FLAG (SET or RESET).
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
    897          {
    898            FlagStatus bitstatus = RESET;
   \                     SAI_GetFlagStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    899            
    900            /* Check the parameters */
    901            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    902            assert_param(IS_SAI_BLOCK_GET_FLAG(SAI_FLAG));
    903            
    904            /* Check the status of the specified SAI flag */
    905            if ((SAI_Block_x->SR & SAI_FLAG) != (uint32_t)RESET)
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD000             BEQ.N    ??SAI_GetFlagStatus_0
    906            {
    907              /* SAI_FLAG is set */
    908              bitstatus = SET;
   \   00000008   0x2201             MOVS     R2,#+1
    909            }
    910            else
    911            {
    912              /* SAI_FLAG is reset */
    913              bitstatus = RESET;
    914            }
    915            /* Return the SAI_FLAG status */
    916            return  bitstatus;
   \                     ??SAI_GetFlagStatus_0: (+1)
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
    917          }
    918          
    919          /**
    920            * @brief  Clears the specified SAI Block x flag.
    921            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
    922            * @param  SAI_FLAG: specifies the SAI block flag to check. 
    923            *          This parameter can be one of the following values: 
    924            *            @arg SAI_FLAG_MUTEDET: MUTE detection flag.  
    925            *            @arg SAI_FLAG_OVRUDR: overrun/underrun flag.
    926            *            @arg SAI_FLAG_WCKCFG: wrong clock configuration flag.            
    927            *            @arg SAI_FLAG_CNRDY: codec not ready flag. 
    928            *            @arg SAI_FLAG_AFSDET: anticipated frame synchronization detection flag.
    929            *            @arg SAI_FLAG_LFSDET: late frame synchronization detection flag. 
    930            *  
    931            * @note    FREQ (FIFO Request) flag is cleared : 
    932            *          - When the audio block is transmitter and the FIFO is full or the FIFO   
    933            *            has one data (one buffer mode) depending the bit FTH in the
    934            *            SAI_xCR2 register.
    935            *          - When the audio block is receiver and the FIFO is not empty           
    936            *  
    937            * @retval None
    938            */

   \                                 In section .text, align 2, keep-with-next
    939          void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG)
    940          {
    941            /* Check the parameters */
    942            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    943            assert_param(IS_SAI_BLOCK_CLEAR_FLAG(SAI_FLAG));
    944              
    945            /* Clear the selected SAI Block flag */
    946            SAI_Block_x->CLRFR |= SAI_FLAG;
   \                     SAI_ClearFlag: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x6181             STR      R1,[R0, #+24]
    947          }
   \   00000006   0x4770             BX       LR               ;; return
    948          
    949          /**
    950            * @brief  Checks whether the specified SAI Block x interrupt has occurred or not.
    951            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
    952            * @param  SAI_IT: specifies the SAI interrupt source to be enabled or disabled. 
    953            *          This parameter can be one of the following values:
    954            *            @arg SAI_IT_FREQ: FIFO Request interrupt 
    955            *            @arg SAI_IT_MUTEDET: MUTE detection interrupt 
    956            *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt 
    957            *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection interrupt                                    
    958            *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt                                
    959            *            @arg SAI_IT_CNRDY: codec not ready interrupt 
    960            *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt 
    961            *                
    962            * @retval The new state of SAI_IT (SET or RESET).
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
    965          {
    966            ITStatus bitstatus = RESET;
   \                     SAI_GetITStatus: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    967            uint32_t  enablestatus = 0;
    968          
    969            /* Check the parameters */
    970            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
    971            assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
    972            
    973            /* Get the SAI_IT enable bit status */
    974            enablestatus = (SAI_Block_x->IMR & SAI_IT) ;
   \   00000002   0x6903             LDR      R3,[R0, #+16]
   \   00000004   0x400B             ANDS     R3,R1,R3
    975          
    976            /* Check the status of the specified SAI interrupt */
    977            if (((SAI_Block_x->SR & SAI_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0x4208             TST      R0,R1
   \   0000000A   0xD002             BEQ.N    ??SAI_GetITStatus_0
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD000             BEQ.N    ??SAI_GetITStatus_0
    978            {
    979              /* SAI_IT is set */
    980              bitstatus = SET;
   \   00000010   0x2201             MOVS     R2,#+1
    981            }
    982            else
    983            {
    984              /* SAI_IT is reset */
    985              bitstatus = RESET;
    986            }
    987            /* Return the SAI_IT status */
    988            return bitstatus;
   \                     ??SAI_GetITStatus_0: (+1)
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0x4770             BX       LR               ;; return
    989          }
    990          
    991          /**
    992            * @brief  Clears the SAI Block x interrupt pending bit.
    993            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral. 
    994            * @param  SAI_IT: specifies the SAI Block interrupt pending bit to clear. 
    995            *          This parameter can be one of the following values:  
    996            *            @arg SAI_IT_MUTEDET: MUTE detection interrupt.  
    997            *            @arg SAI_IT_OVRUDR: overrun/underrun interrupt.
    998            *            @arg SAI_IT_WCKCFG: wrong clock configuration interrupt.            
    999            *            @arg SAI_IT_CNRDY: codec not ready interrupt. 
   1000            *            @arg SAI_IT_AFSDET: anticipated frame synchronization detection interrupt.
   1001            *            @arg SAI_IT_LFSDET: late frame synchronization detection interrupt. 
   1002            *  
   1003            * @note    FREQ (FIFO Request) flag is cleared : 
   1004            *          - When the audio block is transmitter and the FIFO is full or the FIFO   
   1005            *            has one data (one buffer mode) depending the bit FTH in the
   1006            *            SAI_xCR2 register.
   1007            *          - When the audio block is receiver and the FIFO is not empty  
   1008            *            
   1009            * @retval None
   1010            */

   \                                 In section .text, align 2, keep-with-next
   1011          void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT)
   1012          {
   1013            /* Check the parameters */
   1014            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
   1015            assert_param(IS_SAI_BLOCK_CONFIG_IT(SAI_IT));
   1016          
   1017            /* Clear the selected SAI Block x interrupt pending bit */
   1018            SAI_Block_x->CLRFR |= SAI_IT; 
   \                     SAI_ClearITPendingBit: (+1)
   \   00000000   0x6982             LDR      R2,[R0, #+24]
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x6181             STR      R1,[R0, #+24]
   1019          }
   \   00000006   0x4770             BX       LR               ;; return
   1020          
   1021          /**
   1022            * @brief  Returns the status of EN bit for the specified SAI Block x.
   1023            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
   1024            *   
   1025            * @note    After disabling a SAI Block, it is recommended to check (or wait until) 
   1026            *          the SAI Block is effectively disabled. If a Block is disabled while
   1027            *          an audio frame transfer is ongoing, the current frame will be 
   1028            *          transferred and the block will be effectively disabled only at 
   1029            *          the end of audio frame.  
   1030            *      
   1031            * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
   1032            */

   \                                 In section .text, align 2, keep-with-next
   1033          FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x)
   1034          {
   1035            FunctionalState state = DISABLE;
   1036          
   1037            /* Check the parameters */
   1038            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
   1039            if ((SAI_Block_x->CR1 & (uint32_t)SAI_xCR1_SAIEN) != 0)
   \                     SAI_GetCmdStatus: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   1040            {
   1041              /* The selected SAI Block x EN bit is set (audio frame transfer is ongoing) */
   1042              state = ENABLE;
   1043            }
   1044            else
   1045            {
   1046              /* The selected SAI Block x EN bit is cleared (SAI Block is disabled and 
   1047                  all transfers are complete) */
   1048              state = DISABLE;
   \   00000002   0x0C00             LSRS     R0,R0,#+16
   \   00000004   0xF000 0x0001      AND      R0,R0,#0x1
   1049            }
   1050            return state;
   \   00000008   0x4770             BX       LR               ;; return
   1051          }
   1052          
   1053          /**
   1054            * @brief  Returns the current SAI Block x FIFO filled level.
   1055            * @param  SAI_Block_x: where x can be A or B to select the SAI Block peripheral.
   1056            *   
   1057            * @retval The FIFO filling state.
   1058            *           - SAI_FIFOStatus_Empty: when FIFO is empty  
   1059            *           - SAI_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
   1060            *                                               and not empty.
   1061            *           - SAI_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
   1062            *           - SAI_FIFOStatus_HalfFull: if more than 1 half-full.
   1063            *           - SAI_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
   1064            *           - SAI_FIFOStatus_Full: when FIFO is full
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x)
   1067          {
   1068            uint32_t tmpreg = 0;
   1069           
   1070            /* Check the parameters */
   1071            assert_param(IS_SAI_BLOCK_PERIPH(SAI_Block_x));
   1072            
   1073            /* Get the FIFO level bits */
   1074            tmpreg = (uint32_t)((SAI_Block_x->SR & SAI_xSR_FLVL));
   \                     SAI_GetFIFOStatus: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0xF400 0x20E0      AND      R0,R0,#0x70000
   1075            
   1076            return tmpreg;
   \   00000006   0x4770             BX       LR               ;; return
   1077          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40015800         DC32     0x40015800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xFF07C010         DC32     0xff07c010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0xFFF88000         DC32     0xfff88000
   1078          
   1079          
   1080          /**
   1081            * @}
   1082            */
   1083          
   1084          /**
   1085            * @}
   1086            */ 
   1087          #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F446xx || STM32F469_479xx */
   1088          
   1089          /**
   1090            * @}
   1091            */ 
   1092          
   1093          /**
   1094            * @}
   1095            */ 
   1096          
   1097          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SAI_ClearFlag
       0   SAI_ClearITPendingBit
       0   SAI_Cmd
       0   SAI_CompandingModeConfig
       0   SAI_DMACmd
       8   SAI_DeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   SAI_FlushFIFO
       0   SAI_FrameInit
       0   SAI_FrameStructInit
       0   SAI_GetCmdStatus
       0   SAI_GetFIFOStatus
       0   SAI_GetFlagStatus
       0   SAI_GetITStatus
       0   SAI_ITConfig
       0   SAI_Init
       0   SAI_MonoModeConfig
       0   SAI_MuteFrameCounterConfig
       0   SAI_MuteModeCmd
       0   SAI_MuteValueConfig
       0   SAI_ReceiveData
       0   SAI_SendData
       0   SAI_SlotInit
       0   SAI_SlotStructInit
       0   SAI_StructInit
       0   SAI_TRIStateConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       8  SAI_ClearFlag
       8  SAI_ClearITPendingBit
      22  SAI_Cmd
      16  SAI_CompandingModeConfig
      22  SAI_DMACmd
      34  SAI_DeInit
      10  SAI_FlushFIFO
      36  SAI_FrameInit
      18  SAI_FrameStructInit
      10  SAI_GetCmdStatus
       8  SAI_GetFIFOStatus
      14  SAI_GetFlagStatus
      22  SAI_GetITStatus
      20  SAI_ITConfig
      60  SAI_Init
      18  SAI_MonoModeConfig
      18  SAI_MuteFrameCounterConfig
      22  SAI_MuteModeCmd
      16  SAI_MuteValueConfig
       4  SAI_ReceiveData
       4  SAI_SendData
      32  SAI_SlotInit
      16  SAI_SlotStructInit
      28  SAI_StructInit
      18  SAI_TRIStateConfig

 
 496 bytes in section .text
 
 496 bytes of CODE memory

Errors: none
Warnings: none
