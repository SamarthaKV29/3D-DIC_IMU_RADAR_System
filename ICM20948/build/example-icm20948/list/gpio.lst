###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:26
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\prasa\Documents\1.0.0\sources\board-hal\gpio.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\board-hal\gpio.c -D
#        IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D NUCLEO
#        -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000 -D
#        STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\gpio.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\gpio.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\board-hal\gpio.c
      1          /*
      2           * ________________________________________________________________________________________________________
      3           * Copyright (c) 2016-2016 InvenSense Inc. All rights reserved.
      4           *
      5           * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      6           * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
      7           * and other intellectual property rights laws.
      8           *
      9           * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
     10           * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
     11           * from InvenSense is strictly prohibited.
     12           *
     13           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
     14           * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
     15           * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
     17           * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18           * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
     19           * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20           * OF THE SOFTWARE.
     21           * ________________________________________________________________________________________________________
     22           */
     23          
     24          #include "gpio.h"
     25          #include "nvic_config.h"
     26          
     27          // system drivers
     28          #include "stm32f4xx.h"
     29          #include "stm32f4xx_gpio.h"
     30          #include "stm32f4xx_exti.h"
     31          #include "stm32f4xx_syscfg.h"
     32          
     33          /** SPI Slave GPIOs **/
     34          
     35          #define SPI_SLAVE_GPIO               GPIOB
     36          #define SPI_SLAVE_GPIO_CLK           RCC_AHB1Periph_GPIOB
     37          #define SPI_SLAVE_CS_PIN             GPIO_Pin_12
     38          
     39          /** Sensor IRQ GPIOs **/
     40          
     41          #define SENSOR_IRQ_D7_GPIO             GPIOA
     42          #define SENSOR_IRQ_D7_GPIO_CLK         RCC_AHB1Periph_GPIOA
     43          #define SENSOR_IRQ_D7_PIN              GPIO_Pin_8
     44          
     45          #define SENSOR_IRQ_D6_GPIO             GPIOB
     46          #define SENSOR_IRQ_D6_GPIO_CLK         RCC_AHB1Periph_GPIOB
     47          #define SENSOR_IRQ_D6_PIN              GPIO_Pin_10
     48          
     49          #define SENSOR_IRQ_D5_GPIO             GPIOB
     50          #define SENSOR_IRQ_D5_GPIO_CLK         RCC_AHB1Periph_GPIOB
     51          #define SENSOR_IRQ_D5_PIN              GPIO_Pin_4
     52          
     53          #define SENSOR_IRQ_D4_GPIO             GPIOB
     54          #define SENSOR_IRQ_D4_GPIO_CLK         RCC_AHB1Periph_GPIOB
     55          #define SENSOR_IRQ_D4_PIN              GPIO_Pin_5
     56          
     57          /*
     58           * Callback for End of frame transfer interruption
     59           */

   \                                 In section .bss, align 4
     60          static void (*sEnd_of_frame_cb)(void);
   \                     sEnd_of_frame_cb:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
     61          
     62          /*
     63           * Callback for GPIO interruption
     64           */
     65          static void (*sInterrupt_cb)(void * context, int int_num);
     66          
     67          /*
     68           * Context for GPIO interruption callback
     69           */
     70          static void *sContext;
     71          

   \                                 In section .text, align 2, keep-with-next
     72          void gpio_init_pin_out(unsigned pin_num)
     73          {
   \                     gpio_init_pin_out: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     74          	GPIO_InitTypeDef   GPIO_InitStructure;
     75          
     76          	GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_100MHz;
   \   00000004   0x2103             MOVS     R1,#+3
   \   00000006   0xF88D 0x1005      STRB     R1,[SP, #+5]
     77          	GPIO_InitStructure.GPIO_OType 	= GPIO_OType_PP;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF8AD 0x1006      STRH     R1,[SP, #+6]
     78          	GPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_NOPULL;
     79          
     80          	if (pin_num == GPIO_PA9) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD111             BNE.N    ??gpio_init_pin_out_0
     81          		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x4608             MOV      R0,R1
   \   00000018   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
     82          
     83          		/* Init PA.9 as alternate function */
     84          		GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_9;
   \   0000001C   0xF44F 0x7400      MOV      R4,#+512
   \   00000020   0x9400             STR      R4,[SP, #+0]
     85          		GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_OUT;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0004      STRB     R0,[SP, #+4]
     86          		GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable9  ;; 0x40020000
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       GPIO_Init
     87          		/* reset GPIO PA.9 */
     88          		GPIOA->BSRRH = GPIO_Pin_9;
   \   00000034   0x836C             STRH     R4,[R5, #+26]
   \   00000036   0xBD37             POP      {R0-R2,R4,R5,PC}
     89          
     90          	} else if (pin_num == GPIO_PB3) {
   \                     ??gpio_init_pin_out_0: (+1)
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD10F             BNE.N    ??gpio_init_pin_out_1
     91          		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
     92          
     93          		/* Init PB.3 as output */
     94          		GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_3;
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0x9000             STR      R0,[SP, #+0]
     95          		GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_OUT;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF88D 0x0004      STRB     R0,[SP, #+4]
     96          		GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000004E   0x....             LDR.N    R4,??DataTable9_1  ;; 0x40020400
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       GPIO_Init
     97          		/* reset GPIO PB.3 */
     98          		GPIOB->BSRRH = GPIO_Pin_3;
   \   00000058   0x2008             MOVS     R0,#+8
   \   0000005A   0x8360             STRH     R0,[R4, #+26]
     99          	}
    100          }
   \                     ??gpio_init_pin_out_1: (+1)
   \   0000005C   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    101          
    102          

   \                                 In section .text, align 2, keep-with-next
    103          int gpio_get_state(unsigned enable_mask)
    104          {
    105          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D7)) {
   \                     gpio_get_state: (+1)
   \   00000000   0x07C1             LSLS     R1,R0,#+31
   \   00000002   0xD504             BPL.N    ??gpio_get_state_0
    106          		return GPIO_ReadInputDataBit(SENSOR_IRQ_D7_GPIO, SENSOR_IRQ_D7_PIN);
   \   00000004   0xF44F 0x7180      MOV      R1,#+256
   \   00000008   0x....             LDR.N    R0,??DataTable9  ;; 0x40020000
   \   0000000A   0x.... 0x....      B.W      GPIO_ReadInputDataBit
    107          	}
    108          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D6)) {
   \                     ??gpio_get_state_0: (+1)
   \   0000000E   0x0781             LSLS     R1,R0,#+30
   \   00000010   0xD504             BPL.N    ??gpio_get_state_1
    109          		return GPIO_ReadInputDataBit(SENSOR_IRQ_D6_GPIO, SENSOR_IRQ_D6_PIN);
   \   00000012   0xF44F 0x6180      MOV      R1,#+1024
   \   00000016   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40020400
   \   00000018   0x.... 0x....      B.W      GPIO_ReadInputDataBit
    110          	}
    111          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D5)) {
   \                     ??gpio_get_state_1: (+1)
   \   0000001C   0x0741             LSLS     R1,R0,#+29
   \   0000001E   0xD503             BPL.N    ??gpio_get_state_2
    112          		return GPIO_ReadInputDataBit(SENSOR_IRQ_D5_GPIO, SENSOR_IRQ_D5_PIN);
   \   00000020   0x2110             MOVS     R1,#+16
   \   00000022   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40020400
   \   00000024   0x.... 0x....      B.W      GPIO_ReadInputDataBit
    113          	}
    114          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D4)) {
   \                     ??gpio_get_state_2: (+1)
   \   00000028   0x0700             LSLS     R0,R0,#+28
   \   0000002A   0xD503             BPL.N    ??gpio_get_state_3
    115          		return GPIO_ReadInputDataBit(SENSOR_IRQ_D4_GPIO, SENSOR_IRQ_D4_PIN);
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40020400
   \   00000030   0x.... 0x....      B.W      GPIO_ReadInputDataBit
    116          	}
    117          	return -1;
   \                     ??gpio_get_state_3: (+1)
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \   00000038   0x4770             BX       LR               ;; return
    118          }

   \                                 In section .text, align 2, keep-with-next
    119          void gpio_toggle_pin(unsigned pin_num)
    120          {
    121          	/* <pin_num> comes from enum so it needs translation to GPIO address */
    122          	if(pin_num == GPIO_PB3)
   \                     gpio_toggle_pin: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD105             BNE.N    ??gpio_toggle_pin_0
    123          		GPIOB->ODR ^= GPIO_Pin_3;
   \   00000004   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40020414
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF081 0x0108      EOR      R1,R1,#0x8
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x4770             BX       LR
    124          	else if(pin_num == GPIO_PA9)
   \                     ??gpio_toggle_pin_0: (+1)
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD104             BNE.N    ??gpio_toggle_pin_1
    125          		GPIOA->ODR ^= GPIO_Pin_9;
   \   00000014   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40020014
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF481 0x7100      EOR      R1,R1,#0x200
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    126          }
   \                     ??gpio_toggle_pin_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    127          

   \                                 In section .text, align 2, keep-with-next
    128          void gpio_init_ad0_high(void)
    129          {
   \                     gpio_init_ad0_high: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    130          	GPIO_InitTypeDef   GPIO_InitStructure;
    131          
    132          	/* Configure I2C address with PA6 */
    133          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    134          
    135          	GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_100MHz;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    136          	GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0004      STRB     R0,[SP, #+4]
    137          	GPIO_InitStructure.GPIO_OType 	= GPIO_OType_PP;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    138          	GPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_NOPULL;
    139          	GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_6;
   \   0000001C   0x2040             MOVS     R0,#+64
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    140          	GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000020   0x....             LDR.N    R4,??DataTable9  ;; 0x40020000
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       GPIO_Init
    141          	/* PA6 is high to be compatible with InvenSense AKM0991x daughter board */
    142          	GPIO_SetBits(GPIOA, GPIO_Pin_6);
   \   0000002A   0x2140             MOVS     R1,#+64
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       GPIO_SetBits
    143          }
   \   00000032   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    144          

   \                                 In section .text, align 2, keep-with-next
    145          void gpio_init_ncs_high(void)
    146          {
   \                     gpio_init_ncs_high: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    147          	GPIO_InitTypeDef   GPIO_InitStructure;
    148          
    149          	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    150          
    151          	GPIO_InitStructure.GPIO_Speed   = GPIO_Speed_100MHz;
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    152          	GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_OUT;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0004      STRB     R0,[SP, #+4]
    153          	GPIO_InitStructure.GPIO_OType 	= GPIO_OType_PP;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0006      STRB     R0,[SP, #+6]
    154          	GPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_UP;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0007      STRB     R0,[SP, #+7]
    155          	GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_6;
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0x9000             STR      R0,[SP, #+0]
    156          	GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000026   0x....             LDR.N    R4,??DataTable9_1  ;; 0x40020400
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       GPIO_Init
    157          
    158          	GPIO_SetBits(GPIOB, GPIO_Pin_6);
   \   00000030   0x2140             MOVS     R1,#+64
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       GPIO_SetBits
    159          }
   \   00000038   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    160          

   \                                 In section .text, align 2, keep-with-next
    161          void gpio_init_spi_slave_cs_as_int(void (*end_of_frame_cb)(void))
    162          {
   \                     gpio_init_spi_slave_cs_as_int: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4604             MOV      R4,R0
    163          	GPIO_InitTypeDef   GPIO_InitStructure;
    164          	EXTI_InitTypeDef EXTI_InitStructure;
    165          	NVIC_InitTypeDef NVIC_InitStructure;
    166          
    167          	/* Enable SPI GPIO clock */
    168          	RCC_AHB1PeriphClockCmd(SPI_SLAVE_GPIO_CLK, ENABLE);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    169          
    170          	/* Set callback to be called after each end of TX transfer */
    171          	sEnd_of_frame_cb = end_of_frame_cb;
   \   0000000E   0x....             LDR.N    R0,??DataTable9_4
   \   00000010   0x6004             STR      R4,[R0, #+0]
    172          
    173          	/* Configure the CS line as EXTI to detect the end of the frame transferred */
    174          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0010      STRB     R0,[SP, #+16]
    175          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF88D 0x0013      STRB     R0,[SP, #+19]
    176          	GPIO_InitStructure.GPIO_Pin = SPI_SLAVE_CS_PIN;
   \   0000001E   0xF44F 0x5480      MOV      R4,#+4096
   \   00000022   0x9403             STR      R4,[SP, #+12]
    177          	GPIO_Init(SPI_SLAVE_GPIO, &GPIO_InitStructure);
   \   00000024   0xA903             ADD      R1,SP,#+12
   \   00000026   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40020400
   \   00000028   0x.... 0x....      BL       GPIO_Init
    178          
    179          	/* Enable the clock */
    180          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000032   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    181          
    182          	/* Configure EXTI line for CS */
    183          	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, GPIO_PinSource12);
   \   00000036   0x210C             MOVS     R1,#+12
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x.... 0x....      BL       SYSCFG_EXTILineConfig
    184          
    185          	EXTI_InitStructure.EXTI_Line = EXTI_Line12;
   \   0000003E   0x9401             STR      R4,[SP, #+4]
    186          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x000A      STRB     R0,[SP, #+10]
    187          	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0008      STRB     R0,[SP, #+8]
    188          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   \   0000004C   0x2008             MOVS     R0,#+8
   \   0000004E   0xF88D 0x0009      STRB     R0,[SP, #+9]
    189          	EXTI_Init(&EXTI_InitStructure);
   \   00000052   0xA801             ADD      R0,SP,#+4
   \   00000054   0x.... 0x....      BL       EXTI_Init
    190          
    191          	/* Configure NVIC interrupt to EXTI line */
    192          	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   00000058   0x2028             MOVS     R0,#+40
   \   0000005A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    193          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_GPIO_SPI_SLAVE_CS;
   \   0000005E   0x2008             MOVS     R0,#+8
   \   00000060   0xF88D 0x0001      STRB     R0,[SP, #+1]
    194          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF88D 0x0002      STRB     R0,[SP, #+2]
    195          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    196          	NVIC_Init(&NVIC_InitStructure);
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x.... 0x....      BL       NVIC_Init
    197          }
   \   00000076   0xB006             ADD      SP,SP,#+24
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    198          

   \                                 In section .text, align 2, keep-with-next
    199          void gpio_sensor_irq_init(unsigned enable_mask,
    200          		void (*interrupt_cb)(void * context, int int_num), void * context)
    201          {
   \                     gpio_sensor_irq_init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    202          	GPIO_InitTypeDef GPIO_InitStructure;
    203          	EXTI_InitTypeDef EXTI_InitStructure;
    204          	NVIC_InitTypeDef NVIC_InitStructure;
    205          
    206          	sInterrupt_cb = interrupt_cb;
   \   00000006   0x....             LDR.N    R0,??DataTable9_4
   \   00000008   0x6041             STR      R1,[R0, #+4]
    207          	sContext = context;
   \   0000000A   0x6082             STR      R2,[R0, #+8]
    208          
    209          	/* Configure as input */
    210          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0010      STRB     R0,[SP, #+16]
    211          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xF88D 0x0011      STRB     R0,[SP, #+17]
    212          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0012      STRB     R0,[SP, #+18]
    213          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0013      STRB     R0,[SP, #+19]
    214          
    215          	/* Enable the clock */
    216          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   \   00000024   0x4601             MOV      R1,R0
   \   00000026   0xF44F 0x4080      MOV      R0,#+16384
   \   0000002A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    217          
    218          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D7)) {
   \   0000002E   0x07E0             LSLS     R0,R4,#+31
   \   00000030   0xD52A             BPL.N    ??gpio_sensor_irq_init_0
    219          
    220          		RCC_AHB1PeriphClockCmd(SENSOR_IRQ_D7_GPIO_CLK, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x4608             MOV      R0,R1
   \   00000036   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    221          
    222          		/* Configure IRQ_D7 (PA8) */
    223          		GPIO_InitStructure.GPIO_Pin = SENSOR_IRQ_D7_PIN;
   \   0000003A   0xF44F 0x7580      MOV      R5,#+256
   \   0000003E   0x9503             STR      R5,[SP, #+12]
    224          		GPIO_Init(SENSOR_IRQ_D7_GPIO, &GPIO_InitStructure);
   \   00000040   0xA903             ADD      R1,SP,#+12
   \   00000042   0x....             LDR.N    R0,??DataTable9  ;; 0x40020000
   \   00000044   0x.... 0x....      BL       GPIO_Init
    225          
    226          		/* Configure EXTI line for PA8 pin */
    227          		SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource8);
   \   00000048   0x2108             MOVS     R1,#+8
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       SYSCFG_EXTILineConfig
    228          
    229          		EXTI_InitStructure.EXTI_Line = EXTI_Line8;
   \   00000050   0x9501             STR      R5,[SP, #+4]
    230          		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF88D 0x000A      STRB     R0,[SP, #+10]
    231          		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    232          		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   \   0000005E   0x2008             MOVS     R0,#+8
   \   00000060   0xF88D 0x0009      STRB     R0,[SP, #+9]
    233          		EXTI_Init(&EXTI_InitStructure);
   \   00000064   0xA801             ADD      R0,SP,#+4
   \   00000066   0x.... 0x....      BL       EXTI_Init
    234          
    235          		/* Configure NVIC interrupt to EXTI line */
    236          		NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
   \   0000006A   0x2017             MOVS     R0,#+23
   \   0000006C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    237          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_GPIO_IRQ;
   \   00000070   0x2005             MOVS     R0,#+5
   \   00000072   0xF88D 0x0001      STRB     R0,[SP, #+1]
    238          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF88D 0x0002      STRB     R0,[SP, #+2]
    239          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    240          		NVIC_Init(&NVIC_InitStructure);
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x.... 0x....      BL       NVIC_Init
    241          	}
    242          
    243          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D6)) {
   \                     ??gpio_sensor_irq_init_0: (+1)
   \   00000088   0x07A0             LSLS     R0,R4,#+30
   \   0000008A   0xD52A             BPL.N    ??gpio_sensor_irq_init_1
    244          
    245          		RCC_AHB1PeriphClockCmd(SENSOR_IRQ_D6_GPIO_CLK, ENABLE);
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    246          
    247          		/* Configure IRQ_D6 (PB10) */
    248          		GPIO_InitStructure.GPIO_Pin = SENSOR_IRQ_D6_PIN;
   \   00000094   0xF44F 0x6580      MOV      R5,#+1024
   \   00000098   0x9503             STR      R5,[SP, #+12]
    249          		GPIO_Init(SENSOR_IRQ_D6_GPIO, &GPIO_InitStructure);
   \   0000009A   0xA903             ADD      R1,SP,#+12
   \   0000009C   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40020400
   \   0000009E   0x.... 0x....      BL       GPIO_Init
    250          
    251          		/* Configure EXTI line for PB10 pin */
    252          		SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource10);
   \   000000A2   0x210A             MOVS     R1,#+10
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x.... 0x....      BL       SYSCFG_EXTILineConfig
    253          
    254          		EXTI_InitStructure.EXTI_Line = EXTI_Line10;
   \   000000AA   0x9501             STR      R5,[SP, #+4]
    255          		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xF88D 0x000A      STRB     R0,[SP, #+10]
    256          		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF88D 0x0008      STRB     R0,[SP, #+8]
    257          		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   \   000000B8   0x2008             MOVS     R0,#+8
   \   000000BA   0xF88D 0x0009      STRB     R0,[SP, #+9]
    258          		EXTI_Init(&EXTI_InitStructure);
   \   000000BE   0xA801             ADD      R0,SP,#+4
   \   000000C0   0x.... 0x....      BL       EXTI_Init
    259          
    260          		/* Configure NVIC interrupt to EXTI line */
    261          		NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   000000C4   0x2028             MOVS     R0,#+40
   \   000000C6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    262          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_GPIO_IRQ;
   \   000000CA   0x2005             MOVS     R0,#+5
   \   000000CC   0xF88D 0x0001      STRB     R0,[SP, #+1]
    263          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF88D 0x0002      STRB     R0,[SP, #+2]
    264          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xF88D 0x0003      STRB     R0,[SP, #+3]
    265          		NVIC_Init(&NVIC_InitStructure);
   \   000000DC   0x4668             MOV      R0,SP
   \   000000DE   0x.... 0x....      BL       NVIC_Init
    266          	}
    267          
    268          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D5)) {
   \                     ??gpio_sensor_irq_init_1: (+1)
   \   000000E2   0x0760             LSLS     R0,R4,#+29
   \   000000E4   0xD52A             BPL.N    ??gpio_sensor_irq_init_2
    269          
    270          		RCC_AHB1PeriphClockCmd(SENSOR_IRQ_D5_GPIO_CLK, ENABLE);
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0x2002             MOVS     R0,#+2
   \   000000EA   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    271          
    272          		/* Configure IRQ_D5 (PB4) */
    273          		GPIO_InitStructure.GPIO_Pin = SENSOR_IRQ_D5_PIN;
   \   000000EE   0x2010             MOVS     R0,#+16
   \   000000F0   0x9003             STR      R0,[SP, #+12]
    274          		GPIO_Init(SENSOR_IRQ_D5_GPIO, &GPIO_InitStructure);
   \   000000F2   0xA903             ADD      R1,SP,#+12
   \   000000F4   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40020400
   \   000000F6   0x.... 0x....      BL       GPIO_Init
    275          
    276          		/* Configure EXTI line for PB4 pin */
    277          		SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource4);
   \   000000FA   0x2104             MOVS     R1,#+4
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x.... 0x....      BL       SYSCFG_EXTILineConfig
    278          
    279          		EXTI_InitStructure.EXTI_Line = EXTI_Line4;
   \   00000102   0x2010             MOVS     R0,#+16
   \   00000104   0x9001             STR      R0,[SP, #+4]
    280          		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xF88D 0x000A      STRB     R0,[SP, #+10]
    281          		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    282          		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   \   00000112   0x2008             MOVS     R0,#+8
   \   00000114   0xF88D 0x0009      STRB     R0,[SP, #+9]
    283          		EXTI_Init(&EXTI_InitStructure);
   \   00000118   0xA801             ADD      R0,SP,#+4
   \   0000011A   0x.... 0x....      BL       EXTI_Init
    284          
    285          		/* Configure NVIC interrupt to EXTI line */
    286          		NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
   \   0000011E   0x200A             MOVS     R0,#+10
   \   00000120   0xF88D 0x0000      STRB     R0,[SP, #+0]
    287          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_GPIO_IRQ;
   \   00000124   0x2005             MOVS     R0,#+5
   \   00000126   0xF88D 0x0001      STRB     R0,[SP, #+1]
    288          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    289          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0xF88D 0x0003      STRB     R0,[SP, #+3]
    290          		NVIC_Init(&NVIC_InitStructure);
   \   00000136   0x4668             MOV      R0,SP
   \   00000138   0x.... 0x....      BL       NVIC_Init
    291          	}
    292          
    293          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D4)) {
   \                     ??gpio_sensor_irq_init_2: (+1)
   \   0000013C   0x0720             LSLS     R0,R4,#+28
   \   0000013E   0xD52A             BPL.N    ??gpio_sensor_irq_init_3
    294          
    295          		RCC_AHB1PeriphClockCmd(SENSOR_IRQ_D4_GPIO_CLK, ENABLE);
   \   00000140   0x2101             MOVS     R1,#+1
   \   00000142   0x2002             MOVS     R0,#+2
   \   00000144   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
    296          
    297          		/* Configure IRQ_D4 (PB5) */
    298          		GPIO_InitStructure.GPIO_Pin = SENSOR_IRQ_D4_PIN;
   \   00000148   0x2020             MOVS     R0,#+32
   \   0000014A   0x9003             STR      R0,[SP, #+12]
    299          		GPIO_Init(SENSOR_IRQ_D4_GPIO, &GPIO_InitStructure);
   \   0000014C   0xA903             ADD      R1,SP,#+12
   \   0000014E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40020400
   \   00000150   0x.... 0x....      BL       GPIO_Init
    300          
    301          		/* Configure EXTI line for PB5 pin */
    302          		SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource5);
   \   00000154   0x2105             MOVS     R1,#+5
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0x.... 0x....      BL       SYSCFG_EXTILineConfig
    303          
    304          		EXTI_InitStructure.EXTI_Line = EXTI_Line5;
   \   0000015C   0x2020             MOVS     R0,#+32
   \   0000015E   0x9001             STR      R0,[SP, #+4]
    305          		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0xF88D 0x000A      STRB     R0,[SP, #+10]
    306          		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xF88D 0x0008      STRB     R0,[SP, #+8]
    307          		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   \   0000016C   0x2008             MOVS     R0,#+8
   \   0000016E   0xF88D 0x0009      STRB     R0,[SP, #+9]
    308          		EXTI_Init(&EXTI_InitStructure);
   \   00000172   0xA801             ADD      R0,SP,#+4
   \   00000174   0x.... 0x....      BL       EXTI_Init
    309          
    310          		/* Configure NVIC interrupt to EXTI line */
    311          		NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
   \   00000178   0x2017             MOVS     R0,#+23
   \   0000017A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    312          		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_GPIO_IRQ;
   \   0000017E   0x2005             MOVS     R0,#+5
   \   00000180   0xF88D 0x0001      STRB     R0,[SP, #+1]
    313          		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0xF88D 0x0002      STRB     R0,[SP, #+2]
    314          		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    315          		NVIC_Init(&NVIC_InitStructure);
   \   00000190   0x4668             MOV      R0,SP
   \   00000192   0x.... 0x....      BL       NVIC_Init
    316          	}
    317          }
   \                     ??gpio_sensor_irq_init_3: (+1)
   \   00000196   0xB005             ADD      SP,SP,#+20
   \   00000198   0xBD30             POP      {R4,R5,PC}       ;; return
    318          

   \                                 In section .text, align 2, keep-with-next
    319          void EXTI4_IRQHandler(void)
    320          {
   \                     EXTI4_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    321          	if(EXTI_GetITStatus(EXTI_Line4) != RESET) {
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD009             BEQ.N    ??EXTI4_IRQHandler_0
    322          
    323          		sInterrupt_cb(sContext, GPIO_SENSOR_IRQ_D5);
   \   0000000C   0x....             LDR.N    R2,??DataTable9_4
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x6890             LDR      R0,[R2, #+8]
   \   00000012   0x6852             LDR      R2,[R2, #+4]
   \   00000014   0x4790             BLX      R2
    324          		EXTI_ClearITPendingBit(EXTI_Line4);
   \   00000016   0x2010             MOVS     R0,#+16
   \   00000018   0xE8BD 0x4002      POP      {R1,LR}
   \   0000001C   0x.... 0x....      B.W      EXTI_ClearITPendingBit
    325          	}
    326          }
   \                     ??EXTI4_IRQHandler_0: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    327          

   \                                 In section .text, align 2, keep-with-next
    328          void EXTI15_10_IRQHandler(void)
    329          {
   \                     EXTI15_10_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    330          	if(EXTI_GetITStatus(EXTI_Line10) != RESET) {
   \   00000002   0xF44F 0x6080      MOV      R0,#+1024
   \   00000006   0x.... 0x....      BL       EXTI_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD008             BEQ.N    ??EXTI15_10_IRQHandler_0
    331          
    332          		sInterrupt_cb(sContext, GPIO_SENSOR_IRQ_D6);
   \   0000000E   0x....             LDR.N    R2,??DataTable9_4
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x6890             LDR      R0,[R2, #+8]
   \   00000014   0x6852             LDR      R2,[R2, #+4]
   \   00000016   0x4790             BLX      R2
    333          		EXTI_ClearITPendingBit(EXTI_Line10);
   \   00000018   0xF44F 0x6080      MOV      R0,#+1024
   \   0000001C   0x.... 0x....      BL       EXTI_ClearITPendingBit
    334          	}
    335          
    336          	if(EXTI_GetITStatus(EXTI_Line12) != RESET) {
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \   00000020   0xF44F 0x5080      MOV      R0,#+4096
   \   00000024   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD008             BEQ.N    ??EXTI15_10_IRQHandler_1
    337          		sEnd_of_frame_cb();
   \   0000002C   0x....             LDR.N    R0,??DataTable9_4
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x4780             BLX      R0
    338          		EXTI_ClearITPendingBit(EXTI_Line12);
   \   00000032   0xF44F 0x5080      MOV      R0,#+4096
   \   00000036   0xE8BD 0x4002      POP      {R1,LR}
   \   0000003A   0x.... 0x....      B.W      EXTI_ClearITPendingBit
    339          	}
    340          }
   \                     ??EXTI15_10_IRQHandler_1: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    341          

   \                                 In section .text, align 2, keep-with-next
    342          void EXTI9_5_IRQHandler(void)
    343          {
   \                     EXTI9_5_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    344          	if(EXTI_GetITStatus(EXTI_Line8) != RESET) {
   \   00000002   0xF44F 0x7080      MOV      R0,#+256
   \   00000006   0x.... 0x....      BL       EXTI_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD008             BEQ.N    ??EXTI9_5_IRQHandler_0
    345          
    346          		sInterrupt_cb(sContext, GPIO_SENSOR_IRQ_D7);
   \   0000000E   0x....             LDR.N    R2,??DataTable9_4
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6890             LDR      R0,[R2, #+8]
   \   00000014   0x6852             LDR      R2,[R2, #+4]
   \   00000016   0x4790             BLX      R2
    347          		EXTI_ClearITPendingBit(EXTI_Line8);
   \   00000018   0xF44F 0x7080      MOV      R0,#+256
   \   0000001C   0x.... 0x....      BL       EXTI_ClearITPendingBit
    348          	}
    349          
    350          	if(EXTI_GetITStatus(EXTI_Line5) != RESET) {
   \                     ??EXTI9_5_IRQHandler_0: (+1)
   \   00000020   0x2020             MOVS     R0,#+32
   \   00000022   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD009             BEQ.N    ??EXTI9_5_IRQHandler_1
    351          
    352          		sInterrupt_cb(sContext, GPIO_SENSOR_IRQ_D4);
   \   0000002A   0x....             LDR.N    R2,??DataTable9_4
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x6890             LDR      R0,[R2, #+8]
   \   00000030   0x6852             LDR      R2,[R2, #+4]
   \   00000032   0x4790             BLX      R2
    353          		EXTI_ClearITPendingBit(EXTI_Line5);
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0xE8BD 0x4002      POP      {R1,LR}
   \   0000003A   0x.... 0x....      B.W      EXTI_ClearITPendingBit
    354          	}
    355          }
   \                     ??EXTI9_5_IRQHandler_1: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40020414         DC32     0x40020414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     sEnd_of_frame_cb

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   EXTI15_10_IRQHandler
         8   -- Indirect call
         0   -> EXTI_ClearITPendingBit
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
       8   EXTI4_IRQHandler
         8   -- Indirect call
         0   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
       8   EXTI9_5_IRQHandler
         8   -- Indirect call
         0   -> EXTI_ClearITPendingBit
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
       0   gpio_get_state
         0   -> GPIO_ReadInputDataBit
      16   gpio_init_ad0_high
        16   -> GPIO_Init
        16   -> GPIO_SetBits
        16   -> RCC_AHB1PeriphClockCmd
      16   gpio_init_ncs_high
        16   -> GPIO_Init
        16   -> GPIO_SetBits
        16   -> RCC_AHB1PeriphClockCmd
      24   gpio_init_pin_out
        24   -> GPIO_Init
        24   -> RCC_AHB1PeriphClockCmd
      32   gpio_init_spi_slave_cs_as_int
        32   -> EXTI_Init
        32   -> GPIO_Init
        32   -> NVIC_Init
        32   -> RCC_AHB1PeriphClockCmd
        32   -> RCC_APB2PeriphClockCmd
        32   -> SYSCFG_EXTILineConfig
      32   gpio_sensor_irq_init
        32   -> EXTI_Init
        32   -> GPIO_Init
        32   -> NVIC_Init
        32   -> RCC_AHB1PeriphClockCmd
        32   -> RCC_APB2PeriphClockCmd
        32   -> SYSCFG_EXTILineConfig
       0   gpio_toggle_pin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      64  EXTI15_10_IRQHandler
      34  EXTI4_IRQHandler
      64  EXTI9_5_IRQHandler
      58  gpio_get_state
      52  gpio_init_ad0_high
      58  gpio_init_ncs_high
      94  gpio_init_pin_out
     122  gpio_init_spi_slave_cs_as_int
     410  gpio_sensor_irq_init
      32  gpio_toggle_pin
      12  sEnd_of_frame_cb
          sInterrupt_cb
          sContext

 
    12 bytes in section .bss
 1 008 bytes in section .text
 
 1 008 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
