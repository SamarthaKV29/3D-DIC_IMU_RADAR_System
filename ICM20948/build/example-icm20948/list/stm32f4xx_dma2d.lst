###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:35
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma2d.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma2d.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\stm32f4xx_dma2d.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\stm32f4xx_dma2d.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma2d.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dma2d.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    21-October-2015
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the DMA2D controller (DMA2D) peripheral:
      9            *           + Initialization and configuration
     10            *           + Interrupts and flags management
     11            *           
     12            @verbatim  
     13           ===============================================================================
     14                                ##### How to use this driver #####
     15           ===============================================================================
     16              [..]
     17                  (#) Enable DMA2D clock using 
     18                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_DMA2D, ENABLE) function.
     19                      
     20                  (#) Configures DMA2D
     21                    (++) transfer mode 
     22                    (++) pixel format, line_number, pixel_per_line
     23                    (++) output memory address
     24                    (++) alpha value
     25                    (++) output offset
     26                    (++) Default color (RGB)
     27                     
     28                  (#) Configures Foreground or/and background
     29                    (++) memory address
     30                    (++) alpha value
     31                    (++) offset and default color
     32            
     33                  (#) Call the DMA2D_Start() to enable the DMA2D controller.
     34                  
     35              @endverbatim
     36            
     37            ******************************************************************************
     38            * @attention
     39            *
     40            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     41            *
     42            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     43            * You may not use this file except in compliance with the License.
     44            * You may obtain a copy of the License at:
     45            *
     46            *        http://www.st.com/software_license_agreement_liberty_v2
     47            *
     48            * Unless required by applicable law or agreed to in writing, software 
     49            * distributed under the License is distributed on an "AS IS" BASIS, 
     50            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     51            * See the License for the specific language governing permissions and
     52            * limitations under the License.
     53            *
     54            ******************************************************************************
     55            */ 
     56          
     57          /* Includes ------------------------------------------------------------------*/
     58          #include "stm32f4xx_dma2d.h"
     59          #include "stm32f4xx_rcc.h"
     60          
     61          /** @addtogroup STM32F4xx_StdPeriph_Driver
     62            * @{
     63            */
     64          
     65          /** @defgroup DMA2D 
     66            * @brief DMA2D driver modules
     67            * @{
     68            */
     69          
     70          /* Private typedef -----------------------------------------------------------*/
     71          /* Private define ------------------------------------------------------------*/
     72          /* Private macro -------------------------------------------------------------*/
     73          /* Private variables ---------------------------------------------------------*/
     74          /* Private function prototypes -----------------------------------------------*/
     75          /* Private functions ---------------------------------------------------------*/
     76          
     77          #define CR_MASK                     ((uint32_t)0xFFFCE0FC)  /* DMA2D CR Mask */
     78          #define PFCCR_MASK                  ((uint32_t)0x00FC00C0)  /* DMA2D FGPFCCR Mask */
     79          #define DEAD_MASK                   ((uint32_t)0xFFFF00FE)  /* DMA2D DEAD Mask */
     80          
     81          /** @defgroup DMA2D_Private_Functions
     82            * @{
     83            */
     84          
     85          /** @defgroup DMA2D_Group1 Initialization and Configuration functions
     86           *  @brief   Initialization and Configuration functions 
     87           *
     88          @verbatim
     89           ===============================================================================
     90                      ##### Initialization and Configuration functions #####
     91           ===============================================================================
     92              [..]  This section provides functions allowing to:
     93                (+) Initialize and configure the DMA2D
     94                (+) Start/Abort/Suspend Transfer
     95                (+) Initialize, configure and set Foreground and background
     96                (+) configure and enable DeadTime
     97                (+) configure lineWatermark
     98              
     99              
    100          @endverbatim
    101            * @{
    102            */
    103          
    104          /**
    105            * @brief  Deinitializes the DMA2D peripheral registers to their default reset
    106            *         values.
    107            * @param  None
    108            * @retval None
    109            */
    110          

   \                                 In section .text, align 2, keep-with-next
    111          void DMA2D_DeInit(void)
    112          {
   \                     DMA2D_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    113            /* Enable DMA2D reset state */
    114            RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2D, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x0000      MOV      R0,#+8388608
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    115            /* Release DMA2D from reset state */
    116            RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2D, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF44F 0x0000      MOV      R0,#+8388608
   \   00000012   0xE8BD 0x4004      POP      {R2,LR}
   \   00000016   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    117          }
    118          
    119          
    120          /**
    121            * @brief  Initializes the DMA2D peripheral according to the specified parameters
    122            *         in the DMA2D_InitStruct.
    123            * @note   This function can be used only when the DMA2D is disabled.
    124            * @param  DMA2D_InitStruct: pointer to a DMA2D_InitTypeDef structure that contains
    125            *         the configuration information for the specified DMA2D peripheral.
    126            * @retval None
    127            */

   \                                 In section .text, align 2, keep-with-next
    128          void DMA2D_Init(DMA2D_InitTypeDef* DMA2D_InitStruct)
    129          {
   \                     DMA2D_Init: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    130          
    131            uint32_t outgreen = 0;
    132            uint32_t outred   = 0;
    133            uint32_t outalpha = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    134            uint32_t pixline  = 0;
    135          
    136            /* Check the parameters */
    137            assert_param(IS_DMA2D_MODE(DMA2D_InitStruct->DMA2D_Mode));
    138            assert_param(IS_DMA2D_CMODE(DMA2D_InitStruct->DMA2D_CMode));
    139            assert_param(IS_DMA2D_OGREEN(DMA2D_InitStruct->DMA2D_OutputGreen));
    140            assert_param(IS_DMA2D_ORED(DMA2D_InitStruct->DMA2D_OutputRed));
    141            assert_param(IS_DMA2D_OBLUE(DMA2D_InitStruct->DMA2D_OutputBlue));
    142            assert_param(IS_DMA2D_OALPHA(DMA2D_InitStruct->DMA2D_OutputAlpha));
    143            assert_param(IS_DMA2D_OUTPUT_OFFSET(DMA2D_InitStruct->DMA2D_OutputOffset));
    144            assert_param(IS_DMA2D_LINE(DMA2D_InitStruct->DMA2D_NumberOfLine));
    145            assert_param(IS_DMA2D_PIXEL(DMA2D_InitStruct->DMA2D_PixelPerLine));
    146          
    147            /* Configures the DMA2D operation mode */
    148            DMA2D->CR &= (uint32_t)CR_MASK;
   \   00000004   0x....             LDR.N    R1,??DataTable14  ;; 0x4002b000
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x....             LDR.N    R4,??DataTable14_1  ;; 0xfffce0fc
   \   0000000A   0x4023             ANDS     R3,R4,R3
   \   0000000C   0x600B             STR      R3,[R1, #+0]
    149            DMA2D->CR |= (DMA2D_InitStruct->DMA2D_Mode);
   \   0000000E   0x680B             LDR      R3,[R1, #+0]
   \   00000010   0x6804             LDR      R4,[R0, #+0]
   \   00000012   0x4323             ORRS     R3,R4,R3
   \   00000014   0x600B             STR      R3,[R1, #+0]
    150          
    151            /* Configures the color mode of the output image */
    152            DMA2D->OPFCCR &= ~(uint32_t)DMA2D_OPFCCR_CM;
   \   00000016   0x6B4B             LDR      R3,[R1, #+52]
   \   00000018   0x08DB             LSRS     R3,R3,#+3
   \   0000001A   0x00DB             LSLS     R3,R3,#+3
   \   0000001C   0x634B             STR      R3,[R1, #+52]
    153            DMA2D->OPFCCR |= (DMA2D_InitStruct->DMA2D_CMode);
   \   0000001E   0x6B4B             LDR      R3,[R1, #+52]
   \   00000020   0x6844             LDR      R4,[R0, #+4]
   \   00000022   0x4323             ORRS     R3,R4,R3
   \   00000024   0x634B             STR      R3,[R1, #+52]
    154          
    155            /* Configures the output color */
    156          
    157            if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_ARGB8888)
   \   00000026   0x6903             LDR      R3,[R0, #+16]
   \   00000028   0x68C4             LDR      R4,[R0, #+12]
   \   0000002A   0x6845             LDR      R5,[R0, #+4]
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD104             BNE.N    ??DMA2D_Init_0
    158            {
    159              outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 8;
   \   00000030   0x0224             LSLS     R4,R4,#+8
    160              outred = DMA2D_InitStruct->DMA2D_OutputRed << 16;
   \   00000032   0x041B             LSLS     R3,R3,#+16
    161              outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 24;
   \   00000034   0x6942             LDR      R2,[R0, #+20]
   \   00000036   0x0612             LSLS     R2,R2,#+24
   \   00000038   0xE013             B.N      ??DMA2D_Init_1
    162            }
    163            else
    164            
    165              if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_RGB888)
   \                     ??DMA2D_Init_0: (+1)
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD102             BNE.N    ??DMA2D_Init_2
    166              {
    167                outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 8;
   \   0000003E   0x0224             LSLS     R4,R4,#+8
    168                outred = DMA2D_InitStruct->DMA2D_OutputRed << 16;
   \   00000040   0x041B             LSLS     R3,R3,#+16
    169                outalpha = (uint32_t)0x00000000;
   \   00000042   0xE00E             B.N      ??DMA2D_Init_1
    170              }
    171               
    172            else
    173          
    174              if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_RGB565)
   \                     ??DMA2D_Init_2: (+1)
   \   00000044   0x2D02             CMP      R5,#+2
   \   00000046   0xD102             BNE.N    ??DMA2D_Init_3
    175              {
    176                outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 5;
   \   00000048   0x0164             LSLS     R4,R4,#+5
    177                outred = DMA2D_InitStruct->DMA2D_OutputRed << 11;
   \   0000004A   0x02DB             LSLS     R3,R3,#+11
    178                outalpha = (uint32_t)0x00000000;
   \   0000004C   0xE009             B.N      ??DMA2D_Init_1
    179              }
    180          
    181            else
    182          
    183              if (DMA2D_InitStruct->DMA2D_CMode == DMA2D_ARGB1555)
   \                     ??DMA2D_Init_3: (+1)
   \   0000004E   0x6942             LDR      R2,[R0, #+20]
   \   00000050   0x2D03             CMP      R5,#+3
   \   00000052   0xD103             BNE.N    ??DMA2D_Init_4
    184              {  
    185                outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 5;
   \   00000054   0x0164             LSLS     R4,R4,#+5
    186                outred = DMA2D_InitStruct->DMA2D_OutputRed << 10;
   \   00000056   0x029B             LSLS     R3,R3,#+10
    187                outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 15;
   \   00000058   0x03D2             LSLS     R2,R2,#+15
   \   0000005A   0xE002             B.N      ??DMA2D_Init_1
    188              }
    189          
    190            else /* DMA2D_CMode = DMA2D_ARGB4444 */
    191            {
    192              outgreen = DMA2D_InitStruct->DMA2D_OutputGreen << 4;
   \                     ??DMA2D_Init_4: (+1)
   \   0000005C   0x0124             LSLS     R4,R4,#+4
    193              outred = DMA2D_InitStruct->DMA2D_OutputRed << 8;
   \   0000005E   0x021B             LSLS     R3,R3,#+8
    194              outalpha = DMA2D_InitStruct->DMA2D_OutputAlpha << 12;
   \   00000060   0x0312             LSLS     R2,R2,#+12
    195            }  
    196            DMA2D->OCOLR |= ((outgreen) | (outred) | (DMA2D_InitStruct->DMA2D_OutputBlue) | (outalpha));
   \                     ??DMA2D_Init_1: (+1)
   \   00000062   0x6B8D             LDR      R5,[R1, #+56]
   \   00000064   0x4323             ORRS     R3,R3,R4
   \   00000066   0x6884             LDR      R4,[R0, #+8]
   \   00000068   0x4323             ORRS     R3,R4,R3
   \   0000006A   0x431A             ORRS     R2,R2,R3
   \   0000006C   0x432A             ORRS     R2,R2,R5
   \   0000006E   0x638A             STR      R2,[R1, #+56]
    197          
    198            /* Configures the output memory address */
    199            DMA2D->OMAR = (DMA2D_InitStruct->DMA2D_OutputMemoryAdd);
   \   00000070   0x6982             LDR      R2,[R0, #+24]
   \   00000072   0x63CA             STR      R2,[R1, #+60]
    200          
    201            /* Configure  the line Offset */
    202            DMA2D->OOR &= ~(uint32_t)DMA2D_OOR_LO;
   \   00000074   0x6C0A             LDR      R2,[R1, #+64]
   \   00000076   0x0B92             LSRS     R2,R2,#+14
   \   00000078   0x0392             LSLS     R2,R2,#+14
   \   0000007A   0x640A             STR      R2,[R1, #+64]
    203            DMA2D->OOR |= (DMA2D_InitStruct->DMA2D_OutputOffset);
   \   0000007C   0x6C0A             LDR      R2,[R1, #+64]
   \   0000007E   0x69C3             LDR      R3,[R0, #+28]
   \   00000080   0x431A             ORRS     R2,R3,R2
   \   00000082   0x640A             STR      R2,[R1, #+64]
    204          
    205            /* Configure the number of line and pixel per line */
    206            pixline = DMA2D_InitStruct->DMA2D_PixelPerLine << 16; 
   \   00000084   0x6A42             LDR      R2,[R0, #+36]
    207            DMA2D->NLR &= ~(DMA2D_NLR_NL | DMA2D_NLR_PL);
   \   00000086   0x6C4B             LDR      R3,[R1, #+68]
   \   00000088   0xF003 0x4340      AND      R3,R3,#0xC0000000
   \   0000008C   0x644B             STR      R3,[R1, #+68]
    208            DMA2D->NLR |= ((DMA2D_InitStruct->DMA2D_NumberOfLine) | (pixline));
   \   0000008E   0x6C4B             LDR      R3,[R1, #+68]
   \   00000090   0x6A00             LDR      R0,[R0, #+32]
   \   00000092   0xEA50 0x4002      ORRS     R0,R0,R2, LSL #+16
   \   00000096   0x4318             ORRS     R0,R0,R3
   \   00000098   0x6448             STR      R0,[R1, #+68]
    209          
    210          /**
    211            * @brief  Fills each DMA2D_InitStruct member with its default value.
    212            * @param  DMA2D_InitStruct: pointer to a DMA2D_InitTypeDef structure which will
    213            *         be initialized.
    214            * @retval None
    215            */
    216          }
   \   0000009A   0xBC30             POP      {R4,R5}
   \   0000009C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    217          void DMA2D_StructInit(DMA2D_InitTypeDef* DMA2D_InitStruct)
    218          {
    219            /* Initialize the transfer mode member */
    220            DMA2D_InitStruct->DMA2D_Mode = DMA2D_M2M;
   \                     DMA2D_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    221          
    222            /* Initialize the output color mode members */
    223            DMA2D_InitStruct->DMA2D_CMode = DMA2D_ARGB8888;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    224          
    225            /* Initialize the alpha and RGB values */
    226            DMA2D_InitStruct->DMA2D_OutputGreen = 0x00;
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    227            DMA2D_InitStruct->DMA2D_OutputBlue = 0x00;
   \   00000008   0x6081             STR      R1,[R0, #+8]
    228            DMA2D_InitStruct->DMA2D_OutputRed = 0x00;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    229            DMA2D_InitStruct->DMA2D_OutputAlpha = 0x00;
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    230          
    231            /* Initialize the output memory address */
    232            DMA2D_InitStruct->DMA2D_OutputMemoryAdd = 0x00;
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    233          
    234            /* Initialize the output offset */
    235            DMA2D_InitStruct->DMA2D_OutputOffset = 0x00;
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    236          
    237            /* Initialize the number of line and the number of pixel per line */
    238            DMA2D_InitStruct->DMA2D_NumberOfLine = 0x00;
   \   00000012   0x6201             STR      R1,[R0, #+32]
    239            DMA2D_InitStruct->DMA2D_PixelPerLine = 0x00;
   \   00000014   0x6241             STR      R1,[R0, #+36]
    240          }
   \   00000016   0x4770             BX       LR               ;; return
    241          
    242          /**
    243            * @brief  Start the DMA2D transfer.
    244            * @param 
    245            * @retval None
    246            */
    247          

   \                                 In section .text, align 2, keep-with-next
    248          void DMA2D_StartTransfer(void)
    249          {
    250              /* Start DMA2D transfer by setting START bit */
    251              DMA2D->CR |= (uint32_t)DMA2D_CR_START;
   \                     DMA2D_StartTransfer: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14  ;; 0x4002b000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x6001             STR      R1,[R0, #+0]
    252          }
   \   0000000A   0x4770             BX       LR               ;; return
    253          
    254          /**
    255            * @brief  Abort the DMA2D transfer.
    256            * @param
    257            * @retval None
    258            */
    259          

   \                                 In section .text, align 2, keep-with-next
    260          void DMA2D_AbortTransfer(void)
    261          {
    262              /* Start DMA2D transfer by setting START bit */
    263              DMA2D->CR |= (uint32_t)DMA2D_CR_ABORT;
   \                     DMA2D_AbortTransfer: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable14  ;; 0x4002b000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000008   0x6001             STR      R1,[R0, #+0]
    264          
    265          }
   \   0000000A   0x4770             BX       LR               ;; return
    266          
    267          /**
    268            * @brief  Stop or continue the DMA2D transfer.
    269            * @param  NewState: new state of the DMA2D peripheral.
    270            *   This parameter can be: ENABLE or DISABLE.
    271            * @retval None
    272            */

   \                                 In section .text, align 2, keep-with-next
    273          void DMA2D_Suspend(FunctionalState NewState)
    274          {
    275            /* Check the parameters */
    276            assert_param(IS_FUNCTIONAL_STATE(NewState));
    277          
    278            if (NewState != DISABLE)
   \                     DMA2D_Suspend: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14  ;; 0x4002b000
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DMA2D_Suspend_0
    279            {
    280              /* Suspend DMA2D transfer by setting STOP bit */
    281              DMA2D->CR |= (uint32_t)DMA2D_CR_SUSP;
   \   00000008   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    282            }
    283            else
    284            {
    285              /* Continue DMA2D transfer by clearing STOP bit */
    286              DMA2D->CR &= ~(uint32_t)DMA2D_CR_SUSP;
   \                     ??DMA2D_Suspend_0: (+1)
   \   00000010   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000014   0x6008             STR      R0,[R1, #+0]
    287            }
    288          }
   \   00000016   0x4770             BX       LR               ;; return
    289          
    290          /**
    291            * @brief  Configures the Foreground according to the specified parameters
    292            *         in the DMA2D_FGStruct.
    293            * @note   This function can be used only when the transfer is disabled.
    294            * @param  DMA2D_FGStruct: pointer to a DMA2D_FGTypeDef structure that contains
    295            *         the configuration information for the specified Background.
    296            * @retval None
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          void DMA2D_FGConfig(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct)
    299          {
   \                     DMA2D_FGConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
    300          
    301            uint32_t fg_clutcolormode = 0;
    302            uint32_t fg_clutsize = 0;
    303            uint32_t fg_alpha_mode = 0;
    304            uint32_t fg_alphavalue = 0;
    305            uint32_t fg_colorgreen = 0;
    306            uint32_t fg_colorred = 0;
    307          
    308            assert_param(IS_DMA2D_FGO(DMA2D_FG_InitStruct->DMA2D_FGO));
    309            assert_param(IS_DMA2D_FGCM(DMA2D_FG_InitStruct->DMA2D_FGCM));
    310            assert_param(IS_DMA2D_FG_CLUT_CM(DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM));
    311            assert_param(IS_DMA2D_FG_CLUT_SIZE(DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE));
    312            assert_param(IS_DMA2D_FG_ALPHA_MODE(DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE));
    313            assert_param(IS_DMA2D_FG_ALPHA_VALUE(DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE));
    314            assert_param(IS_DMA2D_FGC_BLUE(DMA2D_FG_InitStruct->DMA2D_FGC_BLUE));
    315            assert_param(IS_DMA2D_FGC_GREEN(DMA2D_FG_InitStruct->DMA2D_FGC_GREEN));
    316            assert_param(IS_DMA2D_FGC_RED(DMA2D_FG_InitStruct->DMA2D_FGC_RED));
    317          
    318            /* Configures the FG memory address */
    319            DMA2D->FGMAR = (DMA2D_FG_InitStruct->DMA2D_FGMA);
   \   00000002   0x....             LDR.N    R1,??DataTable14_2  ;; 0x4002b00c
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x600A             STR      R2,[R1, #+0]
    320          
    321            /* Configures the FG offset */
    322            DMA2D->FGOR &= ~(uint32_t)DMA2D_FGOR_LO;
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x0B92             LSRS     R2,R2,#+14
   \   0000000C   0x0392             LSLS     R2,R2,#+14
   \   0000000E   0x604A             STR      R2,[R1, #+4]
    323            DMA2D->FGOR |= (DMA2D_FG_InitStruct->DMA2D_FGO);
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x604A             STR      R2,[R1, #+4]
    324          
    325            /* Configures foreground Pixel Format Convertor */
    326            DMA2D->FGPFCCR &= (uint32_t)PFCCR_MASK;
   \   00000018   0x690A             LDR      R2,[R1, #+16]
   \   0000001A   0x....             LDR.N    R3,??DataTable14_3  ;; 0xfc00c0
   \   0000001C   0x401A             ANDS     R2,R3,R2
   \   0000001E   0x610A             STR      R2,[R1, #+16]
    327            fg_clutcolormode = DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM << 4;
    328            fg_clutsize = DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE << 8;
    329            fg_alpha_mode = DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE << 16;
    330            fg_alphavalue = DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE << 24;
    331            DMA2D->FGPFCCR |= (DMA2D_FG_InitStruct->DMA2D_FGCM | fg_clutcolormode | fg_clutsize | \
    332                              fg_alpha_mode | fg_alphavalue);
   \   00000020   0x690A             LDR      R2,[R1, #+16]
   \   00000022   0x6883             LDR      R3,[R0, #+8]
   \   00000024   0x68C4             LDR      R4,[R0, #+12]
   \   00000026   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   0000002A   0x6904             LDR      R4,[R0, #+16]
   \   0000002C   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000030   0x6944             LDR      R4,[R0, #+20]
   \   00000032   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000036   0x6984             LDR      R4,[R0, #+24]
   \   00000038   0xEA43 0x6304      ORR      R3,R3,R4, LSL #+24
   \   0000003C   0x431A             ORRS     R2,R3,R2
   \   0000003E   0x610A             STR      R2,[R1, #+16]
    333          
    334            /* Configures foreground color */
    335            DMA2D->FGCOLR &= ~(DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | DMA2D_FGCOLR_RED);
   \   00000040   0x694A             LDR      R2,[R1, #+20]
   \   00000042   0xF002 0x427F      AND      R2,R2,#0xFF000000
   \   00000046   0x614A             STR      R2,[R1, #+20]
    336            fg_colorgreen = DMA2D_FG_InitStruct->DMA2D_FGC_GREEN << 8;
    337            fg_colorred = DMA2D_FG_InitStruct->DMA2D_FGC_RED << 16;
    338            DMA2D->FGCOLR |= (DMA2D_FG_InitStruct->DMA2D_FGC_BLUE | fg_colorgreen | fg_colorred);
   \   00000048   0x694A             LDR      R2,[R1, #+20]
   \   0000004A   0x69C3             LDR      R3,[R0, #+28]
   \   0000004C   0x6A04             LDR      R4,[R0, #+32]
   \   0000004E   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000052   0x6A44             LDR      R4,[R0, #+36]
   \   00000054   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000058   0x431A             ORRS     R2,R3,R2
   \   0000005A   0x614A             STR      R2,[R1, #+20]
    339          
    340            /* Configures foreground CLUT memory address */
    341            DMA2D->FGCMAR = DMA2D_FG_InitStruct->DMA2D_FGCMAR;
   \   0000005C   0x6A80             LDR      R0,[R0, #+40]
   \   0000005E   0x6208             STR      R0,[R1, #+32]
    342          }
   \   00000060   0xBC10             POP      {R4}
   \   00000062   0x4770             BX       LR               ;; return
    343          
    344          /**
    345            * @brief  Fills each DMA2D_FGStruct member with its default value.
    346            * @param  DMA2D_FGStruct: pointer to a DMA2D_FGTypeDef structure which will
    347            *         be initialized.
    348            * @retval None
    349            */

   \                                 In section .text, align 2, keep-with-next
    350          void DMA2D_FG_StructInit(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct)
    351          {
    352            /*!< Initialize the DMA2D foreground memory address */
    353            DMA2D_FG_InitStruct->DMA2D_FGMA = 0x00;
   \                     DMA2D_FG_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    354          
    355            /*!< Initialize the DMA2D foreground offset */
    356            DMA2D_FG_InitStruct->DMA2D_FGO = 0x00;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    357          
    358            /*!< Initialize the DMA2D foreground color mode */
    359            DMA2D_FG_InitStruct->DMA2D_FGCM = CM_ARGB8888;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    360          
    361            /*!< Initialize the DMA2D foreground CLUT color mode */
    362            DMA2D_FG_InitStruct->DMA2D_FG_CLUT_CM = CLUT_CM_ARGB8888;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    363          
    364            /*!< Initialize the DMA2D foreground CLUT size */
    365            DMA2D_FG_InitStruct->DMA2D_FG_CLUT_SIZE = 0x00;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    366          
    367            /*!< Initialize the DMA2D foreground alpha mode */
    368            DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_MODE = NO_MODIF_ALPHA_VALUE;
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    369          
    370            /*!< Initialize the DMA2D foreground alpha value */
    371            DMA2D_FG_InitStruct->DMA2D_FGPFC_ALPHA_VALUE = 0x00;
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    372          
    373            /*!< Initialize the DMA2D foreground blue value */
    374            DMA2D_FG_InitStruct->DMA2D_FGC_BLUE = 0x00;
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    375          
    376            /*!< Initialize the DMA2D foreground green value */
    377            DMA2D_FG_InitStruct->DMA2D_FGC_GREEN = 0x00;
   \   00000012   0x6201             STR      R1,[R0, #+32]
    378          
    379            /*!< Initialize the DMA2D foreground red value */
    380            DMA2D_FG_InitStruct->DMA2D_FGC_RED = 0x00;
   \   00000014   0x6241             STR      R1,[R0, #+36]
    381          
    382            /*!< Initialize the DMA2D foreground CLUT memory address */
    383            DMA2D_FG_InitStruct->DMA2D_FGCMAR = 0x00;
   \   00000016   0x6281             STR      R1,[R0, #+40]
    384          }
   \   00000018   0x4770             BX       LR               ;; return
    385          
    386          
    387          /**
    388            * @brief  Configures the Background according to the specified parameters
    389            *         in the DMA2D_BGStruct.
    390            * @note   This function can be used only when the transfer is disabled.
    391            * @param  DMA2D_BGStruct: pointer to a DMA2D_BGTypeDef structure that contains
    392            *         the configuration information for the specified Background.
    393            * @retval None
    394            */

   \                                 In section .text, align 2, keep-with-next
    395          void DMA2D_BGConfig(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct)
    396          {
   \                     DMA2D_BGConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
    397          
    398            uint32_t bg_clutcolormode = 0;
    399            uint32_t bg_clutsize = 0;
    400            uint32_t bg_alpha_mode = 0;
    401            uint32_t bg_alphavalue = 0;
    402            uint32_t bg_colorgreen = 0;
    403            uint32_t bg_colorred = 0;
    404          
    405            assert_param(IS_DMA2D_BGO(DMA2D_BG_InitStruct->DMA2D_BGO));
    406            assert_param(IS_DMA2D_BGCM(DMA2D_BG_InitStruct->DMA2D_BGCM));
    407            assert_param(IS_DMA2D_BG_CLUT_CM(DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM));
    408            assert_param(IS_DMA2D_BG_CLUT_SIZE(DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE));
    409            assert_param(IS_DMA2D_BG_ALPHA_MODE(DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE));
    410            assert_param(IS_DMA2D_BG_ALPHA_VALUE(DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE));
    411            assert_param(IS_DMA2D_BGC_BLUE(DMA2D_BG_InitStruct->DMA2D_BGC_BLUE));
    412            assert_param(IS_DMA2D_BGC_GREEN(DMA2D_BG_InitStruct->DMA2D_BGC_GREEN));
    413            assert_param(IS_DMA2D_BGC_RED(DMA2D_BG_InitStruct->DMA2D_BGC_RED));
    414          
    415            /* Configures the BG memory address */
    416            DMA2D->BGMAR = (DMA2D_BG_InitStruct->DMA2D_BGMA);
   \   00000002   0x....             LDR.N    R1,??DataTable14_4  ;; 0x4002b014
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x600A             STR      R2,[R1, #+0]
    417          
    418            /* Configures the BG offset */
    419            DMA2D->BGOR &= ~(uint32_t)DMA2D_BGOR_LO;
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x0B92             LSRS     R2,R2,#+14
   \   0000000C   0x0392             LSLS     R2,R2,#+14
   \   0000000E   0x604A             STR      R2,[R1, #+4]
    420            DMA2D->BGOR |= (DMA2D_BG_InitStruct->DMA2D_BGO);
   \   00000010   0x684A             LDR      R2,[R1, #+4]
   \   00000012   0x6843             LDR      R3,[R0, #+4]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x604A             STR      R2,[R1, #+4]
    421          
    422            /* Configures background Pixel Format Convertor */
    423            DMA2D->BGPFCCR &= (uint32_t)PFCCR_MASK;
   \   00000018   0x690A             LDR      R2,[R1, #+16]
   \   0000001A   0x....             LDR.N    R3,??DataTable14_3  ;; 0xfc00c0
   \   0000001C   0x401A             ANDS     R2,R3,R2
   \   0000001E   0x610A             STR      R2,[R1, #+16]
    424            bg_clutcolormode = DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM << 4;
    425            bg_clutsize = DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE << 8;
    426            bg_alpha_mode = DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE << 16;
    427            bg_alphavalue = DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE << 24;
    428            DMA2D->BGPFCCR |= (DMA2D_BG_InitStruct->DMA2D_BGCM | bg_clutcolormode | bg_clutsize | \
    429                              bg_alpha_mode | bg_alphavalue);
   \   00000020   0x690A             LDR      R2,[R1, #+16]
   \   00000022   0x6883             LDR      R3,[R0, #+8]
   \   00000024   0x68C4             LDR      R4,[R0, #+12]
   \   00000026   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   0000002A   0x6904             LDR      R4,[R0, #+16]
   \   0000002C   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000030   0x6944             LDR      R4,[R0, #+20]
   \   00000032   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000036   0x6984             LDR      R4,[R0, #+24]
   \   00000038   0xEA43 0x6304      ORR      R3,R3,R4, LSL #+24
   \   0000003C   0x431A             ORRS     R2,R3,R2
   \   0000003E   0x610A             STR      R2,[R1, #+16]
    430          
    431            /* Configures background color */
    432            DMA2D->BGCOLR &= ~(DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | DMA2D_BGCOLR_RED);
   \   00000040   0x694A             LDR      R2,[R1, #+20]
   \   00000042   0xF002 0x427F      AND      R2,R2,#0xFF000000
   \   00000046   0x614A             STR      R2,[R1, #+20]
    433            bg_colorgreen = DMA2D_BG_InitStruct->DMA2D_BGC_GREEN << 8;
    434            bg_colorred = DMA2D_BG_InitStruct->DMA2D_BGC_RED << 16;
    435            DMA2D->BGCOLR |= (DMA2D_BG_InitStruct->DMA2D_BGC_BLUE | bg_colorgreen | bg_colorred);
   \   00000048   0x694A             LDR      R2,[R1, #+20]
   \   0000004A   0x69C3             LDR      R3,[R0, #+28]
   \   0000004C   0x6A04             LDR      R4,[R0, #+32]
   \   0000004E   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000052   0x6A44             LDR      R4,[R0, #+36]
   \   00000054   0xEA43 0x4304      ORR      R3,R3,R4, LSL #+16
   \   00000058   0x431A             ORRS     R2,R3,R2
   \   0000005A   0x614A             STR      R2,[R1, #+20]
    436            
    437            /* Configures background CLUT memory address */
    438            DMA2D->BGCMAR = DMA2D_BG_InitStruct->DMA2D_BGCMAR;
   \   0000005C   0x6A80             LDR      R0,[R0, #+40]
   \   0000005E   0x61C8             STR      R0,[R1, #+28]
    439          
    440          }
   \   00000060   0xBC10             POP      {R4}
   \   00000062   0x4770             BX       LR               ;; return
    441          
    442          /**
    443            * @brief  Fills each DMA2D_BGStruct member with its default value.
    444            * @param  DMA2D_BGStruct: pointer to a DMA2D_BGTypeDef structure which will
    445            *         be initialized.
    446            * @retval None
    447            */

   \                                 In section .text, align 2, keep-with-next
    448          void DMA2D_BG_StructInit(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct)
    449          {
    450            /*!< Initialize the DMA2D background memory address */
    451            DMA2D_BG_InitStruct->DMA2D_BGMA = 0x00;
   \                     DMA2D_BG_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    452          
    453            /*!< Initialize the DMA2D background offset */
    454            DMA2D_BG_InitStruct->DMA2D_BGO = 0x00;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    455          
    456            /*!< Initialize the DMA2D background color mode */
    457            DMA2D_BG_InitStruct->DMA2D_BGCM = CM_ARGB8888;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    458          
    459            /*!< Initialize the DMA2D background CLUT color mode */
    460            DMA2D_BG_InitStruct->DMA2D_BG_CLUT_CM = CLUT_CM_ARGB8888;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    461          
    462            /*!< Initialize the DMA2D background CLUT size */
    463            DMA2D_BG_InitStruct->DMA2D_BG_CLUT_SIZE = 0x00;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    464          
    465            /*!< Initialize the DMA2D background alpha mode */
    466            DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_MODE = NO_MODIF_ALPHA_VALUE;
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    467          
    468            /*!< Initialize the DMA2D background alpha value */
    469            DMA2D_BG_InitStruct->DMA2D_BGPFC_ALPHA_VALUE = 0x00;
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    470          
    471            /*!< Initialize the DMA2D background blue value */
    472            DMA2D_BG_InitStruct->DMA2D_BGC_BLUE = 0x00;
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    473          
    474            /*!< Initialize the DMA2D background green value */
    475            DMA2D_BG_InitStruct->DMA2D_BGC_GREEN = 0x00;
   \   00000012   0x6201             STR      R1,[R0, #+32]
    476          
    477            /*!< Initialize the DMA2D background red value */
    478            DMA2D_BG_InitStruct->DMA2D_BGC_RED = 0x00;
   \   00000014   0x6241             STR      R1,[R0, #+36]
    479          
    480            /*!< Initialize the DMA2D background CLUT memory address */
    481            DMA2D_BG_InitStruct->DMA2D_BGCMAR = 0x00;
   \   00000016   0x6281             STR      R1,[R0, #+40]
    482          }
   \   00000018   0x4770             BX       LR               ;; return
    483          
    484          /**
    485            * @brief  Start the automatic loading of the CLUT or abort the transfer.
    486            * @param  NewState: new state of the DMA2D peripheral.
    487            *   This parameter can be: ENABLE or DISABLE.
    488            * @retval None
    489            */
    490          

   \                                 In section .text, align 2, keep-with-next
    491          void DMA2D_FGStart(FunctionalState NewState) 
    492          {
    493            /* Check the parameters */
    494            assert_param(IS_FUNCTIONAL_STATE(NewState));
    495          
    496            if (NewState != DISABLE)
   \                     DMA2D_FGStart: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_5  ;; 0x4002b01c
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DMA2D_FGStart_0
    497            {
    498              /* Start the automatic loading of the CLUT */
    499              DMA2D->FGPFCCR |= DMA2D_FGPFCCR_START;
   \   00000008   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    500            }
    501            else
    502            {
    503              /* abort the transfer */
    504              DMA2D->FGPFCCR &= (uint32_t)~DMA2D_FGPFCCR_START;
   \                     ??DMA2D_FGStart_0: (+1)
   \   00000010   0xF020 0x0020      BIC      R0,R0,#0x20
   \   00000014   0x6008             STR      R0,[R1, #+0]
    505            }
    506          }
   \   00000016   0x4770             BX       LR               ;; return
    507          
    508          /**
    509            * @brief  Start the automatic loading of the CLUT or abort the transfer.
    510            * @param  NewState: new state of the DMA2D peripheral.
    511            *   This parameter can be: ENABLE or DISABLE.
    512            * @retval None
    513            */
    514            

   \                                 In section .text, align 2, keep-with-next
    515          void DMA2D_BGStart(FunctionalState NewState) 
    516          {
    517            /* Check the parameters */
    518            assert_param(IS_FUNCTIONAL_STATE(NewState));
    519            
    520            if (NewState != DISABLE)
   \                     DMA2D_BGStart: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_6  ;; 0x4002b024
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x6808             LDR      R0,[R1, #+0]
   \   00000006   0xD003             BEQ.N    ??DMA2D_BGStart_0
    521            {
    522              /* Start the automatic loading of the CLUT */
    523              DMA2D->BGPFCCR |= DMA2D_BGPFCCR_START;
   \   00000008   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   \   0000000E   0x4770             BX       LR
    524            }
    525            else
    526            {
    527              /* abort the transfer */
    528              DMA2D->BGPFCCR &= (uint32_t)~DMA2D_BGPFCCR_START;
   \                     ??DMA2D_BGStart_0: (+1)
   \   00000010   0xF020 0x0020      BIC      R0,R0,#0x20
   \   00000014   0x6008             STR      R0,[R1, #+0]
    529            }
    530          }
   \   00000016   0x4770             BX       LR               ;; return
    531          
    532          /**
    533            * @brief  Configures the DMA2D dead time.
    534            * @param  DMA2D_DeadTime: specifies the DMA2D dead time.
    535            *   This parameter can be one of the following values:
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          void DMA2D_DeadTimeConfig(uint32_t DMA2D_DeadTime, FunctionalState NewState)
    539          {
    540             uint32_t DeadTime;
    541          
    542            /* Check the parameters */
    543            assert_param(IS_DMA2D_DEAD_TIME(DMA2D_DeadTime));
    544            assert_param(IS_FUNCTIONAL_STATE(NewState));
    545          
    546            if (NewState != DISABLE)
   \                     DMA2D_DeadTimeConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable14_7  ;; 0x4002b04c
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD00A             BEQ.N    ??DMA2D_DeadTimeConfig_0
    547            {
    548              /* Enable and Configures the dead time */
    549              DMA2D->AMTCR &= (uint32_t)DEAD_MASK;
   \   00000006   0x6811             LDR      R1,[R2, #+0]
   \   00000008   0x....             LDR.N    R3,??DataTable14_8  ;; 0xffff00fe
   \   0000000A   0x4019             ANDS     R1,R3,R1
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    550              DeadTime = DMA2D_DeadTime << 8;
    551              DMA2D->AMTCR |= (DeadTime | DMA2D_AMTCR_EN);
   \   0000000E   0x6811             LDR      R1,[R2, #+0]
   \   00000010   0x0200             LSLS     R0,R0,#+8
   \   00000012   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000016   0x4308             ORRS     R0,R0,R1
   \   00000018   0x6010             STR      R0,[R2, #+0]
   \   0000001A   0x4770             BX       LR
    552            }
    553            else
    554            {
    555               DMA2D->AMTCR &= ~(uint32_t)DMA2D_AMTCR_EN;
   \                     ??DMA2D_DeadTimeConfig_0: (+1)
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x0840             LSRS     R0,R0,#+1
   \   00000020   0x0040             LSLS     R0,R0,#+1
   \   00000022   0x6010             STR      R0,[R2, #+0]
    556            }
    557          }
   \   00000024   0x4770             BX       LR               ;; return
    558          
    559          /**
    560            * @brief  Define the configuration of the line watermark .
    561            * @param  DMA2D_LWatermarkConfig: Line Watermark configuration.
    562            * @retval None
    563            */
    564          

   \                                 In section .text, align 2, keep-with-next
    565          void DMA2D_LineWatermarkConfig(uint32_t DMA2D_LWatermarkConfig)
    566          {
    567            /* Check the parameters */
    568            assert_param(IS_DMA2D_LineWatermark(DMA2D_LWatermarkConfig));
    569          
    570            /* Sets the Line watermark configuration */
    571            DMA2D->LWR = (uint32_t)DMA2D_LWatermarkConfig;
   \                     DMA2D_LineWatermarkConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_9  ;; 0x4002b048
   \   00000002   0x6008             STR      R0,[R1, #+0]
    572          }
   \   00000004   0x4770             BX       LR               ;; return
    573          
    574          /**
    575            * @}
    576            */
    577          
    578          /** @defgroup DMA2D_Group2 Interrupts and flags management functions
    579           *  @brief   Interrupts and flags management functions
    580           *
    581          @verbatim
    582           ===============================================================================
    583                      ##### Interrupts and flags management functions #####
    584           ===============================================================================
    585          
    586              [..] This section provides functions allowing to configure the DMA2D 
    587                   Interrupts and to get the status and clear flags and Interrupts 
    588                   pending bits.
    589              [..] The DMA2D provides 6 Interrupts sources and 6 Flags
    590              
    591              *** Flags ***
    592              =============
    593              [..]
    594                (+) DMA2D_FLAG_CE : Configuration Error Interrupt flag
    595                (+) DMA2D_FLAG_CAE: CLUT Access Error Interrupt flag
    596                (+) DMA2D_FLAG_TW:  Transfer Watermark Interrupt flag
    597                (+) DMA2D_FLAG_TC:  Transfer Complete interrupt flag
    598                (+) DMA2D_FLAG_TE:  Transfer Error interrupt flag
    599                (+) DMA2D_FLAG_CTC: CLUT Transfer Complete Interrupt flag
    600                
    601              *** Interrupts ***
    602              ==================
    603              [..]
    604                (+) DMA2D_IT_CE: Configuration Error Interrupt is generated when a wrong 
    605                                 configuration is detected
    606                (+) DMA2D_IT_CAE: CLUT Access Error Interrupt
    607                (+) DMA2D_IT_TW: Transfer Watermark Interrupt is generated when 
    608                                 the programmed watermark is reached 
    609                (+) DMA2D_IT_TE: Transfer Error interrupt is generated when the CPU trying 
    610                                 to access the CLUT while a CLUT loading or a DMA2D1 transfer 
    611                                 is on going       
    612                (+) DMA2D_IT_CTC: CLUT Transfer Complete Interrupt 
    613                (+) DMA2D_IT_TC: Transfer Complete interrupt         
    614          @endverbatim
    615            * @{
    616            */
    617          /**
    618            * @brief  Enables or disables the specified DMA2D's interrupts.
    619            * @param  DMA2D_IT: specifies the DMA2D interrupts sources to be enabled or disabled.
    620            *   This parameter can be any combination of the following values:
    621            *     @arg DMA2D_IT_CE:   Configuration Error Interrupt Enable.
    622            *     @arg DMA2D_IT_CTC:  CLUT Transfer Complete Interrupt Enable.
    623            *     @arg DMA2D_IT_CAE:  CLUT Access Error Interrupt Enable.
    624            *     @arg DMA2D_IT_TW:   Transfer Watermark Interrupt Enable.
    625            *     @arg DMA2D_IT_TC:   Transfer Complete interrupt enable.
    626            *     @arg DMA2D_IT_TE:   Transfer Error interrupt enable.
    627            * @param NewState: new state of the specified DMA2D interrupts.
    628            *   This parameter can be: ENABLE or DISABLE.
    629            * @retval None
    630            */
    631          

   \                                 In section .text, align 2, keep-with-next
    632          void DMA2D_ITConfig(uint32_t DMA2D_IT, FunctionalState NewState)
    633          {
    634            /* Check the parameters */
    635            assert_param(IS_DMA2D_IT(DMA2D_IT));
    636            assert_param(IS_FUNCTIONAL_STATE(NewState));
    637          
    638            if (NewState != DISABLE)
   \                     DMA2D_ITConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable14  ;; 0x4002b000
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x6811             LDR      R1,[R2, #+0]
   \   00000006   0xD002             BEQ.N    ??DMA2D_ITConfig_0
    639            {
    640              /* Enable the selected DMA2D interrupts */
    641              DMA2D->CR |= DMA2D_IT;
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x6010             STR      R0,[R2, #+0]
   \   0000000C   0x4770             BX       LR
    642            }
    643            else
    644            {
    645              /* Disable the selected DMA2D interrupts */
    646              DMA2D->CR &= (uint32_t)~DMA2D_IT;
   \                     ??DMA2D_ITConfig_0: (+1)
   \   0000000E   0xEA21 0x0000      BIC      R0,R1,R0
   \   00000012   0x6010             STR      R0,[R2, #+0]
    647            }
    648          }
   \   00000014   0x4770             BX       LR               ;; return
    649          
    650          /**
    651            * @brief  Checks whether the specified DMA2D's flag is set or not.
    652            * @param  DMA2D_FLAG: specifies the flag to check.
    653            *   This parameter can be one of the following values:
    654            *     @arg DMA2D_FLAG_CE:   Configuration Error Interrupt flag.
    655            *     @arg DMA2D_FLAG_CTC:  CLUT Transfer Complete Interrupt flag.
    656            *     @arg DMA2D_FLAG_CAE:  CLUT Access Error Interrupt flag.
    657            *     @arg DMA2D_FLAG_TW:   Transfer Watermark Interrupt flag.
    658            *     @arg DMA2D_FLAG_TC:   Transfer Complete interrupt flag.
    659            *     @arg DMA2D_FLAG_TE:   Transfer Error interrupt flag.
    660            * @retval The new state of DMA2D_FLAG (SET or RESET).
    661            */
    662          

   \                                 In section .text, align 2, keep-with-next
    663          FlagStatus DMA2D_GetFlagStatus(uint32_t DMA2D_FLAG)
    664          {
    665            FlagStatus bitstatus = RESET;
   \                     DMA2D_GetFlagStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    666            
    667            /* Check the parameters */
    668            assert_param(IS_DMA2D_GET_FLAG(DMA2D_FLAG));
    669            
    670            /* Check the status of the specified DMA2D flag */
    671            if (((DMA2D->ISR) & DMA2D_FLAG) != (uint32_t)RESET)
   \   00000002   0x....             LDR.N    R2,??DataTable14_10  ;; 0x4002b004
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x4202             TST      R2,R0
   \   00000008   0xD000             BEQ.N    ??DMA2D_GetFlagStatus_0
    672            {
    673              /* DMA2D_FLAG is set */
    674              bitstatus = SET;
   \   0000000A   0x2101             MOVS     R1,#+1
    675            }
    676            else
    677            {
    678              /* DMA2D_FLAG is reset */
    679              bitstatus = RESET;
    680            }
    681            /* Return the DMA2D_FLAG status */
    682            return bitstatus;
   \                     ??DMA2D_GetFlagStatus_0: (+1)
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x4770             BX       LR               ;; return
    683          }
    684          
    685          /**
    686            * @brief  Clears the DMA2D's pending flags.
    687            * @param  DMA2D_FLAG: specifies the flag to clear.
    688            *   This parameter can be any combination of the following values:
    689            *     @arg DMA2D_FLAG_CE:   Configuration Error Interrupt flag.
    690            *     @arg DMA2D_FLAG_CTC:  CLUT Transfer Complete Interrupt flag.
    691            *     @arg DMA2D_FLAG_CAE:  CLUT Access Error Interrupt flag.
    692            *     @arg DMA2D_FLAG_TW:   Transfer Watermark Interrupt flag.
    693            *     @arg DMA2D_FLAG_TC:   Transfer Complete interrupt flag.
    694            *     @arg DMA2D_FLAG_TE:   Transfer Error interrupt flag.
    695            * @retval None
    696            */

   \                                 In section .text, align 2, keep-with-next
    697          void DMA2D_ClearFlag(uint32_t DMA2D_FLAG)
    698          {
    699            /* Check the parameters */
    700            assert_param(IS_DMA2D_GET_FLAG(DMA2D_FLAG));
    701              
    702            /* Clear the corresponding DMA2D flag */
    703            DMA2D->IFCR = (uint32_t)DMA2D_FLAG;
   \                     DMA2D_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable14_11  ;; 0x4002b008
   \   00000002   0x6008             STR      R0,[R1, #+0]
    704          }
   \   00000004   0x4770             BX       LR               ;; return
    705          
    706          /**
    707            * @brief  Checks whether the specified DMA2D's interrupt has occurred or not.
    708            * @param  DMA2D_IT: specifies the DMA2D interrupts sources to check.
    709            *   This parameter can be one of the following values:
    710            *     @arg DMA2D_IT_CE:   Configuration Error Interrupt Enable.
    711            *     @arg DMA2D_IT_CTC:  CLUT Transfer Complete Interrupt Enable.
    712            *     @arg DMA2D_IT_CAE:  CLUT Access Error Interrupt Enable.
    713            *     @arg DMA2D_IT_TW:   Transfer Watermark Interrupt Enable.
    714            *     @arg DMA2D_IT_TC:   Transfer Complete interrupt enable.
    715            *     @arg DMA2D_IT_TE:   Transfer Error interrupt enable.
    716            * @retval The new state of the DMA2D_IT (SET or RESET).
    717            */

   \                                 In section .text, align 2, keep-with-next
    718          ITStatus DMA2D_GetITStatus(uint32_t DMA2D_IT)
    719          {
    720            ITStatus bitstatus = RESET;
   \                     DMA2D_GetITStatus: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    721            uint32_t DMA2D_IT_FLAG = DMA2D_IT >> 8;
    722            
    723            /* Check the parameters */
    724            assert_param(IS_DMA2D_IT(DMA2D_IT));
    725          
    726            if ((DMA2D->ISR & DMA2D_IT_FLAG) != (uint32_t)RESET)
   \   00000002   0x....             LDR.N    R2,??DataTable14  ;; 0x4002b000
   \   00000004   0x6853             LDR      R3,[R2, #+4]
   \   00000006   0xEA13 0x2F10      TST      R3,R0, LSR #+8
   \   0000000A   0xD000             BEQ.N    ??DMA2D_GetITStatus_0
    727            {
    728              bitstatus = SET;
   \   0000000C   0x2101             MOVS     R1,#+1
    729            }
    730            else
    731            {
    732              bitstatus = RESET;
    733            }
    734            
    735            if (((DMA2D->CR & DMA2D_IT) != (uint32_t)RESET) && (bitstatus != (uint32_t)RESET))
   \                     ??DMA2D_GetITStatus_0: (+1)
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x4202             TST      R2,R0
   \   00000012   0xD005             BEQ.N    ??DMA2D_GetITStatus_1
   \   00000014   0x4608             MOV      R0,R1
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x4180             SBCS     R0,R0,R0
   \   0000001A   0x43C0             MVNS     R0,R0
   \   0000001C   0x0FC0             LSRS     R0,R0,#+31
   \   0000001E   0xE000             B.N      ??DMA2D_GetITStatus_2
    736            {
    737              bitstatus = SET;
    738            }
    739            else
    740            {
    741              bitstatus = RESET;
   \                     ??DMA2D_GetITStatus_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
    742            }
    743            return bitstatus;
   \                     ??DMA2D_GetITStatus_2: (+1)
   \   00000022   0xB240             SXTB     R0,R0
   \   00000024   0x4770             BX       LR               ;; return
    744          }
    745          
    746          /**
    747            * @brief  Clears the DMA2D's interrupt pending bits.
    748            * @param  DMA2D_IT: specifies the interrupt pending bit to clear.
    749            *   This parameter can be any combination of the following values:
    750            *     @arg DMA2D_IT_CE:   Configuration Error Interrupt.
    751            *     @arg DMA2D_IT_CTC:  CLUT Transfer Complete Interrupt.
    752            *     @arg DMA2D_IT_CAE:  CLUT Access Error Interrupt.
    753            *     @arg DMA2D_IT_TW:   Transfer Watermark Interrupt.
    754            *     @arg DMA2D_IT_TC:   Transfer Complete interrupt.
    755            *     @arg DMA2D_IT_TE:   Transfer Error interrupt.
    756            * @retval None
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          void DMA2D_ClearITPendingBit(uint32_t DMA2D_IT)
    759          {
    760            /* Check the parameters */
    761            assert_param(IS_DMA2D_IT(DMA2D_IT));
    762            DMA2D_IT = DMA2D_IT >> 8;
    763              
    764            /* Clear the corresponding DMA2D Interrupt */
    765            DMA2D->IFCR = (uint32_t)DMA2D_IT;
   \                     DMA2D_ClearITPendingBit: (+1)
   \   00000000   0x0A00             LSRS     R0,R0,#+8
   \   00000002   0x....             LDR.N    R1,??DataTable14_11  ;; 0x4002b008
   \   00000004   0x6008             STR      R0,[R1, #+0]
    766          }
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x4002B000         DC32     0x4002b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0xFFFCE0FC         DC32     0xfffce0fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x4002B00C         DC32     0x4002b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x00FC00C0         DC32     0xfc00c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x4002B014         DC32     0x4002b014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x4002B01C         DC32     0x4002b01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x4002B024         DC32     0x4002b024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x4002B04C         DC32     0x4002b04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0xFFFF00FE         DC32     0xffff00fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x4002B048         DC32     0x4002b048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x4002B004         DC32     0x4002b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x4002B008         DC32     0x4002b008
    767          
    768          /**
    769            * @}
    770            */
    771          
    772          /**
    773            * @}
    774            */
    775          
    776          /**
    777            * @}
    778            */
    779          
    780          /**
    781            * @}
    782            */
    783          
    784          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA2D_AbortTransfer
       4   DMA2D_BGConfig
       0   DMA2D_BGStart
       0   DMA2D_BG_StructInit
       0   DMA2D_ClearFlag
       0   DMA2D_ClearITPendingBit
       8   DMA2D_DeInit
         0   -> RCC_AHB1PeriphResetCmd
         8   -> RCC_AHB1PeriphResetCmd
       0   DMA2D_DeadTimeConfig
       4   DMA2D_FGConfig
       0   DMA2D_FGStart
       0   DMA2D_FG_StructInit
       0   DMA2D_GetFlagStatus
       0   DMA2D_GetITStatus
       0   DMA2D_ITConfig
       8   DMA2D_Init
       0   DMA2D_LineWatermarkConfig
       0   DMA2D_StartTransfer
       0   DMA2D_StructInit
       0   DMA2D_Suspend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      12  DMA2D_AbortTransfer
     100  DMA2D_BGConfig
      24  DMA2D_BGStart
      26  DMA2D_BG_StructInit
       6  DMA2D_ClearFlag
       8  DMA2D_ClearITPendingBit
      26  DMA2D_DeInit
      38  DMA2D_DeadTimeConfig
     100  DMA2D_FGConfig
      24  DMA2D_FGStart
      26  DMA2D_FG_StructInit
      16  DMA2D_GetFlagStatus
      38  DMA2D_GetITStatus
      22  DMA2D_ITConfig
     158  DMA2D_Init
       6  DMA2D_LineWatermarkConfig
      12  DMA2D_StartTransfer
      24  DMA2D_StructInit
      24  DMA2D_Suspend

 
 738 bytes in section .text
 
 738 bytes of CODE memory

Errors: none
Warnings: none
