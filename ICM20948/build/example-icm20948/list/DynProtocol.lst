###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:25
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\DynamicProtocol\DynProtocol.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\DynamicProtocol\DynProtocol.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\DynProtocol.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\DynProtocol.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\DynamicProtocol\DynProtocol.c
      1          /*
      2           * ________________________________________________________________________________________________________
      3           * Copyright (c) 2016-2016 InvenSense Inc. All rights reserved.
      4           *
      5           * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      6           * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
      7           * and other intellectual property rights laws.
      8           *
      9           * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
     10           * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
     11           * from InvenSense is strictly prohibited.
     12           *
     13           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
     14           * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
     15           * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
     17           * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18           * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
     19           * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20           * OF THE SOFTWARE.
     21           * ________________________________________________________________________________________________________
     22           */
     23          
     24          #include "DynProtocol.h"
     25          
     26          #include "Invn/EmbUtils/Message.h"
     27          #include "Invn/EmbUtils/DataConverter.h"
     28          #include "Invn/InvError.h"
     29          
     30          #include <string.h>
     31          
     32          /** A frame transfer have the format bellow
     33          	<EVENT_TYPE|IDD_WRAPPER_GRP> <PACKET>
     34          	 According to the Event Type:
     35          	- CMD=0
     36          	- RESPONSE=1
     37          	- ASYNC_EVENT=2
     38          	Packet should contains :
     39          	- <CMD> <ARG>
     40          	- <CMD> <ERROR_STATUS> <ARG>
     41          	- <SENSOR_STATUS> <SENSOR_ID> <TIMESTAMP> <DATA>
     42          	*/
     43          
     44          #define MAX_EXPECTED_PAYLOAD (sizeof((*(DynProtocol_t *)(0)).decode_state_machine.tmp_buffer))
     45          
     46          #define EVENT_TYPE_CMD   (0 << 6)
     47          #define EVENT_TYPE_RESP  (1 << 6)
     48          #define EVENT_TYPE_ASYNC (2 << 6)
     49          #define EVENT_TYPE_MASK 0xC0
     50          
     51          #define PROTOCOL_ACCELEROMETER_PRECISION     11
     52          #define PROTOCOL_MAGNETOMETER_PRECISION       4
     53          #define PROTOCOL_GYROSCOPE_PRECISION          4
     54          #define PROTOCOL_QUATERNION_PRECISION        14
     55          #define PROTOCOL_RAW_PRECISION                0
     56          #define PROTOCOL_ORIENTATION_PRECISION        6
     57          #define PROTOCOL_TEMPERATURE_PRECISION        8
     58          #define PROTOCOL_CUSTOM_PRESSURE_PRECISION    8
     59          
     60          #define PROTOCOL_HEADING_ACCURACY_PRECISION   7
     61          
     62          #define DYN_PROTOCOL_QX_TO_QY(value, qx, qy)	((qx >= qy) ? (value >> (qx-qy)) : (value << (qy-qx)) )
     63          

   \                                 In section .text, align 2, keep-with-next
     64          static inline int DynProtocol_decodeVect16QxToQy(const uint8_t * bytes, unsigned len, int qxIn, int qxOut,  int32_t * out)
     65          {
   \                     DynProtocol_decodeVect16QxToQy: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
     66          	unsigned i;
     67          	for(i = 0; i < len; ++i) {
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x9C04             LDR      R4,[SP, #+16]
   \   00000006   0xE004             B.N      ??DynProtocol_decodeVect16QxToQy_0
     68          		int32_t x = (int32_t)(((int8_t *)bytes)[2*i+1] << 8) | bytes[2*i];
     69          		out[i] = (int32_t)DYN_PROTOCOL_QX_TO_QY(x, qxIn ,qxOut);
   \                     ??DynProtocol_decodeVect16QxToQy_1: (+1)
   \   00000008   0x1A9F             SUBS     R7,R3,R2
   \   0000000A   0x40BE             LSLS     R6,R6,R7
   \                     ??DynProtocol_decodeVect16QxToQy_2: (+1)
   \   0000000C   0xF844 0x6025      STR      R6,[R4, R5, LSL #+2]
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \                     ??DynProtocol_decodeVect16QxToQy_0: (+1)
   \   00000012   0x428D             CMP      R5,R1
   \   00000014   0xD20B             BCS.N    ??DynProtocol_decodeVect16QxToQy_3
   \   00000016   0x006E             LSLS     R6,R5,#+1
   \   00000018   0x1987             ADDS     R7,R0,R6
   \   0000001A   0xF997 0x7001      LDRSB    R7,[R7, #+1]
   \   0000001E   0x5D86             LDRB     R6,[R0, R6]
   \   00000020   0xEA46 0x2607      ORR      R6,R6,R7, LSL #+8
   \   00000024   0x429A             CMP      R2,R3
   \   00000026   0xDBEF             BLT.N    ??DynProtocol_decodeVect16QxToQy_1
   \   00000028   0x1AD7             SUBS     R7,R2,R3
   \   0000002A   0x413E             ASRS     R6,R6,R7
   \   0000002C   0xE7EE             B.N      ??DynProtocol_decodeVect16QxToQy_2
     70          	}
     71          
     72          	return 2*len;
   \                     ??DynProtocol_decodeVect16QxToQy_3: (+1)
   \   0000002E   0x0048             LSLS     R0,R1,#+1
   \   00000030   0xBCF0             POP      {R4-R7}
   \   00000032   0x4770             BX       LR               ;; return
     73          }
     74          

   \                                 In section .text, align 2, keep-with-next
     75          static inline int DynProtocol_encodeQxToQyVect16(const int32_t * in, unsigned len, int qxIn, int qxOut, uint8_t * bytes)
     76          {
   \                     DynProtocol_encodeQxToQyVect16: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
     77          	unsigned i;
     78          	for(i = 0; i < len; ++i) {
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x9C04             LDR      R4,[SP, #+16]
   \   00000006   0xE008             B.N      ??DynProtocol_encodeQxToQyVect16_0
     79          		int16_t x = (int16_t)DYN_PROTOCOL_QX_TO_QY(in[i], qxIn ,qxOut);
   \                     ??DynProtocol_encodeQxToQyVect16_1: (+1)
   \   00000008   0x1A9F             SUBS     R7,R3,R2
   \   0000000A   0x40BE             LSLS     R6,R6,R7
   \                     ??DynProtocol_encodeQxToQyVect16_2: (+1)
   \   0000000C   0x006F             LSLS     R7,R5,#+1
   \   0000000E   0x55E6             STRB     R6,[R4, R7]
     80          		bytes[2*i]   = (uint8_t)((uint16_t)x & 0xFF);
     81          		bytes[2*i+1] = (uint8_t)(((uint16_t)x & 0xFF00) >> 8U);
   \   00000010   0xB2B6             UXTH     R6,R6
   \   00000012   0x0A36             LSRS     R6,R6,#+8
   \   00000014   0x4427             ADD      R7,R4,R7
   \   00000016   0x707E             STRB     R6,[R7, #+1]
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??DynProtocol_encodeQxToQyVect16_0: (+1)
   \   0000001A   0x428D             CMP      R5,R1
   \   0000001C   0xD206             BCS.N    ??DynProtocol_encodeQxToQyVect16_3
   \   0000001E   0xF850 0x6025      LDR      R6,[R0, R5, LSL #+2]
   \   00000022   0x429A             CMP      R2,R3
   \   00000024   0xDBF0             BLT.N    ??DynProtocol_encodeQxToQyVect16_1
   \   00000026   0x1AD7             SUBS     R7,R2,R3
   \   00000028   0x413E             ASRS     R6,R6,R7
   \   0000002A   0xE7EF             B.N      ??DynProtocol_encodeQxToQyVect16_2
     82          	}
     83          
     84          	return 2*len;
   \                     ??DynProtocol_encodeQxToQyVect16_3: (+1)
   \   0000002C   0x0048             LSLS     R0,R1,#+1
   \   0000002E   0xBCF0             POP      {R4-R7}
   \   00000030   0x4770             BX       LR               ;; return
     85          }
     86          

   \                                 In section .text, align 2, keep-with-next
     87          static int DynProtocol_getPrecision(DynProtocol_t * self, int sensor_id)
     88          {
     89          	int QxIn;
     90          
     91          	switch (sensor_id)
   \                     DynProtocol_getPrecision: (+1)
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD01A             BEQ.N    ??DynProtocol_getPrecision_0
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD020             BEQ.N    ??DynProtocol_getPrecision_1
   \   00000008   0x2903             CMP      R1,#+3
   \   0000000A   0xD022             BEQ.N    ??DynProtocol_getPrecision_2
   \   0000000C   0x2904             CMP      R1,#+4
   \   0000000E   0xD017             BEQ.N    ??DynProtocol_getPrecision_3
   \   00000010   0x2909             CMP      R1,#+9
   \   00000012   0xD012             BEQ.N    ??DynProtocol_getPrecision_0
   \   00000014   0x290A             CMP      R1,#+10
   \   00000016   0xD010             BEQ.N    ??DynProtocol_getPrecision_0
   \   00000018   0x290B             CMP      R1,#+11
   \   0000001A   0xD018             BEQ.N    ??DynProtocol_getPrecision_4
   \   0000001C   0x290D             CMP      R1,#+13
   \   0000001E   0xD01A             BEQ.N    ??DynProtocol_getPrecision_5
   \   00000020   0x290E             CMP      R1,#+14
   \   00000022   0xD012             BEQ.N    ??DynProtocol_getPrecision_1
   \   00000024   0x290F             CMP      R1,#+15
   \   00000026   0xD012             BEQ.N    ??DynProtocol_getPrecision_4
   \   00000028   0x2910             CMP      R1,#+16
   \   0000002A   0xD009             BEQ.N    ??DynProtocol_getPrecision_3
   \   0000002C   0x2914             CMP      R1,#+20
   \   0000002E   0xD00E             BEQ.N    ??DynProtocol_getPrecision_4
   \   00000030   0x291D             CMP      R1,#+29
   \   00000032   0xD00C             BEQ.N    ??DynProtocol_getPrecision_4
   \   00000034   0x2940             CMP      R1,#+64
   \   00000036   0xD00A             BEQ.N    ??DynProtocol_getPrecision_4
   \   00000038   0xE00F             B.N      ??DynProtocol_getPrecision_6
     92          	{
     93          	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
     94          	case DYN_PRO_SENSOR_TYPE_GRAVITY:
     95          	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
     96          		QxIn = self->precision.acc;
   \                     ??DynProtocol_getPrecision_0: (+1)
   \   0000003A   0xF890 0x0114      LDRB     R0,[R0, #+276]
     97          		break;
   \   0000003E   0x4770             BX       LR
     98          	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
     99          	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
    100          		QxIn = self->precision.gyro;
   \                     ??DynProtocol_getPrecision_3: (+1)
   \   00000040   0xF44F 0x718A      MOV      R1,#+276
   \   00000044   0x4408             ADD      R0,R0,R1
   \   00000046   0x7840             LDRB     R0,[R0, #+1]
    101          		break;
   \   00000048   0x4770             BX       LR
    102          	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
    103          	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
    104          		QxIn = PROTOCOL_MAGNETOMETER_PRECISION;
   \                     ??DynProtocol_getPrecision_1: (+1)
   \   0000004A   0x2004             MOVS     R0,#+4
    105          		break;
   \   0000004C   0x4770             BX       LR
    106          	case DYN_PRO_SENSOR_TYPE_3AXIS:
    107          	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
    108          	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
    109          	case DYN_PRO_SENSOR_TYPE_PREDICTIVE_QUATERNION:
    110          	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
    111          		QxIn = PROTOCOL_QUATERNION_PRECISION;
   \                     ??DynProtocol_getPrecision_4: (+1)
   \   0000004E   0x200E             MOVS     R0,#+14
    112          		break;
   \   00000050   0x4770             BX       LR
    113          	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
    114          		QxIn = PROTOCOL_ORIENTATION_PRECISION;
   \                     ??DynProtocol_getPrecision_2: (+1)
   \   00000052   0x2006             MOVS     R0,#+6
    115          		break;
   \   00000054   0x4770             BX       LR
    116          	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
    117          		QxIn = PROTOCOL_TEMPERATURE_PRECISION;
   \                     ??DynProtocol_getPrecision_5: (+1)
   \   00000056   0x2008             MOVS     R0,#+8
    118          		break;
   \   00000058   0x4770             BX       LR
    119          	default:
    120          		QxIn = PROTOCOL_RAW_PRECISION;
   \                     ??DynProtocol_getPrecision_6: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
    121          		break;
    122          	}
    123          
    124          	return QxIn;
   \   0000005C   0x4770             BX       LR               ;; return
    125          }
    126          

   \                                 In section .text, align 4, keep-with-next
    127          static int16_t DynProtocol_getPayload(DynProtocol_t * self)
    128          {
   \                     DynProtocol_getPayload: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4601             MOV      R1,R0
    129          	const uint8_t eventType = self->decode_state_machine.event_type;
   \   00000004   0x7B0A             LDRB     R2,[R1, #+12]
    130          	const enum DynProtocolEid cmdId = (enum DynProtocolEid)self->decode_state_machine.cmd_id;
   \   00000006   0xF991 0x300E      LDRSB    R3,[R1, #+14]
    131          
    132          	if(self->decode_state_machine.received_size == 0) {
   \   0000000A   0x8A48             LDRH     R0,[R1, #+18]
   \   0000000C   0x0004             MOVS     R4,R0
   \   0000000E   0xD153             BNE.N    ??DynProtocol_getPayload_2
    133          		switch(eventType) {
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD004             BEQ.N    ??DynProtocol_getPayload_3
   \   00000014   0x2A40             CMP      R2,#+64
   \   00000016   0xD021             BEQ.N    ??DynProtocol_getPayload_4
   \   00000018   0x2A80             CMP      R2,#+128
   \   0000001A   0xD041             BEQ.N    ??DynProtocol_getPayload_5
   \   0000001C   0xE044             B.N      ??DynProtocol_getPayload_6
    134          		case EVENT_TYPE_CMD:
    135          			switch(cmdId) {
   \                     ??DynProtocol_getPayload_3: (+1)
   \   0000001E   0x2B24             CMP      R3,#+36
   \   00000020   0xD842             BHI.N    ??DynProtocol_getPayload_6
   \   00000022   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??DynProtocol_getPayload_0:
   \   00000026   0x13 0x41          DC8      0x13,0x41,0x41,0x41
   \              0x41 0x41    
   \   0000002A   0x41 0x41          DC8      0x41,0x41,0x41,0x41
   \              0x41 0x41    
   \   0000002E   0x41 0x41          DC8      0x41,0x41,0x41,0x41
   \              0x41 0x41    
   \   00000032   0x41 0x41          DC8      0x41,0x41,0x41,0x41
   \              0x41 0x41    
   \   00000036   0x13 0x13          DC8      0x13,0x13,0x13,0x13
   \              0x13 0x13    
   \   0000003A   0x41 0x39          DC8      0x41,0x39,0x13,0x39
   \              0x13 0x39    
   \   0000003E   0x41 0x39          DC8      0x41,0x39,0x39,0x15
   \              0x39 0x15    
   \   00000042   0x15 0x39          DC8      0x15,0x39,0x87,0x3F
   \              0x87 0x3F    
   \   00000046   0x17 0x39          DC8      0x17,0x39,0x3F,0x19
   \              0x3F 0x19    
   \   0000004A   0x3F 0x00          DC8      0x3F,0x0
    136          			case DYN_PROTOCOL_EID_PROTOCOLVERSION:    return 0;
    137          			case DYN_PROTOCOL_EID_GET_FW_INFO:        return 0;
    138          			case DYN_PROTOCOL_EID_WHO_AM_I:           return 0;
    139          			case DYN_PROTOCOL_EID_RESET:              return 0;
    140          			case DYN_PROTOCOL_EID_SETUP:              return 0;
    141          			case DYN_PROTOCOL_EID_CLEANUP:            return 0;
   \                     ??DynProtocol_getPayload_7: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD10             POP      {R4,PC}
    142          			case DYN_PROTOCOL_EID_SELF_TEST:          return 1;
    143          			case DYN_PROTOCOL_EID_PING_SENSOR:        return 1;
    144          			case DYN_PROTOCOL_EID_START_SENSOR:       return 1;
    145          			case DYN_PROTOCOL_EID_STOP_SENSOR:        return 1;
    146          			case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:  return 1 + 4;
    147          			case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT: return 1 + 4;
   \                     ??DynProtocol_getPayload_8: (+1)
   \   00000050   0x2005             MOVS     R0,#+5
   \   00000052   0xBD10             POP      {R4,PC}
    148          			case DYN_PROTOCOL_EID_FLUSH_SENSOR:       return 1;
    149          			case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX: return 1 + 1 + (9 * 4); /* sensor + cfg_type + 3x3 q30 */
   \                     ??DynProtocol_getPayload_9: (+1)
   \   00000054   0x2026             MOVS     R0,#+38
   \   00000056   0xBD10             POP      {R4,PC}
    150          			case DYN_PROTOCOL_EID_GET_SENSOR_DATA:    return 1;
    151          			case DYN_PROTOCOL_EID_GET_SW_REG:         return 1 + 1;
    152          			case DYN_PROTOCOL_EID_SET_SENSOR_CFG:     return 1 + 1 + 1 + 64; // sensor + size + cfg_type + max_data_size
   \                     ??DynProtocol_getPayload_10: (+1)
   \   00000058   0x2043             MOVS     R0,#+67
   \   0000005A   0xBD10             POP      {R4,PC}
    153          			case DYN_PROTOCOL_EID_GET_SENSOR_CFG:     return 1 + 1; // sensor + cfg_type
    154          			case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:    return 1 + 1 + (3 * 2); /* sensor + cfg_type + bias (x,y,z) in Qx */
    155          			case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:    return 1 + 1; /* sensor + cfg_type */
    156          			default:
    157          				break;
    158          			}
    159          			break;
    160          
    161          		case EVENT_TYPE_RESP:
    162          			switch(cmdId) {
   \                     ??DynProtocol_getPayload_4: (+1)
   \   0000005C   0x2B00             CMP      R3,#+0
   \   0000005E   0xD017             BEQ.N    ??DynProtocol_getPayload_11
   \   00000060   0x3B10             SUBS     R3,R3,#+16
   \   00000062   0x2B03             CMP      R3,#+3
   \   00000064   0xD918             BLS.N    ??DynProtocol_getPayload_12
   \   00000066   0x1F5B             SUBS     R3,R3,#+5
   \   00000068   0xD016             BEQ.N    ??DynProtocol_getPayload_12
   \   0000006A   0x1E5B             SUBS     R3,R3,#+1
   \   0000006C   0xD010             BEQ.N    ??DynProtocol_getPayload_11
   \   0000006E   0x1E5B             SUBS     R3,R3,#+1
   \   00000070   0xD012             BEQ.N    ??DynProtocol_getPayload_12
   \   00000072   0x1E9B             SUBS     R3,R3,#+2
   \   00000074   0x2B05             CMP      R3,#+5
   \   00000076   0xD90F             BLS.N    ??DynProtocol_getPayload_12
   \   00000078   0x1F9B             SUBS     R3,R3,#+6
   \   0000007A   0xD00F             BEQ.N    ??DynProtocol_getPayload_13
   \   0000007C   0x1E5B             SUBS     R3,R3,#+1
   \   0000007E   0xD00B             BEQ.N    ??DynProtocol_getPayload_12
   \   00000080   0x1E5B             SUBS     R3,R3,#+1
   \   00000082   0xD059             BEQ.N    ??DynProtocol_getPayload_14
   \   00000084   0x1E5B             SUBS     R3,R3,#+1
   \   00000086   0x2B01             CMP      R3,#+1
   \   00000088   0xD906             BLS.N    ??DynProtocol_getPayload_12
   \   0000008A   0x1E9B             SUBS     R3,R3,#+2
   \   0000008C   0xD002             BEQ.N    ??DynProtocol_getPayload_15
   \   0000008E   0xE00B             B.N      ??DynProtocol_getPayload_6
    163          			case DYN_PROTOCOL_EID_PROTOCOLVERSION:    return 16;
    164          			case DYN_PROTOCOL_EID_GET_FW_INFO:        return 16;
   \                     ??DynProtocol_getPayload_11: (+1)
   \   00000090   0x2010             MOVS     R0,#+16
   \   00000092   0xBD10             POP      {R4,PC}
    165          			case DYN_PROTOCOL_EID_WHO_AM_I:           return 1;
    166          			case DYN_PROTOCOL_EID_RESET:              return 1;
    167          			case DYN_PROTOCOL_EID_SETUP:              return 1;
    168          			case DYN_PROTOCOL_EID_CLEANUP:            return 1;
    169          			case DYN_PROTOCOL_EID_SELF_TEST:          return 1;
    170          			case DYN_PROTOCOL_EID_PING_SENSOR:        return 1;
    171          			case DYN_PROTOCOL_EID_START_SENSOR:       return 1;
    172          			case DYN_PROTOCOL_EID_STOP_SENSOR:        return 1;
    173          			case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:  return 1;
    174          			case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT: return 1;
    175          			case DYN_PROTOCOL_EID_FLUSH_SENSOR:       return 1;
    176          			case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX: return 1;
    177          			case DYN_PROTOCOL_EID_GET_SENSOR_DATA:    return 1+1+1+4+64; // rc + sensorStatus + sensorId + timestamp[0-3] + max_data_size
    178          			case DYN_PROTOCOL_EID_GET_SW_REG:         return 1;
    179          			case DYN_PROTOCOL_EID_SET_SENSOR_CFG:     return 1;
    180          			case DYN_PROTOCOL_EID_GET_SENSOR_CFG:     return 1+1+1+1+64; // rc + sensor + size + cfg_type + max_data_size
   \                     ??DynProtocol_getPayload_15: (+1)
   \   00000094   0x2044             MOVS     R0,#+68
   \   00000096   0xBD10             POP      {R4,PC}
    181          			case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:    return 1; /* rc */
   \                     ??DynProtocol_getPayload_12: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xBD10             POP      {R4,PC}
    182          			case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:    return 1 + 1 + 1 + (3 * 2); /* rc + precision + cfg_type + bias (x,y,z) in Qx */
   \                     ??DynProtocol_getPayload_13: (+1)
   \   0000009C   0x2009             MOVS     R0,#+9
   \   0000009E   0xBD10             POP      {R4,PC}
    183          			default:
    184          				break;
    185          			}
    186          			break;
    187          
    188          		case EVENT_TYPE_ASYNC:
    189          			switch(cmdId) {
   \                     ??DynProtocol_getPayload_5: (+1)
   \   000000A0   0x2B30             CMP      R3,#+48
   \   000000A2   0xD101             BNE.N    ??DynProtocol_getPayload_6
    190          			case DYN_PROTOCOL_EID_NEW_SENSOR_DATA:
    191          				/* need at least two more byte to determine payload (sensor status + sensor id) */
    192          				return 2;
   \                     ??DynProtocol_getPayload_16: (+1)
   \   000000A4   0x2002             MOVS     R0,#+2
   \   000000A6   0xBD10             POP      {R4,PC}
    193          			default:
    194          				break;
    195          			}
    196          			break;
    197          
    198          		default:
    199          			break;
    200          		}
    201          	}
    202          	else {
    203          
    204          		/* Payload content : 
    205          		 *   - byte 0 <sensor status> 
    206          		 *   - byte 1 <sensor id> 
    207          		 *   - <sensor data> 
    208          		 */
    209          		const uint8_t sensor_id = self->decode_state_machine.tmp_buffer[1];
    210          
    211          		switch(eventType) {
    212          		case EVENT_TYPE_ASYNC:
    213          			switch(sensor_id) {
    214          			case DYN_PRO_SENSOR_TYPE_RESERVED:
    215          				return self->decode_state_machine.received_size;
    216          			case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
    217          				return 1+1+4+16;
    218          			case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
    219          				return 1+1+6;
    220          			case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
    221          			case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
    222          			case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
    223          			case DYN_PRO_SENSOR_TYPE_OIS:
    224          				return 1+1+4+6;
    225          			case DYN_PRO_SENSOR_TYPE_EIS:
    226          				return 1+1+4+6+6+2;
    227          			case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
    228          				return 1+1+4+2;
    229          			case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
    230          				return 1+1+4+4;
    231          			case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
    232          			case DYN_PRO_SENSOR_TYPE_GRAVITY:
    233          			case DYN_PRO_SENSOR_TYPE_ORIENTATION:
    234          				return 1+1+4+6+1;
    235          			case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
    236          			case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
    237          			case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
    238          				return 1+1+4+6+1;
    239          			case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
    240          			case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
    241          				return 1+1+4+12+1;
    242          			case DYN_PRO_SENSOR_TYPE_PREDICTIVE_QUATERNION:
    243          			case DYN_PRO_SENSOR_TYPE_3AXIS:
    244          			case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
    245          				return 1+1+4+8+1;
    246          			case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
    247          			case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
    248          				return 1+1+4+10+1;
    249          			case DYN_PRO_SENSOR_TYPE_B2S:
    250          			case DYN_PRO_SENSOR_TYPE_SHAKE:
    251          			case DYN_PRO_SENSOR_TYPE_DOUBLE_TAP:
    252          			case DYN_PRO_SENSOR_TYPE_SEDENTARY_REMIND:
    253          			case DYN_PRO_SENSOR_TYPE_SMD:
    254          			case DYN_PRO_SENSOR_TYPE_STEP_DETECTOR:
    255          			case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:
    256          			case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:
    257          			case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
    258          			case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
    259          			case DYN_PRO_SENSOR_TYPE_PRESSURE:
    260          			case DYN_PRO_SENSOR_TYPE_LIGHT:
    261          				return 1+1+4+4;
    262          			case DYN_PRO_SENSOR_TYPE_WOM:
    263          			case DYN_PRO_SENSOR_TYPE_BAC:
    264          				return 1+1+4+1+4;
    265          			case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
    266          				return 1+1+4+4+4;
    267          			case DYN_PRO_SENSOR_TYPE_PROXIMITY:
    268          				return 1+1+4+2;
    269          			case DYN_PRO_SENSOR_TYPE_CUSTOM0:
    270          			case DYN_PRO_SENSOR_TYPE_CUSTOM1:
    271          			case DYN_PRO_SENSOR_TYPE_CUSTOM2:
    272          			case DYN_PRO_SENSOR_TYPE_CUSTOM3:
    273          			case DYN_PRO_SENSOR_TYPE_CUSTOM4:
    274          			case DYN_PRO_SENSOR_TYPE_CUSTOM5:
    275          			case DYN_PRO_SENSOR_TYPE_CUSTOM6:
    276          			case DYN_PRO_SENSOR_TYPE_CUSTOM7:
    277          				return 1+1+4+65;
    278          			default:
    279          				/* undefined for now */
    280          				return -1;
    281          			}
    282          
    283          		default:
    284          			/* do not need to update expected payload */
    285          			return self->decode_state_machine.expected_size;
    286          		}
    287          	}
    288          
    289          	INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: returned payload is -1");
   \                     ??DynProtocol_getPayload_6: (+1)
   \   000000A8   0x.... 0x....      ADR.W    R1,?_0
   \   000000AC   0x2002             MOVS     R0,#+2
   \   000000AE   0x.... 0x....      BL       inv_msg
    290          
    291          	return -1;
   \   000000B2   0xF04F 0x30FF      MOV      R0,#-1
   \   000000B6   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_2: (+1)
   \   000000B8   0x2A80             CMP      R2,#+128
   \   000000BA   0xD142             BNE.N    ??DynProtocol_getPayload_17
   \   000000BC   0x7D49             LDRB     R1,[R1, #+21]
   \   000000BE   0x2940             CMP      R1,#+64
   \   000000C0   0xD83C             BHI.N    ??DynProtocol_getPayload_18
   \   000000C2   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??DynProtocol_getPayload_1:
   \   000000C6   0x21 0x29          DC8      0x21,0x29,0x29,0x29
   \              0x29 0x29    
   \   000000CA   0x29 0x31          DC8      0x29,0x31,0x31,0x3B
   \              0x31 0x3B    
   \   000000CE   0x37 0x29          DC8      0x37,0x29,0x29,0x2F
   \              0x29 0x2F    
   \   000000D2   0x3B 0x37          DC8      0x3B,0x37,0x2B,0x2D
   \              0x2B 0x2D    
   \   000000D6   0x2B 0x31          DC8      0x2B,0x31,0x31,0x35
   \              0x31 0x35    
   \   000000DA   0x2F 0x3B          DC8      0x2F,0x3B,0x31,0x31
   \              0x31 0x31    
   \   000000DE   0x31 0x31          DC8      0x31,0x31,0x33,0x3B
   \              0x33 0x3B    
   \   000000E2   0x31 0x2D          DC8      0x31,0x2D,0x27,0x25
   \              0x27 0x25    
   \   000000E6   0x25 0x25          DC8      0x25,0x25,0x25,0x31
   \              0x25 0x31    
   \   000000EA   0x23 0x3B          DC8      0x23,0x3B,0x3B,0x3B
   \              0x3B 0x3B    
   \   000000EE   0x3B 0x3B          DC8      0x3B,0x3B,0x3B,0x3B
   \              0x3B 0x3B    
   \   000000F2   0x3B 0x3B          DC8      0x3B,0x3B,0x3B,0x31
   \              0x3B 0x31    
   \   000000F6   0x31 0x39          DC8      0x31,0x39,0x39,0x39
   \              0x39 0x39    
   \   000000FA   0x39 0x39          DC8      0x39,0x39,0x39,0x39
   \              0x39 0x39    
   \   000000FE   0x39 0x33          DC8      0x39,0x33,0x31,0x3B
   \              0x31 0x3B    
   \   00000102   0x3B 0x37          DC8      0x3B,0x37,0x3B,0x3B
   \              0x3B 0x3B    
   \   00000106   0x2D 0x00          DC8      0x2D,0x0
   \                     ??DynProtocol_getPayload_19: (+1)
   \   00000108   0xB200             SXTH     R0,R0
   \   0000010A   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_20: (+1)
   \   0000010C   0x2016             MOVS     R0,#+22
   \   0000010E   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_21: (+1)
   \   00000110   0x200C             MOVS     R0,#+12
   \   00000112   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_22: (+1)
   \   00000114   0x2014             MOVS     R0,#+20
   \   00000116   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_23: (+1)
   \   00000118   0x200D             MOVS     R0,#+13
   \   0000011A   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_24: (+1)
   \   0000011C   0x2013             MOVS     R0,#+19
   \   0000011E   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_25: (+1)
   \   00000120   0x200F             MOVS     R0,#+15
   \   00000122   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_26: (+1)
   \   00000124   0x2011             MOVS     R0,#+17
   \   00000126   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_27: (+1)
   \   00000128   0x200A             MOVS     R0,#+10
   \   0000012A   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_28: (+1)
   \   0000012C   0x200B             MOVS     R0,#+11
   \   0000012E   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_29: (+1)
   \   00000130   0x200E             MOVS     R0,#+14
   \   00000132   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_30: (+1)
   \   00000134   0x2008             MOVS     R0,#+8
   \   00000136   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_14: (+1)
   \   00000138   0x2047             MOVS     R0,#+71
   \   0000013A   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_18: (+1)
   \   0000013C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000140   0xBD10             POP      {R4,PC}
   \                     ??DynProtocol_getPayload_17: (+1)
   \   00000142   0xF9B1 0x0010      LDRSH    R0,[R1, #+16]
   \   00000146   0xBD10             POP      {R4,PC}          ;; return
    292          }
    293          

   \                                 In section .text, align 4, keep-with-next
    294          static int DynProtocol_decodeSensorEvent(DynProtocol_t * self, const uint8_t * buffer, uint16_t size,
    295          		DynProtocolEdata_t *edata, enum DynProtocolEtype etype)
    296          {
   \                     DynProtocol_decodeSensorEvent: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0x469A             MOV      R10,R3
    297          	uint16_t idx = 0, i=0;
   \   0000000E   0x2700             MOVS     R7,#+0
    298          	uint32_t *sensorStatus;
    299          	VSensorDataAny *vSensordata;
    300          
    301          	switch(etype) {
   \   00000010   0xF99D 0x0028      LDRSB    R0,[SP, #+40]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD003             BEQ.N    ??DynProtocol_decodeSensorEvent_1
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xF000 0x807B      BEQ.W    ??DynProtocol_decodeSensorEvent_2
   \   0000001E   0xE07E             B.N      ??DynProtocol_decodeSensorEvent_3
    302          	case DYN_PROTOCOL_ETYPE_RESP:
    303          		sensorStatus = &edata->d.response.sensorData.status;
   \                     ??DynProtocol_decodeSensorEvent_1: (+1)
   \   00000020   0xF10A 0x0908      ADD      R9,R10,#+8
    304          		vSensordata = &edata->d.response.sensorData.vdata;
   \   00000024   0xF10A 0x080C      ADD      R8,R10,#+12
    305          		break;
    306          	case DYN_PROTOCOL_ETYPE_ASYNC:
    307          		sensorStatus = &edata->d.async.sensorEvent.status;
    308          		vSensordata = &edata->d.async.sensorEvent.vdata;
    309          		break;
    310          	case DYN_PROTOCOL_ETYPE_CMD:
    311          	default:
    312          		return INV_ERROR_BAD_ARG;
    313          	}
    314          
    315          	memset(vSensordata, 0, sizeof(VSensorDataAny));
   \                     ??DynProtocol_decodeSensorEvent_4: (+1)
   \   00000028   0x463A             MOV      R2,R7
   \   0000002A   0x2148             MOVS     R1,#+72
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x.... 0x....      BL       __aeabi_memset4
    316          
    317          	*sensorStatus    = (uint32_t)(buffer[idx] & 0x03);
   \   00000032   0x7828             LDRB     R0,[R5, #+0]
   \   00000034   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000038   0xF8C9 0x0000      STR      R0,[R9, #+0]
    318          	idx += 1;
    319          	edata->sensor_id = (int)(buffer[idx]);
   \   0000003C   0x7868             LDRB     R0,[R5, #+1]
   \   0000003E   0xF8CA 0x0000      STR      R0,[R10, #+0]
    320          	idx += 1;
    321          
    322          	vSensordata->base.timestamp = (uint32_t)inv_dc_little8_to_int32(&buffer[idx]);
   \   00000042   0x1CA8             ADDS     R0,R5,#+2
   \   00000044   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   00000048   0xF8C8 0x0000      STR      R0,[R8, #+0]
    323          	idx += 4;
   \   0000004C   0xF04F 0x0906      MOV      R9,#+6
    324          
    325          	switch(edata->sensor_id) {
   \   00000050   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000054   0x2840             CMP      R0,#+64
   \   00000056   0xF200 0x81D1      BHI.W    ??DynProtocol_decodeSensorEvent_5
   \   0000005A   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??DynProtocol_decodeSensorEvent_0:
   \   0000005E   0x0055 0x0041      DC16     0x55,0x41,0x63,0x16A
   \              0x0063 0x016A
   \   00000066   0x0097 0x017E      DC16     0x97,0x17E,0x164,0x1CF
   \              0x0164 0x01CF
   \   0000006E   0x0184 0x0041      DC16     0x184,0x41,0x41,0xE5
   \              0x0041 0x00E5
   \   00000076   0x01CF 0x012C      DC16     0x1CF,0x12C,0x77,0xD1
   \              0x0077 0x00D1
   \   0000007E   0x00AE 0x015E      DC16     0xAE,0x15E,0x15E,0x13C
   \              0x015E 0x013C
   \   00000086   0x00E5 0x01CF      DC16     0xE5,0x1CF,0x15E,0x15E
   \              0x015E 0x015E
   \   0000008E   0x015E 0x015E      DC16     0x15E,0x15E,0x148,0x1CF
   \              0x0148 0x01CF
   \   00000096   0x015E 0x00D1      DC16     0x15E,0xD1,0x18A,0x11A
   \              0x018A 0x011A
   \   0000009E   0x011A 0x011A      DC16     0x11A,0x11A,0x11A,0x136
   \              0x011A 0x0136
   \   000000A6   0x01BD 0x01CF      DC16     0x1BD,0x1CF,0x1CF,0x1CF
   \              0x01CF 0x01CF
   \   000000AE   0x01CF 0x01CF      DC16     0x1CF,0x1CF,0x1CF,0x1CF
   \              0x01CF 0x01CF
   \   000000B6   0x01CF 0x01CF      DC16     0x1CF,0x1CF,0x1CF,0x15E
   \              0x01CF 0x015E
   \   000000BE   0x015E 0x01AD      DC16     0x15E,0x1AD,0x1AD,0x1AD
   \              0x01AD 0x01AD
   \   000000C6   0x01AD 0x01AD      DC16     0x1AD,0x1AD,0x1AD,0x1AD
   \              0x01AD 0x01AD
   \   000000CE   0x01AD 0x0153      DC16     0x1AD,0x153,0x15E,0x1CF
   \              0x015E 0x01CF
   \   000000D6   0x01CF 0x0105      DC16     0x1CF,0x105,0x1CF,0x1CF
   \              0x01CF 0x01CF
   \   000000DE   0x00D1             DC16     0xD1
    326          	case DYN_PRO_SENSOR_TYPE_RESERVED:
    327          		break;
    328          	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
    329          	case DYN_PRO_SENSOR_TYPE_GRAVITY:
    330          	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
    331          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.acc, 16, (int32_t*)&vSensordata->data.u32[0]);
   \                     ??DynProtocol_decodeSensorEvent_6: (+1)
   \   000000E0   0xF108 0x0008      ADD      R0,R8,#+8
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0x2310             MOVS     R3,#+16
   \   000000E8   0xF894 0x2114      LDRB     R2,[R4, #+276]
   \   000000EC   0x2103             MOVS     R1,#+3
   \   000000EE   0x1DA8             ADDS     R0,R5,#+6
   \   000000F0   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   000000F4   0x1D80             ADDS     R0,R0,#+6
   \   000000F6   0xB280             UXTH     R0,R0
    332          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
   \   000000F8   0x4601             MOV      R1,R0
   \   000000FA   0x5C69             LDRB     R1,[R5, R1]
   \   000000FC   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   00000100   0xF100 0x0901      ADD      R9,R0,#+1
   \   00000104   0xFA1F 0xF989      UXTH     R9,R9
    333          		break;
    334          	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
    335          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
    336          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
    337          		break;
    338          	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
    339          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
    340          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[3]);
    341          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
    342          		break;
    343          	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
    344          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
    345          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
    346          		break;
    347          	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
    348          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
    349          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[3]);
    350          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
    351          		break;
    352          	case DYN_PRO_SENSOR_TYPE_3AXIS:
    353          	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
    354          	case DYN_PRO_SENSOR_TYPE_PREDICTIVE_QUATERNION:
    355          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 4, PROTOCOL_QUATERNION_PRECISION, 30, (int32_t*)&vSensordata->data.u32[0]);
    356          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
    357          		break;
    358          	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
    359          	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
    360          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 4, PROTOCOL_QUATERNION_PRECISION, 30, (int32_t*)&vSensordata->data.u32[0]);
    361          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_HEADING_ACCURACY_PRECISION, 16, (int32_t*)&vSensordata->data.u32[4]);
    362          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
    363          		break;
    364          	case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
    365          		vSensordata->base.timestamp = 0;
    366          		idx -= 4;
    367          		vSensordata->data.u32[0] = inv_dc_le_to_int16(&buffer[idx]);
    368          		vSensordata->data.u32[1] = inv_dc_le_to_int16(&buffer[idx+2]);
    369          		vSensordata->data.u32[2] = inv_dc_le_to_int16(&buffer[idx+4]);
    370          		break;
    371          	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
    372          	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
    373          	case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
    374          	case DYN_PRO_SENSOR_TYPE_OIS:
    375          		vSensordata->data.u32[0] = inv_dc_le_to_int16(&buffer[idx]);
    376          		vSensordata->data.u32[1] = inv_dc_le_to_int16(&buffer[idx+2]);
    377          		vSensordata->data.u32[2] = inv_dc_le_to_int16(&buffer[idx+4]);
    378          		break;
    379          	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
    380          		DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_TEMPERATURE_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
    381          		break;
    382          	case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
    383          		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
    384          		break;
    385          	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
    386          		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
    387          		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx+4]);
    388          		break;
    389          	case DYN_PRO_SENSOR_TYPE_BAC:
    390          		vSensordata->data.u8[0] = buffer[idx++];
    391          		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
    392          		break;
    393          	case DYN_PRO_SENSOR_TYPE_WOM:
    394          		vSensordata->data.u8[0] = buffer[idx++];
    395          		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
    396          		break;
    397          	case DYN_PRO_SENSOR_TYPE_B2S:
    398          	case DYN_PRO_SENSOR_TYPE_SHAKE:
    399          	case DYN_PRO_SENSOR_TYPE_DOUBLE_TAP:
    400          	case DYN_PRO_SENSOR_TYPE_SEDENTARY_REMIND:
    401          	case DYN_PRO_SENSOR_TYPE_SMD:
    402          	case DYN_PRO_SENSOR_TYPE_STEP_DETECTOR:
    403          	case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:
    404          	case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:
    405          	case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
    406          	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
    407          		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
    408          		break;
    409          	case DYN_PRO_SENSOR_TYPE_PRESSURE:
    410          		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
    411          		break;
    412          	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
    413          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_ORIENTATION_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
    414          		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
    415          		break;
    416          	case DYN_PRO_SENSOR_TYPE_LIGHT:
    417          		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
    418          		break;
    419          	case DYN_PRO_SENSOR_TYPE_PROXIMITY:
    420          		vSensordata->data.u32[0] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);
    421          		break;
    422          	case DYN_PRO_SENSOR_TYPE_EIS:
    423          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
    424          		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[3]);
    425          		vSensordata->data.u32[6] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);;
    426          		break;
    427          	case DYN_PRO_SENSOR_TYPE_CUSTOM0:
    428          	case DYN_PRO_SENSOR_TYPE_CUSTOM1:
    429          	case DYN_PRO_SENSOR_TYPE_CUSTOM2:
    430          	case DYN_PRO_SENSOR_TYPE_CUSTOM3:
    431          	case DYN_PRO_SENSOR_TYPE_CUSTOM4:
    432          	case DYN_PRO_SENSOR_TYPE_CUSTOM5:
    433          	case DYN_PRO_SENSOR_TYPE_CUSTOM6:
    434          	case DYN_PRO_SENSOR_TYPE_CUSTOM7:
    435          	{
    436          		/* meta data contains size of custom sensors.
    437          		 * Check size is not bigger than VSensorData array */
    438          		vSensordata->base.meta_data = buffer[idx++];
    439          		if(vSensordata->base.meta_data > sizeof(vSensordata->data.u8))
    440          			return -1;
    441          
    442          		memcpy(vSensordata->data.u8, &buffer[idx], vSensordata->base.meta_data);
    443          		//hard code the payload size until payload has a fixed value for custom sensors
    444          		idx += sizeof(vSensordata->data.u8);
    445          		break;
    446          	}
    447          
    448          	case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
    449          		for (i=0; i<4; i++) {
    450          			vSensordata->data.u32[i] = inv_dc_little8_to_int32(&buffer[idx]); // raw pressure
    451          			idx += 4;
    452          		}
    453          		break;
    454          
    455          	default:
    456          		return -1;
    457          	}
    458          
    459          	// check if we did not read more bytes than actually transfered by protocol
    460          	if(idx > size)
   \                     ??DynProtocol_decodeSensorEvent_7: (+1)
   \   00000108   0x454E             CMP      R6,R9
   \   0000010A   0xF080 0x817A      BCS.W    ??DynProtocol_decodeSensorEvent_8
    461          		return -1;
   \   0000010E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000112   0xE177             B.N      ??DynProtocol_decodeSensorEvent_9
   \                     ??DynProtocol_decodeSensorEvent_2: (+1)
   \   00000114   0xF10A 0x0904      ADD      R9,R10,#+4
   \   00000118   0xF10A 0x0808      ADD      R8,R10,#+8
   \   0000011C   0xE784             B.N      ??DynProtocol_decodeSensorEvent_4
   \                     ??DynProtocol_decodeSensorEvent_3: (+1)
   \   0000011E   0xF06F 0x000A      MVN      R0,#+10
   \   00000122   0xE16F             B.N      ??DynProtocol_decodeSensorEvent_9
   \                     ??DynProtocol_decodeSensorEvent_10: (+1)
   \   00000124   0xF108 0x0008      ADD      R0,R8,#+8
   \   00000128   0x9000             STR      R0,[SP, #+0]
   \   0000012A   0x2310             MOVS     R3,#+16
   \   0000012C   0x2204             MOVS     R2,#+4
   \   0000012E   0x2103             MOVS     R1,#+3
   \   00000130   0x1DA8             ADDS     R0,R5,#+6
   \   00000132   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   00000136   0x1D80             ADDS     R0,R0,#+6
   \   00000138   0xB280             UXTH     R0,R0
   \   0000013A   0x4601             MOV      R1,R0
   \   0000013C   0x5C69             LDRB     R1,[R5, R1]
   \   0000013E   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   00000142   0xF100 0x0901      ADD      R9,R0,#+1
   \   00000146   0xFA1F 0xF989      UXTH     R9,R9
   \   0000014A   0xE7DD             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_11: (+1)
   \   0000014C   0xF108 0x0008      ADD      R0,R8,#+8
   \   00000150   0x9000             STR      R0,[SP, #+0]
   \   00000152   0x2310             MOVS     R3,#+16
   \   00000154   0x2204             MOVS     R2,#+4
   \   00000156   0x2103             MOVS     R1,#+3
   \   00000158   0x1DA8             ADDS     R0,R5,#+6
   \   0000015A   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   0000015E   0x1D84             ADDS     R4,R0,#+6
   \   00000160   0xB2A4             UXTH     R4,R4
   \   00000162   0xF108 0x0014      ADD      R0,R8,#+20
   \   00000166   0x9000             STR      R0,[SP, #+0]
   \   00000168   0x2310             MOVS     R3,#+16
   \   0000016A   0x2204             MOVS     R2,#+4
   \   0000016C   0x2103             MOVS     R1,#+3
   \   0000016E   0x4620             MOV      R0,R4
   \   00000170   0x4428             ADD      R0,R5,R0
   \   00000172   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   00000176   0x1900             ADDS     R0,R0,R4
   \   00000178   0xB280             UXTH     R0,R0
   \   0000017A   0x4601             MOV      R1,R0
   \   0000017C   0x5C69             LDRB     R1,[R5, R1]
   \   0000017E   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   00000182   0xF100 0x0901      ADD      R9,R0,#+1
   \   00000186   0xFA1F 0xF989      UXTH     R9,R9
   \   0000018A   0xE7BD             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_12: (+1)
   \   0000018C   0xF108 0x0008      ADD      R0,R8,#+8
   \   00000190   0x9000             STR      R0,[SP, #+0]
   \   00000192   0x2310             MOVS     R3,#+16
   \   00000194   0xF44F 0x708A      MOV      R0,#+276
   \   00000198   0x4420             ADD      R0,R4,R0
   \   0000019A   0x7842             LDRB     R2,[R0, #+1]
   \   0000019C   0x2103             MOVS     R1,#+3
   \   0000019E   0x1DA8             ADDS     R0,R5,#+6
   \   000001A0   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   000001A4   0x1D80             ADDS     R0,R0,#+6
   \   000001A6   0xB280             UXTH     R0,R0
   \   000001A8   0x4601             MOV      R1,R0
   \   000001AA   0x5C69             LDRB     R1,[R5, R1]
   \   000001AC   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   000001B0   0xF100 0x0901      ADD      R9,R0,#+1
   \   000001B4   0xFA1F 0xF989      UXTH     R9,R9
   \   000001B8   0xE7A6             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_13: (+1)
   \   000001BA   0xF44F 0x708A      MOV      R0,#+276
   \   000001BE   0x4404             ADD      R4,R4,R0
   \   000001C0   0xF108 0x0008      ADD      R0,R8,#+8
   \   000001C4   0x9000             STR      R0,[SP, #+0]
   \   000001C6   0x2310             MOVS     R3,#+16
   \   000001C8   0x7862             LDRB     R2,[R4, #+1]
   \   000001CA   0x2103             MOVS     R1,#+3
   \   000001CC   0x1DA8             ADDS     R0,R5,#+6
   \   000001CE   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   000001D2   0x1D87             ADDS     R7,R0,#+6
   \   000001D4   0xB2BF             UXTH     R7,R7
   \   000001D6   0xF108 0x0014      ADD      R0,R8,#+20
   \   000001DA   0x9000             STR      R0,[SP, #+0]
   \   000001DC   0x2310             MOVS     R3,#+16
   \   000001DE   0x7862             LDRB     R2,[R4, #+1]
   \   000001E0   0x2103             MOVS     R1,#+3
   \   000001E2   0x4638             MOV      R0,R7
   \   000001E4   0x4428             ADD      R0,R5,R0
   \   000001E6   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   000001EA   0x19C0             ADDS     R0,R0,R7
   \   000001EC   0xB280             UXTH     R0,R0
   \   000001EE   0x4601             MOV      R1,R0
   \   000001F0   0x5C69             LDRB     R1,[R5, R1]
   \   000001F2   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   000001F6   0xF100 0x0901      ADD      R9,R0,#+1
   \   000001FA   0xFA1F 0xF989      UXTH     R9,R9
   \   000001FE   0xE783             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_14: (+1)
   \   00000200   0xF108 0x0008      ADD      R0,R8,#+8
   \   00000204   0x9000             STR      R0,[SP, #+0]
   \   00000206   0x231E             MOVS     R3,#+30
   \   00000208   0x220E             MOVS     R2,#+14
   \   0000020A   0x2104             MOVS     R1,#+4
   \   0000020C   0x1DA8             ADDS     R0,R5,#+6
   \   0000020E   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   00000212   0x1D80             ADDS     R0,R0,#+6
   \   00000214   0xB280             UXTH     R0,R0
   \   00000216   0x4601             MOV      R1,R0
   \   00000218   0x5C69             LDRB     R1,[R5, R1]
   \   0000021A   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   0000021E   0xF100 0x0901      ADD      R9,R0,#+1
   \   00000222   0xFA1F 0xF989      UXTH     R9,R9
   \   00000226   0xE76F             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_15: (+1)
   \   00000228   0xF108 0x0008      ADD      R0,R8,#+8
   \   0000022C   0x9000             STR      R0,[SP, #+0]
   \   0000022E   0x231E             MOVS     R3,#+30
   \   00000230   0x220E             MOVS     R2,#+14
   \   00000232   0x2104             MOVS     R1,#+4
   \   00000234   0x1DA8             ADDS     R0,R5,#+6
   \   00000236   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   0000023A   0x1D84             ADDS     R4,R0,#+6
   \   0000023C   0xB2A4             UXTH     R4,R4
   \   0000023E   0xF108 0x0018      ADD      R0,R8,#+24
   \   00000242   0x9000             STR      R0,[SP, #+0]
   \   00000244   0x2310             MOVS     R3,#+16
   \   00000246   0x2207             MOVS     R2,#+7
   \   00000248   0x2101             MOVS     R1,#+1
   \   0000024A   0x4620             MOV      R0,R4
   \   0000024C   0x4428             ADD      R0,R5,R0
   \   0000024E   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   00000252   0x1900             ADDS     R0,R0,R4
   \   00000254   0xB280             UXTH     R0,R0
   \   00000256   0x4601             MOV      R1,R0
   \   00000258   0x5C69             LDRB     R1,[R5, R1]
   \   0000025A   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   0000025E   0xF100 0x0901      ADD      R9,R0,#+1
   \   00000262   0xFA1F 0xF989      UXTH     R9,R9
   \   00000266   0xE74F             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_16: (+1)
   \   00000268   0x4638             MOV      R0,R7
   \   0000026A   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   0000026E   0xF04F 0x0902      MOV      R9,#+2
   \   00000272   0x1CA8             ADDS     R0,R5,#+2
   \   00000274   0x.... 0x....      BL       inv_dc_le_to_int16
   \   00000278   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   0000027C   0x1D28             ADDS     R0,R5,#+4
   \   0000027E   0x.... 0x....      BL       inv_dc_le_to_int16
   \   00000282   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \   00000286   0x1DA8             ADDS     R0,R5,#+6
   \   00000288   0x.... 0x....      BL       inv_dc_le_to_int16
   \   0000028C   0xF8C8 0x0010      STR      R0,[R8, #+16]
   \   00000290   0xE73A             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_17: (+1)
   \   00000292   0x1DA8             ADDS     R0,R5,#+6
   \   00000294   0x.... 0x....      BL       inv_dc_le_to_int16
   \   00000298   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   0000029C   0xF105 0x0008      ADD      R0,R5,#+8
   \   000002A0   0x.... 0x....      BL       inv_dc_le_to_int16
   \   000002A4   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \   000002A8   0xF105 0x000A      ADD      R0,R5,#+10
   \   000002AC   0x.... 0x....      BL       inv_dc_le_to_int16
   \   000002B0   0xF8C8 0x0010      STR      R0,[R8, #+16]
   \   000002B4   0xE728             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_18: (+1)
   \   000002B6   0xF108 0x0008      ADD      R0,R8,#+8
   \   000002BA   0x9000             STR      R0,[SP, #+0]
   \   000002BC   0x2310             MOVS     R3,#+16
   \   000002BE   0x2208             MOVS     R2,#+8
   \   000002C0   0x2101             MOVS     R1,#+1
   \   000002C2   0x1DA8             ADDS     R0,R5,#+6
   \   000002C4   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   000002C8   0xE71E             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_19: (+1)
   \   000002CA   0x1DA8             ADDS     R0,R5,#+6
   \   000002CC   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   000002D0   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   000002D4   0xE718             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_20: (+1)
   \   000002D6   0x1DA8             ADDS     R0,R5,#+6
   \   000002D8   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   000002DC   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   000002E0   0xF105 0x000A      ADD      R0,R5,#+10
   \   000002E4   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   000002E8   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   000002EC   0xE70C             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_21: (+1)
   \   000002EE   0x79A8             LDRB     R0,[R5, #+6]
   \   000002F0   0xF888 0x0008      STRB     R0,[R8, #+8]
   \   000002F4   0xF04F 0x0907      MOV      R9,#+7
   \   000002F8   0x1DE8             ADDS     R0,R5,#+7
   \   000002FA   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   000002FE   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   00000302   0xE701             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_22: (+1)
   \   00000304   0x79A8             LDRB     R0,[R5, #+6]
   \   00000306   0xF888 0x0008      STRB     R0,[R8, #+8]
   \   0000030A   0xF04F 0x0907      MOV      R9,#+7
   \   0000030E   0x1DE8             ADDS     R0,R5,#+7
   \   00000310   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   00000314   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   00000318   0xE6F6             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_23: (+1)
   \   0000031A   0x1DA8             ADDS     R0,R5,#+6
   \   0000031C   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   00000320   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   00000324   0xE6F0             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_24: (+1)
   \   00000326   0x1DA8             ADDS     R0,R5,#+6
   \   00000328   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   0000032C   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   00000330   0xE6EA             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_25: (+1)
   \   00000332   0xF108 0x0008      ADD      R0,R8,#+8
   \   00000336   0x9000             STR      R0,[SP, #+0]
   \   00000338   0x2310             MOVS     R3,#+16
   \   0000033A   0x464A             MOV      R2,R9
   \   0000033C   0x2103             MOVS     R1,#+3
   \   0000033E   0x1DA8             ADDS     R0,R5,#+6
   \   00000340   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   00000344   0x1D80             ADDS     R0,R0,#+6
   \   00000346   0xB280             UXTH     R0,R0
   \   00000348   0x4601             MOV      R1,R0
   \   0000034A   0x5C69             LDRB     R1,[R5, R1]
   \   0000034C   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   00000350   0xF100 0x0901      ADD      R9,R0,#+1
   \   00000354   0xFA1F 0xF989      UXTH     R9,R9
   \   00000358   0xE6D6             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_26: (+1)
   \   0000035A   0x1DA8             ADDS     R0,R5,#+6
   \   0000035C   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   00000360   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   00000364   0xE6D0             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_27: (+1)
   \   00000366   0x1DA8             ADDS     R0,R5,#+6
   \   00000368   0x.... 0x....      BL       inv_dc_le_to_int16
   \   0000036C   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   00000370   0xE6CA             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_28: (+1)
   \   00000372   0xF44F 0x708A      MOV      R0,#+276
   \   00000376   0x4404             ADD      R4,R4,R0
   \   00000378   0xF108 0x0008      ADD      R0,R8,#+8
   \   0000037C   0x9000             STR      R0,[SP, #+0]
   \   0000037E   0x2310             MOVS     R3,#+16
   \   00000380   0x7862             LDRB     R2,[R4, #+1]
   \   00000382   0x2103             MOVS     R1,#+3
   \   00000384   0x1DA8             ADDS     R0,R5,#+6
   \   00000386   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   0000038A   0x1D87             ADDS     R7,R0,#+6
   \   0000038C   0xB2BF             UXTH     R7,R7
   \   0000038E   0xF108 0x0014      ADD      R0,R8,#+20
   \   00000392   0x9000             STR      R0,[SP, #+0]
   \   00000394   0x2310             MOVS     R3,#+16
   \   00000396   0x7862             LDRB     R2,[R4, #+1]
   \   00000398   0x2103             MOVS     R1,#+3
   \   0000039A   0x4638             MOV      R0,R7
   \   0000039C   0x4428             ADD      R0,R5,R0
   \   0000039E   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
   \   000003A2   0xEB00 0x0907      ADD      R9,R0,R7
   \   000003A6   0xFA1F 0xF989      UXTH     R9,R9
   \   000003AA   0xEB05 0x0009      ADD      R0,R5,R9
   \   000003AE   0x.... 0x....      BL       inv_dc_le_to_int16
   \   000003B2   0xF8C8 0x0020      STR      R0,[R8, #+32]
   \   000003B6   0xE6A7             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_29: (+1)
   \   000003B8   0x79AA             LDRB     R2,[R5, #+6]
   \   000003BA   0xF8C8 0x2004      STR      R2,[R8, #+4]
   \   000003BE   0x2A41             CMP      R2,#+65
   \   000003C0   0xD302             BCC.N    ??DynProtocol_decodeSensorEvent_30
   \   000003C2   0xF04F 0x30FF      MOV      R0,#-1
   \   000003C6   0xE01D             B.N      ??DynProtocol_decodeSensorEvent_9
   \                     ??DynProtocol_decodeSensorEvent_30: (+1)
   \   000003C8   0x1DE9             ADDS     R1,R5,#+7
   \   000003CA   0xF108 0x0008      ADD      R0,R8,#+8
   \   000003CE   0x.... 0x....      BL       __aeabi_memcpy
   \   000003D2   0xF04F 0x0947      MOV      R9,#+71
   \   000003D6   0xE697             B.N      ??DynProtocol_decodeSensorEvent_7
   \                     ??DynProtocol_decodeSensorEvent_31: (+1)
   \   000003D8   0xB2BF             UXTH     R7,R7
   \   000003DA   0x463C             MOV      R4,R7
   \   000003DC   0x2C04             CMP      R4,#+4
   \   000003DE   0xF6BF 0xAE93      BGE.W    ??DynProtocol_decodeSensorEvent_7
   \   000003E2   0xEB05 0x0009      ADD      R0,R5,R9
   \   000003E6   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   000003EA   0xEB08 0x0184      ADD      R1,R8,R4, LSL #+2
   \   000003EE   0x6088             STR      R0,[R1, #+8]
   \   000003F0   0xF109 0x0904      ADD      R9,R9,#+4
   \   000003F4   0xFA1F 0xF989      UXTH     R9,R9
   \   000003F8   0x1C7F             ADDS     R7,R7,#+1
   \   000003FA   0xE7ED             B.N      ??DynProtocol_decodeSensorEvent_31
   \                     ??DynProtocol_decodeSensorEvent_5: (+1)
   \   000003FC   0xF04F 0x30FF      MOV      R0,#-1
   \   00000400   0xE000             B.N      ??DynProtocol_decodeSensorEvent_9
    462          
    463          	return 0;
   \                     ??DynProtocol_decodeSensorEvent_8: (+1)
   \   00000402   0x2000             MOVS     R0,#+0
   \                     ??DynProtocol_decodeSensorEvent_9: (+1)
   \   00000404   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    464          
    465          }
    466          

   \                                 In section .text, align 4, keep-with-next
    467          static int DynProtocol_decodePktCommand(DynProtocol_t * self,
    468          		struct DynProtocolEdata * edata)
    469          {
   \                     DynProtocol_decodePktCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
    470          	int i, precision;
    471          	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
    472          
    473          	if(self->decode_state_machine.cmd_id == DYN_PROTOCOL_EID_PROTOCOLVERSION) {
   \   00000008   0x7BA8             LDRB     R0,[R5, #+14]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??DynProtocol_decodePktCommand_1
    474          		edata->sensor_id = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6020             STR      R0,[R4, #+0]
   \   00000012   0xE060             B.N      ??DynProtocol_decodePktCommand_2
    475          	}
    476          	else {
    477          		edata->sensor_id = buf[0];
   \                     ??DynProtocol_decodePktCommand_1: (+1)
   \   00000014   0x7D28             LDRB     R0,[R5, #+20]
   \   00000016   0x6020             STR      R0,[R4, #+0]
    478          
    479          		switch(self->decode_state_machine.cmd_id) {
   \   00000018   0x7BA8             LDRB     R0,[R5, #+14]
   \   0000001A   0x381B             SUBS     R0,R0,#+27
   \   0000001C   0x2809             CMP      R0,#+9
   \   0000001E   0xD85A             BHI.N    ??DynProtocol_decodePktCommand_2
   \   00000020   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??DynProtocol_decodePktCommand_0:
   \   00000024   0x05 0x0B          DC8      0x5,0xB,0x59,0x49
   \              0x59 0x49    
   \   00000028   0x46 0x11          DC8      0x46,0x11,0x59,0x20
   \              0x59 0x20    
   \   0000002C   0x23 0x46          DC8      0x23,0x46
    480          		case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:
    481          			edata->d.command.period = (uint32_t)inv_dc_little8_to_int32(&buf[1]);
   \                     ??DynProtocol_decodePktCommand_3: (+1)
   \   0000002E   0xF105 0x0015      ADD      R0,R5,#+21
   \   00000032   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   00000036   0x6060             STR      R0,[R4, #+4]
    482          			break;
   \   00000038   0xE04D             B.N      ??DynProtocol_decodePktCommand_2
    483          
    484          		case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT:
    485          			edata->d.command.timeout = (uint32_t)inv_dc_little8_to_int32(&buf[1]);
   \                     ??DynProtocol_decodePktCommand_4: (+1)
   \   0000003A   0xF105 0x0015      ADD      R0,R5,#+21
   \   0000003E   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   00000042   0x6060             STR      R0,[R4, #+4]
    486          			break;
   \   00000044   0xE047             B.N      ??DynProtocol_decodePktCommand_2
    487          
    488          		case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX:
    489          		{
    490          			edata->d.command.cfg.base.type = buf[1];
   \                     ??DynProtocol_decodePktCommand_5: (+1)
   \   00000046   0x7D68             LDRB     R0,[R5, #+21]
   \   00000048   0x6060             STR      R0,[R4, #+4]
    491          			for (i = 0; i < 9; i++)
   \   0000004A   0x2600             MOVS     R6,#+0
   \                     ??DynProtocol_decodePktCommand_6: (+1)
   \   0000004C   0x2E09             CMP      R6,#+9
   \   0000004E   0xDA42             BGE.N    ??DynProtocol_decodePktCommand_2
    492          				((VSensorConfigReferenceFrame *)&edata->d.command.cfg)->matrix[i] = (intq30_t) inv_dc_little8_to_int32(&buf[2 + i * 4]);
   \   00000050   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \   00000054   0x3016             ADDS     R0,R0,#+22
   \   00000056   0x.... 0x....      BL       inv_dc_little8_to_int32
   \   0000005A   0xEB04 0x0186      ADD      R1,R4,R6, LSL #+2
   \   0000005E   0x6088             STR      R0,[R1, #+8]
   \   00000060   0x1C76             ADDS     R6,R6,#+1
   \   00000062   0xE7F3             B.N      ??DynProtocol_decodePktCommand_6
    493          			break;
    494          		}
    495          
    496          		case DYN_PROTOCOL_EID_GET_SW_REG:
    497          			edata->d.command.regAddr = buf[1];
   \                     ??DynProtocol_decodePktCommand_7: (+1)
   \   00000064   0x7D68             LDRB     R0,[R5, #+21]
   \   00000066   0x7120             STRB     R0,[R4, #+4]
    498          			break;
   \   00000068   0xE035             B.N      ??DynProtocol_decodePktCommand_2
    499          
    500          		case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
    501          		{
    502          			edata->d.command.cfg.base.type = buf[1];
   \                     ??DynProtocol_decodePktCommand_8: (+1)
   \   0000006A   0x7D68             LDRB     R0,[R5, #+21]
   \   0000006C   0x6060             STR      R0,[R4, #+4]
    503          			edata->d.command.cfg.size = buf[2];
   \   0000006E   0x7DA8             LDRB     R0,[R5, #+22]
   \   00000070   0x7220             STRB     R0,[R4, #+8]
    504          
    505          			switch (edata->d.command.cfg.base.type) {
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0x2803             CMP      R0,#+3
   \   00000076   0xD10E             BNE.N    ??DynProtocol_decodePktCommand_9
    506          			case VSENSOR_CONFIG_TYPE_OFFSET:
    507          			{
    508          				precision = DynProtocol_getPrecision(self, edata->sensor_id);
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0x.... 0x....      BL       DynProtocol_getPrecision
    509          				DynProtocol_decodeVect16QxToQy(&buf[3], 3, precision, 16, (int32_t*)&edata->d.command.cfg.buffer[0]);
   \   00000080   0xF104 0x0109      ADD      R1,R4,#+9
   \   00000084   0x9100             STR      R1,[SP, #+0]
   \   00000086   0x2310             MOVS     R3,#+16
   \   00000088   0x4602             MOV      R2,R0
   \   0000008A   0x2103             MOVS     R1,#+3
   \   0000008C   0xF105 0x0017      ADD      R0,R5,#+23
   \   00000090   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
    510          				break;
   \   00000094   0xE01F             B.N      ??DynProtocol_decodePktCommand_2
    511          			}
    512          
    513          			default:
    514          				if(buf[2] > sizeof(edata->d.command.cfg.buffer))
   \                     ??DynProtocol_decodePktCommand_9: (+1)
   \   00000096   0x7DAA             LDRB     R2,[R5, #+22]
   \   00000098   0x2A41             CMP      R2,#+65
   \   0000009A   0xD302             BCC.N    ??DynProtocol_decodePktCommand_10
    515          					return -1;
   \   0000009C   0xF04F 0x30FF      MOV      R0,#-1
   \   000000A0   0xBD76             POP      {R1,R2,R4-R6,PC}
    516          
    517          				memcpy(edata->d.command.cfg.buffer, &buf[3], buf[2]);
   \                     ??DynProtocol_decodePktCommand_10: (+1)
   \   000000A2   0xF105 0x0117      ADD      R1,R5,#+23
   \   000000A6   0xF104 0x0009      ADD      R0,R4,#+9
   \   000000AA   0x.... 0x....      BL       __aeabi_memcpy
    518          				break;
   \   000000AE   0xE012             B.N      ??DynProtocol_decodePktCommand_2
    519          			}
    520          			break;
    521          		}
    522          
    523          		case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
    524          			edata->d.command.cfg.base.type = buf[1];
    525          			break;
    526          
    527          		case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
    528          			edata->d.command.cfg.base.type = buf[1];
   \                     ??DynProtocol_decodePktCommand_11: (+1)
   \   000000B0   0x7D68             LDRB     R0,[R5, #+21]
   \   000000B2   0x6060             STR      R0,[R4, #+4]
    529          			break;
   \   000000B4   0xE00F             B.N      ??DynProtocol_decodePktCommand_2
    530          
    531          		case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:
    532          			edata->d.command.cfg.base.type = buf[1];
   \                     ??DynProtocol_decodePktCommand_12: (+1)
   \   000000B6   0x7D68             LDRB     R0,[R5, #+21]
   \   000000B8   0x6060             STR      R0,[R4, #+4]
    533          			precision = DynProtocol_getPrecision(self, edata->sensor_id);
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x4628             MOV      R0,R5
   \   000000BE   0x.... 0x....      BL       DynProtocol_getPrecision
    534          			DynProtocol_decodeVect16QxToQy(&buf[2], 3, precision, 16, &((VSensorConfigOffset *)&edata->d.command.cfg)->vect[0]);
   \   000000C2   0xF104 0x0108      ADD      R1,R4,#+8
   \   000000C6   0x9100             STR      R1,[SP, #+0]
   \   000000C8   0x2310             MOVS     R3,#+16
   \   000000CA   0x4602             MOV      R2,R0
   \   000000CC   0x2103             MOVS     R1,#+3
   \   000000CE   0xF105 0x0016      ADD      R0,R5,#+22
   \   000000D2   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
    535          			break;
    536          
    537          		default:
    538          			break;
    539          		}
    540          	}
    541          
    542          	return 0;
   \                     ??DynProtocol_decodePktCommand_2: (+1)
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    543          }
    544          

   \                                 In section .text, align 2, keep-with-next
    545          static int DynProtocol_decodePktResponse(DynProtocol_t * self,
    546          		struct DynProtocolEdata * edata)
    547          {
   \                     DynProtocol_decodePktResponse: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460C             MOV      R4,R1
    548          	int precision;
    549          	int rc = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    550          	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
    551          	const uint16_t len = self->decode_state_machine.received_size;
   \   0000000A   0x8A72             LDRH     R2,[R6, #+18]
    552          
    553          	switch(self->decode_state_machine.cmd_id) {
   \   0000000C   0x7BB0             LDRB     R0,[R6, #+14]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD008             BEQ.N    ??DynProtocol_decodePktResponse_0
   \   00000012   0x2816             CMP      R0,#+22
   \   00000014   0xD006             BEQ.N    ??DynProtocol_decodePktResponse_0
   \   00000016   0x281F             CMP      R0,#+31
   \   00000018   0xD044             BEQ.N    ??DynProtocol_decodePktResponse_1
   \   0000001A   0x2821             CMP      R0,#+33
   \   0000001C   0xD00B             BEQ.N    ??DynProtocol_decodePktResponse_2
   \   0000001E   0x2824             CMP      R0,#+36
   \   00000020   0xD018             BEQ.N    ??DynProtocol_decodePktResponse_3
   \   00000022   0xE056             B.N      ??DynProtocol_decodePktResponse_4
    554          	case DYN_PROTOCOL_EID_PROTOCOLVERSION:
    555          	case DYN_PROTOCOL_EID_GET_FW_INFO:
    556          		memcpy(edata->d.response.version, buf, sizeof(edata->d.response.version) - 1);
   \                     ??DynProtocol_decodePktResponse_0: (+1)
   \   00000024   0x220F             MOVS     R2,#+15
   \   00000026   0xF106 0x0114      ADD      R1,R6,#+20
   \   0000002A   0x1D20             ADDS     R0,R4,#+4
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy4
    557          		edata->d.response.version[sizeof(edata->d.response.version)-1] = '\0';
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x74E0             STRB     R0,[R4, #+19]
    558          		break;
   \   00000034   0xE050             B.N      ??DynProtocol_decodePktResponse_5
   \                     ??DynProtocol_decodePktResponse_2: (+1)
   \   00000036   0xF996 0x0014      LDRSB    R0,[R6, #+20]
   \   0000003A   0x6060             STR      R0,[R4, #+4]
    559          
    560          	case DYN_PROTOCOL_EID_GET_SENSOR_DATA:
    561          	{
    562          		edata->d.response.sensorData.rc = (int)(int8_t)buf[0];
    563          		if(edata->d.response.sensorData.rc == 0)
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD14B             BNE.N    ??DynProtocol_decodePktResponse_5
    564          			rc = DynProtocol_decodeSensorEvent(self, &buf[1], len, edata, DYN_PROTOCOL_ETYPE_RESP);
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x4623             MOV      R3,R4
   \   00000046   0xF106 0x0115      ADD      R1,R6,#+21
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       DynProtocol_decodeSensorEvent
   \   00000050   0x4605             MOV      R5,R0
   \   00000052   0xE041             B.N      ??DynProtocol_decodePktResponse_5
    565          		break;
    566          	}
    567          
    568          	case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
    569          	{
    570          		edata->d.response.sensorcfg.rc = (int)(int8_t)buf[0];
   \                     ??DynProtocol_decodePktResponse_3: (+1)
   \   00000054   0xF996 0x0014      LDRSB    R0,[R6, #+20]
   \   00000058   0x6060             STR      R0,[R4, #+4]
    571          		edata->d.response.sensorcfg.cfg.base.type = buf[1];
   \   0000005A   0x7D70             LDRB     R0,[R6, #+21]
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
    572          		edata->d.response.sensorcfg.cfg.size = buf[2];
   \   0000005E   0x7DB0             LDRB     R0,[R6, #+22]
   \   00000060   0x7320             STRB     R0,[R4, #+12]
    573          
    574          		switch (edata->d.response.sensorcfg.cfg.base.type) {
   \   00000062   0x68A0             LDR      R0,[R4, #+8]
   \   00000064   0x2803             CMP      R0,#+3
   \   00000066   0xD110             BNE.N    ??DynProtocol_decodePktResponse_6
    575          		case VSENSOR_CONFIG_TYPE_OFFSET:
    576          		{
    577          			edata->sensor_id = (int)(int8_t)buf[3];
   \   00000068   0xF996 0x1017      LDRSB    R1,[R6, #+23]
   \   0000006C   0x6021             STR      R1,[R4, #+0]
    578          			precision = DynProtocol_getPrecision(self, edata->sensor_id);
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x.... 0x....      BL       DynProtocol_getPrecision
    579          			DynProtocol_decodeVect16QxToQy(&buf[4], 3, precision, 16, (int32_t*)&edata->d.response.sensorcfg.cfg.buffer[0]);
   \   00000074   0xF104 0x010D      ADD      R1,R4,#+13
   \   00000078   0x9100             STR      R1,[SP, #+0]
   \   0000007A   0x2310             MOVS     R3,#+16
   \   0000007C   0x4602             MOV      R2,R0
   \   0000007E   0x2103             MOVS     R1,#+3
   \   00000080   0xF106 0x0018      ADD      R0,R6,#+24
   \   00000084   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
    580          			break;
   \   00000088   0xE026             B.N      ??DynProtocol_decodePktResponse_5
    581          		}
    582          
    583          		default:
    584          			if(buf[2] > sizeof(edata->d.response.sensorcfg.cfg.buffer))
   \                     ??DynProtocol_decodePktResponse_6: (+1)
   \   0000008A   0x7DB2             LDRB     R2,[R6, #+22]
   \   0000008C   0x2A41             CMP      R2,#+65
   \   0000008E   0xD302             BCC.N    ??DynProtocol_decodePktResponse_7
    585          				return -1;
   \   00000090   0xF04F 0x30FF      MOV      R0,#-1
   \   00000094   0xBD76             POP      {R1,R2,R4-R6,PC}
    586          
    587          			memcpy(edata->d.response.sensorcfg.cfg.buffer, &buf[3], buf[2]);
   \                     ??DynProtocol_decodePktResponse_7: (+1)
   \   00000096   0xF106 0x0117      ADD      R1,R6,#+23
   \   0000009A   0xF104 0x000D      ADD      R0,R4,#+13
   \   0000009E   0x.... 0x....      BL       __aeabi_memcpy
    588          			break;
   \   000000A2   0xE019             B.N      ??DynProtocol_decodePktResponse_5
    589          		}
    590          
    591          		break;
    592          	}
    593          
    594          	case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
    595          		edata->d.response.sensorcfg.rc = (int)(int8_t)buf[0];
   \                     ??DynProtocol_decodePktResponse_1: (+1)
   \   000000A4   0xF996 0x0014      LDRSB    R0,[R6, #+20]
   \   000000A8   0x6060             STR      R0,[R4, #+4]
    596          		edata->sensor_id = (int)(int8_t)buf[1];
   \   000000AA   0xF996 0x0015      LDRSB    R0,[R6, #+21]
   \   000000AE   0x6020             STR      R0,[R4, #+0]
    597          		edata->d.response.sensorcfg.cfg.base.type = buf[2];
   \   000000B0   0x7DB0             LDRB     R0,[R6, #+22]
   \   000000B2   0x60A0             STR      R0,[R4, #+8]
    598          		precision = DynProtocol_getPrecision(self, edata->sensor_id);
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x4630             MOV      R0,R6
   \   000000B8   0x.... 0x....      BL       DynProtocol_getPrecision
    599          		DynProtocol_decodeVect16QxToQy(&buf[3], 3, precision, 16, &((VSensorConfigOffset *)&edata->d.response.sensorcfg.cfg)->vect[0]);
   \   000000BC   0xF104 0x010C      ADD      R1,R4,#+12
   \   000000C0   0x9100             STR      R1,[SP, #+0]
   \   000000C2   0x2310             MOVS     R3,#+16
   \   000000C4   0x4602             MOV      R2,R0
   \   000000C6   0x2103             MOVS     R1,#+3
   \   000000C8   0xF106 0x0017      ADD      R0,R6,#+23
   \   000000CC   0x.... 0x....      BL       DynProtocol_decodeVect16QxToQy
    600          		break;
   \   000000D0   0xE002             B.N      ??DynProtocol_decodePktResponse_5
    601          
    602          	default:
    603          		edata->d.response.rc = (int)(int8_t)buf[0];
   \                     ??DynProtocol_decodePktResponse_4: (+1)
   \   000000D2   0xF996 0x0014      LDRSB    R0,[R6, #+20]
   \   000000D6   0x6060             STR      R0,[R4, #+4]
    604          	}
    605          
    606          	return rc;
   \                     ??DynProtocol_decodePktResponse_5: (+1)
   \   000000D8   0x4628             MOV      R0,R5
   \   000000DA   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    607          }
    608          

   \                                 In section .text, align 2, keep-with-next
    609          static int DynProtocol_decodePktAsync(DynProtocol_t * self,
    610          		struct DynProtocolEdata * edata)
    611          {
   \                     DynProtocol_decodePktAsync: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    612          	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
    613          	const uint16_t len = self->decode_state_machine.received_size;
    614          
    615          	switch(self->decode_state_machine.cmd_id) {
   \   00000002   0x7B82             LDRB     R2,[R0, #+14]
   \   00000004   0x2A30             CMP      R2,#+48
   \   00000006   0xD108             BNE.N    ??DynProtocol_decodePktAsync_0
    616          	case DYN_PROTOCOL_EID_NEW_SENSOR_DATA:
    617          		return DynProtocol_decodeSensorEvent(self, buf, len, edata, DYN_PROTOCOL_ETYPE_ASYNC);
   \   00000008   0x2202             MOVS     R2,#+2
   \   0000000A   0x9200             STR      R2,[SP, #+0]
   \   0000000C   0x460B             MOV      R3,R1
   \   0000000E   0x8A42             LDRH     R2,[R0, #+18]
   \   00000010   0xF100 0x0114      ADD      R1,R0,#+20
   \   00000014   0x.... 0x....      BL       DynProtocol_decodeSensorEvent
   \   00000018   0xBD02             POP      {R1,PC}
    618          
    619          	default:
    620          		return -1;
   \                     ??DynProtocol_decodePktAsync_0: (+1)
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    621          	}
    622          }
    623          

   \                                 In section .text, align 2, keep-with-next
    624          static inline void DynProtocol_callEventCB(DynProtocol_t * self,
    625          	enum DynProtocolEtype etype,
    626          	enum DynProtocolEid eid,
    627          	const DynProtocolEdata_t * edata
    628          )
    629          {
   \                     DynProtocol_callEventCB: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461A             MOV      R2,R3
    630          	if(self->event_cb) {
   \   0000000A   0x6825             LDR      R5,[R4, #+0]
   \   0000000C   0x002B             MOVS     R3,R5
   \   0000000E   0xD001             BEQ.N    ??DynProtocol_callEventCB_0
    631          		self->event_cb(etype, eid, edata, self->event_cb_cookie);
   \   00000010   0x6863             LDR      R3,[R4, #+4]
   \   00000012   0x47A8             BLX      R5
    632          	}
    633          }
   \                     ??DynProtocol_callEventCB_0: (+1)
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    634          

   \                                 In section .text, align 2, keep-with-next
    635          static int DynProtocol_doProcess(DynProtocol_t * self)
    636          {
   \                     DynProtocol_doProcess: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB0A1             SUB      SP,SP,#+132
   \   00000004   0x4604             MOV      R4,R0
    637          	struct DynProtocolEdata edata;
    638          	enum DynProtocolEtype etype;
    639          	int rc;
    640          
    641          	self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x7220             STRB     R0,[R4, #+8]
    642          
    643          	switch(self->decode_state_machine.event_type) {
   \   0000000A   0x7B20             LDRB     R0,[R4, #+12]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??DynProtocol_doProcess_0
   \   00000010   0x2840             CMP      R0,#+64
   \   00000012   0xD013             BEQ.N    ??DynProtocol_doProcess_1
   \   00000014   0x2880             CMP      R0,#+128
   \   00000016   0xD018             BEQ.N    ??DynProtocol_doProcess_2
   \   00000018   0xE01E             B.N      ??DynProtocol_doProcess_3
    644          	case EVENT_TYPE_CMD:
    645          		rc = DynProtocol_decodePktCommand(self, &edata);
   \                     ??DynProtocol_doProcess_0: (+1)
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       DynProtocol_decodePktCommand
   \   00000022   0x4605             MOV      R5,R0
    646          		etype = DYN_PROTOCOL_ETYPE_CMD;
   \   00000024   0x2100             MOVS     R1,#+0
    647          		break;
    648          
    649          	case EVENT_TYPE_RESP:
    650          		rc = DynProtocol_decodePktResponse(self, &edata);
    651          		etype = DYN_PROTOCOL_ETYPE_RESP;
    652          		break;
    653          
    654          	case EVENT_TYPE_ASYNC:
    655          		rc = DynProtocol_decodePktAsync(self, &edata);
    656          		etype = DYN_PROTOCOL_ETYPE_ASYNC;
    657          		break;
    658          
    659          	default:
    660          		INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: Unexpected packet type");
    661          		return -1;
    662          	}
    663          
    664          	if(rc == 0) {
   \                     ??DynProtocol_doProcess_4: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD11E             BNE.N    ??DynProtocol_doProcess_5
    665          		DynProtocol_callEventCB(self, etype, (enum DynProtocolEid)self->decode_state_machine.cmd_id, &edata);
   \   0000002A   0x466B             MOV      R3,SP
   \   0000002C   0xF994 0x000E      LDRSB    R0,[R4, #+14]
   \   00000030   0x4602             MOV      R2,R0
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       DynProtocol_callEventCB
    666          		return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE01B             B.N      ??DynProtocol_doProcess_6
    667          	} else {
   \                     ??DynProtocol_doProcess_1: (+1)
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       DynProtocol_decodePktResponse
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xE7ED             B.N      ??DynProtocol_doProcess_4
   \                     ??DynProtocol_doProcess_2: (+1)
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       DynProtocol_decodePktAsync
   \   00000052   0x4605             MOV      R5,R0
   \   00000054   0x2102             MOVS     R1,#+2
   \   00000056   0xE7E6             B.N      ??DynProtocol_doProcess_4
   \                     ??DynProtocol_doProcess_3: (+1)
   \   00000058   0x.... 0x....      ADR.W    R1,?_1
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0x.... 0x....      BL       inv_msg
   \   00000062   0xF04F 0x30FF      MOV      R0,#-1
   \   00000066   0xE005             B.N      ??DynProtocol_doProcess_6
    668          		INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected packet received.");
   \                     ??DynProtocol_doProcess_5: (+1)
   \   00000068   0x.... 0x....      ADR.W    R1,?_2
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x.... 0x....      BL       inv_msg
    669          	}
    670          
    671          	return rc;
   \   00000072   0x4628             MOV      R0,R5
   \                     ??DynProtocol_doProcess_6: (+1)
   \   00000074   0xB021             ADD      SP,SP,#+132
   \   00000076   0xBD30             POP      {R4,R5,PC}       ;; return
    672          }
    673          

   \                                 In section .text, align 4, keep-with-next
    674          static int DynProtocol_encodeSensorEvent(DynProtocol_t * self, const DynProtocolEdata_t *edata,
    675          		uint8_t * outBuffer, uint16_t maxBufferSize, enum DynProtocolEtype etype)
    676          {
   \                     DynProtocol_encodeSensorEvent: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
    677          	uint16_t idx = 0, i=0;
   \   0000000C   0x2700             MOVS     R7,#+0
   \   0000000E   0x46B8             MOV      R8,R7
    678          	uint32_t sensorStatus;
    679          	uint32_t timestamp;
    680          	const VSensorDataAny *vSensordata;
    681          
    682          	switch(etype) {
   \   00000010   0xF99D 0x0028      LDRSB    R0,[SP, #+40]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD002             BEQ.N    ??DynProtocol_encodeSensorEvent_1
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD077             BEQ.N    ??DynProtocol_encodeSensorEvent_2
   \   0000001C   0xE07B             B.N      ??DynProtocol_encodeSensorEvent_3
    683          	case DYN_PROTOCOL_ETYPE_RESP:
    684          		sensorStatus = edata->d.response.sensorData.status;
   \                     ??DynProtocol_encodeSensorEvent_1: (+1)
   \   0000001E   0xF8DB 0x0008      LDR      R0,[R11, #+8]
    685          		vSensordata = &edata->d.response.sensorData.vdata;
   \   00000022   0xF10B 0x090C      ADD      R9,R11,#+12
    686          		break;
    687          
    688          	case DYN_PROTOCOL_ETYPE_ASYNC:
    689          		sensorStatus = edata->d.async.sensorEvent.status;
    690          		vSensordata = &edata->d.async.sensorEvent.vdata;
    691          		break;
    692          
    693          	case DYN_PROTOCOL_ETYPE_CMD:
    694          	default:
    695          		return INV_ERROR_BAD_ARG;
    696          	}
    697          
    698          	timestamp = (uint32_t)vSensordata->base.timestamp;
   \                     ??DynProtocol_encodeSensorEvent_4: (+1)
   \   00000026   0xF8D9 0xA000      LDR      R10,[R9, #+0]
    699          
    700          	if(maxBufferSize < 4) {
   \   0000002A   0x2E04             CMP      R6,#+4
   \   0000002C   0xF2C0 0x8131      BLT.W    ??DynProtocol_encodeSensorEvent_5
    701          		goto error_size;
    702          	}
    703          
    704          	outBuffer[idx] = (uint8_t)(sensorStatus & 0x03);
   \   00000030   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000034   0x7028             STRB     R0,[R5, #+0]
    705          	idx += 1;
    706          	outBuffer[idx] = (uint8_t)edata->sensor_id;
   \   00000036   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000003A   0x7068             STRB     R0,[R5, #+1]
    707          	idx += 1;
    708          
    709          	inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
   \   0000003C   0x1CA9             ADDS     R1,R5,#+2
   \   0000003E   0x4650             MOV      R0,R10
   \   00000040   0x.... 0x....      BL       inv_dc_int32_to_little8
    710          	idx += 4;
   \   00000044   0x2706             MOVS     R7,#+6
    711          
    712          	maxBufferSize -= idx;
   \   00000046   0x1FB6             SUBS     R6,R6,#+6
    713          
    714          	switch(edata->sensor_id) {
   \   00000048   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000004C   0x2840             CMP      R0,#+64
   \   0000004E   0xF200 0x81EB      BHI.W    ??DynProtocol_encodeSensorEvent_6
   \   00000052   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??DynProtocol_encodeSensorEvent_0:
   \   00000056   0x0059 0x0041      DC16     0x59,0x41,0x63,0x16B
   \              0x0063 0x016B
   \   0000005E   0x009F 0x0182      DC16     0x9F,0x182,0x182,0x1E9
   \              0x0182 0x01E9
   \   00000066   0x018C 0x0041      DC16     0x18C,0x41,0x41,0xF6
   \              0x0041 0x00F6
   \   0000006E   0x01E9 0x013B      DC16     0x1E9,0x13B,0x7B,0xDF
   \              0x007B 0x00DF
   \   00000076   0x00B9 0x0162      DC16     0xB9,0x162,0x162,0x147
   \              0x0162 0x0147
   \   0000007E   0x00F6 0x01E9      DC16     0xF6,0x1E9,0x162,0x162
   \              0x0162 0x0162
   \   00000086   0x0162 0x0162      DC16     0x162,0x162,0x156,0x1E9
   \              0x0156 0x01E9
   \   0000008E   0x0162 0x00DF      DC16     0x162,0xDF,0x197,0x122
   \              0x0197 0x0122
   \   00000096   0x0122 0x0122      DC16     0x122,0x122,0x122,0x182
   \              0x0122 0x0182
   \   0000009E   0x01D4 0x01E9      DC16     0x1D4,0x1E9,0x1E9,0x1E9
   \              0x01E9 0x01E9
   \   000000A6   0x01E9 0x01E9      DC16     0x1E9,0x1E9,0x1E9,0x1E9
   \              0x01E9 0x01E9
   \   000000AE   0x01E9 0x01E9      DC16     0x1E9,0x1E9,0x1E9,0x162
   \              0x01E9 0x0162
   \   000000B6   0x0162 0x01BE      DC16     0x162,0x1BE,0x1BE,0x1BE
   \              0x01BE 0x01BE
   \   000000BE   0x01BE 0x01BE      DC16     0x1BE,0x1BE,0x1BE,0x1BE
   \              0x01BE 0x01BE
   \   000000C6   0x01BE 0x0156      DC16     0x1BE,0x156,0x162,0x1E9
   \              0x0162 0x01E9
   \   000000CE   0x01E9 0x0119      DC16     0x1E9,0x119,0x1E9,0x1E9
   \              0x01E9 0x01E9
   \   000000D6   0x00DF             DC16     0xDF
    715          	case DYN_PRO_SENSOR_TYPE_RESERVED:
    716          		/* no data */
    717          		break;
    718          
    719          	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
    720          	case DYN_PRO_SENSOR_TYPE_GRAVITY:
    721          	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
    722          		if(maxBufferSize < 6+1)
   \                     ??DynProtocol_encodeSensorEvent_7: (+1)
   \   000000D8   0xB2B6             UXTH     R6,R6
   \   000000DA   0x2E07             CMP      R6,#+7
   \   000000DC   0xF2C0 0x80D9      BLT.W    ??DynProtocol_encodeSensorEvent_5
    723          			goto error_size;
    724          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.acc, &outBuffer[idx]);
   \   000000E0   0x1DA8             ADDS     R0,R5,#+6
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0xF894 0x3114      LDRB     R3,[R4, #+276]
   \   000000E8   0x2210             MOVS     R2,#+16
   \   000000EA   0x2103             MOVS     R1,#+3
   \   000000EC   0xF109 0x0008      ADD      R0,R9,#+8
   \   000000F0   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000000F4   0x1D80             ADDS     R0,R0,#+6
   \   000000F6   0xB280             UXTH     R0,R0
    725          		/* report accuracy */
    726          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
   \   000000F8   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   000000FC   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000100   0x4602             MOV      R2,R0
   \   00000102   0x54A9             STRB     R1,[R5, R2]
   \   00000104   0x1C47             ADDS     R7,R0,#+1
   \   00000106   0xB2BF             UXTH     R7,R7
    727          		break;
    728          
    729          	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
    730          		if(maxBufferSize < 6+1)
    731          			goto error_size;
    732          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
    733          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
    734          		break;
    735          
    736          	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
    737          		if(maxBufferSize < 13)
    738          			goto error_size;
    739          		// uncalibrated data
    740          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
    741          		// bias
    742          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
    743          		// accuracy
    744          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
    745          		break;
    746          
    747          	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
    748          		if(maxBufferSize < 6+1)
    749          			goto error_size;
    750          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
    751          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
    752          		break;
    753          
    754          	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
    755          		if(maxBufferSize < 13)
    756          			goto error_size;
    757          		// uncalibrated data
    758          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
    759          		// bias
    760          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, self->precision.gyro, &outBuffer[idx]);
    761          		// accuracy
    762          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
    763          		break;
    764          
    765          	case DYN_PRO_SENSOR_TYPE_3AXIS:
    766          	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
    767          	case DYN_PRO_SENSOR_TYPE_PREDICTIVE_QUATERNION:
    768          		if(maxBufferSize < 9)
    769          			goto error_size;
    770          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 4, 30, PROTOCOL_QUATERNION_PRECISION, &outBuffer[idx]);
    771          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
    772          		break;
    773          
    774          	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
    775          	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
    776          		if(maxBufferSize < 11)
    777          			goto error_size;
    778          		// w,x,y,z in Q30
    779          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 4, 30, PROTOCOL_QUATERNION_PRECISION, &outBuffer[idx]);
    780          		// accuracy in q16
    781          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[4], 1, 16, PROTOCOL_HEADING_ACCURACY_PRECISION, &outBuffer[idx]);
    782          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
    783          		break;
    784          
    785          	case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
    786          		// no timestamp
    787          		idx -= 4;
    788          		maxBufferSize += idx;
    789          		if(maxBufferSize < 6)
    790          			goto error_size;
    791          		inv_dc_int16_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
    792          		inv_dc_int16_to_little8(vSensordata->data.u32[1], &outBuffer[idx+2]);
    793          		inv_dc_int16_to_little8(vSensordata->data.u32[2], &outBuffer[idx+4]);
    794          		idx += 6;
    795          		break;
    796          
    797          	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
    798          	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
    799          	case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
    800          	case DYN_PRO_SENSOR_TYPE_OIS:
    801          		if(maxBufferSize < 6)
    802          			goto error_size;
    803          		inv_dc_int16_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
    804          		inv_dc_int16_to_little8(vSensordata->data.u32[1], &outBuffer[idx+2]);
    805          		inv_dc_int16_to_little8(vSensordata->data.u32[2], &outBuffer[idx+4]);
    806          		idx += 6;
    807          		break;
    808          
    809          	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
    810          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 1, 16, PROTOCOL_TEMPERATURE_PRECISION, &outBuffer[idx]);
    811          		break;
    812          
    813          	case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
    814          		if(maxBufferSize < 4)
    815          			goto error_size;
    816          		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
    817          		idx += 4;
    818          		break;
    819          
    820          	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
    821          		if(maxBufferSize < 8)
    822          			goto error_size;
    823          		inv_dc_int32_to_little8((int32_t)vSensordata->data.u32[0], &outBuffer[idx]);
    824          		idx += 4;
    825          		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
    826          		idx += 4;
    827          		break;
    828          
    829          	case DYN_PRO_SENSOR_TYPE_BAC:
    830          		if(maxBufferSize < 5)
    831          			goto error_size;
    832          		outBuffer[idx++] = vSensordata->data.u8[0];
    833          		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
    834          		idx += 4;
    835          		break;
    836          	case DYN_PRO_SENSOR_TYPE_WOM:
    837          		if(maxBufferSize < 5)
    838          			goto error_size;
    839          		outBuffer[idx++] = vSensordata->data.u8[0];
    840          		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
    841          		idx += 4;
    842          		break;
    843          	case DYN_PRO_SENSOR_TYPE_B2S:
    844          	case DYN_PRO_SENSOR_TYPE_SHAKE:
    845          	case DYN_PRO_SENSOR_TYPE_DOUBLE_TAP:
    846          	case DYN_PRO_SENSOR_TYPE_SEDENTARY_REMIND:
    847          	case DYN_PRO_SENSOR_TYPE_SMD:
    848          	case DYN_PRO_SENSOR_TYPE_STEP_DETECTOR:
    849          	case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:
    850          	case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:
    851          	case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
    852          	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
    853          	{
    854          		if(maxBufferSize < 4)
    855          			goto error_size;
    856          		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
    857          		idx += 4;
    858          		break;
    859          	}
    860          
    861          	case DYN_PRO_SENSOR_TYPE_PRESSURE:
    862          	{
    863          		if(maxBufferSize < 4)
    864          			goto error_size;
    865          		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
    866          		idx += 4;
    867          		break;
    868          	}
    869          
    870          	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
    871          	{
    872          		if(maxBufferSize < 6+1)
    873          			goto error_size;
    874          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_ORIENTATION_PRECISION, &outBuffer[idx]);
    875          		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
    876          		break;
    877          	}
    878          
    879          	case DYN_PRO_SENSOR_TYPE_LIGHT:
    880          	{
    881          		if(maxBufferSize < 4)
    882          			goto error_size;
    883          		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
    884          		idx += 4;
    885          		break;
    886          	}
    887          
    888          	case DYN_PRO_SENSOR_TYPE_PROXIMITY:
    889          	{
    890          		if(maxBufferSize < 2)
    891          			goto error_size;
    892          		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[0], &outBuffer[idx]);
    893          		idx += 2;
    894          		break;
    895          	}
    896          
    897          	case DYN_PRO_SENSOR_TYPE_EIS:
    898          	{
    899          		if(maxBufferSize < 14)
    900          			goto error_size;
    901          		// uncalibrated data
    902          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
    903          		// bias
    904          		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, self->precision.gyro, &outBuffer[idx]);
    905          		// delta_ts
    906          		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[6], &outBuffer[idx]);
    907          		idx += 2;
    908          		break;
    909          	}
    910          
    911          	case DYN_PRO_SENSOR_TYPE_CUSTOM0:
    912          	case DYN_PRO_SENSOR_TYPE_CUSTOM1:
    913          	case DYN_PRO_SENSOR_TYPE_CUSTOM2:
    914          	case DYN_PRO_SENSOR_TYPE_CUSTOM3:
    915          	case DYN_PRO_SENSOR_TYPE_CUSTOM4:
    916          	case DYN_PRO_SENSOR_TYPE_CUSTOM5:
    917          	case DYN_PRO_SENSOR_TYPE_CUSTOM6:
    918          	case DYN_PRO_SENSOR_TYPE_CUSTOM7:
    919          	{
    920          		if(maxBufferSize < 64)
    921          			goto error_size;
    922          		// meta data contains size of custom sensors, it can be checked in host
    923          		outBuffer[idx++] = vSensordata->base.meta_data;
    924          		// one byte less available in outBuffer
    925          		maxBufferSize--;
    926          		// let's make sure that size to be copied is not bigger than size left in outBuffer
    927          		if(vSensordata->base.meta_data > maxBufferSize)
    928          			goto error_size;
    929          
    930          		memcpy(&outBuffer[idx], vSensordata->data.u8, vSensordata->base.meta_data);
    931          		//set hardly the payload size until payload has a fixed value for custom sensors
    932          		idx += sizeof(vSensordata->data.u8);
    933          		break;
    934          	}
    935          
    936          	case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
    937          	{
    938          		if(maxBufferSize < 16)
    939          			goto error_size;
    940          
    941          		for (i=0; i<4; i++) {
    942          			inv_dc_int32_to_little8(vSensordata->data.u32[i], &outBuffer[idx]); // raw pressure
    943          			idx += 4;
    944          		}
    945          		break;
    946          	}
    947          
    948          
    949          	default:
    950          		return -1;
    951          	}
    952          
    953          	return idx;
   \                     ??DynProtocol_encodeSensorEvent_8: (+1)
   \   00000108   0x4638             MOV      R0,R7
   \   0000010A   0xE0C4             B.N      ??DynProtocol_encodeSensorEvent_9
   \                     ??DynProtocol_encodeSensorEvent_2: (+1)
   \   0000010C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000110   0xF10B 0x0908      ADD      R9,R11,#+8
   \   00000114   0xE787             B.N      ??DynProtocol_encodeSensorEvent_4
   \                     ??DynProtocol_encodeSensorEvent_3: (+1)
   \   00000116   0xF06F 0x000A      MVN      R0,#+10
   \   0000011A   0xE0BC             B.N      ??DynProtocol_encodeSensorEvent_9
   \                     ??DynProtocol_encodeSensorEvent_10: (+1)
   \   0000011C   0xB2B6             UXTH     R6,R6
   \   0000011E   0x2E07             CMP      R6,#+7
   \   00000120   0xF2C0 0x80B7      BLT.W    ??DynProtocol_encodeSensorEvent_5
   \   00000124   0x1DA8             ADDS     R0,R5,#+6
   \   00000126   0x9000             STR      R0,[SP, #+0]
   \   00000128   0x2304             MOVS     R3,#+4
   \   0000012A   0x2210             MOVS     R2,#+16
   \   0000012C   0x2103             MOVS     R1,#+3
   \   0000012E   0xF109 0x0008      ADD      R0,R9,#+8
   \   00000132   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   00000136   0x1D80             ADDS     R0,R0,#+6
   \   00000138   0xB280             UXTH     R0,R0
   \   0000013A   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   0000013E   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000142   0x4602             MOV      R2,R0
   \   00000144   0x54A9             STRB     R1,[R5, R2]
   \   00000146   0x1C47             ADDS     R7,R0,#+1
   \   00000148   0xB2BF             UXTH     R7,R7
   \   0000014A   0xE7DD             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_11: (+1)
   \   0000014C   0xB2B6             UXTH     R6,R6
   \   0000014E   0x2E0D             CMP      R6,#+13
   \   00000150   0xF2C0 0x809F      BLT.W    ??DynProtocol_encodeSensorEvent_5
   \   00000154   0x1DA8             ADDS     R0,R5,#+6
   \   00000156   0x9000             STR      R0,[SP, #+0]
   \   00000158   0x2304             MOVS     R3,#+4
   \   0000015A   0x2210             MOVS     R2,#+16
   \   0000015C   0x2103             MOVS     R1,#+3
   \   0000015E   0xF109 0x0008      ADD      R0,R9,#+8
   \   00000162   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   00000166   0x1D84             ADDS     R4,R0,#+6
   \   00000168   0xB2A4             UXTH     R4,R4
   \   0000016A   0x4620             MOV      R0,R4
   \   0000016C   0x4428             ADD      R0,R5,R0
   \   0000016E   0x9000             STR      R0,[SP, #+0]
   \   00000170   0x2304             MOVS     R3,#+4
   \   00000172   0x2210             MOVS     R2,#+16
   \   00000174   0x2103             MOVS     R1,#+3
   \   00000176   0xF109 0x0014      ADD      R0,R9,#+20
   \   0000017A   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   0000017E   0x1900             ADDS     R0,R0,R4
   \   00000180   0xB280             UXTH     R0,R0
   \   00000182   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   00000186   0xF001 0x0107      AND      R1,R1,#0x7
   \   0000018A   0x4602             MOV      R2,R0
   \   0000018C   0x54A9             STRB     R1,[R5, R2]
   \   0000018E   0x1C47             ADDS     R7,R0,#+1
   \   00000190   0xB2BF             UXTH     R7,R7
   \   00000192   0xE7B9             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_12: (+1)
   \   00000194   0xB2B6             UXTH     R6,R6
   \   00000196   0x2E07             CMP      R6,#+7
   \   00000198   0xDB7B             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   0000019A   0x1DA8             ADDS     R0,R5,#+6
   \   0000019C   0x9000             STR      R0,[SP, #+0]
   \   0000019E   0xF44F 0x708A      MOV      R0,#+276
   \   000001A2   0x4420             ADD      R0,R4,R0
   \   000001A4   0x7843             LDRB     R3,[R0, #+1]
   \   000001A6   0x2210             MOVS     R2,#+16
   \   000001A8   0x2103             MOVS     R1,#+3
   \   000001AA   0xF109 0x0008      ADD      R0,R9,#+8
   \   000001AE   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000001B2   0x1D80             ADDS     R0,R0,#+6
   \   000001B4   0xB280             UXTH     R0,R0
   \   000001B6   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   000001BA   0xF001 0x0107      AND      R1,R1,#0x7
   \   000001BE   0x4602             MOV      R2,R0
   \   000001C0   0x54A9             STRB     R1,[R5, R2]
   \   000001C2   0x1C47             ADDS     R7,R0,#+1
   \   000001C4   0xB2BF             UXTH     R7,R7
   \   000001C6   0xE79F             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_13: (+1)
   \   000001C8   0xB2B6             UXTH     R6,R6
   \   000001CA   0x2E0D             CMP      R6,#+13
   \   000001CC   0xDB61             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   000001CE   0xF44F 0x708A      MOV      R0,#+276
   \   000001D2   0x4404             ADD      R4,R4,R0
   \   000001D4   0x1DA8             ADDS     R0,R5,#+6
   \   000001D6   0x9000             STR      R0,[SP, #+0]
   \   000001D8   0x7863             LDRB     R3,[R4, #+1]
   \   000001DA   0x2210             MOVS     R2,#+16
   \   000001DC   0x2103             MOVS     R1,#+3
   \   000001DE   0xF109 0x0008      ADD      R0,R9,#+8
   \   000001E2   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000001E6   0x1D86             ADDS     R6,R0,#+6
   \   000001E8   0xB2B6             UXTH     R6,R6
   \   000001EA   0x4630             MOV      R0,R6
   \   000001EC   0x4428             ADD      R0,R5,R0
   \   000001EE   0x9000             STR      R0,[SP, #+0]
   \   000001F0   0x7863             LDRB     R3,[R4, #+1]
   \   000001F2   0x2210             MOVS     R2,#+16
   \   000001F4   0x2103             MOVS     R1,#+3
   \   000001F6   0xF109 0x0014      ADD      R0,R9,#+20
   \   000001FA   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000001FE   0x1980             ADDS     R0,R0,R6
   \   00000200   0xB280             UXTH     R0,R0
   \   00000202   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   00000206   0xF001 0x0107      AND      R1,R1,#0x7
   \   0000020A   0x4602             MOV      R2,R0
   \   0000020C   0x54A9             STRB     R1,[R5, R2]
   \   0000020E   0x1C47             ADDS     R7,R0,#+1
   \   00000210   0xB2BF             UXTH     R7,R7
   \   00000212   0xE779             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_14: (+1)
   \   00000214   0xB2B6             UXTH     R6,R6
   \   00000216   0x2E09             CMP      R6,#+9
   \   00000218   0xDB3B             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   0000021A   0x1DA8             ADDS     R0,R5,#+6
   \   0000021C   0x9000             STR      R0,[SP, #+0]
   \   0000021E   0x230E             MOVS     R3,#+14
   \   00000220   0x221E             MOVS     R2,#+30
   \   00000222   0x2104             MOVS     R1,#+4
   \   00000224   0xF109 0x0008      ADD      R0,R9,#+8
   \   00000228   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   0000022C   0x1D80             ADDS     R0,R0,#+6
   \   0000022E   0xB280             UXTH     R0,R0
   \   00000230   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   00000234   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000238   0x4602             MOV      R2,R0
   \   0000023A   0x54A9             STRB     R1,[R5, R2]
   \   0000023C   0x1C47             ADDS     R7,R0,#+1
   \   0000023E   0xB2BF             UXTH     R7,R7
   \   00000240   0xE762             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_15: (+1)
   \   00000242   0xB2B6             UXTH     R6,R6
   \   00000244   0x2E0B             CMP      R6,#+11
   \   00000246   0xDB24             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   00000248   0x1DA8             ADDS     R0,R5,#+6
   \   0000024A   0x9000             STR      R0,[SP, #+0]
   \   0000024C   0x230E             MOVS     R3,#+14
   \   0000024E   0x221E             MOVS     R2,#+30
   \   00000250   0x2104             MOVS     R1,#+4
   \   00000252   0xF109 0x0008      ADD      R0,R9,#+8
   \   00000256   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   0000025A   0x1D84             ADDS     R4,R0,#+6
   \   0000025C   0xB2A4             UXTH     R4,R4
   \   0000025E   0x4620             MOV      R0,R4
   \   00000260   0x4428             ADD      R0,R5,R0
   \   00000262   0x9000             STR      R0,[SP, #+0]
   \   00000264   0x2307             MOVS     R3,#+7
   \   00000266   0x2210             MOVS     R2,#+16
   \   00000268   0x2101             MOVS     R1,#+1
   \   0000026A   0xF109 0x0018      ADD      R0,R9,#+24
   \   0000026E   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   00000272   0x1900             ADDS     R0,R0,R4
   \   00000274   0xB280             UXTH     R0,R0
   \   00000276   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   0000027A   0xF001 0x0107      AND      R1,R1,#0x7
   \   0000027E   0x4602             MOV      R2,R0
   \   00000280   0x54A9             STRB     R1,[R5, R2]
   \   00000282   0x1C47             ADDS     R7,R0,#+1
   \   00000284   0xB2BF             UXTH     R7,R7
   \   00000286   0xE73F             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_16: (+1)
   \   00000288   0x2702             MOVS     R7,#+2
   \   0000028A   0x1CB6             ADDS     R6,R6,#+2
   \   0000028C   0xB2B6             UXTH     R6,R6
   \   0000028E   0x2E06             CMP      R6,#+6
   \   00000290   0xDA06             BGE.N    ??DynProtocol_encodeSensorEvent_17
    954          
    955          error_size:
    956          	return maxBufferSize + idx + 1; /* +1 to indicate buffer is too small */
   \                     ??DynProtocol_encodeSensorEvent_5: (+1)
   \   00000292   0x19B8             ADDS     R0,R7,R6
   \   00000294   0x1C40             ADDS     R0,R0,#+1
   \                     ??DynProtocol_encodeSensorEvent_9: (+1)
   \   00000296   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??DynProtocol_encodeSensorEvent_18: (+1)
   \   0000029A   0xB2B6             UXTH     R6,R6
   \   0000029C   0x2E06             CMP      R6,#+6
   \   0000029E   0xDBF8             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \                     ??DynProtocol_encodeSensorEvent_17: (+1)
   \   000002A0   0x19EC             ADDS     R4,R5,R7
   \   000002A2   0x4621             MOV      R1,R4
   \   000002A4   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   000002A8   0xB200             SXTH     R0,R0
   \   000002AA   0x.... 0x....      BL       inv_dc_int16_to_little8
   \   000002AE   0x1CA1             ADDS     R1,R4,#+2
   \   000002B0   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   000002B4   0xB200             SXTH     R0,R0
   \   000002B6   0x.... 0x....      BL       inv_dc_int16_to_little8
   \   000002BA   0x1D21             ADDS     R1,R4,#+4
   \   000002BC   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \   000002C0   0xB200             SXTH     R0,R0
   \   000002C2   0x.... 0x....      BL       inv_dc_int16_to_little8
   \   000002C6   0x1DBF             ADDS     R7,R7,#+6
   \   000002C8   0xB2BF             UXTH     R7,R7
   \   000002CA   0xE71D             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_19: (+1)
   \   000002CC   0x1DA8             ADDS     R0,R5,#+6
   \   000002CE   0x9000             STR      R0,[SP, #+0]
   \   000002D0   0x2308             MOVS     R3,#+8
   \   000002D2   0x2210             MOVS     R2,#+16
   \   000002D4   0x2101             MOVS     R1,#+1
   \   000002D6   0xF109 0x0008      ADD      R0,R9,#+8
   \   000002DA   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000002DE   0x1D87             ADDS     R7,R0,#+6
   \   000002E0   0xB2BF             UXTH     R7,R7
   \   000002E2   0xE711             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_20: (+1)
   \   000002E4   0xB2B6             UXTH     R6,R6
   \   000002E6   0x2E08             CMP      R6,#+8
   \   000002E8   0xDBD3             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   000002EA   0x1DA9             ADDS     R1,R5,#+6
   \   000002EC   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   000002F0   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   000002F4   0xF105 0x010A      ADD      R1,R5,#+10
   \   000002F8   0x4650             MOV      R0,R10
   \   000002FA   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   000002FE   0x270E             MOVS     R7,#+14
   \   00000300   0xE702             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_21: (+1)
   \   00000302   0xB2B6             UXTH     R6,R6
   \   00000304   0x2E05             CMP      R6,#+5
   \   00000306   0xDBC4             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   00000308   0xF899 0x0008      LDRB     R0,[R9, #+8]
   \   0000030C   0x71A8             STRB     R0,[R5, #+6]
   \   0000030E   0x1DE9             ADDS     R1,R5,#+7
   \   00000310   0x4650             MOV      R0,R10
   \   00000312   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   00000316   0x270B             MOVS     R7,#+11
   \   00000318   0xE6F6             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_22: (+1)
   \   0000031A   0xB2B6             UXTH     R6,R6
   \   0000031C   0x2E04             CMP      R6,#+4
   \   0000031E   0xDBB8             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   00000320   0x1DA9             ADDS     R1,R5,#+6
   \   00000322   0x4650             MOV      R0,R10
   \   00000324   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   00000328   0x270A             MOVS     R7,#+10
   \   0000032A   0xE6ED             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_23: (+1)
   \   0000032C   0xB2B6             UXTH     R6,R6
   \   0000032E   0x2E07             CMP      R6,#+7
   \   00000330   0xDBAF             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   00000332   0x1DA8             ADDS     R0,R5,#+6
   \   00000334   0x9000             STR      R0,[SP, #+0]
   \   00000336   0x463B             MOV      R3,R7
   \   00000338   0x2210             MOVS     R2,#+16
   \   0000033A   0x2103             MOVS     R1,#+3
   \   0000033C   0xF109 0x0008      ADD      R0,R9,#+8
   \   00000340   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   00000344   0x1D80             ADDS     R0,R0,#+6
   \   00000346   0xB280             UXTH     R0,R0
   \   00000348   0xF899 0x1004      LDRB     R1,[R9, #+4]
   \   0000034C   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000350   0x4602             MOV      R2,R0
   \   00000352   0x54A9             STRB     R1,[R5, R2]
   \   00000354   0x1C47             ADDS     R7,R0,#+1
   \   00000356   0xB2BF             UXTH     R7,R7
   \   00000358   0xE6D6             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_24: (+1)
   \   0000035A   0xB2B6             UXTH     R6,R6
   \   0000035C   0x2E04             CMP      R6,#+4
   \   0000035E   0xDB98             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   00000360   0x1DA9             ADDS     R1,R5,#+6
   \   00000362   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   00000366   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   0000036A   0x270A             MOVS     R7,#+10
   \   0000036C   0xE6CC             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_25: (+1)
   \   0000036E   0xB2B6             UXTH     R6,R6
   \   00000370   0x2E02             CMP      R6,#+2
   \   00000372   0xDB8E             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   00000374   0x1DA9             ADDS     R1,R5,#+6
   \   00000376   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   0000037A   0xB200             SXTH     R0,R0
   \   0000037C   0x.... 0x....      BL       inv_dc_int16_to_little8
   \   00000380   0x2708             MOVS     R7,#+8
   \   00000382   0xE6C1             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_26: (+1)
   \   00000384   0xB2B6             UXTH     R6,R6
   \   00000386   0x2E0E             CMP      R6,#+14
   \   00000388   0xDB83             BLT.N    ??DynProtocol_encodeSensorEvent_5
   \   0000038A   0xF44F 0x708A      MOV      R0,#+276
   \   0000038E   0x4404             ADD      R4,R4,R0
   \   00000390   0x1DA8             ADDS     R0,R5,#+6
   \   00000392   0x9000             STR      R0,[SP, #+0]
   \   00000394   0x7863             LDRB     R3,[R4, #+1]
   \   00000396   0x2210             MOVS     R2,#+16
   \   00000398   0x2103             MOVS     R1,#+3
   \   0000039A   0xF109 0x0008      ADD      R0,R9,#+8
   \   0000039E   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000003A2   0x1D86             ADDS     R6,R0,#+6
   \   000003A4   0xB2B6             UXTH     R6,R6
   \   000003A6   0x4630             MOV      R0,R6
   \   000003A8   0x4428             ADD      R0,R5,R0
   \   000003AA   0x9000             STR      R0,[SP, #+0]
   \   000003AC   0x7863             LDRB     R3,[R4, #+1]
   \   000003AE   0x2210             MOVS     R2,#+16
   \   000003B0   0x2103             MOVS     R1,#+3
   \   000003B2   0xF109 0x0014      ADD      R0,R9,#+20
   \   000003B6   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000003BA   0x1984             ADDS     R4,R0,R6
   \   000003BC   0xB2A4             UXTH     R4,R4
   \   000003BE   0x4620             MOV      R0,R4
   \   000003C0   0x1829             ADDS     R1,R5,R0
   \   000003C2   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000003C6   0xB200             SXTH     R0,R0
   \   000003C8   0x.... 0x....      BL       inv_dc_int16_to_little8
   \   000003CC   0x1CA7             ADDS     R7,R4,#+2
   \   000003CE   0xB2BF             UXTH     R7,R7
   \   000003D0   0xE69A             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_27: (+1)
   \   000003D2   0xB2B6             UXTH     R6,R6
   \   000003D4   0x2E40             CMP      R6,#+64
   \   000003D6   0xF6FF 0xAF5C      BLT.W    ??DynProtocol_encodeSensorEvent_5
   \   000003DA   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \   000003DE   0x71A8             STRB     R0,[R5, #+6]
   \   000003E0   0x2707             MOVS     R7,#+7
   \   000003E2   0x1E76             SUBS     R6,R6,#+1
   \   000003E4   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \   000003E8   0xB2B6             UXTH     R6,R6
   \   000003EA   0x4296             CMP      R6,R2
   \   000003EC   0xF4FF 0xAF51      BCC.W    ??DynProtocol_encodeSensorEvent_5
   \   000003F0   0xF109 0x0108      ADD      R1,R9,#+8
   \   000003F4   0x1DE8             ADDS     R0,R5,#+7
   \   000003F6   0x.... 0x....      BL       __aeabi_memcpy
   \   000003FA   0x2747             MOVS     R7,#+71
   \   000003FC   0xE684             B.N      ??DynProtocol_encodeSensorEvent_8
   \                     ??DynProtocol_encodeSensorEvent_28: (+1)
   \   000003FE   0xB2B6             UXTH     R6,R6
   \   00000400   0x2E10             CMP      R6,#+16
   \   00000402   0xF6FF 0xAF46      BLT.W    ??DynProtocol_encodeSensorEvent_5
   \                     ??DynProtocol_encodeSensorEvent_29: (+1)
   \   00000406   0xFA1F 0xF888      UXTH     R8,R8
   \   0000040A   0x4640             MOV      R0,R8
   \   0000040C   0x2804             CMP      R0,#+4
   \   0000040E   0xF6BF 0xAE7B      BGE.W    ??DynProtocol_encodeSensorEvent_8
   \   00000412   0x19E9             ADDS     R1,R5,R7
   \   00000414   0xEB09 0x0080      ADD      R0,R9,R0, LSL #+2
   \   00000418   0x6880             LDR      R0,[R0, #+8]
   \   0000041A   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   0000041E   0x1D3F             ADDS     R7,R7,#+4
   \   00000420   0xB2BF             UXTH     R7,R7
   \   00000422   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000426   0xE7EE             B.N      ??DynProtocol_encodeSensorEvent_29
   \                     ??DynProtocol_encodeSensorEvent_6: (+1)
   \   00000428   0xF04F 0x30FF      MOV      R0,#-1
   \   0000042C   0xE733             B.N      ??DynProtocol_encodeSensorEvent_9
    957          }
    958          
    959          

   \                                 In section .text, align 2, keep-with-next
    960          static int DynProtocol_checkFrameSize(DynProtocol_t * self)
    961          {
   \                     DynProtocol_checkFrameSize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    962          	if(self->decode_state_machine.expected_size == UINT16_MAX) {
   \   00000002   0x8A01             LDRH     R1,[R0, #+16]
   \   00000004   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000008   0x4299             CMP      R1,R3
   \   0000000A   0xD107             BNE.N    ??DynProtocol_checkFrameSize_0
    963          		/* assume frame is unknown, return error */
    964          		INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unknown frame");
   \   0000000C   0x.... 0x....      ADR.W    R1,?_3
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       inv_msg
    965          		return INV_ERROR_SIZE;
   \   00000016   0xF06F 0x0004      MVN      R0,#+4
   \   0000001A   0xBD02             POP      {R1,PC}
    966          	}
    967          
    968          	/*
    969          	 * expected_size is the payload expected size (not the total frame expected size).
    970          	 * it should respect this condititon:
    971          	 *  current_frame_size >= 1 byte (GID) + 1 byte (CID) + expected_size
    972          	 * note : current_frame_size == UINT16_MAX means check on frame size disabled (default).
    973          	 */
    974          	if(self->decode_state_machine.current_frame_size != UINT16_MAX) {
   \                     ??DynProtocol_checkFrameSize_0: (+1)
   \   0000001C   0x8942             LDRH     R2,[R0, #+10]
   \   0000001E   0x429A             CMP      R2,R3
   \   00000020   0xD00A             BEQ.N    ??DynProtocol_checkFrameSize_1
    975          		if(self->decode_state_machine.current_frame_size < (self->decode_state_machine.expected_size + 2)) {
   \   00000022   0x1C8B             ADDS     R3,R1,#+2
   \   00000024   0x429A             CMP      R2,R3
   \   00000026   0xDA07             BGE.N    ??DynProtocol_checkFrameSize_1
    976          			INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Frame size error. size=%dB (expected %dB)",
    977          				self->decode_state_machine.current_frame_size, self->decode_state_machine.expected_size + 2);
   \   00000028   0x.... 0x....      ADR.W    R1,?_4
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       inv_msg
    978          			return INV_ERROR_SIZE;
   \   00000032   0xF06F 0x0004      MVN      R0,#+4
   \   00000036   0xBD02             POP      {R1,PC}
    979          		}
    980          	}
    981          
    982          	return INV_ERROR_SUCCESS;
   \                     ??DynProtocol_checkFrameSize_1: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD02             POP      {R1,PC}          ;; return
    983          }
    984          

   \                                 In section .text, align 2, keep-with-next
    985          void DynProtocol_init(DynProtocol_t * self,
    986          		DynProtocolEvent_cb event_cb, void * event_cb_cookie)
    987          {
   \                     DynProtocol_init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    988          	memset(self, 0, sizeof(*self));
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF44F 0x718C      MOV      R1,#+280
   \   0000000E   0x.... 0x....      BL       __aeabi_memset4
    989          
    990          	self->event_cb        = event_cb;
   \   00000012   0x6025             STR      R5,[R4, #+0]
    991          	self->event_cb_cookie = event_cb_cookie;
   \   00000014   0x6066             STR      R6,[R4, #+4]
    992          	self->decode_state_machine.current_frame_size = UINT16_MAX;
   \   00000016   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000001A   0x8160             STRH     R0,[R4, #+10]
    993          	self->precision.acc = PROTOCOL_ACCELEROMETER_PRECISION;
   \   0000001C   0xF44F 0x708A      MOV      R0,#+276
   \   00000020   0x4420             ADD      R0,R4,R0
   \   00000022   0x210B             MOVS     R1,#+11
   \   00000024   0x7001             STRB     R1,[R0, #+0]
    994          	self->precision.gyro = PROTOCOL_GYROSCOPE_PRECISION;
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x7041             STRB     R1,[R0, #+1]
    995          }
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    996          

   \                                 In section .text, align 2, keep-with-next
    997          void DynProtocol_processReset(DynProtocol_t * self)
    998          {
    999          	self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
   \                     DynProtocol_processReset: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7201             STRB     R1,[R0, #+8]
   1000          }
   \   00000004   0x4770             BX       LR               ;; return
   1001          

   \                                 In section .text, align 2, keep-with-next
   1002          void DynProtocol_setCurrentFrameSize(DynProtocol_t * self, uint16_t frameSizeB)
   1003          {
   1004          	self->decode_state_machine.current_frame_size = frameSizeB;
   \                     DynProtocol_setCurrentFrameSize: (+1)
   \   00000000   0x8141             STRH     R1,[R0, #+10]
   1005          }
   \   00000002   0x4770             BX       LR               ;; return
   1006          

   \                                 In section .text, align 2, keep-with-next
   1007          int DynProtocol_setPrecision(DynProtocol_t * self, int sensor, uint8_t precision)
   1008          {
   1009          	int rc = 0;
   \                     DynProtocol_setPrecision: (+1)
   \   00000000   0x2300             MOVS     R3,#+0
   1010          	switch(sensor)
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD002             BEQ.N    ??DynProtocol_setPrecision_0
   \   00000006   0x2904             CMP      R1,#+4
   \   00000008   0xD003             BEQ.N    ??DynProtocol_setPrecision_1
   \   0000000A   0xE007             B.N      ??DynProtocol_setPrecision_2
   1011          	{
   1012          		case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
   1013          			self->precision.acc = precision;
   \                     ??DynProtocol_setPrecision_0: (+1)
   \   0000000C   0xF880 0x2114      STRB     R2,[R0, #+276]
   1014          			break;
   \   00000010   0xE006             B.N      ??DynProtocol_setPrecision_3
   1015          		case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
   1016          			self->precision.gyro = precision;
   \                     ??DynProtocol_setPrecision_1: (+1)
   \   00000012   0xF44F 0x718A      MOV      R1,#+276
   \   00000016   0x4408             ADD      R0,R0,R1
   \   00000018   0x7042             STRB     R2,[R0, #+1]
   1017          			break;
   \   0000001A   0xE001             B.N      ??DynProtocol_setPrecision_3
   1018          		default :
   1019          			rc = -1;
   \                     ??DynProtocol_setPrecision_2: (+1)
   \   0000001C   0xF04F 0x33FF      MOV      R3,#-1
   1020          			break;
   1021          	}
   1022          	return rc;
   \                     ??DynProtocol_setPrecision_3: (+1)
   \   00000020   0x4618             MOV      R0,R3
   \   00000022   0x4770             BX       LR               ;; return
   1023          }
   1024          

   \                                 In section .text, align 2, keep-with-next
   1025          int DynProtocol_processPktByte(DynProtocol_t * self, uint8_t rcvByte)
   1026          {
   \                     DynProtocol_processPktByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1027          	switch(self->decode_state_machine.state) {
   \   00000004   0xF994 0x0008      LDRSB    R0,[R4, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??DynProtocol_processPktByte_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD02F             BEQ.N    ??DynProtocol_processPktByte_1
   \   00000010   0xD315             BCC.N    ??DynProtocol_processPktByte_2
   \   00000012   0xE053             B.N      ??DynProtocol_processPktByte_3
   1028          	case PROTOCOL_STATE_GID:
   1029          	{
   1030          		self->decode_state_machine.event_type = (rcvByte & EVENT_TYPE_MASK);
   \                     ??DynProtocol_processPktByte_0: (+1)
   \   00000014   0xF001 0x00C0      AND      R0,R1,#0xC0
   \   00000018   0x7320             STRB     R0,[R4, #+12]
   1031          		self->decode_state_machine.group_id   = (rcvByte & ~EVENT_TYPE_MASK);
   \   0000001A   0xF001 0x003F      AND      R0,R1,#0x3F
   \   0000001E   0x7360             STRB     R0,[R4, #+13]
   1032          		self->decode_state_machine.state      = PROTOCOL_STATE_CID;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7220             STRB     R0,[R4, #+8]
   1033          
   1034          		if(self->decode_state_machine.group_id != DYN_PROTOCOL_GROUP_ID) {
   \   00000024   0x7B60             LDRB     R0,[R4, #+13]
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD048             BEQ.N    ??DynProtocol_processPktByte_3
   1035          			self->decode_state_machine.state  = PROTOCOL_STATE_IDLE;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7220             STRB     R0,[R4, #+8]
   1036          			INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Invalid group ID");
   \   0000002E   0x.... 0x....      ADR.W    R1,?_5
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       inv_msg
   1037          			return -1;
   \   00000038   0xF04F 0x30FF      MOV      R0,#-1
   \   0000003C   0xBD10             POP      {R4,PC}
   1038          		}
   1039          		break;
   1040          	}
   1041          
   1042          	case PROTOCOL_STATE_CID:
   1043          	{
   1044          		int rc;
   1045          
   1046          		self->decode_state_machine.cmd_id     = rcvByte;
   \                     ??DynProtocol_processPktByte_2: (+1)
   \   0000003E   0x73A1             STRB     R1,[R4, #+14]
   1047          		self->decode_state_machine.state      = PROTOCOL_STATE_PAYLOAD;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x7220             STRB     R0,[R4, #+8]
   1048          		self->decode_state_machine.received_size = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x8260             STRH     R0,[R4, #+18]
   1049          		self->decode_state_machine.expected_size = 0;
   \   00000048   0x8220             STRH     R0,[R4, #+16]
   1050          		self->decode_state_machine.expected_size = DynProtocol_getPayload(self);
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       DynProtocol_getPayload
   \   00000050   0x8220             STRH     R0,[R4, #+16]
   1051          
   1052          		if((rc = DynProtocol_checkFrameSize(self)) != INV_ERROR_SUCCESS) {
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       DynProtocol_checkFrameSize
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD002             BEQ.N    ??DynProtocol_processPktByte_4
   1053          			self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x7221             STRB     R1,[R4, #+8]
   1054          			return rc;
   \   00000060   0xBD10             POP      {R4,PC}
   1055          		}
   1056          
   1057          		if(self->decode_state_machine.expected_size == 0) {
   \                     ??DynProtocol_processPktByte_4: (+1)
   \   00000062   0x8A20             LDRH     R0,[R4, #+16]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD129             BNE.N    ??DynProtocol_processPktByte_3
   1058          			return DynProtocol_doProcess(self);
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006E   0x....             B.N      DynProtocol_doProcess
   1059          		}
   1060          		break;
   1061          	}
   1062          
   1063          	case PROTOCOL_STATE_PAYLOAD:
   1064          	{
   1065          		int rc;
   1066          
   1067          		if(self->decode_state_machine.received_size >= MAX_EXPECTED_PAYLOAD)
   \                     ??DynProtocol_processPktByte_1: (+1)
   \   00000070   0x8A60             LDRH     R0,[R4, #+18]
   \   00000072   0x28FF             CMP      R0,#+255
   \   00000074   0xD905             BLS.N    ??DynProtocol_processPktByte_5
   1068          			INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: internal buffer size full");
   \   00000076   0x.... 0x....      ADR.W    R1,?_6
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0x.... 0x....      BL       inv_msg
   \   00000080   0xE001             B.N      ??DynProtocol_processPktByte_6
   1069          		else
   1070          			self->decode_state_machine.tmp_buffer[self->decode_state_machine.received_size] = rcvByte;
   \                     ??DynProtocol_processPktByte_5: (+1)
   \   00000082   0x4420             ADD      R0,R4,R0
   \   00000084   0x7501             STRB     R1,[R0, #+20]
   1071          
   1072          		self->decode_state_machine.received_size++;
   \                     ??DynProtocol_processPktByte_6: (+1)
   \   00000086   0x8A60             LDRH     R0,[R4, #+18]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x8260             STRH     R0,[R4, #+18]
   1073          		if(self->decode_state_machine.received_size == self->decode_state_machine.expected_size)
   \   0000008C   0x8A21             LDRH     R1,[R4, #+16]
   \   0000008E   0xB280             UXTH     R0,R0
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD103             BNE.N    ??DynProtocol_processPktByte_7
   1074          			/* update expected payload, in case actual payload cannot be determined using only CID */
   1075          			self->decode_state_machine.expected_size = DynProtocol_getPayload(self);
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       DynProtocol_getPayload
   \   0000009A   0x8220             STRH     R0,[R4, #+16]
   1076          
   1077          		if((rc = DynProtocol_checkFrameSize(self)) != INV_ERROR_SUCCESS) {
   \                     ??DynProtocol_processPktByte_7: (+1)
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       DynProtocol_checkFrameSize
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD002             BEQ.N    ??DynProtocol_processPktByte_8
   1078          			self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x7221             STRB     R1,[R4, #+8]
   1079          			return rc;
   \   000000AA   0xBD10             POP      {R4,PC}
   1080          		}
   1081          
   1082          		if(self->decode_state_machine.received_size == self->decode_state_machine.expected_size)
   \                     ??DynProtocol_processPktByte_8: (+1)
   \   000000AC   0x8A60             LDRH     R0,[R4, #+18]
   \   000000AE   0x8A21             LDRH     R1,[R4, #+16]
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xD103             BNE.N    ??DynProtocol_processPktByte_3
   1083          			return DynProtocol_doProcess(self);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xE8BD 0x4010      POP      {R4,LR}
   \   000000BA   0x....             B.N      DynProtocol_doProcess
   1084          
   1085          		break;
   1086          	}
   1087          	}
   1088          
   1089          	return 0;
   \                     ??DynProtocol_processPktByte_3: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xBD10             POP      {R4,PC}          ;; return
   1090          }
   1091          

   \                                 In section .text, align 4, keep-with-next
   1092          int DynProtocol_encodeCommand(DynProtocol_t * self,
   1093          		enum DynProtocolEid eid, const DynProtocolEdata_t * edata,
   1094          		uint8_t * outBuffer, uint16_t maxBufferSize, uint16_t *outBufferSize)
   1095          {
   \                     DynProtocol_encodeCommand: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461D             MOV      R5,R3
   \   0000000A   0x9E09             LDR      R6,[SP, #+36]
   1096          	int i, precision;
   1097          	uint16_t idx = 0;
   1098          
   1099          	(void)self;
   1100          
   1101          	*outBufferSize = 0;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x8032             STRH     R2,[R6, #+0]
   \   00000010   0x9A08             LDR      R2,[SP, #+32]
   1102          
   1103          	if(maxBufferSize < 2)
   \   00000012   0x2A02             CMP      R2,#+2
   \   00000014   0xF2C0 0x80A1      BLT.W    ??DynProtocol_encodeCommand_1
   1104          		goto error_size;
   1105          
   1106          	outBuffer[idx]  = EVENT_TYPE_CMD; // Set event type
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x702B             STRB     R3,[R5, #+0]
   1107          	outBuffer[idx++] |= (DYN_PROTOCOL_GROUP_ID & ~EVENT_TYPE_MASK); // Set group ID
   \   0000001C   0x2303             MOVS     R3,#+3
   \   0000001E   0x702B             STRB     R3,[R5, #+0]
   1108          	outBuffer[idx++] = (uint8_t)eid;
   \   00000020   0x7069             STRB     R1,[R5, #+1]
   \   00000022   0x2702             MOVS     R7,#+2
   1109          
   1110          	switch(eid) {
   \   00000024   0x2924             CMP      R1,#+36
   \   00000026   0xF200 0x8090      BHI.W    ??DynProtocol_encodeCommand_2
   \   0000002A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??DynProtocol_encodeCommand_0:
   \   0000002E   0x1A 0x8E          DC8      0x1A,0x8E,0x8E,0x8E
   \              0x8E 0x8E    
   \   00000032   0x8E 0x8E          DC8      0x8E,0x8E,0x8E,0x8E
   \              0x8E 0x8E    
   \   00000036   0x8E 0x8E          DC8      0x8E,0x8E,0x8E,0x8E
   \              0x8E 0x8E    
   \   0000003A   0x8E 0x8E          DC8      0x8E,0x8E,0x8E,0x8E
   \              0x8E 0x8E    
   \   0000003E   0x1A 0x1A          DC8      0x1A,0x1A,0x1A,0x1A
   \              0x1A 0x1A    
   \   00000042   0x8E 0x13          DC8      0x8E,0x13,0x1A,0x13
   \              0x1A 0x13    
   \   00000046   0x8E 0x13          DC8      0x8E,0x13,0x13,0x1D
   \              0x13 0x1D    
   \   0000004A   0x1D 0x13          DC8      0x1D,0x13,0x78,0x6F
   \              0x78 0x6F    
   \   0000004E   0x31 0x13          DC8      0x31,0x13,0x28,0x4A
   \              0x28 0x4A    
   \   00000052   0x6F 0x00          DC8      0x6F,0x0
   1111          	case DYN_PROTOCOL_EID_PROTOCOLVERSION:
   1112          	case DYN_PROTOCOL_EID_GET_FW_INFO:
   1113          	case DYN_PROTOCOL_EID_WHO_AM_I:
   1114          	case DYN_PROTOCOL_EID_RESET:
   1115          	case DYN_PROTOCOL_EID_SETUP:
   1116          	case DYN_PROTOCOL_EID_CLEANUP:
   1117          		break;
   1118          
   1119          	case DYN_PROTOCOL_EID_SELF_TEST:
   1120          	case DYN_PROTOCOL_EID_PING_SENSOR:
   1121          	case DYN_PROTOCOL_EID_START_SENSOR:
   1122          	case DYN_PROTOCOL_EID_STOP_SENSOR:
   1123          	case DYN_PROTOCOL_EID_FLUSH_SENSOR:
   1124          	case DYN_PROTOCOL_EID_GET_SENSOR_DATA:
   1125          		if((maxBufferSize - idx) < 1)
   \                     ??DynProtocol_encodeCommand_3: (+1)
   \   00000054   0x1E90             SUBS     R0,R2,#+2
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xF2C0 0x807F      BLT.W    ??DynProtocol_encodeCommand_1
   1126          			goto error_size;
   1127          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x70A8             STRB     R0,[R5, #+2]
   \   00000060   0x461F             MOV      R7,R3
   1128          		break;
   1129          
   1130          	case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:
   1131          		if((maxBufferSize - idx) < 5)
   1132          			goto error_size;
   1133          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1134          		inv_dc_int32_to_little8(edata->d.command.period, &outBuffer[idx]);
   1135          		idx += 4;
   1136          		break;
   1137          
   1138          	case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT:
   1139          		if((maxBufferSize - idx) < 5)
   1140          			goto error_size;
   1141          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1142          		inv_dc_int32_to_little8(edata->d.command.timeout, &outBuffer[idx]);
   1143          		idx += 4;
   1144          		break;
   1145          
   1146          	case DYN_PROTOCOL_EID_GET_SW_REG:
   1147          		if((maxBufferSize - idx) < 2)
   1148          			goto error_size;
   1149          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1150          		outBuffer[idx++] = (uint8_t)edata->d.command.regAddr;
   1151          		break;
   1152          
   1153          	case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX:
   1154          		if ((maxBufferSize - idx) < 1 + 1 + (9 * 4))
   1155          			goto error_size;
   1156          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1157          		outBuffer[idx++] = (uint8_t)((VSensorConfigReferenceFrame *)&edata->d.command.cfg)->base.type;
   1158          		for (i = 0; i < 9; i++) {
   1159          			inv_dc_int32_to_little8(((VSensorConfigReferenceFrame *)&edata->d.command.cfg)->matrix[i], &outBuffer[idx]);
   1160          			idx += 4;
   1161          		}
   1162          		break;
   1163          
   1164          	case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
   1165          		if((maxBufferSize - idx) < 67)
   1166          			goto error_size;
   1167          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1168          		outBuffer[idx++] = (uint8_t)edata->d.command.cfg.base.type;
   1169          		outBuffer[idx++] = (uint8_t)edata->d.command.cfg.size;
   1170          		switch (edata->d.command.cfg.base.type) {
   1171          		case VSENSOR_CONFIG_TYPE_OFFSET:
   1172          			precision = DynProtocol_getPrecision(self, edata->sensor_id);
   1173          			DynProtocol_encodeQxToQyVect16((int32_t*)&edata->d.command.cfg.buffer[0], 3, 16, precision, &outBuffer[idx]);
   1174          			break;
   1175          		default:
   1176          			// we don't know what is the value of cfg.size so let's make sure
   1177          			// there is enough room in outBuffer.
   1178          			if((maxBufferSize - idx) < edata->d.command.cfg.size)
   1179          				goto error_size;
   1180          			memcpy(&outBuffer[idx], edata->d.command.cfg.buffer, edata->d.command.cfg.size);
   1181          			break;
   1182          		}
   1183          		idx = 67 + 2;
   1184          		break;
   1185          
   1186          	case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
   1187          		if((maxBufferSize - idx) < 2)
   1188          			goto error_size;
   1189          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1190          		outBuffer[idx++] = (uint8_t)edata->d.command.cfg.base.type;
   1191          		break;
   1192          
   1193          	case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
   1194          		if((maxBufferSize - idx) < 2)
   1195          			goto error_size;
   1196          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1197          		outBuffer[idx++] = (uint8_t)edata->d.command.cfg.base.type;
   1198          		break;
   1199          
   1200          	case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:
   1201          		if ((maxBufferSize - idx) < 1 + (3 * 2))
   1202          			goto error_size;
   1203          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   1204          		outBuffer[idx++] = (uint8_t)edata->d.command.cfg.base.type;
   1205          		precision = DynProtocol_getPrecision(self, edata->sensor_id);
   1206          		idx += DynProtocol_encodeQxToQyVect16(&((VSensorConfigOffset *)&edata->d.command.cfg)->vect[0], 3, 16, precision, &outBuffer[idx]);
   1207          		break;
   1208          
   1209          	default:
   1210          		INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected argument for encode_command()");
   1211          		return -1;
   1212          	}
   1213          
   1214          	*outBufferSize = (idx);
   \                     ??DynProtocol_encodeCommand_4: (+1)
   \   00000062   0x8037             STRH     R7,[R6, #+0]
   1215          	return 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE07F             B.N      ??DynProtocol_encodeCommand_5
   \                     ??DynProtocol_encodeCommand_6: (+1)
   \   00000068   0x1E90             SUBS     R0,R2,#+2
   \   0000006A   0x2805             CMP      R0,#+5
   \   0000006C   0xDB75             BLT.N    ??DynProtocol_encodeCommand_1
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x70A8             STRB     R0,[R5, #+2]
   \   00000072   0x1CE9             ADDS     R1,R5,#+3
   \   00000074   0x6860             LDR      R0,[R4, #+4]
   \   00000076   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   0000007A   0x2707             MOVS     R7,#+7
   \   0000007C   0xE7F1             B.N      ??DynProtocol_encodeCommand_4
   \                     ??DynProtocol_encodeCommand_7: (+1)
   \   0000007E   0x1E90             SUBS     R0,R2,#+2
   \   00000080   0x2802             CMP      R0,#+2
   \   00000082   0xDB6A             BLT.N    ??DynProtocol_encodeCommand_1
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x70A8             STRB     R0,[R5, #+2]
   \   00000088   0x7920             LDRB     R0,[R4, #+4]
   \   0000008A   0x70E8             STRB     R0,[R5, #+3]
   \   0000008C   0x2704             MOVS     R7,#+4
   \   0000008E   0xE7E8             B.N      ??DynProtocol_encodeCommand_4
   \                     ??DynProtocol_encodeCommand_8: (+1)
   \   00000090   0x1E90             SUBS     R0,R2,#+2
   \   00000092   0x2826             CMP      R0,#+38
   \   00000094   0xDB61             BLT.N    ??DynProtocol_encodeCommand_1
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x70A8             STRB     R0,[R5, #+2]
   \   0000009A   0x6860             LDR      R0,[R4, #+4]
   \   0000009C   0x70E8             STRB     R0,[R5, #+3]
   \   0000009E   0x2704             MOVS     R7,#+4
   \   000000A0   0xF04F 0x0800      MOV      R8,#+0
   \                     ??DynProtocol_encodeCommand_9: (+1)
   \   000000A4   0xF1B8 0x0F09      CMP      R8,#+9
   \   000000A8   0xDADB             BGE.N    ??DynProtocol_encodeCommand_4
   \   000000AA   0x4638             MOV      R0,R7
   \   000000AC   0x1829             ADDS     R1,R5,R0
   \   000000AE   0xEB04 0x0088      ADD      R0,R4,R8, LSL #+2
   \   000000B2   0x6880             LDR      R0,[R0, #+8]
   \   000000B4   0x.... 0x....      BL       inv_dc_int32_to_little8
   \   000000B8   0x1D3F             ADDS     R7,R7,#+4
   \   000000BA   0xB2BF             UXTH     R7,R7
   \   000000BC   0xF108 0x0801      ADD      R8,R8,#+1
   \   000000C0   0xE7F0             B.N      ??DynProtocol_encodeCommand_9
   \                     ??DynProtocol_encodeCommand_10: (+1)
   \   000000C2   0x1E91             SUBS     R1,R2,#+2
   \   000000C4   0x2943             CMP      R1,#+67
   \   000000C6   0xDB48             BLT.N    ??DynProtocol_encodeCommand_1
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x70A9             STRB     R1,[R5, #+2]
   \   000000CC   0x6861             LDR      R1,[R4, #+4]
   \   000000CE   0x70E9             STRB     R1,[R5, #+3]
   \   000000D0   0x7A21             LDRB     R1,[R4, #+8]
   \   000000D2   0x7129             STRB     R1,[R5, #+4]
   \   000000D4   0x6861             LDR      R1,[R4, #+4]
   \   000000D6   0x2903             CMP      R1,#+3
   \   000000D8   0xD10C             BNE.N    ??DynProtocol_encodeCommand_11
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x.... 0x....      BL       DynProtocol_getPrecision
   \   000000E0   0x1D69             ADDS     R1,R5,#+5
   \   000000E2   0x9100             STR      R1,[SP, #+0]
   \   000000E4   0x4603             MOV      R3,R0
   \   000000E6   0x2210             MOVS     R2,#+16
   \   000000E8   0x2103             MOVS     R1,#+3
   \   000000EA   0xF104 0x0009      ADD      R0,R4,#+9
   \   000000EE   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   000000F2   0xE009             B.N      ??DynProtocol_encodeCommand_12
   \                     ??DynProtocol_encodeCommand_11: (+1)
   \   000000F4   0x7A20             LDRB     R0,[R4, #+8]
   \   000000F6   0x1F51             SUBS     R1,R2,#+5
   \   000000F8   0x4281             CMP      R1,R0
   \   000000FA   0xDB2E             BLT.N    ??DynProtocol_encodeCommand_1
   \   000000FC   0x4602             MOV      R2,R0
   \   000000FE   0xF104 0x0109      ADD      R1,R4,#+9
   \   00000102   0x1D68             ADDS     R0,R5,#+5
   \   00000104   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??DynProtocol_encodeCommand_12: (+1)
   \   00000108   0x2745             MOVS     R7,#+69
   \   0000010A   0xE7AA             B.N      ??DynProtocol_encodeCommand_4
   \                     ??DynProtocol_encodeCommand_13: (+1)
   \   0000010C   0x1E90             SUBS     R0,R2,#+2
   \   0000010E   0x2802             CMP      R0,#+2
   \   00000110   0xDB23             BLT.N    ??DynProtocol_encodeCommand_1
   \   00000112   0x6820             LDR      R0,[R4, #+0]
   \   00000114   0x70A8             STRB     R0,[R5, #+2]
   \   00000116   0x6860             LDR      R0,[R4, #+4]
   \   00000118   0x70E8             STRB     R0,[R5, #+3]
   \   0000011A   0x2704             MOVS     R7,#+4
   \   0000011C   0xE7A1             B.N      ??DynProtocol_encodeCommand_4
   \                     ??DynProtocol_encodeCommand_14: (+1)
   \   0000011E   0x1E91             SUBS     R1,R2,#+2
   \   00000120   0x2907             CMP      R1,#+7
   \   00000122   0xDB1A             BLT.N    ??DynProtocol_encodeCommand_1
   \   00000124   0x6821             LDR      R1,[R4, #+0]
   \   00000126   0x70A9             STRB     R1,[R5, #+2]
   \   00000128   0x6861             LDR      R1,[R4, #+4]
   \   0000012A   0x70E9             STRB     R1,[R5, #+3]
   \   0000012C   0x6821             LDR      R1,[R4, #+0]
   \   0000012E   0x.... 0x....      BL       DynProtocol_getPrecision
   \   00000132   0x1D29             ADDS     R1,R5,#+4
   \   00000134   0x9100             STR      R1,[SP, #+0]
   \   00000136   0x4603             MOV      R3,R0
   \   00000138   0x2210             MOVS     R2,#+16
   \   0000013A   0x2103             MOVS     R1,#+3
   \   0000013C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000140   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   00000144   0x1D07             ADDS     R7,R0,#+4
   \   00000146   0xB2BF             UXTH     R7,R7
   \   00000148   0xE78B             B.N      ??DynProtocol_encodeCommand_4
   \                     ??DynProtocol_encodeCommand_2: (+1)
   \   0000014A   0x.... 0x....      ADR.W    R1,?_7
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0x.... 0x....      BL       inv_msg
   \   00000154   0xF04F 0x30FF      MOV      R0,#-1
   \   00000158   0xE006             B.N      ??DynProtocol_encodeCommand_5
   1216          
   1217          error_size:
   1218          	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: output buffer size too small");
   \                     ??DynProtocol_encodeCommand_1: (+1)
   \   0000015A   0x.... 0x....      ADR.W    R1,?_8
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0x.... 0x....      BL       inv_msg
   1219          	return -1;
   \   00000164   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??DynProtocol_encodeCommand_5: (+1)
   \   00000168   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1220          }
   1221          

   \                                 In section .text, align 2, keep-with-next
   1222          int DynProtocol_encodeResponse(DynProtocol_t * self,
   1223          		enum DynProtocolEid eid, const DynProtocolEdata_t * edata,
   1224          		uint8_t * outBuffer, uint16_t maxBufferSize, uint16_t *outBufferSize)
   1225          {
   \                     DynProtocol_encodeResponse: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x461E             MOV      R6,R3
   \   00000006   0x9C07             LDR      R4,[SP, #+28]
   1226          	int precision;
   1227          	uint16_t idx = 0;
   1228          
   1229          	(void)self;
   1230          
   1231          	*outBufferSize = 0;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x8022             STRH     R2,[R4, #+0]
   \   0000000C   0x9A06             LDR      R2,[SP, #+24]
   1232          
   1233          	if(maxBufferSize < 2)
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x2B02             CMP      R3,#+2
   \   00000012   0xF2C0 0x808C      BLT.W    ??DynProtocol_encodeResponse_0
   1234          		goto error_size;
   1235          
   1236          	outBuffer[idx]  = EVENT_TYPE_RESP; // Set event type
   \   00000016   0x2740             MOVS     R7,#+64
   \   00000018   0x7037             STRB     R7,[R6, #+0]
   1237          	outBuffer[idx++] |= DYN_PROTOCOL_GROUP_ID & ~EVENT_TYPE_MASK; // Set group ID
   \   0000001A   0x2743             MOVS     R7,#+67
   \   0000001C   0x7037             STRB     R7,[R6, #+0]
   1238          	outBuffer[idx++] = (uint8_t)eid;
   \   0000001E   0x7071             STRB     R1,[R6, #+1]
   1239          
   1240          	switch(eid) {
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD017             BEQ.N    ??DynProtocol_encodeResponse_1
   \   00000024   0x3910             SUBS     R1,R1,#+16
   \   00000026   0x2903             CMP      R1,#+3
   \   00000028   0xD920             BLS.N    ??DynProtocol_encodeResponse_2
   \   0000002A   0x1F49             SUBS     R1,R1,#+5
   \   0000002C   0xD01E             BEQ.N    ??DynProtocol_encodeResponse_2
   \   0000002E   0x1E49             SUBS     R1,R1,#+1
   \   00000030   0xD010             BEQ.N    ??DynProtocol_encodeResponse_1
   \   00000032   0x1E49             SUBS     R1,R1,#+1
   \   00000034   0xD01A             BEQ.N    ??DynProtocol_encodeResponse_2
   \   00000036   0x1E89             SUBS     R1,R1,#+2
   \   00000038   0x2905             CMP      R1,#+5
   \   0000003A   0xD917             BLS.N    ??DynProtocol_encodeResponse_2
   \   0000003C   0x1F89             SUBS     R1,R1,#+6
   \   0000003E   0xD054             BEQ.N    ??DynProtocol_encodeResponse_3
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0xD013             BEQ.N    ??DynProtocol_encodeResponse_2
   \   00000044   0x1E49             SUBS     R1,R1,#+1
   \   00000046   0xD018             BEQ.N    ??DynProtocol_encodeResponse_4
   \   00000048   0x1E49             SUBS     R1,R1,#+1
   \   0000004A   0x2901             CMP      R1,#+1
   \   0000004C   0xD90E             BLS.N    ??DynProtocol_encodeResponse_2
   \   0000004E   0x1E89             SUBS     R1,R1,#+2
   \   00000050   0xD025             BEQ.N    ??DynProtocol_encodeResponse_5
   \   00000052   0xE064             B.N      ??DynProtocol_encodeResponse_6
   1241          	case DYN_PROTOCOL_EID_PROTOCOLVERSION:
   1242          	case DYN_PROTOCOL_EID_GET_FW_INFO:
   1243          	{
   1244          		if((maxBufferSize - idx) < 16)
   \                     ??DynProtocol_encodeResponse_1: (+1)
   \   00000054   0x1E98             SUBS     R0,R3,#+2
   \   00000056   0x2810             CMP      R0,#+16
   \   00000058   0xDB69             BLT.N    ??DynProtocol_encodeResponse_0
   1245          			goto error_size;
   1246          		memcpy(&outBuffer[idx], edata->d.response.version, 15);
   \   0000005A   0x220F             MOVS     R2,#+15
   \   0000005C   0x1D29             ADDS     R1,R5,#+4
   \   0000005E   0x1CB0             ADDS     R0,R6,#+2
   \   00000060   0x.... 0x....      BL       __aeabi_memcpy
   1247          		outBuffer[idx+15] = '\0';
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x7470             STRB     R0,[R6, #+17]
   1248          		idx += 16;
   \   00000068   0x2012             MOVS     R0,#+18
   1249          		break;
   \   0000006A   0xE055             B.N      ??DynProtocol_encodeResponse_7
   1250          	}
   1251          
   1252          	case DYN_PROTOCOL_EID_WHO_AM_I:
   1253          	case DYN_PROTOCOL_EID_RESET:
   1254          	case DYN_PROTOCOL_EID_SETUP:
   1255          	case DYN_PROTOCOL_EID_CLEANUP:
   1256          	case DYN_PROTOCOL_EID_SELF_TEST:
   1257          	case DYN_PROTOCOL_EID_PING_SENSOR:
   1258          	case DYN_PROTOCOL_EID_START_SENSOR:
   1259          	case DYN_PROTOCOL_EID_STOP_SENSOR:
   1260          	case DYN_PROTOCOL_EID_FLUSH_SENSOR:
   1261          	case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:
   1262          	case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT:
   1263          	case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX:
   1264          	case DYN_PROTOCOL_EID_GET_SW_REG:
   1265          	case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
   1266          	case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:
   1267          	{
   1268          		if((maxBufferSize - idx) < 1)
   \                     ??DynProtocol_encodeResponse_2: (+1)
   \   0000006C   0x1E98             SUBS     R0,R3,#+2
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xDB5D             BLT.N    ??DynProtocol_encodeResponse_0
   1269          			goto error_size;
   1270          		outBuffer[idx++] = (uint8_t)edata->d.response.rc;
   \   00000072   0x6868             LDR      R0,[R5, #+4]
   \   00000074   0x70B0             STRB     R0,[R6, #+2]
   \   00000076   0x2003             MOVS     R0,#+3
   1271          		break;
   \   00000078   0xE04E             B.N      ??DynProtocol_encodeResponse_7
   1272          	}
   1273          
   1274          	case DYN_PROTOCOL_EID_GET_SENSOR_DATA:
   1275          	{
   1276          		if((maxBufferSize - idx) < (1+1+1+4+64)) // need room for rc+sensorstatus+sensorid+timestamp+data
   \                     ??DynProtocol_encodeResponse_4: (+1)
   \   0000007A   0x1E99             SUBS     R1,R3,#+2
   \   0000007C   0x2947             CMP      R1,#+71
   \   0000007E   0xDB56             BLT.N    ??DynProtocol_encodeResponse_0
   1277          			goto error_size;
   1278          		outBuffer[idx++] = edata->d.response.sensorData.rc;
   \   00000080   0x6869             LDR      R1,[R5, #+4]
   \   00000082   0x70B1             STRB     R1,[R6, #+2]
   1279           		if(DynProtocol_encodeSensorEvent(self, edata, &outBuffer[idx], maxBufferSize - idx, DYN_PROTOCOL_ETYPE_RESP) == -1)
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x9100             STR      R1,[SP, #+0]
   \   00000088   0x1ED3             SUBS     R3,R2,#+3
   \   0000008A   0xB29B             UXTH     R3,R3
   \   0000008C   0x1CF2             ADDS     R2,R6,#+3
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0x.... 0x....      BL       DynProtocol_encodeSensorEvent
   \   00000094   0xF110 0x0F01      CMN      R0,#+1
   \   00000098   0xD041             BEQ.N    ??DynProtocol_encodeResponse_6
   1280          			goto error_arg;
   1281          
   1282          		// GET_SENSOR_DATA response frame size is fixed:
   1283          		//  EVT_TYPE + EVT_ID + RC + SENSOR_STATUS + SENSORID + TIMESTAMP[0-3] + MAX_SENSOR_EVENT_DATA_SIZE (arbitrary fixed to 64B)
   1284          		idx = 1+1+1+1+1+4+64;
   \   0000009A   0x2049             MOVS     R0,#+73
   1285          		break;
   \   0000009C   0xE03C             B.N      ??DynProtocol_encodeResponse_7
   1286          	}
   1287          
   1288          	case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
   1289          	{
   1290          		if((maxBufferSize - idx) < 68)
   \                     ??DynProtocol_encodeResponse_5: (+1)
   \   0000009E   0x1E99             SUBS     R1,R3,#+2
   \   000000A0   0x2944             CMP      R1,#+68
   \   000000A2   0xDB44             BLT.N    ??DynProtocol_encodeResponse_0
   1291          			goto error_size;
   1292          		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.rc;
   \   000000A4   0x6869             LDR      R1,[R5, #+4]
   \   000000A6   0x70B1             STRB     R1,[R6, #+2]
   1293          		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.type;
   \   000000A8   0x68A9             LDR      R1,[R5, #+8]
   \   000000AA   0x70F1             STRB     R1,[R6, #+3]
   1294          		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.size;
   \   000000AC   0x7B29             LDRB     R1,[R5, #+12]
   \   000000AE   0x7131             STRB     R1,[R6, #+4]
   1295          		switch (edata->d.response.sensorcfg.cfg.base.type) {
   \   000000B0   0x68A9             LDR      R1,[R5, #+8]
   \   000000B2   0x2903             CMP      R1,#+3
   \   000000B4   0xD10E             BNE.N    ??DynProtocol_encodeResponse_8
   1296          		case VSENSOR_CONFIG_TYPE_OFFSET:
   1297          			outBuffer[idx++] = (uint8_t)edata->sensor_id;
   \   000000B6   0x6829             LDR      R1,[R5, #+0]
   \   000000B8   0x7171             STRB     R1,[R6, #+5]
   1298          			precision = DynProtocol_getPrecision(self, edata->sensor_id);
   \   000000BA   0x6829             LDR      R1,[R5, #+0]
   \   000000BC   0x.... 0x....      BL       DynProtocol_getPrecision
   1299          			DynProtocol_encodeQxToQyVect16((int32_t*)&edata->d.response.sensorcfg.cfg.buffer[0], 3, 16, precision, &outBuffer[idx]);
   \   000000C0   0x1DB1             ADDS     R1,R6,#+6
   \   000000C2   0x9100             STR      R1,[SP, #+0]
   \   000000C4   0x4603             MOV      R3,R0
   \   000000C6   0x2210             MOVS     R2,#+16
   \   000000C8   0x2103             MOVS     R1,#+3
   \   000000CA   0xF105 0x000D      ADD      R0,R5,#+13
   \   000000CE   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   1300          			break;
   \   000000D2   0xE008             B.N      ??DynProtocol_encodeResponse_9
   1301          		default:
   1302          			// we don't know what is the value of cfg.size so let's make sure
   1303          			// there is enough room in outBuffer.
   1304          			if((maxBufferSize - idx) < edata->d.response.sensorcfg.cfg.size)
   \                     ??DynProtocol_encodeResponse_8: (+1)
   \   000000D4   0x7B2A             LDRB     R2,[R5, #+12]
   \   000000D6   0x1F58             SUBS     R0,R3,#+5
   \   000000D8   0x4290             CMP      R0,R2
   \   000000DA   0xDB28             BLT.N    ??DynProtocol_encodeResponse_0
   1305          				goto error_size;
   1306          			memcpy(&outBuffer[idx], edata->d.response.sensorcfg.cfg.buffer, edata->d.response.sensorcfg.cfg.size);
   \   000000DC   0xF105 0x010D      ADD      R1,R5,#+13
   \   000000E0   0x1D70             ADDS     R0,R6,#+5
   \   000000E2   0x.... 0x....      BL       __aeabi_memcpy
   1307          			break;
   1308          		}
   1309          		idx = 68 + 2;
   \                     ??DynProtocol_encodeResponse_9: (+1)
   \   000000E6   0x2046             MOVS     R0,#+70
   1310          		break;
   \   000000E8   0xE016             B.N      ??DynProtocol_encodeResponse_7
   1311          	}
   1312          
   1313          	case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
   1314          	{
   1315          		if ((maxBufferSize - idx) < 1 + 1 + 1 + (3 * 2))
   \                     ??DynProtocol_encodeResponse_3: (+1)
   \   000000EA   0x1E99             SUBS     R1,R3,#+2
   \   000000EC   0x2909             CMP      R1,#+9
   \   000000EE   0xDB1E             BLT.N    ??DynProtocol_encodeResponse_0
   1316          			goto error_size;
   1317          		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.rc;
   \   000000F0   0x6869             LDR      R1,[R5, #+4]
   \   000000F2   0x70B1             STRB     R1,[R6, #+2]
   1318          		outBuffer[idx++] = (uint8_t)edata->sensor_id;
   \   000000F4   0x6829             LDR      R1,[R5, #+0]
   \   000000F6   0x70F1             STRB     R1,[R6, #+3]
   1319          		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.type;
   \   000000F8   0x68A9             LDR      R1,[R5, #+8]
   \   000000FA   0x7131             STRB     R1,[R6, #+4]
   1320          		precision = DynProtocol_getPrecision(self, edata->sensor_id);
   \   000000FC   0x6829             LDR      R1,[R5, #+0]
   \   000000FE   0x.... 0x....      BL       DynProtocol_getPrecision
   1321          		idx += DynProtocol_encodeQxToQyVect16(&((VSensorConfigOffset *)&edata->d.response.sensorcfg.cfg)->vect[0], 3, 16, precision, &outBuffer[idx]);
   \   00000102   0x1D71             ADDS     R1,R6,#+5
   \   00000104   0x9100             STR      R1,[SP, #+0]
   \   00000106   0x4603             MOV      R3,R0
   \   00000108   0x2210             MOVS     R2,#+16
   \   0000010A   0x2103             MOVS     R1,#+3
   \   0000010C   0xF105 0x000C      ADD      R0,R5,#+12
   \   00000110   0x.... 0x....      BL       DynProtocol_encodeQxToQyVect16
   \   00000114   0x1D40             ADDS     R0,R0,#+5
   \   00000116   0xB280             UXTH     R0,R0
   1322          		break;
   1323          	}
   1324          
   1325          	default:
   1326          		goto error_arg;
   1327          	}
   1328          
   1329          	*outBufferSize = (idx);
   \                     ??DynProtocol_encodeResponse_7: (+1)
   \   00000118   0x8020             STRH     R0,[R4, #+0]
   1330          
   1331          	return 0;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xBDF2             POP      {R1,R4-R7,PC}
   1332          
   1333          error_arg:
   1334          	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected argument for DynProtocol_encodeResponse()");
   \                     ??DynProtocol_encodeResponse_6: (+1)
   \   0000011E   0x.... 0x....      ADR.W    R1,?_9
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x.... 0x....      BL       inv_msg
   1335          	return -1;
   \   00000128   0xF04F 0x30FF      MOV      R0,#-1
   \   0000012C   0xBDF2             POP      {R1,R4-R7,PC}
   1336          
   1337          error_size:
   1338          	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: output buffer size too small");
   \                     ??DynProtocol_encodeResponse_0: (+1)
   \   0000012E   0x.... 0x....      ADR.W    R1,?_8
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0x.... 0x....      BL       inv_msg
   1339          	return -1;
   \   00000138   0xF04F 0x30FF      MOV      R0,#-1
   \   0000013C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1340          }
   1341          

   \                                 In section .text, align 2, keep-with-next
   1342          int DynProtocol_encodeAsync(DynProtocol_t * self,
   1343          		enum DynProtocolEid eid, const DynProtocolEdata_t * edata,
   1344          		uint8_t * outBuffer, uint16_t maxBufferSize, uint16_t *outBufferSize)
   1345          {
   \                     DynProtocol_encodeAsync: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4611             MOV      R1,R2
   \   00000006   0x461F             MOV      R7,R3
   \   00000008   0x9D07             LDR      R5,[SP, #+28]
   1346          	uint16_t idx = 0;
   1347          	int len;
   1348          
   1349          	(void)self;
   1350          
   1351          	*outBufferSize = 0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x802A             STRH     R2,[R5, #+0]
   \   0000000E   0x9A06             LDR      R2,[SP, #+24]
   1352          
   1353          	if(maxBufferSize < 2)
   \   00000010   0x4616             MOV      R6,R2
   \   00000012   0x2E02             CMP      R6,#+2
   \   00000014   0xDB1F             BLT.N    ??DynProtocol_encodeAsync_0
   1354          		goto error_size;
   1355          
   1356          	outBuffer[idx]  = EVENT_TYPE_ASYNC; // Set event type
   \   00000016   0x2380             MOVS     R3,#+128
   \   00000018   0x703B             STRB     R3,[R7, #+0]
   1357          	outBuffer[idx++] |= DYN_PROTOCOL_GROUP_ID & ~EVENT_TYPE_MASK; // Set group ID
   \   0000001A   0x2383             MOVS     R3,#+131
   \   0000001C   0x703B             STRB     R3,[R7, #+0]
   1358          	outBuffer[idx++] = (uint8_t)eid;
   \   0000001E   0x707C             STRB     R4,[R7, #+1]
   1359          
   1360          	switch(eid) {
   \   00000020   0x2C30             CMP      R4,#+48
   \   00000022   0xD110             BNE.N    ??DynProtocol_encodeAsync_1
   1361          	case DYN_PROTOCOL_EID_NEW_SENSOR_DATA:
   1362          	{
   1363          		len = DynProtocol_encodeSensorEvent(self, edata, &outBuffer[idx], maxBufferSize - idx, DYN_PROTOCOL_ETYPE_ASYNC);
   \   00000024   0x2302             MOVS     R3,#+2
   \   00000026   0x9300             STR      R3,[SP, #+0]
   \   00000028   0x1E93             SUBS     R3,R2,#+2
   \   0000002A   0xB29B             UXTH     R3,R3
   \   0000002C   0x1CBA             ADDS     R2,R7,#+2
   \   0000002E   0x.... 0x....      BL       DynProtocol_encodeSensorEvent
   1364          		if(len == -1)
   \   00000032   0xF110 0x0F01      CMN      R0,#+1
   \   00000036   0xD006             BEQ.N    ??DynProtocol_encodeAsync_1
   1365          			goto error_arg;
   1366          		else if(len > maxBufferSize - idx)
   \   00000038   0x1EB1             SUBS     R1,R6,#+2
   \   0000003A   0x4281             CMP      R1,R0
   \   0000003C   0xDB0B             BLT.N    ??DynProtocol_encodeAsync_0
   1367          			goto error_size;
   1368          
   1369          		idx += len;
   1370          		break;
   1371          	}
   1372          
   1373          	default:
   1374          		goto error_arg;
   1375          	}
   1376          
   1377          	*outBufferSize = (idx);
   \   0000003E   0x1C80             ADDS     R0,R0,#+2
   \   00000040   0x8028             STRH     R0,[R5, #+0]
   1378          
   1379          	return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}
   1380          
   1381          error_arg:
   1382          	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected argument for encode_async()");
   \                     ??DynProtocol_encodeAsync_1: (+1)
   \   00000046   0x.... 0x....      ADR.W    R1,?_10
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      BL       inv_msg
   1383          	return -1;
   \   00000050   0xF04F 0x30FF      MOV      R0,#-1
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}
   1384          
   1385          error_size:
   1386          	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: output buffer size too small");
   \                     ??DynProtocol_encodeAsync_0: (+1)
   \   00000056   0x.... 0x....      ADR.W    R1,?_8
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       inv_msg
   1387          	return -1;
   \   00000060   0xF04F 0x30FF      MOV      R0,#-1
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1388          }
   1389          

   \                                 In section .text, align 4, keep-with-next
   1390          const char * DynProtocol_sensorTypeToStr(int type)
   1391          {
   1392          	switch(type) {
   \                     DynProtocol_sensorTypeToStr: (+1)
   \   00000000   0x2840             CMP      R0,#+64
   \   00000002   0xF200 0x80D1      BHI.W    ??DynProtocol_sensorTypeToStr_1
   \   00000006   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??DynProtocol_sensorTypeToStr_0:
   \   0000000A   0x21 0x24          DC8      0x21,0x24,0x27,0x2A
   \              0x27 0x2A    
   \   0000000E   0x2D 0x30          DC8      0x2D,0x30,0x33,0x36
   \              0x33 0x36    
   \   00000012   0x39 0x3C          DC8      0x39,0x3C,0x3F,0x42
   \              0x3F 0x42    
   \   00000016   0x45 0x48          DC8      0x45,0x48,0x4B,0x4E
   \              0x4B 0x4E    
   \   0000001A   0x51 0x54          DC8      0x51,0x54,0x56,0x59
   \              0x56 0x59    
   \   0000001E   0x5C 0x5F          DC8      0x5C,0x5F,0x62,0x65
   \              0x62 0x65    
   \   00000022   0x68 0x6B          DC8      0x68,0x6B,0x6E,0x70
   \              0x6E 0x70    
   \   00000026   0x72 0x74          DC8      0x72,0x74,0x77,0x79
   \              0x77 0x79    
   \   0000002A   0x7B 0x7E          DC8      0x7B,0x7E,0x81,0x84
   \              0x81 0x84    
   \   0000002E   0x87 0x8A          DC8      0x87,0x8A,0x8C,0x8F
   \              0x8C 0x8F    
   \   00000032   0x92 0x94          DC8      0x92,0x94,0x97,0x9A
   \              0x97 0x9A    
   \   00000036   0x9D 0xA0          DC8      0x9D,0xA0,0xA3,0xA6
   \              0xA3 0xA6    
   \   0000003A   0xA9 0xAC          DC8      0xA9,0xAC,0xAF,0xB2
   \              0xAF 0xB2    
   \   0000003E   0xB5 0xB8          DC8      0xB5,0xB8,0xBB,0xBE
   \              0xBB 0xBE    
   \   00000042   0xC1 0xC4          DC8      0xC1,0xC4,0xC6,0xCF
   \              0xC6 0xCF    
   \   00000046   0xC9 0xCF          DC8      0xC9,0xCF,0xCF,0xCF
   \              0xCF 0xCF    
   \   0000004A   0xCC 0x00          DC8      0xCC,0x0
   1393          	case DYN_PRO_SENSOR_TYPE_RESERVED:               return "RESERVED";
   \                     ??DynProtocol_sensorTypeToStr_2: (+1)
   \   0000004C   0x.... 0x....      ADR.W    R0,?_11
   \   00000050   0x4770             BX       LR
   1394          	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:          return "ACCELEROMETER";
   \                     ??DynProtocol_sensorTypeToStr_3: (+1)
   \   00000052   0x.... 0x....      ADR.W    R0,?_12
   \   00000056   0x4770             BX       LR
   1395          	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:           return "MAGNETOMETER";
   \                     ??DynProtocol_sensorTypeToStr_4: (+1)
   \   00000058   0x.... 0x....      ADR.W    R0,?_13
   \   0000005C   0x4770             BX       LR
   1396          	case DYN_PRO_SENSOR_TYPE_ORIENTATION:            return "ORIENTATION";
   \                     ??DynProtocol_sensorTypeToStr_5: (+1)
   \   0000005E   0x.... 0x....      ADR.W    R0,?_14
   \   00000062   0x4770             BX       LR
   1397          	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:              return "GYROSCOPE";
   \                     ??DynProtocol_sensorTypeToStr_6: (+1)
   \   00000064   0x.... 0x....      ADR.W    R0,?_15
   \   00000068   0x4770             BX       LR
   1398          	case DYN_PRO_SENSOR_TYPE_LIGHT:                  return "LIGHT";
   \                     ??DynProtocol_sensorTypeToStr_7: (+1)
   \   0000006A   0x.... 0x....      ADR.W    R0,?_16
   \   0000006E   0x4770             BX       LR
   1399          	case DYN_PRO_SENSOR_TYPE_PRESSURE:               return "PRESSURE";
   \                     ??DynProtocol_sensorTypeToStr_8: (+1)
   \   00000070   0x.... 0x....      ADR.W    R0,?_17
   \   00000074   0x4770             BX       LR
   1400          	case DYN_PRO_SENSOR_TYPE_TEMPERATURE:            return "TEMPERATURE";
   \                     ??DynProtocol_sensorTypeToStr_9: (+1)
   \   00000076   0x.... 0x....      ADR.W    R0,?_18
   \   0000007A   0x4770             BX       LR
   1401          	case DYN_PRO_SENSOR_TYPE_PROXIMITY:              return "PROXIMITY";
   \                     ??DynProtocol_sensorTypeToStr_10: (+1)
   \   0000007C   0x.... 0x....      ADR.W    R0,?_19
   \   00000080   0x4770             BX       LR
   1402          	case DYN_PRO_SENSOR_TYPE_GRAVITY:                return "GRAVITY";
   \                     ??DynProtocol_sensorTypeToStr_11: (+1)
   \   00000082   0x.... 0x....      ADR.W    R0,?_20
   \   00000086   0x4770             BX       LR
   1403          	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:    return "LINEAR_ACCELERATION";
   \                     ??DynProtocol_sensorTypeToStr_12: (+1)
   \   00000088   0x.... 0x....      ADR.W    R0,?_21
   \   0000008C   0x4770             BX       LR
   1404          	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:        return "ROTATION_VECTOR";
   \                     ??DynProtocol_sensorTypeToStr_13: (+1)
   \   0000008E   0x.... 0x....      ADR.W    R0,?_22
   \   00000092   0x4770             BX       LR
   1405          	case DYN_PRO_SENSOR_TYPE_HUMIDITY:               return "HUMIDITY";
   \                     ??DynProtocol_sensorTypeToStr_14: (+1)
   \   00000094   0x.... 0x....      ADR.W    R0,?_23
   \   00000098   0x4770             BX       LR
   1406          	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:    return "AMBIENT_TEMPERATURE";
   \                     ??DynProtocol_sensorTypeToStr_15: (+1)
   \   0000009A   0x.... 0x....      ADR.W    R0,?_24
   \   0000009E   0x4770             BX       LR
   1407          	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:     return "UNCAL_MAGNETOMETER";
   \                     ??DynProtocol_sensorTypeToStr_16: (+1)
   \   000000A0   0x.... 0x....      ADR.W    R0,?_25
   \   000000A4   0x4770             BX       LR
   1408          	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:   return "GAME_ROTATION_VECTOR";
   \                     ??DynProtocol_sensorTypeToStr_17: (+1)
   \   000000A6   0x.... 0x....      ADR.W    R0,?_26
   \   000000AA   0x4770             BX       LR
   1409          	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:        return "UNCAL_GYROSCOPE";
   \                     ??DynProtocol_sensorTypeToStr_18: (+1)
   \   000000AC   0x.... 0x....      ADR.W    R0,?_27
   \   000000B0   0x4770             BX       LR
   1410          	case DYN_PRO_SENSOR_TYPE_SMD:                    return "SMD";
   \                     ??DynProtocol_sensorTypeToStr_19: (+1)
   \   000000B2   0x....             ADR.N    R0,??DataTable73  ;; "SMD"
   \   000000B4   0x4770             BX       LR
   1411          	case DYN_PRO_SENSOR_TYPE_STEP_DETECTOR:          return "STEP_DETECTOR";
   \                     ??DynProtocol_sensorTypeToStr_20: (+1)
   \   000000B6   0x.... 0x....      ADR.W    R0,?_29
   \   000000BA   0x4770             BX       LR
   1412          	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:           return "STEP_COUNTER";
   \                     ??DynProtocol_sensorTypeToStr_21: (+1)
   \   000000BC   0x.... 0x....      ADR.W    R0,?_30
   \   000000C0   0x4770             BX       LR
   1413          	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR: return "GEOMAG_ROTATION_VECTOR";
   \                     ??DynProtocol_sensorTypeToStr_22: (+1)
   \   000000C2   0x.... 0x....      ADR.W    R0,?_31
   \   000000C6   0x4770             BX       LR
   1414          	case DYN_PRO_SENSOR_TYPE_HEART_RATE:             return "HEART_RATE";
   \                     ??DynProtocol_sensorTypeToStr_23: (+1)
   \   000000C8   0x.... 0x....      ADR.W    R0,?_32
   \   000000CC   0x4770             BX       LR
   1415          	case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:          return "TILT_DETECTOR";
   \                     ??DynProtocol_sensorTypeToStr_24: (+1)
   \   000000CE   0x.... 0x....      ADR.W    R0,?_33
   \   000000D2   0x4770             BX       LR
   1416          	case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:           return "WAKE_GESTURE";
   \                     ??DynProtocol_sensorTypeToStr_25: (+1)
   \   000000D4   0x.... 0x....      ADR.W    R0,?_34
   \   000000D8   0x4770             BX       LR
   1417          	case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:         return "GLANCE_GESTURE";
   \                     ??DynProtocol_sensorTypeToStr_26: (+1)
   \   000000DA   0x.... 0x....      ADR.W    R0,?_35
   \   000000DE   0x4770             BX       LR
   1418          	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:        return "PICK_UP_GESTURE";
   \                     ??DynProtocol_sensorTypeToStr_27: (+1)
   \   000000E0   0x.... 0x....      ADR.W    R0,?_36
   \   000000E4   0x4770             BX       LR
   1419          	case DYN_PRO_SENSOR_TYPE_BAC:                    return "BAC";
   \                     ??DynProtocol_sensorTypeToStr_28: (+1)
   \   000000E6   0x....             ADR.N    R0,??DataTable73_1  ;; "BAC"
   \   000000E8   0x4770             BX       LR
   1420          	case DYN_PRO_SENSOR_TYPE_PDR:                    return "PDR";
   \                     ??DynProtocol_sensorTypeToStr_29: (+1)
   \   000000EA   0x....             ADR.N    R0,??DataTable73_2  ;; "PDR"
   \   000000EC   0x4770             BX       LR
   1421          	case DYN_PRO_SENSOR_TYPE_B2S:                    return "B2S";
   \                     ??DynProtocol_sensorTypeToStr_30: (+1)
   \   000000EE   0x....             ADR.N    R0,??DataTable73_3  ;; "B2S"
   \   000000F0   0x4770             BX       LR
   1422          	case DYN_PRO_SENSOR_TYPE_3AXIS:                  return "3AXIS";
   \                     ??DynProtocol_sensorTypeToStr_31: (+1)
   \   000000F2   0x.... 0x....      ADR.W    R0,?_40
   \   000000F6   0x4770             BX       LR
   1423          	case DYN_PRO_SENSOR_TYPE_EIS:                    return "EIS";
   \                     ??DynProtocol_sensorTypeToStr_32: (+1)
   \   000000F8   0x....             ADR.N    R0,??DataTable73_4  ;; "EIS"
   \   000000FA   0x4770             BX       LR
   1424          	case DYN_PRO_SENSOR_TYPE_OIS:                    return "OIS";
   \                     ??DynProtocol_sensorTypeToStr_33: (+1)
   \   000000FC   0x....             ADR.N    R0,??DataTable73_5  ;; "OIS"
   \   000000FE   0x4770             BX       LR
   1425          	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:      return "RAW_ACCELEROMETER";
   \                     ??DynProtocol_sensorTypeToStr_34: (+1)
   \   00000100   0x.... 0x....      ADR.W    R0,?_43
   \   00000104   0x4770             BX       LR
   1426          	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:          return "RAW_GYROSCOPE";
   \                     ??DynProtocol_sensorTypeToStr_35: (+1)
   \   00000106   0x.... 0x....      ADR.W    R0,?_44
   \   0000010A   0x4770             BX       LR
   1427          	case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:       return "RAW_MAGNETOMETER";
   \                     ??DynProtocol_sensorTypeToStr_36: (+1)
   \   0000010C   0x.... 0x....      ADR.W    R0,?_45
   \   00000110   0x4770             BX       LR
   1428          	case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:        return "RAW_TEMPERATURE";
   \                     ??DynProtocol_sensorTypeToStr_37: (+1)
   \   00000112   0x.... 0x....      ADR.W    R0,?_46
   \   00000116   0x4770             BX       LR
   1429          	case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:        return "CUSTOM_PRESSURE";
   \                     ??DynProtocol_sensorTypeToStr_38: (+1)
   \   00000118   0x.... 0x....      ADR.W    R0,?_47
   \   0000011C   0x4770             BX       LR
   1430          	case DYN_PRO_SENSOR_TYPE_MIC:                    return "MIC";
   \                     ??DynProtocol_sensorTypeToStr_39: (+1)
   \   0000011E   0x....             ADR.N    R0,??DataTable73_6  ;; "MIC"
   \   00000120   0x4770             BX       LR
   1431          	case DYN_PRO_SENSOR_TYPE_TSIMU:                  return "TSIMU";
   \                     ??DynProtocol_sensorTypeToStr_40: (+1)
   \   00000122   0x.... 0x....      ADR.W    R0,?_49
   \   00000126   0x4770             BX       LR
   1432          	case DYN_PRO_SENSOR_TYPE_RAW_PPG:                return "RAW_PPG";
   \                     ??DynProtocol_sensorTypeToStr_41: (+1)
   \   00000128   0x.... 0x....      ADR.W    R0,?_50
   \   0000012C   0x4770             BX       LR
   1433          	case DYN_PRO_SENSOR_TYPE_HRV:                    return "HRV";
   \                     ??DynProtocol_sensorTypeToStr_42: (+1)
   \   0000012E   0x....             ADR.N    R0,??DataTable73_7  ;; "HRV"
   \   00000130   0x4770             BX       LR
   1434          	case DYN_PRO_SENSOR_TYPE_SLEEP_ANALYSIS:         return "SLEEP_ANALYSIS";
   \                     ??DynProtocol_sensorTypeToStr_43: (+1)
   \   00000132   0x.... 0x....      ADR.W    R0,?_52
   \   00000136   0x4770             BX       LR
   1435          	case DYN_PRO_SENSOR_TYPE_BAC_EXTENDED:           return "BAC_EXTENDED";
   \                     ??DynProtocol_sensorTypeToStr_44: (+1)
   \   00000138   0x.... 0x....      ADR.W    R0,?_53
   \   0000013C   0x4770             BX       LR
   1436          	case DYN_PRO_SENSOR_TYPE_BAC_STATISTICS:         return "BAC_STATISTICS";
   \                     ??DynProtocol_sensorTypeToStr_45: (+1)
   \   0000013E   0x.... 0x....      ADR.W    R0,?_54
   \   00000142   0x4770             BX       LR
   1437          	case DYN_PRO_SENSOR_TYPE_FLOOR_CLIMB_COUNTER:    return "FLOOR_CLIMB_COUNTER";
   \                     ??DynProtocol_sensorTypeToStr_46: (+1)
   \   00000144   0x.... 0x....      ADR.W    R0,?_55
   \   00000148   0x4770             BX       LR
   1438          	case DYN_PRO_SENSOR_TYPE_ENERGY_EXPENDITURE:     return "ENERGY_EXPENDITURE";
   \                     ??DynProtocol_sensorTypeToStr_47: (+1)
   \   0000014A   0x.... 0x....      ADR.W    R0,?_56
   \   0000014E   0x4770             BX       LR
   1439          	case DYN_PRO_SENSOR_TYPE_DISTANCE:               return "DISTANCE";
   \                     ??DynProtocol_sensorTypeToStr_48: (+1)
   \   00000150   0x.... 0x....      ADR.W    R0,?_57
   \   00000154   0x4770             BX       LR
   1440          	case DYN_PRO_SENSOR_TYPE_SHAKE:                  return "SHAKE";
   \                     ??DynProtocol_sensorTypeToStr_49: (+1)
   \   00000156   0x.... 0x....      ADR.W    R0,?_58
   \   0000015A   0x4770             BX       LR
   1441          	case DYN_PRO_SENSOR_TYPE_DOUBLE_TAP:             return "DOUBLE_TAP";
   \                     ??DynProtocol_sensorTypeToStr_50: (+1)
   \   0000015C   0x.... 0x....      ADR.W    R0,?_59
   \   00000160   0x4770             BX       LR
   1442          	case DYN_PRO_SENSOR_TYPE_CUSTOM0:                return "CUSTOM0";
   \                     ??DynProtocol_sensorTypeToStr_51: (+1)
   \   00000162   0x.... 0x....      ADR.W    R0,?_60
   \   00000166   0x4770             BX       LR
   1443          	case DYN_PRO_SENSOR_TYPE_CUSTOM1:                return "CUSTOM1";
   \                     ??DynProtocol_sensorTypeToStr_52: (+1)
   \   00000168   0x.... 0x....      ADR.W    R0,?_61
   \   0000016C   0x4770             BX       LR
   1444          	case DYN_PRO_SENSOR_TYPE_CUSTOM2:                return "CUSTOM2";
   \                     ??DynProtocol_sensorTypeToStr_53: (+1)
   \   0000016E   0x.... 0x....      ADR.W    R0,?_62
   \   00000172   0x4770             BX       LR
   1445          	case DYN_PRO_SENSOR_TYPE_CUSTOM3:                return "CUSTOM3";
   \                     ??DynProtocol_sensorTypeToStr_54: (+1)
   \   00000174   0x.... 0x....      ADR.W    R0,?_63
   \   00000178   0x4770             BX       LR
   1446          	case DYN_PRO_SENSOR_TYPE_CUSTOM4:                return "CUSTOM4";
   \                     ??DynProtocol_sensorTypeToStr_55: (+1)
   \   0000017A   0x.... 0x....      ADR.W    R0,?_64
   \   0000017E   0x4770             BX       LR
   1447          	case DYN_PRO_SENSOR_TYPE_CUSTOM5:                return "CUSTOM5";
   \                     ??DynProtocol_sensorTypeToStr_56: (+1)
   \   00000180   0x.... 0x....      ADR.W    R0,?_65
   \   00000184   0x4770             BX       LR
   1448          	case DYN_PRO_SENSOR_TYPE_CUSTOM6:                return "CUSTOM6";
   \                     ??DynProtocol_sensorTypeToStr_57: (+1)
   \   00000186   0x.... 0x....      ADR.W    R0,?_66
   \   0000018A   0x4770             BX       LR
   1449          	case DYN_PRO_SENSOR_TYPE_CUSTOM7:                return "CUSTOM7";
   \                     ??DynProtocol_sensorTypeToStr_58: (+1)
   \   0000018C   0x.... 0x....      ADR.W    R0,?_67
   \   00000190   0x4770             BX       LR
   1450          	case DYN_PRO_SENSOR_TYPE_WOM:                    return "WOM";
   \                     ??DynProtocol_sensorTypeToStr_59: (+1)
   \   00000192   0x....             ADR.N    R0,??DataTable73_8  ;; "WOM"
   \   00000194   0x4770             BX       LR
   1451          	case DYN_PRO_SENSOR_TYPE_SEDENTARY_REMIND:       return "SEDENTARY_REMIND";
   \                     ??DynProtocol_sensorTypeToStr_60: (+1)
   \   00000196   0x.... 0x....      ADR.W    R0,?_69
   \   0000019A   0x4770             BX       LR
   1452          	case DYN_PRO_SENSOR_TYPE_FSYNC_EVENT:            return "FSYNC_EVENT";
   \                     ??DynProtocol_sensorTypeToStr_61: (+1)
   \   0000019C   0x.... 0x....      ADR.W    R0,?_70
   \   000001A0   0x4770             BX       LR
   1453          	case DYN_PRO_SENSOR_TYPE_PREDICTIVE_QUATERNION:  return "PRED_QUAT";
   \                     ??DynProtocol_sensorTypeToStr_62: (+1)
   \   000001A2   0x.... 0x....      ADR.W    R0,?_71
   \   000001A6   0x4770             BX       LR
   1454          	default:                                         return "";
   \                     ??DynProtocol_sensorTypeToStr_1: (+1)
   \   000001A8   0x....             ADR.N    R0,??DataTable73_9  ;; ""
   \   000001AA   0x4770             BX       LR               ;; return
   1455          	}
   1456          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x79          DC8 "DynProtocol: returned payload is -1"
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \              0x63 0x6F    
   \              0x6C 0x3A    
   \              0x20 0x72    
   \              0x65 0x74    
   \              0x75 0x72    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x70 0x61    
   \              0x79 0x6C    
   \              0x6F 0x61    
   \              0x64 0x20    
   \              0x69 0x73    
   \              0x20 0x2D    
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73:
   \   00000000   0x53 0x4D          DC8      "SMD"
   \              0x44 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_1:
   \   00000000   0x42 0x41          DC8      "BAC"
   \              0x43 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_2:
   \   00000000   0x50 0x44          DC8      "PDR"
   \              0x52 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_3:
   \   00000000   0x42 0x32          DC8      "B2S"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_4:
   \   00000000   0x45 0x49          DC8      "EIS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_5:
   \   00000000   0x4F 0x49          DC8      "OIS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_6:
   \   00000000   0x4D 0x49          DC8      "MIC"
   \              0x43 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_7:
   \   00000000   0x48 0x52          DC8      "HRV"
   \              0x56 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_8:
   \   00000000   0x57 0x4F          DC8      "WOM"
   \              0x4D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable73_9:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x44 0x79          DC8 "DynProtocol: Unexpected packet type"
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \              0x63 0x6F    
   \              0x6C 0x3A    
   \              0x20 0x55    
   \              0x6E 0x65    
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x70 0x61    
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x79 0x70    
   \              0x65 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x44 0x79          DC8 "DynProtocol: Unexpected packet received."
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \              0x63 0x6F    
   \              0x6C 0x3A    
   \              0x20 0x55    
   \              0x6E 0x65    
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x70 0x61    
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x72    
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \              0x64 0x2E    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x44 0x79          DC8 "DynProtocol: Unknown frame"
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \              0x63 0x6F    
   \              0x6C 0x3A    
   \              0x20 0x55    
   \              0x6E 0x6B    
   \              0x6E 0x6F    
   \              0x77 0x6E    
   \              0x20 0x66    
   \              0x72 0x61    
   \              0x6D 0x65    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x44 0x79          DC8 44H, 79H, 6EH, 50H, 72H, 6FH, 74H, 6FH
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \   00000008   0x63 0x6F          DC8 63H, 6FH, 6CH, 3AH, 20H, 46H, 72H, 61H
   \              0x6C 0x3A    
   \              0x20 0x46    
   \              0x72 0x61    
   \   00000010   0x6D 0x65          DC8 6DH, 65H, 20H, 73H, 69H, 7AH, 65H, 20H
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x20    
   \   00000018   0x65 0x72          DC8 65H, 72H, 72H, 6FH, 72H, 2EH, 20H, 73H
   \              0x72 0x6F    
   \              0x72 0x2E    
   \              0x20 0x73    
   \   00000020   0x69 0x7A          DC8 69H, 7AH, 65H, 3DH, 25H, 64H, 42H, 20H
   \              0x65 0x3D    
   \              0x25 0x64    
   \              0x42 0x20    
   \   00000028   0x28 0x65          DC8 28H, 65H, 78H, 70H, 65H, 63H, 74H, 65H
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65    
   \   00000030   0x64 0x20          DC8 64H, 20H, 25H, 64H, 42H, 29H, 0
   \              0x25 0x64    
   \              0x42 0x29    
   \              0x00         
   \   00000037   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x44 0x79          DC8 "DynProtocol: Invalid group ID"
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \              0x63 0x6F    
   \              0x6C 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x67    
   \              0x72 0x6F    
   \              0x75 0x70    
   \              0x20 0x49    
   \              0x44 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x44 0x79          DC8 "DynProtocol: internal buffer size full"
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \              0x63 0x6F    
   \              0x6C 0x3A    
   \              0x20 0x69    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x6E 0x61    
   \              0x6C 0x20    
   \              0x62 0x75    
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x20    
   \              0x66 0x75    
   \              0x6C 0x6C    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x44 0x79          DC8 44H, 79H, 6EH, 50H, 72H, 6FH, 74H, 6FH
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \   00000008   0x63 0x6F          DC8 63H, 6FH, 6CH, 3AH, 20H, 55H, 6EH, 65H
   \              0x6C 0x3A    
   \              0x20 0x55    
   \              0x6E 0x65    
   \   00000010   0x78 0x70          DC8 78H, 70H, 65H, 63H, 74H, 65H, 64H, 20H
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x20    
   \   00000018   0x61 0x72          DC8 61H, 72H, 67H, 75H, 6DH, 65H, 6EH, 74H
   \              0x67 0x75    
   \              0x6D 0x65    
   \              0x6E 0x74    
   \   00000020   0x20 0x66          DC8 20H, 66H, 6FH, 72H, 20H, 65H, 6EH, 63H
   \              0x6F 0x72    
   \              0x20 0x65    
   \              0x6E 0x63    
   \   00000028   0x6F 0x64          DC8 6FH, 64H, 65H, 5FH, 63H, 6FH, 6DH, 6DH
   \              0x65 0x5F    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \   00000030   0x61 0x6E          DC8 61H, 6EH, 64H, 28H, 29H, 0
   \              0x64 0x28    
   \              0x29 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x44 0x79          DC8 "DynProtocol: output buffer size too small"
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \              0x63 0x6F    
   \              0x6C 0x3A    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x70 0x75    
   \              0x74 0x20    
   \              0x62 0x75    
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x73 0x6D    
   \              0x61 0x6C    
   \              0x6C 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x44 0x79          DC8 44H, 79H, 6EH, 50H, 72H, 6FH, 74H, 6FH
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \   00000008   0x63 0x6F          DC8 63H, 6FH, 6CH, 3AH, 20H, 55H, 6EH, 65H
   \              0x6C 0x3A    
   \              0x20 0x55    
   \              0x6E 0x65    
   \   00000010   0x78 0x70          DC8 78H, 70H, 65H, 63H, 74H, 65H, 64H, 20H
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x20    
   \   00000018   0x61 0x72          DC8 61H, 72H, 67H, 75H, 6DH, 65H, 6EH, 74H
   \              0x67 0x75    
   \              0x6D 0x65    
   \              0x6E 0x74    
   \   00000020   0x20 0x66          DC8 20H, 66H, 6FH, 72H, 20H, 44H, 79H, 6EH
   \              0x6F 0x72    
   \              0x20 0x44    
   \              0x79 0x6E    
   \   00000028   0x50 0x72          DC8 50H, 72H, 6FH, 74H, 6FH, 63H, 6FH, 6CH
   \              0x6F 0x74    
   \              0x6F 0x63    
   \              0x6F 0x6C    
   \   00000030   0x5F 0x65          DC8 5FH, 65H, 6EH, 63H, 6FH, 64H, 65H, 52H
   \              0x6E 0x63    
   \              0x6F 0x64    
   \              0x65 0x52    
   \   00000038   0x65 0x73          DC8 65H, 73H, 70H, 6FH, 6EH, 73H, 65H, 28H
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x28    
   \   00000040   0x29 0x00          DC8 29H, 0
   \   00000042   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x44 0x79          DC8 44H, 79H, 6EH, 50H, 72H, 6FH, 74H, 6FH
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x74 0x6F    
   \   00000008   0x63 0x6F          DC8 63H, 6FH, 6CH, 3AH, 20H, 55H, 6EH, 65H
   \              0x6C 0x3A    
   \              0x20 0x55    
   \              0x6E 0x65    
   \   00000010   0x78 0x70          DC8 78H, 70H, 65H, 63H, 74H, 65H, 64H, 20H
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x20    
   \   00000018   0x61 0x72          DC8 61H, 72H, 67H, 75H, 6DH, 65H, 6EH, 74H
   \              0x67 0x75    
   \              0x6D 0x65    
   \              0x6E 0x74    
   \   00000020   0x20 0x66          DC8 20H, 66H, 6FH, 72H, 20H, 65H, 6EH, 63H
   \              0x6F 0x72    
   \              0x20 0x65    
   \              0x6E 0x63    
   \   00000028   0x6F 0x64          DC8 6FH, 64H, 65H, 5FH, 61H, 73H, 79H, 6EH
   \              0x65 0x5F    
   \              0x61 0x73    
   \              0x79 0x6E    
   \   00000030   0x63 0x28          DC8 63H, 28H, 29H, 0
   \              0x29 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x52 0x45          DC8 "RESERVED"
   \              0x53 0x45    
   \              0x52 0x56    
   \              0x45 0x44    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x41 0x43          DC8 "ACCELEROMETER"
   \              0x43 0x45    
   \              0x4C 0x45    
   \              0x52 0x4F    
   \              0x4D 0x45    
   \              0x54 0x45    
   \              0x52 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x4D 0x41          DC8 "MAGNETOMETER"
   \              0x47 0x4E    
   \              0x45 0x54    
   \              0x4F 0x4D    
   \              0x45 0x54    
   \              0x45 0x52    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x4F 0x52          DC8 "ORIENTATION"
   \              0x49 0x45    
   \              0x4E 0x54    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x47 0x59          DC8 "GYROSCOPE"
   \              0x52 0x4F    
   \              0x53 0x43    
   \              0x4F 0x50    
   \              0x45 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x4C 0x49          DC8 "LIGHT"
   \              0x47 0x48    
   \              0x54 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x50 0x52          DC8 "PRESSURE"
   \              0x45 0x53    
   \              0x53 0x55    
   \              0x52 0x45    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_28:
   \   00000000   0x53 0x4D          DC8 "SMD"
   \              0x44 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_37:
   \   00000000   0x42 0x41          DC8 "BAC"
   \              0x43 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_38:
   \   00000000   0x50 0x44          DC8 "PDR"
   \              0x52 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_39:
   \   00000000   0x42 0x32          DC8 "B2S"
   \              0x53 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_41:
   \   00000000   0x45 0x49          DC8 "EIS"
   \              0x53 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_42:
   \   00000000   0x4F 0x49          DC8 "OIS"
   \              0x53 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_48:
   \   00000000   0x4D 0x49          DC8 "MIC"
   \              0x43 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_51:
   \   00000000   0x48 0x52          DC8 "HRV"
   \              0x56 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x54 0x45          DC8 "TEMPERATURE"
   \              0x4D 0x50    
   \              0x45 0x52    
   \              0x41 0x54    
   \              0x55 0x52    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \   00000000   0x50 0x52          DC8 "PROXIMITY"
   \              0x4F 0x58    
   \              0x49 0x4D    
   \              0x49 0x54    
   \              0x59 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \   00000000   0x47 0x52          DC8 "GRAVITY"
   \              0x41 0x56    
   \              0x49 0x54    
   \              0x59 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \   00000000   0x4C 0x49          DC8 "LINEAR_ACCELERATION"
   \              0x4E 0x45    
   \              0x41 0x52    
   \              0x5F 0x41    
   \              0x43 0x43    
   \              0x45 0x4C    
   \              0x45 0x52    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \   00000000   0x52 0x4F          DC8 "ROTATION_VECTOR"
   \              0x54 0x41    
   \              0x54 0x49    
   \              0x4F 0x4E    
   \              0x5F 0x56    
   \              0x45 0x43    
   \              0x54 0x4F    
   \              0x52 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \   00000000   0x48 0x55          DC8 "HUMIDITY"
   \              0x4D 0x49    
   \              0x44 0x49    
   \              0x54 0x59    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \   00000000   0x41 0x4D          DC8 "AMBIENT_TEMPERATURE"
   \              0x42 0x49    
   \              0x45 0x4E    
   \              0x54 0x5F    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x45 0x52    
   \              0x41 0x54    
   \              0x55 0x52    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \   00000000   0x55 0x4E          DC8 "UNCAL_MAGNETOMETER"
   \              0x43 0x41    
   \              0x4C 0x5F    
   \              0x4D 0x41    
   \              0x47 0x4E    
   \              0x45 0x54    
   \              0x4F 0x4D    
   \              0x45 0x54    
   \              0x45 0x52    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \   00000000   0x47 0x41          DC8 "GAME_ROTATION_VECTOR"
   \              0x4D 0x45    
   \              0x5F 0x52    
   \              0x4F 0x54    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x5F    
   \              0x56 0x45    
   \              0x43 0x54    
   \              0x4F 0x52    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \   00000000   0x55 0x4E          DC8 "UNCAL_GYROSCOPE"
   \              0x43 0x41    
   \              0x4C 0x5F    
   \              0x47 0x59    
   \              0x52 0x4F    
   \              0x53 0x43    
   \              0x4F 0x50    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_29:
   \   00000000   0x53 0x54          DC8 "STEP_DETECTOR"
   \              0x45 0x50    
   \              0x5F 0x44    
   \              0x45 0x54    
   \              0x45 0x43    
   \              0x54 0x4F    
   \              0x52 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_30:
   \   00000000   0x53 0x54          DC8 "STEP_COUNTER"
   \              0x45 0x50    
   \              0x5F 0x43    
   \              0x4F 0x55    
   \              0x4E 0x54    
   \              0x45 0x52    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_31:
   \   00000000   0x47 0x45          DC8 "GEOMAG_ROTATION_VECTOR"
   \              0x4F 0x4D    
   \              0x41 0x47    
   \              0x5F 0x52    
   \              0x4F 0x54    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x5F    
   \              0x56 0x45    
   \              0x43 0x54    
   \              0x4F 0x52    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_32:
   \   00000000   0x48 0x45          DC8 "HEART_RATE"
   \              0x41 0x52    
   \              0x54 0x5F    
   \              0x52 0x41    
   \              0x54 0x45    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \   00000000   0x54 0x49          DC8 "TILT_DETECTOR"
   \              0x4C 0x54    
   \              0x5F 0x44    
   \              0x45 0x54    
   \              0x45 0x43    
   \              0x54 0x4F    
   \              0x52 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \   00000000   0x57 0x41          DC8 "WAKE_GESTURE"
   \              0x4B 0x45    
   \              0x5F 0x47    
   \              0x45 0x53    
   \              0x54 0x55    
   \              0x52 0x45    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \   00000000   0x47 0x4C          DC8 "GLANCE_GESTURE"
   \              0x41 0x4E    
   \              0x43 0x45    
   \              0x5F 0x47    
   \              0x45 0x53    
   \              0x54 0x55    
   \              0x52 0x45    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_36:
   \   00000000   0x50 0x49          DC8 "PICK_UP_GESTURE"
   \              0x43 0x4B    
   \              0x5F 0x55    
   \              0x50 0x5F    
   \              0x47 0x45    
   \              0x53 0x54    
   \              0x55 0x52    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_40:
   \   00000000   0x33 0x41          DC8 "3AXIS"
   \              0x58 0x49    
   \              0x53 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_43:
   \   00000000   0x52 0x41          DC8 "RAW_ACCELEROMETER"
   \              0x57 0x5F    
   \              0x41 0x43    
   \              0x43 0x45    
   \              0x4C 0x45    
   \              0x52 0x4F    
   \              0x4D 0x45    
   \              0x54 0x45    
   \              0x52 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_44:
   \   00000000   0x52 0x41          DC8 "RAW_GYROSCOPE"
   \              0x57 0x5F    
   \              0x47 0x59    
   \              0x52 0x4F    
   \              0x53 0x43    
   \              0x4F 0x50    
   \              0x45 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_45:
   \   00000000   0x52 0x41          DC8 "RAW_MAGNETOMETER"
   \              0x57 0x5F    
   \              0x4D 0x41    
   \              0x47 0x4E    
   \              0x45 0x54    
   \              0x4F 0x4D    
   \              0x45 0x54    
   \              0x45 0x52    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_46:
   \   00000000   0x52 0x41          DC8 "RAW_TEMPERATURE"
   \              0x57 0x5F    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x45 0x52    
   \              0x41 0x54    
   \              0x55 0x52    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_47:
   \   00000000   0x43 0x55          DC8 "CUSTOM_PRESSURE"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x5F 0x50    
   \              0x52 0x45    
   \              0x53 0x53    
   \              0x55 0x52    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_49:
   \   00000000   0x54 0x53          DC8 "TSIMU"
   \              0x49 0x4D    
   \              0x55 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_50:
   \   00000000   0x52 0x41          DC8 "RAW_PPG"
   \              0x57 0x5F    
   \              0x50 0x50    
   \              0x47 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_52:
   \   00000000   0x53 0x4C          DC8 "SLEEP_ANALYSIS"
   \              0x45 0x45    
   \              0x50 0x5F    
   \              0x41 0x4E    
   \              0x41 0x4C    
   \              0x59 0x53    
   \              0x49 0x53    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_53:
   \   00000000   0x42 0x41          DC8 "BAC_EXTENDED"
   \              0x43 0x5F    
   \              0x45 0x58    
   \              0x54 0x45    
   \              0x4E 0x44    
   \              0x45 0x44    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_54:
   \   00000000   0x42 0x41          DC8 "BAC_STATISTICS"
   \              0x43 0x5F    
   \              0x53 0x54    
   \              0x41 0x54    
   \              0x49 0x53    
   \              0x54 0x49    
   \              0x43 0x53    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_55:
   \   00000000   0x46 0x4C          DC8 "FLOOR_CLIMB_COUNTER"
   \              0x4F 0x4F    
   \              0x52 0x5F    
   \              0x43 0x4C    
   \              0x49 0x4D    
   \              0x42 0x5F    
   \              0x43 0x4F    
   \              0x55 0x4E    
   \              0x54 0x45    
   \              0x52 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_56:
   \   00000000   0x45 0x4E          DC8 "ENERGY_EXPENDITURE"
   \              0x45 0x52    
   \              0x47 0x59    
   \              0x5F 0x45    
   \              0x58 0x50    
   \              0x45 0x4E    
   \              0x44 0x49    
   \              0x54 0x55    
   \              0x52 0x45    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_57:
   \   00000000   0x44 0x49          DC8 "DISTANCE"
   \              0x53 0x54    
   \              0x41 0x4E    
   \              0x43 0x45    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_58:
   \   00000000   0x53 0x48          DC8 "SHAKE"
   \              0x41 0x4B    
   \              0x45 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_59:
   \   00000000   0x44 0x4F          DC8 "DOUBLE_TAP"
   \              0x55 0x42    
   \              0x4C 0x45    
   \              0x5F 0x54    
   \              0x41 0x50    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_60:
   \   00000000   0x43 0x55          DC8 "CUSTOM0"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x30 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_61:
   \   00000000   0x43 0x55          DC8 "CUSTOM1"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_62:
   \   00000000   0x43 0x55          DC8 "CUSTOM2"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x32 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_63:
   \   00000000   0x43 0x55          DC8 "CUSTOM3"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x33 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_64:
   \   00000000   0x43 0x55          DC8 "CUSTOM4"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x34 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_65:
   \   00000000   0x43 0x55          DC8 "CUSTOM5"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x35 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_66:
   \   00000000   0x43 0x55          DC8 "CUSTOM6"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x36 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_67:
   \   00000000   0x43 0x55          DC8 "CUSTOM7"
   \              0x53 0x54    
   \              0x4F 0x4D    
   \              0x37 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_69:
   \   00000000   0x53 0x45          DC8 "SEDENTARY_REMIND"
   \              0x44 0x45    
   \              0x4E 0x54    
   \              0x41 0x52    
   \              0x59 0x5F    
   \              0x52 0x45    
   \              0x4D 0x49    
   \              0x4E 0x44    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_70:
   \   00000000   0x46 0x53          DC8 "FSYNC_EVENT"
   \              0x59 0x4E    
   \              0x43 0x5F    
   \              0x45 0x56    
   \              0x45 0x4E    
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_71:
   \   00000000   0x50 0x52          DC8 "PRED_QUAT"
   \              0x45 0x44    
   \              0x5F 0x51    
   \              0x55 0x41    
   \              0x54 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_68:
   \   00000000   0x57 0x4F          DC8 "WOM"
   \              0x4D 0x00    

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_72:
   \   00000000   0x00               DC8 ""

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DynProtocol_callEventCB
        16   -- Indirect call
       8   DynProtocol_checkFrameSize
         8   -> inv_msg
       8   DynProtocol_decodePktAsync
         8   -> DynProtocol_decodeSensorEvent
      24   DynProtocol_decodePktCommand
        24   -> DynProtocol_decodeVect16QxToQy
        24   -> DynProtocol_getPrecision
        24   -> __aeabi_memcpy
        24   -> inv_dc_little8_to_int32
      24   DynProtocol_decodePktResponse
        24   -> DynProtocol_decodeSensorEvent
        24   -> DynProtocol_decodeVect16QxToQy
        24   -> DynProtocol_getPrecision
        24   -> __aeabi_memcpy
        24   -> __aeabi_memcpy4
      40   DynProtocol_decodeSensorEvent
        40   -> DynProtocol_decodeVect16QxToQy
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset4
        40   -> inv_dc_le_to_int16
        40   -> inv_dc_little8_to_int32
      16   DynProtocol_decodeVect16QxToQy
     144   DynProtocol_doProcess
       144   -> DynProtocol_callEventCB
       144   -> DynProtocol_decodePktAsync
       144   -> DynProtocol_decodePktCommand
       144   -> DynProtocol_decodePktResponse
       144   -> inv_msg
      24   DynProtocol_encodeAsync
        24   -> DynProtocol_encodeSensorEvent
        24   -> inv_msg
      32   DynProtocol_encodeCommand
        32   -> DynProtocol_encodeQxToQyVect16
        32   -> DynProtocol_getPrecision
        32   -> __aeabi_memcpy
        32   -> inv_dc_int32_to_little8
        32   -> inv_msg
      16   DynProtocol_encodeQxToQyVect16
      24   DynProtocol_encodeResponse
        24   -> DynProtocol_encodeQxToQyVect16
        24   -> DynProtocol_encodeSensorEvent
        24   -> DynProtocol_getPrecision
        24   -> __aeabi_memcpy
        24   -> inv_msg
      40   DynProtocol_encodeSensorEvent
        40   -> DynProtocol_encodeQxToQyVect16
        40   -> __aeabi_memcpy
        40   -> inv_dc_int16_to_little8
        40   -> inv_dc_int32_to_little8
       8   DynProtocol_getPayload
         8   -> inv_msg
       0   DynProtocol_getPrecision
      16   DynProtocol_init
        16   -> __aeabi_memset4
       8   DynProtocol_processPktByte
         8   -> DynProtocol_checkFrameSize
         0   -> DynProtocol_doProcess
         8   -> DynProtocol_getPayload
         8   -> inv_msg
       0   DynProtocol_processReset
       0   DynProtocol_sensorTypeToStr
       0   DynProtocol_setCurrentFrameSize
       0   DynProtocol_setPrecision


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable73
       4  ??DataTable73_1
       4  ??DataTable73_2
       4  ??DataTable73_3
       4  ??DataTable73_4
       4  ??DataTable73_5
       4  ??DataTable73_6
       4  ??DataTable73_7
       4  ??DataTable73_8
       4  ??DataTable73_9
      36  ?_0
      36  ?_1
      52  ?_10
      12  ?_11
      16  ?_12
      16  ?_13
      12  ?_14
      12  ?_15
       8  ?_16
      12  ?_17
      12  ?_18
      12  ?_19
      44  ?_2
       8  ?_20
      20  ?_21
      16  ?_22
      12  ?_23
      20  ?_24
      20  ?_25
      24  ?_26
      16  ?_27
       4  ?_28
      16  ?_29
      28  ?_3
      16  ?_30
      24  ?_31
      12  ?_32
      16  ?_33
      16  ?_34
      16  ?_35
      16  ?_36
       4  ?_37
       4  ?_38
       4  ?_39
      56  ?_4
       8  ?_40
       4  ?_41
       4  ?_42
      20  ?_43
      16  ?_44
      20  ?_45
      16  ?_46
      16  ?_47
       4  ?_48
       8  ?_49
      32  ?_5
       8  ?_50
       4  ?_51
      16  ?_52
      16  ?_53
      16  ?_54
      20  ?_55
      20  ?_56
      12  ?_57
       8  ?_58
      12  ?_59
      40  ?_6
       8  ?_60
       8  ?_61
       8  ?_62
       8  ?_63
       8  ?_64
       8  ?_65
       8  ?_66
       8  ?_67
       4  ?_68
      20  ?_69
      56  ?_7
      12  ?_70
      12  ?_71
       1  ?_72
      44  ?_8
      68  ?_9
      22  DynProtocol_callEventCB
      60  DynProtocol_checkFrameSize
      32  DynProtocol_decodePktAsync
     218  DynProtocol_decodePktCommand
     220  DynProtocol_decodePktResponse
    1032  DynProtocol_decodeSensorEvent
      52  DynProtocol_decodeVect16QxToQy
     120  DynProtocol_doProcess
     102  DynProtocol_encodeAsync
     364  DynProtocol_encodeCommand
      50  DynProtocol_encodeQxToQyVect16
     318  DynProtocol_encodeResponse
    1070  DynProtocol_encodeSensorEvent
     328  DynProtocol_getPayload
      94  DynProtocol_getPrecision
      44  DynProtocol_init
     192  DynProtocol_processPktByte
       6  DynProtocol_processReset
     428  DynProtocol_sensorTypeToStr
       4  DynProtocol_setCurrentFrameSize
      36  DynProtocol_setPrecision

 
    37 bytes in section .rodata
 6 044 bytes in section .text
 
 6 044 bytes of CODE  memory
    37 bytes of CONST memory

Errors: none
Warnings: none
