###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:25
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\DeviceIcm20948.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\DeviceIcm20948.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\DeviceIcm20948.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\DeviceIcm20948.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\DeviceIcm20948.c
      1          /*
      2           * ________________________________________________________________________________________________________
      3           * Copyright (c) 2015-2015 InvenSense Inc. All rights reserved.
      4           *
      5           * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      6           * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
      7           * and other intellectual property rights laws.
      8           *
      9           * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
     10           * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
     11           * from InvenSense is strictly prohibited.
     12           *
     13           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
     14           * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
     15           * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
     17           * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18           * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
     19           * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20           * OF THE SOFTWARE.
     21           * ________________________________________________________________________________________________________
     22           */
     23          
     24          #include "DeviceIcm20948.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void inv_sensor_listener_notify(inv_sensor_listener_t const *, inv_sensor_event_t const *)
   \                     inv_sensor_listener_notify: (+1)
   \   00000000   0x4602             MOV      R2,R0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD002             BEQ.N    ??inv_sensor_listener_notify_0
   \   00000008   0x6851             LDR      R1,[R2, #+4]
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x4710             BX       R2
   \                     ??inv_sensor_listener_notify_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void inv_icm20948_reset_states(struct inv_icm20948 *, struct inv_icm20948_serif const *)
   \                     inv_icm20948_reset_states: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x....             LDR.N    R6,??DataTable20
   \   00000008   0x6830             LDR      R0,[R6, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD008             BEQ.N    ??inv_icm20948_reset_states_0
   \   0000000E   0x22D8             MOVS     R2,#+216
   \   00000010   0x.... 0x....      ADR.W    R1,?_1
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       __aeabi_assert
   \   0000001C   0x.... 0x....      BL       __iar_EmptyStepPoint
   \                     ??inv_icm20948_reset_states_0: (+1)
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0xF44F 0x619F      MOV      R1,#+1272
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       __aeabi_memset4
   \   0000002C   0xEC95 0x0B06      VLDM     R5,{D0-D2}
   \   00000030   0xEC84 0x0B06      VSTM     R4,{D0-D2}
   \   00000034   0x6034             STR      R4,[R6, #+0]
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
     25          #include "Invn/InvExport.h"
     26          #include "Invn/EmbUtils/Message.h"
     27          

   \                                 In section .text, align 4, keep-with-next
     28          static const inv_device_vt_t device_icm20948_vt = {
   \                     device_icm20948_vt:
   \   00000000   0x........         DC32 inv_device_icm20948_whoami, inv_device_icm20948_reset
   \              0x........   
   \   00000008   0x........         DC32 inv_device_icm20948_setup, inv_device_icm20948_cleanup
   \              0x........   
   \   00000010   0x........         DC32 inv_device_icm20948_load, inv_device_icm20948_poll
   \              0x........   
   \   00000018   0x........         DC32 inv_device_icm20948_self_test, 0H, inv_device_icm20948_ping_sensor
   \              0x00000000   
   \              0x........   
   \   00000024   0x00000000         DC32 0H, inv_device_icm20948_enable_sensor
   \              0x........   
   \   0000002C   0x........         DC32 inv_device_icm20948_set_sensor_period_us
   \   00000030   0x........         DC32 inv_device_icm20948_set_sensor_timeout, 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   00000040   0x........         DC32 inv_device_icm20948_set_sensor_mounting_matrix, 0H
   \              0x00000000   
   \   00000048   0x........         DC32 inv_device_icm20948_set_sensor_config
   \   0000004C   0x........         DC32 inv_device_icm20948_get_sensor_config
   \   00000050   0x........         DC32 inv_device_icm20948_write_mems_register
   \   00000054   0x........         DC32 inv_device_icm20948_read_mems_register
     29          	inv_device_icm20948_whoami,
     30          	inv_device_icm20948_reset,
     31          	inv_device_icm20948_setup,
     32          	inv_device_icm20948_cleanup,
     33          	inv_device_icm20948_load,
     34          	inv_device_icm20948_poll,
     35          	inv_device_icm20948_self_test,
     36          	0,//inv_device_icm20948_get_fw_info,
     37          	inv_device_icm20948_ping_sensor,
     38          	0,//inv_device_icm20948_set_running_state,
     39          	inv_device_icm20948_enable_sensor,
     40          	inv_device_icm20948_set_sensor_period_us,
     41          	inv_device_icm20948_set_sensor_timeout,
     42          	0,//inv_device_icm20948_flush_sensor,
     43          	0,//inv_device_icm20948_set_sensor_bias,
     44          	0,//inv_device_icm20948_get_sensor_bias,
     45          	inv_device_icm20948_set_sensor_mounting_matrix,
     46          	0,//inv_device_icm20948_get_sensor_data,
     47          	inv_device_icm20948_set_sensor_config,
     48          	inv_device_icm20948_get_sensor_config,
     49          	inv_device_icm20948_write_mems_register,
     50          	inv_device_icm20948_read_mems_register,
     51          };
     52          

   \                                 In section .text, align 4, keep-with-next
     53          static enum inv_icm20948_sensor idd_sensortype_2_driver(int sensor)
     54          {
     55          	switch(sensor) {
   \                     idd_sensortype_2_driver: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x2820             CMP      R0,#+32
   \   00000004   0xD83A             BHI.N    ??idd_sensortype_2_driver_1
   \   00000006   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??idd_sensortype_2_driver_0:
   \   0000000A   0x15 0x29          DC8      0x15,0x29,0x35,0x17
   \              0x35 0x17    
   \   0000000E   0x39 0x39          DC8      0x39,0x39,0x39,0x39
   \              0x39 0x39    
   \   00000012   0x31 0x33          DC8      0x31,0x33,0x25,0x39
   \              0x25 0x39    
   \   00000016   0x39 0x19          DC8      0x39,0x19,0x23,0x1B
   \              0x23 0x1B    
   \   0000001A   0x2B 0x1F          DC8      0x2B,0x1F,0x21,0x27
   \              0x21 0x27    
   \   0000001E   0x39 0x2F          DC8      0x39,0x2F,0x39,0x39
   \              0x39 0x39    
   \   00000022   0x2D 0x1D          DC8      0x2D,0x1D,0x39,0x37
   \              0x39 0x37    
   \   00000026   0x39 0x39          DC8      0x39,0x39,0x39,0x11
   \              0x39 0x11    
   \   0000002A   0x13 0x00          DC8      0x13,0x0
     56          	case INV_SENSOR_TYPE_RAW_ACCELEROMETER:       return INV_ICM20948_SENSOR_RAW_ACCELEROMETER;
   \                     ??idd_sensortype_2_driver_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x4770             BX       LR
     57          	case INV_SENSOR_TYPE_RAW_GYROSCOPE:           return INV_ICM20948_SENSOR_RAW_GYROSCOPE;
   \                     ??idd_sensortype_2_driver_3: (+1)
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x4770             BX       LR
     58          	case INV_SENSOR_TYPE_ACCELEROMETER:           return INV_ICM20948_SENSOR_ACCELEROMETER;
   \                     ??idd_sensortype_2_driver_4: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4770             BX       LR
     59          	case INV_SENSOR_TYPE_GYROSCOPE:               return INV_ICM20948_SENSOR_GYROSCOPE;
   \                     ??idd_sensortype_2_driver_5: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x4770             BX       LR
     60          	case INV_SENSOR_TYPE_UNCAL_MAGNETOMETER:      return INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED;
   \                     ??idd_sensortype_2_driver_6: (+1)
   \   0000003C   0x2004             MOVS     R0,#+4
   \   0000003E   0x4770             BX       LR
     61          	case INV_SENSOR_TYPE_UNCAL_GYROSCOPE:         return INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED;
   \                     ??idd_sensortype_2_driver_7: (+1)
   \   00000040   0x2005             MOVS     R0,#+5
   \   00000042   0x4770             BX       LR
     62          	case INV_SENSOR_TYPE_BAC:                     return INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON;
   \                     ??idd_sensortype_2_driver_8: (+1)
   \   00000044   0x2006             MOVS     R0,#+6
   \   00000046   0x4770             BX       LR
     63          	case INV_SENSOR_TYPE_STEP_DETECTOR:           return INV_ICM20948_SENSOR_STEP_DETECTOR;
   \                     ??idd_sensortype_2_driver_9: (+1)
   \   00000048   0x2007             MOVS     R0,#+7
   \   0000004A   0x4770             BX       LR
     64          	case INV_SENSOR_TYPE_STEP_COUNTER:            return INV_ICM20948_SENSOR_STEP_COUNTER;
   \                     ??idd_sensortype_2_driver_10: (+1)
   \   0000004C   0x2008             MOVS     R0,#+8
   \   0000004E   0x4770             BX       LR
     65          	case INV_SENSOR_TYPE_GAME_ROTATION_VECTOR:    return INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR;
   \                     ??idd_sensortype_2_driver_11: (+1)
   \   00000050   0x2009             MOVS     R0,#+9
   \   00000052   0x4770             BX       LR
     66          	case INV_SENSOR_TYPE_ROTATION_VECTOR:         return INV_ICM20948_SENSOR_ROTATION_VECTOR;
   \                     ??idd_sensortype_2_driver_12: (+1)
   \   00000054   0x200A             MOVS     R0,#+10
   \   00000056   0x4770             BX       LR
     67          	case INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:  return INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR;
   \                     ??idd_sensortype_2_driver_13: (+1)
   \   00000058   0x200B             MOVS     R0,#+11
   \   0000005A   0x4770             BX       LR
     68          	case INV_SENSOR_TYPE_MAGNETOMETER:            return INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD;
   \                     ??idd_sensortype_2_driver_14: (+1)
   \   0000005C   0x200C             MOVS     R0,#+12
   \   0000005E   0x4770             BX       LR
     69          	case INV_SENSOR_TYPE_SMD:                     return INV_ICM20948_SENSOR_WAKEUP_SIGNIFICANT_MOTION;
   \                     ??idd_sensortype_2_driver_15: (+1)
   \   00000060   0x200D             MOVS     R0,#+13
   \   00000062   0x4770             BX       LR
     70          	case INV_SENSOR_TYPE_PICK_UP_GESTURE:         return INV_ICM20948_SENSOR_FLIP_PICKUP;
   \                     ??idd_sensortype_2_driver_16: (+1)
   \   00000064   0x200E             MOVS     R0,#+14
   \   00000066   0x4770             BX       LR
     71          	case INV_SENSOR_TYPE_TILT_DETECTOR:           return INV_ICM20948_SENSOR_WAKEUP_TILT_DETECTOR;
   \                     ??idd_sensortype_2_driver_17: (+1)
   \   00000068   0x200F             MOVS     R0,#+15
   \   0000006A   0x4770             BX       LR
     72          	case INV_SENSOR_TYPE_GRAVITY:                 return INV_ICM20948_SENSOR_GRAVITY;
   \                     ??idd_sensortype_2_driver_18: (+1)
   \   0000006C   0x2010             MOVS     R0,#+16
   \   0000006E   0x4770             BX       LR
     73          	case INV_SENSOR_TYPE_LINEAR_ACCELERATION:     return INV_ICM20948_SENSOR_LINEAR_ACCELERATION;
   \                     ??idd_sensortype_2_driver_19: (+1)
   \   00000070   0x2011             MOVS     R0,#+17
   \   00000072   0x4770             BX       LR
     74          	case INV_SENSOR_TYPE_ORIENTATION:             return INV_ICM20948_SENSOR_ORIENTATION;
   \                     ??idd_sensortype_2_driver_20: (+1)
   \   00000074   0x2012             MOVS     R0,#+18
   \   00000076   0x4770             BX       LR
     75          	case INV_SENSOR_TYPE_B2S:                     return INV_ICM20948_SENSOR_B2S;
   \                     ??idd_sensortype_2_driver_21: (+1)
   \   00000078   0x2013             MOVS     R0,#+19
   \   0000007A   0x4770             BX       LR
     76          	default:                                      return INV_ICM20948_SENSOR_MAX;
   \                     ??idd_sensortype_2_driver_1: (+1)
   \   0000007C   0x2014             MOVS     R0,#+20
   \   0000007E   0x4770             BX       LR               ;; return
     77          	}
     78          }
     79          

   \                                 In section .text, align 4, keep-with-next
     80          static int idd_driver_2_sensortype(enum inv_icm20948_sensor sensor)
     81          {
     82          	switch(sensor) {
   \                     idd_driver_2_sensortype: (+1)
   \   00000000   0x2813             CMP      R0,#+19
   \   00000002   0xD833             BHI.N    ??idd_driver_2_sensortype_1
   \   00000004   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??idd_driver_2_sensortype_0:
   \   00000008   0x0A 0x0C          DC8      0xA,0xC,0xE,0x10
   \              0x0E 0x10    
   \   0000000C   0x12 0x14          DC8      0x12,0x14,0x16,0x18
   \              0x16 0x18    
   \   00000010   0x1A 0x1C          DC8      0x1A,0x1C,0x1E,0x20
   \              0x1E 0x20    
   \   00000014   0x22 0x24          DC8      0x22,0x24,0x26,0x28
   \              0x26 0x28    
   \   00000018   0x2A 0x2C          DC8      0x2A,0x2C,0x2E,0x30
   \              0x2E 0x30    
     83          	case INV_ICM20948_SENSOR_ACCELEROMETER:                    return INV_SENSOR_TYPE_ACCELEROMETER;
   \                     ??idd_driver_2_sensortype_2: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR
     84          	case INV_ICM20948_SENSOR_GYROSCOPE:                        return INV_SENSOR_TYPE_GYROSCOPE;
   \                     ??idd_driver_2_sensortype_3: (+1)
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x4770             BX       LR
     85          	case INV_ICM20948_SENSOR_RAW_ACCELEROMETER:                return INV_SENSOR_TYPE_RAW_ACCELEROMETER;
   \                     ??idd_driver_2_sensortype_4: (+1)
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0x4770             BX       LR
     86          	case INV_ICM20948_SENSOR_RAW_GYROSCOPE:                    return INV_SENSOR_TYPE_RAW_GYROSCOPE;
   \                     ??idd_driver_2_sensortype_5: (+1)
   \   00000028   0x2021             MOVS     R0,#+33
   \   0000002A   0x4770             BX       LR
     87          	case INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:      return INV_SENSOR_TYPE_UNCAL_MAGNETOMETER;
   \                     ??idd_driver_2_sensortype_6: (+1)
   \   0000002C   0x200E             MOVS     R0,#+14
   \   0000002E   0x4770             BX       LR
     88          	case INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED:           return INV_SENSOR_TYPE_UNCAL_GYROSCOPE;
   \                     ??idd_driver_2_sensortype_7: (+1)
   \   00000030   0x2010             MOVS     R0,#+16
   \   00000032   0x4770             BX       LR
     89          	case INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON:           return INV_SENSOR_TYPE_BAC;
   \                     ??idd_driver_2_sensortype_8: (+1)
   \   00000034   0x201A             MOVS     R0,#+26
   \   00000036   0x4770             BX       LR
     90          	case INV_ICM20948_SENSOR_STEP_DETECTOR:                    return INV_SENSOR_TYPE_STEP_DETECTOR;
   \                     ??idd_driver_2_sensortype_9: (+1)
   \   00000038   0x2012             MOVS     R0,#+18
   \   0000003A   0x4770             BX       LR
     91          	case INV_ICM20948_SENSOR_STEP_COUNTER:                     return INV_SENSOR_TYPE_STEP_COUNTER;
   \                     ??idd_driver_2_sensortype_10: (+1)
   \   0000003C   0x2013             MOVS     R0,#+19
   \   0000003E   0x4770             BX       LR
     92          	case INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR:             return INV_SENSOR_TYPE_GAME_ROTATION_VECTOR;
   \                     ??idd_driver_2_sensortype_11: (+1)
   \   00000040   0x200F             MOVS     R0,#+15
   \   00000042   0x4770             BX       LR
     93          	case INV_ICM20948_SENSOR_ROTATION_VECTOR:                  return INV_SENSOR_TYPE_ROTATION_VECTOR;
   \                     ??idd_driver_2_sensortype_12: (+1)
   \   00000044   0x200B             MOVS     R0,#+11
   \   00000046   0x4770             BX       LR
     94          	case INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:      return INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR;
   \                     ??idd_driver_2_sensortype_13: (+1)
   \   00000048   0x2014             MOVS     R0,#+20
   \   0000004A   0x4770             BX       LR
     95          	case INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD:                return INV_SENSOR_TYPE_MAGNETOMETER;
   \                     ??idd_driver_2_sensortype_14: (+1)
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x4770             BX       LR
     96          	case INV_ICM20948_SENSOR_WAKEUP_SIGNIFICANT_MOTION:        return INV_SENSOR_TYPE_SMD;
   \                     ??idd_driver_2_sensortype_15: (+1)
   \   00000050   0x2011             MOVS     R0,#+17
   \   00000052   0x4770             BX       LR
     97          	case INV_ICM20948_SENSOR_FLIP_PICKUP:                      return INV_SENSOR_TYPE_PICK_UP_GESTURE;
   \                     ??idd_driver_2_sensortype_16: (+1)
   \   00000054   0x2019             MOVS     R0,#+25
   \   00000056   0x4770             BX       LR
     98          	case INV_ICM20948_SENSOR_WAKEUP_TILT_DETECTOR:             return INV_SENSOR_TYPE_TILT_DETECTOR;
   \                     ??idd_driver_2_sensortype_17: (+1)
   \   00000058   0x2016             MOVS     R0,#+22
   \   0000005A   0x4770             BX       LR
     99          	case INV_ICM20948_SENSOR_GRAVITY:                          return INV_SENSOR_TYPE_GRAVITY;
   \                     ??idd_driver_2_sensortype_18: (+1)
   \   0000005C   0x2009             MOVS     R0,#+9
   \   0000005E   0x4770             BX       LR
    100          	case INV_ICM20948_SENSOR_LINEAR_ACCELERATION:              return INV_SENSOR_TYPE_LINEAR_ACCELERATION;
   \                     ??idd_driver_2_sensortype_19: (+1)
   \   00000060   0x200A             MOVS     R0,#+10
   \   00000062   0x4770             BX       LR
    101          	case INV_ICM20948_SENSOR_ORIENTATION:                      return INV_SENSOR_TYPE_ORIENTATION;
   \                     ??idd_driver_2_sensortype_20: (+1)
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x4770             BX       LR
    102          	case INV_ICM20948_SENSOR_B2S:                              return INV_SENSOR_TYPE_B2S;
   \                     ??idd_driver_2_sensortype_21: (+1)
   \   00000068   0x201C             MOVS     R0,#+28
   \   0000006A   0x4770             BX       LR
    103          	default:                                                   return INV_SENSOR_TYPE_MAX;
   \                     ??idd_driver_2_sensortype_1: (+1)
   \   0000006C   0x2041             MOVS     R0,#+65
   \   0000006E   0x4770             BX       LR               ;; return
    104          	}
    105          }
    106          
    107          static void data_handler(void * context, enum inv_icm20948_sensor sensor, uint64_t timestamp,
    108          		const void * data, const void *arg);
    109          
    110          static inv_bool_t build_sensor_event(inv_device_icm20948_t * self,
    111          		int sensorid, uint64_t timestamp, const void * data, const void *arg,
    112          		inv_sensor_event_t * event);
    113          

   \                                 In section .text, align 2, keep-with-next
    114          static int host_serif_read_reg_legacy(void * context, uint8_t reg, uint8_t * data, uint32_t len)
    115          {
   \                     host_serif_read_reg_legacy: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461A             MOV      R2,R3
    116          	inv_host_serif_t * serif = (inv_host_serif_t *)context;
    117          
    118          	return serif->read_reg(reg, data, len);
   \   0000000A   0x68A3             LDR      R3,[R4, #+8]
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0xBC10             POP      {R4}
   \   00000010   0x4718             BX       R3
    119          }
    120          
    121          /* For BW compatibility
    122           * wrapper function to adapt prototype of write_reg() as defined in inv_host_serif
    123           * to expected prototype for inv_serif_hal
    124           */

   \                                 In section .text, align 2, keep-with-next
    125          static int host_serif_write_reg_legacy(void * context, uint8_t reg, const uint8_t * data, uint32_t len)
    126          {
   \                     host_serif_write_reg_legacy: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x461A             MOV      R2,R3
    127          	inv_host_serif_t * serif = (inv_host_serif_t *)context;
    128          
    129          	return serif->write_reg(reg, data, len);
   \   0000000A   0x68E3             LDR      R3,[R4, #+12]
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0xBC10             POP      {R4}
   \   00000010   0x4718             BX       R3
    130          }
    131          

   \                                 In section .text, align 2, keep-with-next
    132          void inv_device_icm20948_init(inv_device_icm20948_t * self,
    133          		const inv_host_serif_t * serif, const inv_sensor_listener_t * listener,
    134          		const uint8_t  * dmp3_image, uint32_t dmp3_image_size)
    135          {
   \                     inv_device_icm20948_init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    136          	/* create an a inv_serif_hal_t object from a inv_host_serif_t */
    137          	const inv_serif_hal_t serif_hal = {
    138          		host_serif_read_reg_legacy, host_serif_write_reg_legacy, /* use small wrappers to adapt prototype */
    139          		serif->max_read_size, serif->max_write_size,
    140          		serif->serif_type, &self->legacy_serif
    141          	};
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x.... 0x....      ADR.W    R1,?_18
   \   0000000E   0xEC91 0x0B06      VLDM     R1,{D0-D2}
   \   00000012   0xEC80 0x0B06      VSTM     R0,{D0-D2}
   \   00000016   0x6968             LDR      R0,[R5, #+20]
   \   00000018   0x9003             STR      R0,[SP, #+12]
   \   0000001A   0x69A8             LDR      R0,[R5, #+24]
   \   0000001C   0x9004             STR      R0,[SP, #+16]
   \   0000001E   0x69E8             LDR      R0,[R5, #+28]
   \   00000020   0x9005             STR      R0,[SP, #+20]
   \   00000022   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000026   0x9006             STR      R0,[SP, #+24]
    142          
    143          	/* call the 'constructor' */
    144          	inv_device_icm20948_init2(self, &serif_hal, listener, dmp3_image, dmp3_image_size);
   \   00000028   0x980A             LDR      R0,[SP, #+40]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_device_icm20948_init2
    145          	/* keep a copy of the user inv_host_serif_t (used in the _legacy callbacks) */
    146          	self->legacy_serif = *serif;
   \   00000034   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000038   0xEC95 0x0B08      VLDM     R5,{D0-D3}
   \   0000003C   0xEC80 0x0B08      VSTM     R0,{D0-D3}
    147          }
   \   00000040   0xB007             ADD      SP,SP,#+28
   \   00000042   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \   00000000   0x........         DC32 host_serif_read_reg_legacy, host_serif_write_reg_legacy, 0, 0, 0
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   00000014   0x00000000         DC32 0H
    148          

   \                                 In section .text, align 2, keep-with-next
    149          void inv_device_icm20948_init2(inv_device_icm20948_t * self,
    150          		const inv_serif_hal_t * serif, const inv_sensor_listener_t * listener,
    151          		const uint8_t  * dmp3_image, uint32_t dmp3_image_size)
    152          {
   \                     inv_device_icm20948_init2: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    153          	struct inv_icm20948_serif icm20948_serif;
    154          
    155          	assert(self);
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD108             BNE.N    ??inv_device_icm20948_init2_0
   \   00000010   0x229B             MOVS     R2,#+155
   \   00000012   0x.... 0x....      ADR.W    R1,?_3
   \   00000016   0x.... 0x....      ADR.W    R0,?_2
   \   0000001A   0x.... 0x....      BL       __aeabi_assert
   \   0000001E   0x.... 0x....      BL       __iar_EmptyStepPoint
    156          
    157          	memset(self, 0, sizeof(*self));
   \                     ??inv_device_icm20948_init2_0: (+1)
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0xF44F 0x61A6      MOV      R1,#+1328
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       __aeabi_memset4
    158          	
    159          	/* initialize icm20948 serif structure */
    160          	icm20948_serif.context   = serif->context;
   \   0000002E   0x6968             LDR      R0,[R5, #+20]
   \   00000030   0x9000             STR      R0,[SP, #+0]
    161          	icm20948_serif.read_reg  = serif->read_reg;
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x9001             STR      R0,[SP, #+4]
    162          	icm20948_serif.write_reg = serif->write_reg;
   \   00000036   0x6868             LDR      R0,[R5, #+4]
   \   00000038   0x9002             STR      R0,[SP, #+8]
    163          	icm20948_serif.max_read  = serif->max_read_transaction_size;
   \   0000003A   0x68A8             LDR      R0,[R5, #+8]
   \   0000003C   0x9003             STR      R0,[SP, #+12]
    164          	icm20948_serif.max_write = serif->max_write_transaction_size;
   \   0000003E   0x68E8             LDR      R0,[R5, #+12]
   \   00000040   0x9004             STR      R0,[SP, #+16]
    165          	icm20948_serif.is_spi    = !!(serif->serif_type == INV_SERIF_HAL_TYPE_SPI);
   \   00000042   0x6928             LDR      R0,[R5, #+16]
   \   00000044   0x2802             CMP      R0,#+2
   \   00000046   0xD101             BNE.N    ??inv_device_icm20948_init2_1
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??inv_device_icm20948_init2_2
   \                     ??inv_device_icm20948_init2_1: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??inv_device_icm20948_init2_2: (+1)
   \   0000004E   0x9005             STR      R0,[SP, #+20]
    166          	
    167          	/* build base */
    168          	self->base.instance = self;
   \   00000050   0x6024             STR      R4,[R4, #+0]
    169          	self->base.vt       = &device_icm20948_vt;
   \   00000052   0x.... 0x....      ADR.W    R0,device_icm20948_vt
   \   00000056   0x6060             STR      R0,[R4, #+4]
    170          	self->base.listener = listener;
   \   00000058   0x60A6             STR      R6,[R4, #+8]
    171          	self->dmp3_image = dmp3_image;
   \   0000005A   0xF44F 0x60A5      MOV      R0,#+1320
   \   0000005E   0x4420             ADD      R0,R4,R0
   \   00000060   0x6007             STR      R7,[R0, #+0]
    172          	self->dmp3_image_size = dmp3_image_size;
   \   00000062   0x990C             LDR      R1,[SP, #+48]
   \   00000064   0x6041             STR      R1,[R0, #+4]
    173          	/* reset icm20948 driver states */
    174          	inv_icm20948_reset_states(&self->icm20948_states, &icm20948_serif);
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000006C   0x.... 0x....      BL       inv_icm20948_reset_states
    175          	
    176          	/* initialise mounting matrix to identity */
    177          	self->icm20948_states.mounting_matrix[0] = 1;
   \   00000070   0xF44F 0x7029      MOV      R0,#+676
   \   00000074   0x4420             ADD      R0,R4,R0
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x7001             STRB     R1,[R0, #+0]
    178          	self->icm20948_states.mounting_matrix[4] = 1;
   \   0000007A   0x7101             STRB     R1,[R0, #+4]
    179          	self->icm20948_states.mounting_matrix[8] = 1;
   \   0000007C   0x7201             STRB     R1,[R0, #+8]
    180          
    181          	/*initialise base state structure*/
    182          	inv_icm20948_init_structure(&self->icm20948_states);
   \   0000007E   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000082   0x.... 0x....      BL       inv_icm20948_init_structure
    183          	
    184          #if (MEMS_CHIP == HW_ICM20948)
    185          	/*force the usage of akm9916 for 20948*/
    186          	inv_device_icm20948_init_aux_compass( self, INV_ICM20948_COMPASS_ID_AK09916, 0x0C);
   \   00000086   0x220C             MOVS     R2,#+12
   \   00000088   0x2103             MOVS     R1,#+3
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       inv_device_icm20948_init_aux_compass
    187          #endif
    188          }
   \   00000090   0xB007             ADD      SP,SP,#+28
   \   00000092   0xBDF0             POP      {R4-R7,PC}       ;; return
    189          

   \                                 In section .text, align 2, keep-with-next
    190          int inv_device_icm20948_poll(void * context)
    191          {
    192          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    193          
    194          	return inv_icm20948_poll_sensor(&self->icm20948_states, self, data_handler);
   \                     inv_device_icm20948_poll: (+1)
   \   00000000   0x.... 0x....      ADR.W    R2,data_handler
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x3030             ADDS     R0,R0,#+48
   \   00000008   0x.... 0x....      B.W      inv_icm20948_poll_sensor
    195          }
    196          

   \                                 In section .text, align 2, keep-with-next
    197          int inv_device_icm20948_whoami(void * context, uint8_t * whoami)
    198          {
   \                     inv_device_icm20948_whoami: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    199          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    200          
    201          	assert(whoami);
   \   00000006   0xD108             BNE.N    ??inv_device_icm20948_whoami_0
   \   00000008   0x22C9             MOVS     R2,#+201
   \   0000000A   0x.... 0x....      ADR.W    R1,?_3
   \   0000000E   0x.... 0x....      ADR.W    R0,?_4
   \   00000012   0x.... 0x....      BL       __aeabi_assert
   \   00000016   0x.... 0x....      BL       __iar_EmptyStepPoint
    202          
    203          	return inv_icm20948_get_whoami(&self->icm20948_states, whoami);
   \                     ??inv_device_icm20948_whoami_0: (+1)
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000020   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000024   0x.... 0x....      B.W      inv_icm20948_get_whoami
    204          }
    205          

   \                                 In section .text, align 2, keep-with-next
    206          int inv_device_icm20948_reset(void * context)
    207          {
   \                     inv_device_icm20948_reset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    208          	int rc = 0;
    209          
    210          	INV_MSG(INV_MSG_LEVEL_VERBOSE, "Reseting device...");
   \   00000004   0x.... 0x....      ADR.W    R1,?_5
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0x.... 0x....      BL       inv_msg
    211          	rc |= inv_device_icm20948_cleanup(context);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       inv_device_icm20948_cleanup
   \   00000014   0x4605             MOV      R5,R0
    212          	rc |= inv_device_icm20948_setup(context);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_device_icm20948_setup
   \   0000001C   0xEA50 0x0405      ORRS     R4,R0,R5
    213          	
    214          		if(rc != 0) {
   \   00000020   0xD007             BEQ.N    ??inv_device_icm20948_reset_0
    215          		INV_MSG(INV_MSG_LEVEL_ERROR, "Icm20648 reset returned %d", rc);
   \   00000022   0x4622             MOV      R2,R4
   \   00000024   0x.... 0x....      ADR.W    R1,?_6
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       inv_msg
    216          		return rc;
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
    217          	}
    218          
    219          	return 0;
   \                     ??inv_device_icm20948_reset_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    220          }
    221          

   \                                 In section .text, align 2, keep-with-next
    222          int inv_device_icm20948_setup(void * context)
    223          {
   \                     inv_device_icm20948_setup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    224          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    225          	int rc;
    226          	uint8_t whoami;
    227          
    228          	INV_MSG(INV_MSG_LEVEL_INFO, "Booting up Icm20948...");
   \   00000004   0x.... 0x....      ADR.W    R1,?_7
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       inv_msg
    229          
    230          	/* Check WHOAMI */
    231          	INV_MSG(INV_MSG_LEVEL_VERBOSE, "Reading WHOAMI...");
   \   0000000E   0x.... 0x....      ADR.W    R1,?_8
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0x.... 0x....      BL       inv_msg
    232          	if((rc = inv_device_icm20948_whoami(self, &whoami)) != 0) {
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       inv_device_icm20948_whoami
   \   00000020   0x0005             MOVS     R5,R0
   \   00000022   0xD007             BEQ.N    ??inv_device_icm20948_setup_0
    233          		INV_MSG(INV_MSG_LEVEL_ERROR, "Error %d when reading WHOAMI value", rc);
   \   00000024   0x462A             MOV      R2,R5
   \   00000026   0x.... 0x....      ADR.W    R1,?_9
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      BL       inv_msg
    234          		return rc;
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}
    235          	}
    236          
    237          	if(whoami == 0 || whoami == 0xff) {
   \                     ??inv_device_icm20948_setup_0: (+1)
   \   00000034   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000038   0x4610             MOV      R0,R2
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ.N    ??inv_device_icm20948_setup_1
   \   0000003E   0x2AFF             CMP      R2,#+255
   \   00000040   0xD107             BNE.N    ??inv_device_icm20948_setup_2
    238          		INV_MSG(INV_MSG_LEVEL_ERROR, "Unexpected WHOAMI value 0x%x. Aborting setup.", whoami);
   \                     ??inv_device_icm20948_setup_1: (+1)
   \   00000042   0x.... 0x....      ADR.W    R1,?_10
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       inv_msg
    239          		return INV_ERROR;
   \   0000004C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}
    240          	} else {
    241          		INV_MSG(INV_MSG_LEVEL_INFO, "WHOAMI value: 0x%x", whoami);
   \                     ??inv_device_icm20948_setup_2: (+1)
   \   00000052   0x.... 0x....      ADR.W    R1,?_11
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0x.... 0x....      BL       inv_msg
    242          	}
    243          	/* Setup accel and gyro mounting matrix and associated angle for current board */
    244          	inv_icm20948_init_matrix(&self->icm20948_states);
   \   0000005C   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000060   0x.... 0x....      BL       inv_icm20948_init_matrix
    245          
    246          	/* set default power mode */
    247          	INV_MSG(INV_MSG_LEVEL_VERBOSE, "Putting Icm20948 in sleep mode...");
   \   00000064   0x.... 0x....      ADR.W    R1,?_12
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0x.... 0x....      BL       inv_msg
    248          	if((rc = inv_icm20948_initialize(&self->icm20948_states, self->dmp3_image,
    249          			self->dmp3_image_size)) != 0)
   \   0000006E   0xF44F 0x60A5      MOV      R0,#+1320
   \   00000072   0x4420             ADD      R0,R4,R0
   \   00000074   0x6842             LDR      R2,[R0, #+4]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000007C   0x.... 0x....      BL       inv_icm20948_initialize
   \   00000080   0x0005             MOVS     R5,R0
   \   00000082   0xD007             BEQ.N    ??inv_device_icm20948_setup_3
    250          		goto error;
    251           
    252          	/* Initialize auxiliary sensors */
    253          	inv_icm20948_initialize_auxiliary(&self->icm20948_states);
    254          
    255          	inv_icm20948_init_scale(&self->icm20948_states);
    256          
    257          	/* re-initialise base state structure */
    258          	inv_icm20948_init_structure(&self->icm20948_states);
    259          	
    260          	/* we should be good to go ! */
    261          	INV_MSG(INV_MSG_LEVEL_VERBOSE, "We're good to go !");
    262          
    263          	return 0;
    264          error:
    265          	INV_MSG(INV_MSG_LEVEL_ERROR, "Error %d while setting-up device.", rc);
   \   00000084   0x462A             MOV      R2,R5
   \   00000086   0x.... 0x....      ADR.W    R1,?_14
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      BL       inv_msg
    266          
    267          	return rc;
   \   00000090   0x4628             MOV      R0,R5
   \   00000092   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??inv_device_icm20948_setup_3: (+1)
   \   00000094   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000098   0x.... 0x....      BL       inv_icm20948_initialize_auxiliary
   \   0000009C   0xF104 0x0030      ADD      R0,R4,#+48
   \   000000A0   0x.... 0x....      BL       inv_icm20948_init_scale
   \   000000A4   0xF104 0x0030      ADD      R0,R4,#+48
   \   000000A8   0x.... 0x....      BL       inv_icm20948_init_structure
   \   000000AC   0x.... 0x....      ADR.W    R1,?_13
   \   000000B0   0x2004             MOVS     R0,#+4
   \   000000B2   0x.... 0x....      BL       inv_msg
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    268          }
    269          

   \                                 In section .text, align 2, keep-with-next
    270          int inv_device_icm20948_cleanup(void * context)
    271          {
   \                     inv_device_icm20948_cleanup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    272          	int i = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    273          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    274          
    275          	/* Disable all supported sensors */
    276          	for (i=0; i<INV_SENSOR_TYPE_MAX; ++i) {
   \   00000006   0xE00B             B.N      ??inv_device_icm20948_cleanup_0
    277          		if (inv_device_icm20948_ping_sensor(context, i) == 0)
   \                     ??inv_device_icm20948_cleanup_1: (+1)
   \   00000008   0x4629             MOV      R1,R5
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       inv_device_icm20948_ping_sensor
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD104             BNE.N    ??inv_device_icm20948_cleanup_2
    278          			inv_device_icm20948_enable_sensor(context, i, 0);
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x4629             MOV      R1,R5
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       inv_device_icm20948_enable_sensor
    279          	}	
   \                     ??inv_device_icm20948_cleanup_2: (+1)
   \   0000001E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??inv_device_icm20948_cleanup_0: (+1)
   \   00000020   0x2D41             CMP      R5,#+65
   \   00000022   0xDBF1             BLT.N    ??inv_device_icm20948_cleanup_1
    280          	
    281          	return inv_icm20948_soft_reset(&self->icm20948_states);
   \   00000024   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000028   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000002C   0x.... 0x....      B.W      inv_icm20948_soft_reset
    282          }
    283          

   \                                 In section .text, align 2, keep-with-next
    284          int inv_device_icm20948_load(void * context, int what,
    285          		const uint8_t * image, uint32_t size, inv_bool_t verify, inv_bool_t force)
    286          {
   \                     inv_device_icm20948_load: (+1)
   \   00000000   0x4611             MOV      R1,R2
   \   00000002   0x461A             MOV      R2,R3
    287          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    288          	(void)what;
    289          	(void)verify;
    290          	(void)force;
    291          
    292          	return inv_icm20948_load(&self->icm20948_states, image, size);
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0x3030             ADDS     R0,R0,#+48
   \   00000008   0x.... 0x....      B.W      inv_icm20948_load
    293          }
    294          

   \                                 In section .text, align 2, keep-with-next
    295          int inv_device_icm20948_self_test(void * context, int sensor)
    296          {
   \                     inv_device_icm20948_self_test: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    297          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    298          	int rc;
    299          
    300          	if(inv_device_icm20948_ping_sensor(context, sensor) != 0)
   \   00000006   0x.... 0x....      BL       inv_device_icm20948_ping_sensor
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD109             BNE.N    ??inv_device_icm20948_self_test_0
    301          		return INV_ERROR_BAD_ARG;
    302          
    303          	if((sensor != INV_SENSOR_TYPE_RAW_ACCELEROMETER) &&
    304          			(sensor != INV_SENSOR_TYPE_ACCELEROMETER) &&
    305          			(sensor != INV_SENSOR_TYPE_RAW_GYROSCOPE) &&
    306          			(sensor != INV_SENSOR_TYPE_GYROSCOPE) &&
    307          			(sensor != INV_SENSOR_TYPE_MAGNETOMETER))
   \   0000000E   0x2D20             CMP      R5,#+32
   \   00000010   0xD00A             BEQ.N    ??inv_device_icm20948_self_test_1
   \   00000012   0x2D01             CMP      R5,#+1
   \   00000014   0xD008             BEQ.N    ??inv_device_icm20948_self_test_1
   \   00000016   0x2D21             CMP      R5,#+33
   \   00000018   0xD006             BEQ.N    ??inv_device_icm20948_self_test_1
   \   0000001A   0x2D04             CMP      R5,#+4
   \   0000001C   0xD004             BEQ.N    ??inv_device_icm20948_self_test_1
   \   0000001E   0x2D02             CMP      R5,#+2
   \   00000020   0xD002             BEQ.N    ??inv_device_icm20948_self_test_1
    308          			//(sensor != INV_SENSOR_TYPE_RAW_MAGNETOMETER) AxL add rawmag
    309          		return INV_ERROR_BAD_ARG;
   \                     ??inv_device_icm20948_self_test_0: (+1)
   \   00000022   0xF06F 0x000A      MVN      R0,#+10
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    310          
    311          	if(self->icm20948_states.selftest_done) {
   \                     ??inv_device_icm20948_self_test_1: (+1)
   \   00000028   0xF894 0x00C0      LDRB     R0,[R4, #+192]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD006             BEQ.N    ??inv_device_icm20948_self_test_2
    312          		INV_MSG(INV_MSG_LEVEL_WARNING, "Self-test already ran once!");
   \   00000030   0x.... 0x....      ADR.W    R1,?_15
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x.... 0x....      BL       inv_msg
    313          		return INV_ERROR_SUCCESS;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}
    314          	}
    315          
    316          	/* Reset the device in case the self-test doesn't run at start */
    317          	inv_device_icm20948_cleanup(context);
   \                     ??inv_device_icm20948_self_test_2: (+1)
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       inv_device_icm20948_cleanup
    318          	if((inv_icm20948_run_selftest(&self->icm20948_states) & INV_ICM20948_SELF_TEST_OK) 
    319          			== INV_ICM20948_SELF_TEST_OK) {
   \   00000044   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000048   0x.... 0x....      BL       inv_icm20948_run_selftest
   \   0000004C   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000050   0x2807             CMP      R0,#+7
   \   00000052   0xD104             BNE.N    ??inv_device_icm20948_self_test_3
    320          		self->icm20948_states.selftest_done = 1;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0xF884 0x00C0      STRB     R0,[R4, #+192]
    321          		rc = 0;
   \   0000005A   0x2500             MOVS     R5,#+0
   \   0000005C   0xE001             B.N      ??inv_device_icm20948_self_test_4
    322          	}
    323          	else
    324          		rc = INV_ERROR;
   \                     ??inv_device_icm20948_self_test_3: (+1)
   \   0000005E   0xF04F 0x35FF      MOV      R5,#-1
    325          
    326          	/* It's advised to re-init the device after self-test for normal use */
    327          	inv_device_icm20948_reset(context);
   \                     ??inv_device_icm20948_self_test_4: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       inv_device_icm20948_reset
    328          	return rc;
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    329          }
    330          

   \                                 In section .text, align 2, keep-with-next
    331          int inv_device_icm20948_ping_sensor(void * context, int sensor)
    332          {
   \                     inv_device_icm20948_ping_sensor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    333          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    334          	
    335          	/* HW sensors */
    336          	if( (sensor == INV_SENSOR_TYPE_RAW_ACCELEROMETER) ||
    337          	    (sensor == INV_SENSOR_TYPE_RAW_GYROSCOPE) ||
    338          	    (sensor == INV_SENSOR_TYPE_GAME_ROTATION_VECTOR) ||
    339          	    (sensor == INV_SENSOR_TYPE_ACCELEROMETER) ||
    340          	    (sensor == INV_SENSOR_TYPE_GYROSCOPE) ||
    341          	    (sensor == INV_SENSOR_TYPE_UNCAL_GYROSCOPE) ||
    342          	    (sensor == INV_SENSOR_TYPE_SMD) ||
    343          	    (sensor == INV_SENSOR_TYPE_STEP_DETECTOR) ||
    344          	    (sensor == INV_SENSOR_TYPE_STEP_COUNTER) ||
    345          	    (sensor == INV_SENSOR_TYPE_B2S) ||
    346          	    (sensor == INV_SENSOR_TYPE_PICK_UP_GESTURE) ||
    347          	    (sensor == INV_SENSOR_TYPE_BAC) ||
    348          	    (sensor == INV_SENSOR_TYPE_GRAVITY) ||
    349          	    (sensor == INV_SENSOR_TYPE_LINEAR_ACCELERATION) ||
    350          	    (sensor == INV_SENSOR_TYPE_TILT_DETECTOR) ) {
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xD02A             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   00000006   0x2921             CMP      R1,#+33
   \   00000008   0xD028             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   0000000A   0x290F             CMP      R1,#+15
   \   0000000C   0xD026             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD024             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD022             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   00000016   0x2910             CMP      R1,#+16
   \   00000018   0xD020             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   0000001A   0x2911             CMP      R1,#+17
   \   0000001C   0xD01E             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   0000001E   0x2912             CMP      R1,#+18
   \   00000020   0xD01C             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   00000022   0x2913             CMP      R1,#+19
   \   00000024   0xD01A             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   00000026   0x291C             CMP      R1,#+28
   \   00000028   0xD018             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   0000002A   0x2919             CMP      R1,#+25
   \   0000002C   0xD016             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   0000002E   0x291A             CMP      R1,#+26
   \   00000030   0xD014             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   00000032   0x2909             CMP      R1,#+9
   \   00000034   0xD012             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   00000036   0x290A             CMP      R1,#+10
   \   00000038   0xD010             BEQ.N    ??inv_device_icm20948_ping_sensor_0
   \   0000003A   0x2916             CMP      R1,#+22
   \   0000003C   0xD00E             BEQ.N    ??inv_device_icm20948_ping_sensor_0
    351          		return 0;
    352          	} else if( (sensor == INV_SENSOR_TYPE_MAGNETOMETER) ||
    353          	           (sensor == INV_SENSOR_TYPE_UNCAL_MAGNETOMETER) ||
    354          	           (sensor == INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR) ||
    355          	           (sensor == INV_SENSOR_TYPE_ORIENTATION) ||
    356          	           (sensor == INV_SENSOR_TYPE_ROTATION_VECTOR) ) {
   \   0000003E   0x2902             CMP      R1,#+2
   \   00000040   0xD007             BEQ.N    ??inv_device_icm20948_ping_sensor_1
   \   00000042   0x290E             CMP      R1,#+14
   \   00000044   0xD005             BEQ.N    ??inv_device_icm20948_ping_sensor_1
   \   00000046   0x2914             CMP      R1,#+20
   \   00000048   0xD003             BEQ.N    ??inv_device_icm20948_ping_sensor_1
   \   0000004A   0x2903             CMP      R1,#+3
   \   0000004C   0xD001             BEQ.N    ??inv_device_icm20948_ping_sensor_1
   \   0000004E   0x290B             CMP      R1,#+11
   \   00000050   0xD106             BNE.N    ??inv_device_icm20948_ping_sensor_2
    357          		if(inv_icm20948_compass_isconnected(&self->icm20948_states))
   \                     ??inv_device_icm20948_ping_sensor_1: (+1)
   \   00000052   0x3030             ADDS     R0,R0,#+48
   \   00000054   0x.... 0x....      BL       inv_icm20948_compass_isconnected
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??inv_device_icm20948_ping_sensor_2
    358          			return 0;
   \                     ??inv_device_icm20948_ping_sensor_0: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD02             POP      {R1,PC}
    359          	}
    360          
    361          	return INV_ERROR_BAD_ARG;
   \                     ??inv_device_icm20948_ping_sensor_2: (+1)
   \   00000060   0xF06F 0x000A      MVN      R0,#+10
   \   00000064   0xBD02             POP      {R1,PC}          ;; return
    362          }
    363          

   \                                 In section .text, align 2, keep-with-next
    364          int inv_device_icm20948_enable_sensor(void * context, int sensor, inv_bool_t en)
    365          {
   \                     inv_device_icm20948_enable_sensor: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4615             MOV      R5,R2
    366          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    367          
    368          	return inv_icm20948_enable_sensor(&self->icm20948_states, idd_sensortype_2_driver(sensor), en);
   \   00000008   0x.... 0x....      BL       idd_sensortype_2_driver
   \   0000000C   0x462A             MOV      R2,R5
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000014   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000018   0x.... 0x....      B.W      inv_icm20948_enable_sensor
    369          }
    370          

   \                                 In section .text, align 2, keep-with-next
    371          int inv_device_icm20948_set_sensor_period_us(void * context,
    372          		int sensor, uint32_t period)
    373          {
   \                     inv_device_icm20948_set_sensor_period_us: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4615             MOV      R5,R2
    374          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    375          
    376          	/* convert period back to ms as this is what expects the driver for now */
    377          	period /= 1000;
    378          
    379          	return inv_icm20948_set_sensor_period(&self->icm20948_states, idd_sensortype_2_driver(sensor), period);
   \   00000008   0x.... 0x....      BL       idd_sensortype_2_driver
   \   0000000C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000010   0xFBB5 0xF2F1      UDIV     R2,R5,R1
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000001A   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   0000001E   0x.... 0x....      B.W      inv_icm20948_set_sensor_period
    380          }
    381          

   \                                 In section .text, align 2, keep-with-next
    382          int inv_device_icm20948_set_sensor_timeout(void * context,
    383          		int sensor, uint32_t period)
    384          {
    385          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    386          	(void)sensor;
    387          
    388          	return inv_icm20948_enable_batch_timeout(&self->icm20948_states, period);
   \                     inv_device_icm20948_set_sensor_timeout: (+1)
   \   00000000   0x4611             MOV      R1,R2
   \   00000002   0xB289             UXTH     R1,R1
   \   00000004   0x3030             ADDS     R0,R0,#+48
   \   00000006   0x.... 0x....      B.W      inv_icm20948_enable_batch_timeout
    389          }
    390          

   \                                 In section .text, align 2, keep-with-next
    391          int inv_device_icm20948_set_sensor_mounting_matrix(void * context,
    392          		int sensor, const float matrix[9])
    393          {
   \                     inv_device_icm20948_set_sensor_mounting_matrix: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x4615             MOV      R5,R2
    394          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    395          	
    396          	return inv_icm20948_set_matrix(&self->icm20948_states, matrix, idd_sensortype_2_driver(sensor));
   \   00000008   0x.... 0x....      BL       idd_sensortype_2_driver
   \   0000000C   0x4602             MOV      R2,R0
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000014   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000018   0x.... 0x....      B.W      inv_icm20948_set_matrix
    397          }
    398          

   \                                 In section .text, align 2, keep-with-next
    399          int inv_device_icm20948_write_mems_register(void * context, int sensor, uint16_t reg_addr,
    400          		const void * data, unsigned size)
    401          {
   \                     inv_device_icm20948_write_mems_register: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   \   00000002   0x4611             MOV      R1,R2
   \   00000004   0x461A             MOV      R2,R3
    402          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    403          
    404          	(void)sensor;
    405          
    406          	return inv_icm20948_write_reg(&self->icm20948_states, (uint8_t)reg_addr, (uint8_t*)data, size);
   \   00000006   0x9B02             LDR      R3,[SP, #+8]
   \   00000008   0xB2C9             UXTB     R1,R1
   \   0000000A   0x3030             ADDS     R0,R0,#+48
   \   0000000C   0xB002             ADD      SP,SP,#+8
   \   0000000E   0x.... 0x....      B.W      inv_icm20948_write_reg
    407          }
    408          

   \                                 In section .text, align 2, keep-with-next
    409          int inv_device_icm20948_read_mems_register(void * context, int sensor, uint16_t reg_addr,
    410          		void * data, unsigned size)
    411          {
   \                     inv_device_icm20948_read_mems_register: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   \   00000002   0x4611             MOV      R1,R2
   \   00000004   0x461A             MOV      R2,R3
    412          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    413          
    414          	(void)sensor;
    415          
    416          	return inv_icm20948_read_reg(&self->icm20948_states, (uint8_t)reg_addr, (uint8_t*)data, size);
   \   00000006   0x9B02             LDR      R3,[SP, #+8]
   \   00000008   0xB2C9             UXTB     R1,R1
   \   0000000A   0x3030             ADDS     R0,R0,#+48
   \   0000000C   0xB002             ADD      SP,SP,#+8
   \   0000000E   0x.... 0x....      B.W      inv_icm20948_read_reg
    417          }
    418          

   \                                 In section .text, align 2, keep-with-next
    419          void inv_device_icm20948_init_aux_compass(inv_device_icm20948_t * self,
    420          	int aux_compass_id, uint8_t aux_compass_addr)
    421          {
    422          	/* register auxiliary compass (assuming AK09911) */
    423          	inv_icm20948_register_aux_compass(&self->icm20948_states,
    424          			(enum inv_icm20948_compass_id)aux_compass_id, aux_compass_addr);
   \                     inv_device_icm20948_init_aux_compass: (+1)
   \   00000000   0xB249             SXTB     R1,R1
   \   00000002   0x3030             ADDS     R0,R0,#+48
   \   00000004   0x.... 0x....      B.W      inv_icm20948_register_aux_compass
    425          }
    426          

   \                                 In section .text, align 2, keep-with-next
    427          int inv_device_icm20948_set_sensor_config(void * context, int sensor, int setting,
    428          		const void * value, unsigned size)
    429          {
   \                     inv_device_icm20948_set_sensor_config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x461E             MOV      R6,R3
    430          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    431          	int rc = 0;
    432          	(void)size;
    433          	
    434          	switch (setting) {
   \   0000000A   0x2A03             CMP      R2,#+3
   \   0000000C   0xD028             BEQ.N    ??inv_device_icm20948_set_sensor_config_0
   \   0000000E   0x2A05             CMP      R2,#+5
   \   00000010   0xD002             BEQ.N    ??inv_device_icm20948_set_sensor_config_1
   \   00000012   0x2A07             CMP      R2,#+7
   \   00000014   0xD01E             BEQ.N    ??inv_device_icm20948_set_sensor_config_2
   \   00000016   0xE02D             B.N      ??inv_device_icm20948_set_sensor_config_3
    435          		case INV_DEVICE_ICM20948_CONFIG_FSR : {
    436          			int temp_bias[3];
    437          			//In case FSR change, we save and apply new bias
    438          			inv_icm20948_get_bias(&self->icm20948_states, idd_sensortype_2_driver(sensor), temp_bias);
   \                     ??inv_device_icm20948_set_sensor_config_1: (+1)
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       idd_sensortype_2_driver
   \   0000001E   0x466A             MOV      R2,SP
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000026   0x.... 0x....      BL       inv_icm20948_get_bias
    439          			rc = inv_icm20948_set_fsr(&self->icm20948_states, idd_sensortype_2_driver(sensor), value);
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       idd_sensortype_2_driver
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x4632             MOV      R2,R6
   \   00000034   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000038   0x.... 0x....      BL       inv_icm20948_set_fsr
   \   0000003C   0x4606             MOV      R6,R0
    440          			inv_icm20948_set_bias(&self->icm20948_states, idd_sensortype_2_driver(sensor), temp_bias);
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       idd_sensortype_2_driver
   \   00000044   0x466A             MOV      R2,SP
   \   00000046   0x4601             MOV      R1,R0
   \   00000048   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000004C   0x.... 0x....      BL       inv_icm20948_set_bias
    441          			break;
    442          		}
    443          		case INV_DEVICE_ICM20948_CONFIG_POWER_MODE :
    444          			return inv_icm20948_set_lowpower_or_highperformance(&self->icm20948_states, *((uint8_t *)value));
    445          		case INV_DEVICE_ICM20948_CONFIG_OFFSET :
    446          			return inv_icm20948_set_bias(&self->icm20948_states, idd_sensortype_2_driver(sensor), value);
    447          		/*case INV_DEVICE_ICM20948_CONFIG_WOM_THRESHOLD: //AxL
    448          			switch(sensor) {
    449          			case INV_SENSOR_TYPE_WOM:
    450          				return inv_icm20948_set_wom_threshold(&self->icm20948_states, (uint8_t)(*(const inv_device_icm20948_config_wom_threshold_t *)value));
    451          			default:
    452          				return -1;
    453          			}*/
    454          		default :
    455          			return -1;
    456          	}
    457          	return rc;
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0xE011             B.N      ??inv_device_icm20948_set_sensor_config_4
   \                     ??inv_device_icm20948_set_sensor_config_2: (+1)
   \   00000054   0x7831             LDRB     R1,[R6, #+0]
   \   00000056   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000005A   0x.... 0x....      BL       inv_icm20948_set_lowpower_or_highperformance
   \   0000005E   0xE00B             B.N      ??inv_device_icm20948_set_sensor_config_4
   \                     ??inv_device_icm20948_set_sensor_config_0: (+1)
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       idd_sensortype_2_driver
   \   00000066   0x4632             MOV      R2,R6
   \   00000068   0x4601             MOV      R1,R0
   \   0000006A   0xF104 0x0030      ADD      R0,R4,#+48
   \   0000006E   0x.... 0x....      BL       inv_icm20948_set_bias
   \   00000072   0xE001             B.N      ??inv_device_icm20948_set_sensor_config_4
   \                     ??inv_device_icm20948_set_sensor_config_3: (+1)
   \   00000074   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??inv_device_icm20948_set_sensor_config_4: (+1)
   \   00000078   0xB004             ADD      SP,SP,#+16
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    458          }
    459          

   \                                 In section .text, align 2, keep-with-next
    460          int inv_device_icm20948_get_sensor_config(void * context, int sensor, int setting,
    461          		void *value_out, unsigned size)
    462          {
   \                     inv_device_icm20948_get_sensor_config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x461D             MOV      R5,R3
    463          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    464          	(void)size;
    465          	switch (setting) {
   \   00000008   0x2A03             CMP      R2,#+3
   \   0000000A   0xD015             BEQ.N    ??inv_device_icm20948_get_sensor_config_0
   \   0000000C   0x2A05             CMP      R2,#+5
   \   0000000E   0xD002             BEQ.N    ??inv_device_icm20948_get_sensor_config_1
   \   00000010   0x2A07             CMP      R2,#+7
   \   00000012   0xD00A             BEQ.N    ??inv_device_icm20948_get_sensor_config_2
   \   00000014   0xE01A             B.N      ??inv_device_icm20948_get_sensor_config_3
    466          		case INV_DEVICE_ICM20948_CONFIG_FSR :
    467          			return inv_icm20948_get_fsr(&self->icm20948_states, idd_sensortype_2_driver(sensor), value_out);
   \                     ??inv_device_icm20948_get_sensor_config_1: (+1)
   \   00000016   0x.... 0x....      BL       idd_sensortype_2_driver
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x462A             MOV      R2,R5
   \   0000001E   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000022   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000026   0x.... 0x....      B.W      inv_icm20948_get_fsr
    468          		case INV_DEVICE_ICM20948_CONFIG_POWER_MODE :
    469          			return inv_icm20948_get_lowpower_or_highperformance(&self->icm20948_states, value_out);
   \                     ??inv_device_icm20948_get_sensor_config_2: (+1)
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000030   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000034   0x.... 0x....      B.W      inv_icm20948_get_lowpower_or_highperformance
    470          		case INV_DEVICE_ICM20948_CONFIG_OFFSET :
    471          			return inv_icm20948_get_bias(&self->icm20948_states, idd_sensortype_2_driver(sensor), value_out);
   \                     ??inv_device_icm20948_get_sensor_config_0: (+1)
   \   00000038   0x.... 0x....      BL       idd_sensortype_2_driver
   \   0000003C   0x4601             MOV      R1,R0
   \   0000003E   0x462A             MOV      R2,R5
   \   00000040   0xF104 0x0030      ADD      R0,R4,#+48
   \   00000044   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000048   0x.... 0x....      B.W      inv_icm20948_get_bias
    472          		default :
    473          			return -1;
   \                     ??inv_device_icm20948_get_sensor_config_3: (+1)
   \   0000004C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    474          	}
    475          }
    476          /******************************************************************************/
    477          

   \                                 In section .text, align 4, keep-with-next
    478          static void data_handler(void * context, enum inv_icm20948_sensor sensor, uint64_t timestamp,
    479          		const void * data, const void *arg)
    480          {
   \                     data_handler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB098             SUB      SP,SP,#+96
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x461D             MOV      R5,R3
    481          	inv_device_icm20948_t * self = (inv_device_icm20948_t *)context;
    482          	inv_sensor_event_t event;
    483          	const int sensortype = idd_driver_2_sensortype(sensor);
   \   0000000C   0x.... 0x....      BL       idd_driver_2_sensortype
   \   00000010   0x4601             MOV      R1,R0
    484          	
    485          	if(build_sensor_event(self, sensortype, timestamp, data, arg, &event)) {
   \   00000012   0xA804             ADD      R0,SP,#+16
   \   00000014   0x9002             STR      R0,[SP, #+8]
   \   00000016   0x981D             LDR      R0,[SP, #+116]
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x981C             LDR      R0,[SP, #+112]
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   \   0000001E   0x4622             MOV      R2,R4
   \   00000020   0x462B             MOV      R3,R5
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       build_sensor_event
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD003             BEQ.N    ??data_handler_0
    486          		inv_sensor_listener_notify(self->base.listener, &event);
   \   0000002C   0xA904             ADD      R1,SP,#+16
   \   0000002E   0x68B0             LDR      R0,[R6, #+8]
   \   00000030   0x.... 0x....      BL       inv_sensor_listener_notify
    487          	}
    488          }
   \                     ??data_handler_0: (+1)
   \   00000034   0xB018             ADD      SP,SP,#+96
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    489          

   \                                 In section .text, align 4, keep-with-next
    490          static inv_bool_t build_sensor_event_data(inv_device_icm20948_t * self, 
    491          		uint8_t sensortype, const void * data, const void *arg, 
    492          		inv_sensor_event_t * event)
    493          {
   \                     build_sensor_event_data: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x461D             MOV      R5,R3
   \   00000008   0x9E0A             LDR      R6,[SP, #+40]
    494          	float raw_bias_data[6];
    495          	(void)self;
    496          
    497          	switch(sensortype) {
   \   0000000A   0x1E49             SUBS     R1,R1,#+1
   \   0000000C   0x2920             CMP      R1,#+32
   \   0000000E   0xF200 0x809F      BHI.W    ??build_sensor_event_data_1
   \   00000012   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??build_sensor_event_data_0:
   \   00000016   0x50 0x5D          DC8      0x50,0x5D,0x8F,0x43
   \              0x8F 0x43    
   \   0000001A   0x9D 0x9D          DC8      0x9D,0x9D,0x9D,0x9D
   \              0x9D 0x9D    
   \   0000001E   0x50 0x50          DC8      0x50,0x50,0x6A,0x9D
   \              0x6A 0x9D    
   \   00000022   0x9D 0x2B          DC8      0x9D,0x2B,0x77,0x11
   \              0x77 0x11    
   \   00000026   0x85 0x85          DC8      0x85,0x85,0x88,0x6A
   \              0x88 0x6A    
   \   0000002A   0x9D 0x85          DC8      0x9D,0x85,0x9D,0x9D
   \              0x9D 0x9D    
   \   0000002E   0x85 0x7E          DC8      0x85,0x7E,0x9D,0x85
   \              0x9D 0x85    
   \   00000032   0x9D 0x9D          DC8      0x9D,0x9D,0x9D,0x96
   \              0x9D 0x96    
   \   00000036   0x96 0x00          DC8      0x96,0x0
    498          	case INV_SENSOR_TYPE_UNCAL_GYROSCOPE:
    499          		memcpy(raw_bias_data, data, sizeof(raw_bias_data));
   \                     ??build_sensor_event_data_2: (+1)
   \   00000038   0x2218             MOVS     R2,#+24
   \   0000003A   0x4621             MOV      R1,R4
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x.... 0x....      BL       __aeabi_memcpy
    500          		memcpy(event->data.gyr.vect, &raw_bias_data[0], sizeof(event->data.gyr.vect));
   \   00000042   0x220C             MOVS     R2,#+12
   \   00000044   0x4669             MOV      R1,SP
   \   00000046   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000004A   0x.... 0x....      BL       __aeabi_memcpy4
    501          		memcpy(event->data.gyr.bias, &raw_bias_data[3], sizeof(event->data.gyr.bias));
   \   0000004E   0x220C             MOVS     R2,#+12
   \   00000050   0xA903             ADD      R1,SP,#+12
   \   00000052   0xF106 0x001C      ADD      R0,R6,#+28
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy4
    502          		memcpy(&(event->data.gyr.accuracy_flag), arg, sizeof(event->data.gyr.accuracy_flag));
   \   0000005A   0x2201             MOVS     R2,#+1
   \   0000005C   0x4629             MOV      R1,R5
   \   0000005E   0xF106 0x0028      ADD      R0,R6,#+40
   \   00000062   0x.... 0x....      BL       __aeabi_memcpy
    503          		break;
    504          	case INV_SENSOR_TYPE_UNCAL_MAGNETOMETER:
    505          		memcpy(raw_bias_data, data, sizeof(raw_bias_data));
    506          		memcpy(event->data.mag.vect, &raw_bias_data[0], sizeof(event->data.mag.vect));
    507          		memcpy(event->data.mag.bias, &raw_bias_data[3], sizeof(event->data.mag.bias));
    508          		memcpy(&(event->data.gyr.accuracy_flag), arg, sizeof(event->data.gyr.accuracy_flag));
    509          		break;
    510          	case INV_SENSOR_TYPE_GYROSCOPE:
    511          		memcpy(event->data.gyr.vect, data, sizeof(event->data.gyr.vect));
    512          		memcpy(&(event->data.gyr.accuracy_flag), arg, sizeof(event->data.gyr.accuracy_flag));
    513          		break;
    514          	case INV_SENSOR_TYPE_GRAVITY:
    515          	case INV_SENSOR_TYPE_LINEAR_ACCELERATION:
    516          	case INV_SENSOR_TYPE_ACCELEROMETER:
    517          		memcpy(event->data.acc.vect, data, sizeof(event->data.acc.vect));
    518          		memcpy(&(event->data.acc.accuracy_flag), arg, sizeof(event->data.acc.accuracy_flag));
    519          		break;
    520          	case INV_SENSOR_TYPE_MAGNETOMETER:
    521          		memcpy(event->data.mag.vect, data, sizeof(event->data.mag.vect));
    522          		memcpy(&(event->data.mag.accuracy_flag), arg, sizeof(event->data.mag.accuracy_flag));
    523          		break;
    524          	case INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
    525          	case INV_SENSOR_TYPE_ROTATION_VECTOR:
    526          		memcpy(&(event->data.quaternion.accuracy), arg, sizeof(event->data.quaternion.accuracy));
    527          		memcpy(event->data.quaternion.quat, data, sizeof(event->data.quaternion.quat));
    528          		break;
    529          	case INV_SENSOR_TYPE_GAME_ROTATION_VECTOR:
    530          		memcpy(event->data.quaternion.quat, data, sizeof(event->data.quaternion.quat));
    531          		break;
    532          	case INV_SENSOR_TYPE_BAC:
    533          		memcpy(&(event->data.bac.event), data, sizeof(event->data.bac.event));
    534          		break;
    535          	case INV_SENSOR_TYPE_PICK_UP_GESTURE:
    536          	case INV_SENSOR_TYPE_TILT_DETECTOR:
    537          	case INV_SENSOR_TYPE_STEP_DETECTOR:
    538          	case INV_SENSOR_TYPE_SMD:
    539          	case INV_SENSOR_TYPE_B2S:
    540          		event->data.event = true;
    541          		break;
    542          	case INV_SENSOR_TYPE_STEP_COUNTER:
    543          		memcpy(&(event->data.step.count), data, sizeof(event->data.step.count));
    544          		break;
    545          	case INV_SENSOR_TYPE_ORIENTATION:
    546          		//we just want to copy x,y,z from orientation data
    547          		memcpy(&(event->data.orientation), data, 3*sizeof(float));
    548          		break;
    549          	case INV_SENSOR_TYPE_RAW_ACCELEROMETER:
    550          	case INV_SENSOR_TYPE_RAW_GYROSCOPE:
    551          		memcpy(event->data.raw3d.vect, data, sizeof(event->data.raw3d.vect));
    552          		break;
    553          	default:
    554          		return false;
    555          	}
    556          
    557          	return true;
   \                     ??build_sensor_event_data_3: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \                     ??build_sensor_event_data_4: (+1)
   \   00000068   0xB006             ADD      SP,SP,#+24
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??build_sensor_event_data_5: (+1)
   \   0000006C   0x2218             MOVS     R2,#+24
   \   0000006E   0x4621             MOV      R1,R4
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x.... 0x....      BL       __aeabi_memcpy
   \   00000076   0x220C             MOVS     R2,#+12
   \   00000078   0x4669             MOV      R1,SP
   \   0000007A   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000007E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000082   0x220C             MOVS     R2,#+12
   \   00000084   0xA903             ADD      R1,SP,#+12
   \   00000086   0xF106 0x001C      ADD      R0,R6,#+28
   \   0000008A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000008E   0x2201             MOVS     R2,#+1
   \   00000090   0x4629             MOV      R1,R5
   \   00000092   0xF106 0x0028      ADD      R0,R6,#+40
   \   00000096   0x.... 0x....      BL       __aeabi_memcpy
   \   0000009A   0xE7E4             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_6: (+1)
   \   0000009C   0x220C             MOVS     R2,#+12
   \   0000009E   0x4621             MOV      R1,R4
   \   000000A0   0xF106 0x0010      ADD      R0,R6,#+16
   \   000000A4   0x.... 0x....      BL       __aeabi_memcpy
   \   000000A8   0x2201             MOVS     R2,#+1
   \   000000AA   0x4629             MOV      R1,R5
   \   000000AC   0xF106 0x0028      ADD      R0,R6,#+40
   \   000000B0   0x.... 0x....      BL       __aeabi_memcpy
   \   000000B4   0xE7D7             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_7: (+1)
   \   000000B6   0x220C             MOVS     R2,#+12
   \   000000B8   0x4621             MOV      R1,R4
   \   000000BA   0xF106 0x0010      ADD      R0,R6,#+16
   \   000000BE   0x.... 0x....      BL       __aeabi_memcpy
   \   000000C2   0x2201             MOVS     R2,#+1
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0xF106 0x0028      ADD      R0,R6,#+40
   \   000000CA   0x.... 0x....      BL       __aeabi_memcpy
   \   000000CE   0xE7CA             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_8: (+1)
   \   000000D0   0x220C             MOVS     R2,#+12
   \   000000D2   0x4621             MOV      R1,R4
   \   000000D4   0xF106 0x0010      ADD      R0,R6,#+16
   \   000000D8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000DC   0x2201             MOVS     R2,#+1
   \   000000DE   0x4629             MOV      R1,R5
   \   000000E0   0xF106 0x0028      ADD      R0,R6,#+40
   \   000000E4   0x.... 0x....      BL       __aeabi_memcpy
   \   000000E8   0xE7BD             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_9: (+1)
   \   000000EA   0x2204             MOVS     R2,#+4
   \   000000EC   0x4629             MOV      R1,R5
   \   000000EE   0xF106 0x0020      ADD      R0,R6,#+32
   \   000000F2   0x.... 0x....      BL       __aeabi_memcpy
   \   000000F6   0x2210             MOVS     R2,#+16
   \   000000F8   0x4621             MOV      R1,R4
   \   000000FA   0xF106 0x0010      ADD      R0,R6,#+16
   \   000000FE   0x.... 0x....      BL       __aeabi_memcpy
   \   00000102   0xE7B0             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_10: (+1)
   \   00000104   0x2210             MOVS     R2,#+16
   \   00000106   0x4621             MOV      R1,R4
   \   00000108   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000010C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000110   0xE7A9             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_11: (+1)
   \   00000112   0x2204             MOVS     R2,#+4
   \   00000114   0x4621             MOV      R1,R4
   \   00000116   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000011A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000011E   0xE7A2             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_12: (+1)
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x6130             STR      R0,[R6, #+16]
   \   00000124   0xE79F             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_13: (+1)
   \   00000126   0x2208             MOVS     R2,#+8
   \   00000128   0x4621             MOV      R1,R4
   \   0000012A   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000012E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000132   0xE798             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_14: (+1)
   \   00000134   0x220C             MOVS     R2,#+12
   \   00000136   0x4621             MOV      R1,R4
   \   00000138   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000013C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000140   0xE791             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_15: (+1)
   \   00000142   0x220C             MOVS     R2,#+12
   \   00000144   0x4621             MOV      R1,R4
   \   00000146   0xF106 0x0010      ADD      R0,R6,#+16
   \   0000014A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000014E   0xE78A             B.N      ??build_sensor_event_data_3
   \                     ??build_sensor_event_data_1: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xE789             B.N      ??build_sensor_event_data_4
    558          }
    559          

   \                                 In section .text, align 2, keep-with-next
    560          static inv_bool_t build_sensor_event(inv_device_icm20948_t * self,
    561          		int sensorid, uint64_t timestamp, const void * data, const void *arg,
    562          		inv_sensor_event_t * event)
    563          {
   \                     build_sensor_event: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x461D             MOV      R5,R3
   \   0000000E   0xF8DD 0x8028      LDR      R8,[SP, #+40]
    564          	assert(event);
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xD109             BNE.N    ??build_sensor_event_0
   \   00000018   0xF44F 0x720D      MOV      R2,#+564
   \   0000001C   0x.... 0x....      ADR.W    R1,?_3
   \   00000020   0x.... 0x....      ADR.W    R0,?_16
   \   00000024   0x.... 0x....      BL       __aeabi_assert
   \   00000028   0x.... 0x....      BL       __iar_EmptyStepPoint
    565          
    566          	memset(event, 0, sizeof(*event));
   \                     ??build_sensor_event_0: (+1)
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2150             MOVS     R1,#+80
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0x.... 0x....      BL       __aeabi_memset4
    567          
    568          	(void)self;
    569          
    570          	if(!build_sensor_event_data(self, sensorid, data, arg, event)) {
   \   00000036   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000003A   0x9B09             LDR      R3,[SP, #+36]
   \   0000003C   0x9A08             LDR      R2,[SP, #+32]
   \   0000003E   0x4638             MOV      R0,R7
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0xB2C9             UXTB     R1,R1
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       build_sensor_event_data
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD107             BNE.N    ??build_sensor_event_1
    571          		INV_MSG(INV_MSG_LEVEL_WARNING, "Unexpected sensor id %d. Data Ignored.", sensorid);
   \   0000004E   0x463A             MOV      R2,R7
   \   00000050   0x.... 0x....      ADR.W    R1,?_17
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x.... 0x....      BL       inv_msg
    572          		return false;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE007             B.N      ??build_sensor_event_2
    573          	}
    574          
    575          	/* finish up building event */
    576          	event->sensor	= sensorid;
   \                     ??build_sensor_event_1: (+1)
   \   0000005E   0xF8C8 0x7000      STR      R7,[R8, #+0]
    577          	event->timestamp = timestamp;
   \   00000062   0xE9C8 0x4502      STRD     R4,R5,[R8, #+8]
    578          	event->status	= INV_SENSOR_STATUS_DATA_UPDATED;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF8C8 0x0004      STR      R0,[R8, #+4]
    579          
    580          	return true;
   \   0000006C   0x2001             MOVS     R0,#+1
   \                     ??build_sensor_event_2: (+1)
   \   0000006E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    581          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     icm20948_instance

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x69 0x63          DC8 "icm20948_instance == 0"
   \              0x6D 0x32    
   \              0x30 0x39    
   \              0x34 0x38    
   \              0x5F 0x69    
   \              0x6E 0x73    
   \              0x74 0x61    
   \              0x6E 0x63    
   \              0x65 0x20    
   \              0x3D 0x3D    
   \              0x20 0x30    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x70          DC8 5CH, 70H, 72H, 61H, 73H, 61H, 5CH, 44H
   \              0x72 0x61    
   \              0x73 0x61    
   \              0x5C 0x44    
   \   00000010   0x6F 0x63          DC8 6FH, 63H, 75H, 6DH, 65H, 6EH, 74H, 73H
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x73    
   \   00000018   0x5C 0x31          DC8 5CH, 31H, 2EH, 30H, 2EH, 30H, 5CH, 73H
   \              0x2E 0x30    
   \              0x2E 0x30    
   \              0x5C 0x73    
   \   00000020   0x6F 0x75          DC8 6FH, 75H, 72H, 63H, 65H, 73H, 5CH, 65H
   \              0x72 0x63    
   \              0x65 0x73    
   \              0x5C 0x65    
   \   00000028   0x78 0x61          DC8 78H, 61H, 6DH, 70H, 6CH, 65H, 73H, 5CH
   \              0x6D 0x70    
   \              0x6C 0x65    
   \              0x73 0x5C    
   \   00000030   0x65 0x78          DC8 65H, 78H, 61H, 6DH, 70H, 6CH, 65H, 2DH
   \              0x61 0x6D    
   \              0x70 0x6C    
   \              0x65 0x2D    
   \   00000038   0x69 0x63          DC8 69H, 63H, 6DH, 32H, 30H, 39H, 34H, 38H
   \              0x6D 0x32    
   \              0x30 0x39    
   \              0x34 0x38    
   \   00000040   0x2F 0x2E          DC8 2FH, 2EH, 2EH, 2FH, 2EH, 2EH, 5CH, 49H
   \              0x2E 0x2F    
   \              0x2E 0x2E    
   \              0x5C 0x49    
   \   00000048   0x6E 0x76          DC8 6EH, 76H, 6EH, 2FH, 44H, 65H, 76H, 69H
   \              0x6E 0x2F    
   \              0x44 0x65    
   \              0x76 0x69    
   \   00000050   0x63 0x65          DC8 63H, 65H, 73H, 2FH, 44H, 72H, 69H, 76H
   \              0x73 0x2F    
   \              0x44 0x72    
   \              0x69 0x76    
   \   00000058   0x65 0x72          DC8 65H, 72H, 73H, 2FH, 49H, 63H, 6DH, 32H
   \              0x73 0x2F    
   \              0x49 0x63    
   \              0x6D 0x32    
   \   00000060   0x30 0x39          DC8 30H, 39H, 34H, 38H, 2FH, 49H, 63H, 6DH
   \              0x34 0x38    
   \              0x2F 0x49    
   \              0x63 0x6D    
   \   00000068   0x32 0x30          DC8 32H, 30H, 39H, 34H, 38H, 2EH, 68H, 0
   \              0x39 0x34    
   \              0x38 0x2E    
   \              0x68 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x73 0x65          DC8 "self"
   \              0x6C 0x66    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x70          DC8 5CH, 70H, 72H, 61H, 73H, 61H, 5CH, 44H
   \              0x72 0x61    
   \              0x73 0x61    
   \              0x5C 0x44    
   \   00000010   0x6F 0x63          DC8 6FH, 63H, 75H, 6DH, 65H, 6EH, 74H, 73H
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x73    
   \   00000018   0x5C 0x31          DC8 5CH, 31H, 2EH, 30H, 2EH, 30H, 5CH, 73H
   \              0x2E 0x30    
   \              0x2E 0x30    
   \              0x5C 0x73    
   \   00000020   0x6F 0x75          DC8 6FH, 75H, 72H, 63H, 65H, 73H, 5CH, 49H
   \              0x72 0x63    
   \              0x65 0x73    
   \              0x5C 0x49    
   \   00000028   0x6E 0x76          DC8 6EH, 76H, 6EH, 5CH, 44H, 65H, 76H, 69H
   \              0x6E 0x5C    
   \              0x44 0x65    
   \              0x76 0x69    
   \   00000030   0x63 0x65          DC8 63H, 65H, 73H, 5CH, 44H, 65H, 76H, 69H
   \              0x73 0x5C    
   \              0x44 0x65    
   \              0x76 0x69    
   \   00000038   0x63 0x65          DC8 63H, 65H, 49H, 63H, 6DH, 32H, 30H, 39H
   \              0x49 0x63    
   \              0x6D 0x32    
   \              0x30 0x39    
   \   00000040   0x34 0x38          DC8 34H, 38H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x77 0x68          DC8 "whoami"
   \              0x6F 0x61    
   \              0x6D 0x69    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x52 0x65          DC8 "Reseting device..."
   \              0x73 0x65    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x2E    
   \              0x2E 0x2E    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x49 0x63          DC8 "Icm20648 reset returned %d"
   \              0x6D 0x32    
   \              0x30 0x36    
   \              0x34 0x38    
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x65 0x74    
   \              0x20 0x72    
   \              0x65 0x74    
   \              0x75 0x72    
   \              0x6E 0x65    
   \              0x64 0x20    
   \              0x25 0x64    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x42 0x6F          DC8 "Booting up Icm20948..."
   \              0x6F 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x75 0x70    
   \              0x20 0x49    
   \              0x63 0x6D    
   \              0x32 0x30    
   \              0x39 0x34    
   \              0x38 0x2E    
   \              0x2E 0x2E    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x52 0x65          DC8 "Reading WHOAMI..."
   \              0x61 0x64    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x57 0x48    
   \              0x4F 0x41    
   \              0x4D 0x49    
   \              0x2E 0x2E    
   \              0x2E 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x45 0x72          DC8 "Error %d when reading WHOAMI value"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x25 0x64    
   \              0x20 0x77    
   \              0x68 0x65    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x57 0x48    
   \              0x4F 0x41    
   \              0x4D 0x49    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x55 0x6E          DC8 "Unexpected WHOAMI value 0x%x. Aborting setup."
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x57    
   \              0x48 0x4F    
   \              0x41 0x4D    
   \              0x49 0x20    
   \              0x76 0x61    
   \              0x6C 0x75    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x2E 0x20    
   \              0x41 0x62    
   \              0x6F 0x72    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x75 0x70    
   \              0x2E 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x57 0x48          DC8 "WHOAMI value: 0x%x"
   \              0x4F 0x41    
   \              0x4D 0x49    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x50 0x75          DC8 "Putting Icm20948 in sleep mode..."
   \              0x74 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x49 0x63    
   \              0x6D 0x32    
   \              0x30 0x39    
   \              0x34 0x38    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x73 0x6C    
   \              0x65 0x65    
   \              0x70 0x20    
   \              0x6D 0x6F    
   \              0x64 0x65    
   \              0x2E 0x2E    
   \              0x2E 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x57 0x65          DC8 "We're good to go !"
   \              0x27 0x72    
   \              0x65 0x20    
   \              0x67 0x6F    
   \              0x6F 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x67 0x6F    
   \              0x20 0x21    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0x45 0x72          DC8 "Error %d while setting-up device."
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x25 0x64    
   \              0x20 0x77    
   \              0x68 0x69    
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x2D 0x75    
   \              0x70 0x20    
   \              0x64 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x2E 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x53 0x65          DC8 "Self-test already ran once!"
   \              0x6C 0x66    
   \              0x2D 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x61 0x6C    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x20    
   \              0x72 0x61    
   \              0x6E 0x20    
   \              0x6F 0x6E    
   \              0x63 0x65    
   \              0x21 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \   00000000   0x65 0x76          DC8 "event"
   \              0x65 0x6E    
   \              0x74 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \   00000000   0x55 0x6E          DC8 "Unexpected sensor id %d. Data Ignored."
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x73    
   \              0x65 0x6E    
   \              0x73 0x6F    
   \              0x72 0x20    
   \              0x69 0x64    
   \              0x20 0x25    
   \              0x64 0x2E    
   \              0x20 0x44    
   \              0x61 0x74    
   \              0x61 0x20    
   \              0x49 0x67    
   \              0x6E 0x6F    
   \              0x72 0x65    
   \              0x64 0x2E    
   \              0x00         
   \   00000027   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   build_sensor_event
        32   -> __aeabi_assert
        32   -> __aeabi_memset4
        32   -> __iar_EmptyStepPoint
        32   -> build_sensor_event_data
        32   -> inv_msg
      40   build_sensor_event_data
        40   -> __aeabi_memcpy
        40   -> __aeabi_memcpy4
     112   data_handler
       112   -> build_sensor_event
       112   -> idd_driver_2_sensortype
       112   -> inv_sensor_listener_notify
       8   host_serif_read_reg_legacy
         0   -- Indirect call
       8   host_serif_write_reg_legacy
         0   -- Indirect call
       0   idd_driver_2_sensortype
       0   idd_sensortype_2_driver
      16   inv_device_icm20948_cleanup
        16   -> inv_device_icm20948_enable_sensor
        16   -> inv_device_icm20948_ping_sensor
         0   -> inv_icm20948_soft_reset
      16   inv_device_icm20948_enable_sensor
        16   -> idd_sensortype_2_driver
         0   -> inv_icm20948_enable_sensor
      16   inv_device_icm20948_get_sensor_config
        16   -> idd_sensortype_2_driver
         0   -> inv_icm20948_get_bias
         0   -> inv_icm20948_get_fsr
         0   -> inv_icm20948_get_lowpower_or_highperformance
      40   inv_device_icm20948_init
        40   -> inv_device_icm20948_init2
      48   inv_device_icm20948_init2
        48   -> __aeabi_assert
        48   -> __aeabi_memset4
        48   -> __iar_EmptyStepPoint
        48   -> inv_device_icm20948_init_aux_compass
        48   -> inv_icm20948_init_structure
        48   -> inv_icm20948_reset_states
       0   inv_device_icm20948_init_aux_compass
         0   -> inv_icm20948_register_aux_compass
       0   inv_device_icm20948_load
         0   -> inv_icm20948_load
       8   inv_device_icm20948_ping_sensor
         8   -> inv_icm20948_compass_isconnected
       0   inv_device_icm20948_poll
         0   -> inv_icm20948_poll_sensor
       8   inv_device_icm20948_read_mems_register
         0   -> inv_icm20948_read_reg
      16   inv_device_icm20948_reset
        16   -> inv_device_icm20948_cleanup
        16   -> inv_device_icm20948_setup
        16   -> inv_msg
      16   inv_device_icm20948_self_test
        16   -> inv_device_icm20948_cleanup
        16   -> inv_device_icm20948_ping_sensor
        16   -> inv_device_icm20948_reset
        16   -> inv_icm20948_run_selftest
        16   -> inv_msg
      32   inv_device_icm20948_set_sensor_config
        32   -> idd_sensortype_2_driver
        32   -> inv_icm20948_get_bias
        32   -> inv_icm20948_set_bias
        32   -> inv_icm20948_set_fsr
        32   -> inv_icm20948_set_lowpower_or_highperformance
      16   inv_device_icm20948_set_sensor_mounting_matrix
        16   -> idd_sensortype_2_driver
         0   -> inv_icm20948_set_matrix
      16   inv_device_icm20948_set_sensor_period_us
        16   -> idd_sensortype_2_driver
         0   -> inv_icm20948_set_sensor_period
       0   inv_device_icm20948_set_sensor_timeout
         0   -> inv_icm20948_enable_batch_timeout
      16   inv_device_icm20948_setup
        16   -> inv_device_icm20948_whoami
        16   -> inv_icm20948_init_matrix
        16   -> inv_icm20948_init_scale
        16   -> inv_icm20948_init_structure
        16   -> inv_icm20948_initialize
        16   -> inv_icm20948_initialize_auxiliary
        16   -> inv_msg
      16   inv_device_icm20948_whoami
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
         0   -> inv_icm20948_get_whoami
       8   inv_device_icm20948_write_mems_register
         0   -> inv_icm20948_write_reg
      16   inv_icm20948_reset_states
        16   -> __aeabi_assert
        16   -> __aeabi_memset4
        16   -> __iar_EmptyStepPoint
       0   inv_sensor_listener_notify
         0   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
      24  ?_0
     112  ?_1
      48  ?_10
      20  ?_11
      36  ?_12
      20  ?_13
      36  ?_14
      28  ?_15
       8  ?_16
      40  ?_17
      24  ?_18
       8  ?_2
      72  ?_3
       8  ?_4
      20  ?_5
      28  ?_6
      24  ?_7
      20  ?_8
      36  ?_9
     114  build_sensor_event
     340  build_sensor_event_data
      56  data_handler
      88  device_icm20948_vt
      18  host_serif_read_reg_legacy
      18  host_serif_write_reg_legacy
     112  idd_driver_2_sensortype
     128  idd_sensortype_2_driver
      48  inv_device_icm20948_cleanup
      28  inv_device_icm20948_enable_sensor
      82  inv_device_icm20948_get_sensor_config
      68  inv_device_icm20948_init
     148  inv_device_icm20948_init2
       8  inv_device_icm20948_init_aux_compass
      12  inv_device_icm20948_load
     102  inv_device_icm20948_ping_sensor
      12  inv_device_icm20948_poll
      18  inv_device_icm20948_read_mems_register
      54  inv_device_icm20948_reset
     108  inv_device_icm20948_self_test
     124  inv_device_icm20948_set_sensor_config
      28  inv_device_icm20948_set_sensor_mounting_matrix
      34  inv_device_icm20948_set_sensor_period_us
      10  inv_device_icm20948_set_sensor_timeout
     186  inv_device_icm20948_setup
      40  inv_device_icm20948_whoami
      18  inv_device_icm20948_write_mems_register
      56  inv_icm20948_reset_states
      16  inv_sensor_listener_notify

 
 2 690 bytes in section .text
 
 2 690 bytes of CODE memory

Errors: none
Warnings: none
