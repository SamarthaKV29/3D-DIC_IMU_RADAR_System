###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948AuxCompassAkm.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948AuxCompassAkm.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\Icm20948AuxCompassAkm.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\Icm20948AuxCompassAkm.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948AuxCompassAkm.c
      1          /*
      2          * ________________________________________________________________________________________________________
      3          * Copyright © 2014-2015 InvenSense Inc. Portions Copyright © 2014-2015 Movea. All rights reserved.
      4          * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      5          * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright and
      6          * other intellectual property rights laws.
      7          * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
      8          * and any use, reproduction, disclosure or distribution of the Software without an express license
      9          * agreement from InvenSense is strictly prohibited.
     10          * ________________________________________________________________________________________________________
     11          */
     12          
     13          #include "Icm20948.h"
     14          
     15          #include "Icm20948AuxCompassAkm.h"
     16          
     17          #include "Icm20948Defs.h"              
     18          #include "Icm20948DataConverter.h"               
     19          #include "Icm20948AuxTransport.h"
     20          #include "Icm20948Dmp3Driver.h"
     21          
     22          /* AKM definitions */
     23          #define REG_AKM_ID               0x00
     24          #define REG_AKM_INFO             0x01
     25          #define REG_AKM_STATUS           0x02
     26          #define REG_AKM_MEASURE_DATA     0x03
     27          #define REG_AKM_MODE             0x0A
     28          #define REG_AKM_ST_CTRL          0x0C
     29          #define REG_AKM_SENSITIVITY      0x10
     30          #define REG_AKM8963_CNTL1        0x0A
     31          
     32          #if (MEMS_CHIP == HW_ICM20648)
     33          /* AK09911 register definition */
     34          #define REG_AK09911_DMP_READ    0x3
     35          #define REG_AK09911_STATUS1     0x10
     36          #define REG_AK09911_CNTL2       0x31
     37          #define REG_AK09911_SENSITIVITY 0x60
     38          #define REG_AK09911_MEASURE_DATA     0x11
     39          
     40          /* AK09912 register definition */
     41          #define REG_AK09912_DMP_READ    0x3
     42          #define REG_AK09912_STATUS1     0x10
     43          #define REG_AK09912_CNTL1       0x30
     44          #define REG_AK09912_CNTL2       0x31
     45          #define REG_AK09912_SENSITIVITY 0x60
     46          #define REG_AK09912_MEASURE_DATA     0x11
     47          #endif
     48          
     49          /* AK09916 register definition */
     50          #define REG_AK09916_DMP_READ    0x3
     51          #define REG_AK09916_STATUS1     0x10
     52          #define REG_AK09916_STATUS2     0x18
     53          #define REG_AK09916_CNTL2       0x31
     54          #define REG_AK09916_CNTL3       0x32
     55          #define REG_AK09916_MEASURE_DATA     0x11
     56          #define REG_AK09916_TEST        0x33
     57          
     58          //-- REG WIA
     59          #define DATA_AKM_ID              0x48
     60          //-- REG CNTL2
     61          #define DATA_AKM_MODE_PD	 0x00
     62          #define DATA_AKM_MODE_SM	 0x01
     63          #define DATA_AKM_MODE_ST	 0x08
     64          #define DATA_AK09911_MODE_ST	 0x10
     65          #define DATA_AK09912_MODE_ST	 0x10
     66          #define DATA_AK09916_MODE_ST	 0x10
     67          #define DATA_AKM_MODE_FR	 0x0F
     68          #define DATA_AK09911_MODE_FR     0x1F
     69          #define DATA_AK09912_MODE_FR     0x1F
     70          // AK09916 doesn't support Fuse ROM access
     71          #define DATA_AKM_SELF_TEST       0x40
     72          //-- REG Status 1
     73          #define DATA_AKM_DRDY            0x01
     74          #define DATA_AKM9916_DOR         0x01
     75          #define DATA_AKM8963_BIT         0x10
     76          
     77          #if (MEMS_CHIP == HW_ICM20648)
     78          /* 0.3 uT * (1 << 30) */
     79          #define DATA_AKM8975_SCALE       322122547
     80          /* 0.6 uT * (1 << 30) */
     81          #define DATA_AKM8972_SCALE       644245094
     82          /* 0.6 uT * (1 << 30) */
     83          #define DATA_AKM8963_SCALE0      644245094
     84          /* 0.6 uT * (1 << 30) */
     85          #define DATA_AK09911_SCALE       644245094
     86          /* 0.15 uT * (1 << 30) */
     87          #define DATA_AK09912_SCALE       161061273
     88          #endif
     89          /* 0.15 uT * (1 << 30) */
     90          #define DATA_AKM8963_SCALE1      161061273
     91          /* 0.15 uT * (1 << 30) */
     92          #define DATA_AK09916_SCALE       161061273
     93          
     94          #define DATA_AKM8963_SCALE_SHIFT      4
     95          #define DATA_AKM_MIN_READ_TIME            (9 * NSEC_PER_MSEC)
     96          
     97          /* AK09912C NSF */
     98          /* 0:disable, 1:Low, 2:Middle, 3:High */
     99          #define DATA_AK9912_NSF  1
    100          #define DATA_AK9912_NSF_SHIFT 5
    101          
    102          #define DEF_ST_COMPASS_WAIT_MIN     (10 * 1000)
    103          #define DEF_ST_COMPASS_WAIT_MAX     (15 * 1000)
    104          #define DEF_ST_COMPASS_TRY_TIMES    10
    105          #define DEF_ST_COMPASS_8963_SHIFT   2
    106          #define DEF_ST_COMPASS_9916_SHIFT   2
    107          #define X                           0
    108          #define Y                           1
    109          #define Z                           2
    110          
    111          /* milliseconds between each access */
    112          #define AKM_RATE_SCALE       10
    113          
    114          #define DATA_AKM_99_BYTES_DMP   10
    115          #define DATA_AKM_89_BYTES_DMP   9
    116          
    117          #if (MEMS_CHIP == HW_ICM20648)
    118          static const short AKM8975_ST_Lower[3] = {-100, -100, -1000};
    119          static const short AKM8975_ST_Upper[3] = {100, 100, -300};
    120          
    121          static const short AKM8972_ST_Lower[3] = {-50, -50, -500};
    122          static const short AKM8972_ST_Upper[3] = {50, 50, -100};
    123          
    124          static const short AKM8963_ST_Lower[3] = {-200, -200, -3200};
    125          static const short AKM8963_ST_Upper[3] = {200, 200, -800};
    126          
    127          static const short AK09911_ST_Lower[3] = {-30, -30, -400};
    128          static const short AK09911_ST_Upper[3] = {30, 30, -50};
    129          
    130          static const short AK09912_ST_Lower[3] = {-200, -200, -1600};
    131          static const short AK09912_ST_Upper[3] = {200, 200, -400};
    132          #endif
    133          

   \                                 In section .text, align 4, keep-with-next
    134          static const short AK09916_ST_Lower[3] = {-200, -200, -1000};
   \                     AK09916_ST_Lower:
   \   00000000   0xFF38 0xFF38      DC16 -200, -200, -1000
   \              0xFC18       
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
    135          static const short AK09916_ST_Upper[3] = {200, 200, -200};
   \                     AK09916_ST_Upper:
   \   00000000   0x00C8 0x00C8      DC16 200, 200, -200
   \              0xFF38       
   \   00000006   0x00 0x00          DC8 0, 0
    136          

   \                                 In section .text, align 2, keep-with-next
    137          void inv_icm20948_register_aux_compass(struct inv_icm20948 * s,
    138          		enum inv_icm20948_compass_id compass_id, uint8_t compass_i2c_addr)
    139          {
    140          	switch(compass_id) {
   \                     inv_icm20948_register_aux_compass: (+1)
   \   00000000   0xF100 0x0384      ADD      R3,R0,#+132
   \   00000004   0x2903             CMP      R1,#+3
   \   00000006   0xD10C             BNE.N    ??inv_icm20948_register_aux_compass_0
    141          #if (MEMS_CHIP == HW_ICM20648)
    142          	case INV_ICM20948_COMPASS_ID_AK09911:
    143          		s->secondary_state.compass_slave_id = HW_AK09911;
    144          		s->secondary_state.compass_chip_addr = compass_i2c_addr;
    145          		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
    146          		/* initialise mounting matrix of compass to identity akm9911 */
    147          		s->mounting_matrix_secondary_compass[0] = -1 ;
    148          		s->mounting_matrix_secondary_compass[4] = -1;
    149          		s->mounting_matrix_secondary_compass[8] = 1;
    150          		break;
    151          	case INV_ICM20948_COMPASS_ID_AK09912:
    152          		s->secondary_state.compass_slave_id = HW_AK09912;
    153          		s->secondary_state.compass_chip_addr = compass_i2c_addr;
    154          		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
    155          		/* initialise mounting matrix of compass to identity akm9912 */
    156          		s->mounting_matrix_secondary_compass[0] = 1 ;
    157          		s->mounting_matrix_secondary_compass[4] = 1;
    158          		s->mounting_matrix_secondary_compass[8] = 1;
    159          		break;
    160          	case INV_ICM20948_COMPASS_ID_AK08963:
    161          		s->secondary_state.compass_slave_id = HW_AK8963;
    162          		s->secondary_state.compass_chip_addr = compass_i2c_addr;
    163          		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
    164          		/* initialise mounting matrix of compass to identity akm8963 */
    165          		s->mounting_matrix_secondary_compass[0] = 1;
    166          		s->mounting_matrix_secondary_compass[4] = 1;
    167          		s->mounting_matrix_secondary_compass[8] = 1;
    168          		break;
    169          #endif
    170          	case INV_ICM20948_COMPASS_ID_AK09916:
    171          		s->secondary_state.compass_slave_id = HW_AK09916;
   \   00000008   0x2125             MOVS     R1,#+37
   \   0000000A   0x6059             STR      R1,[R3, #+4]
    172          		s->secondary_state.compass_chip_addr = compass_i2c_addr;
   \   0000000C   0x601A             STR      R2,[R3, #+0]
    173          		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x7219             STRB     R1,[R3, #+8]
    174          		/* initialise mounting matrix of compass to identity akm9916 */
    175          		s->mounting_matrix_secondary_compass[0] = 1 ;
   \   00000012   0xF200 0x207D      ADDW     R0,R0,#+637
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    176          		s->mounting_matrix_secondary_compass[4] = -1;
   \   00000018   0xF04F 0x31FF      MOV      R1,#-1
   \   0000001C   0x7101             STRB     R1,[R0, #+4]
    177          		s->mounting_matrix_secondary_compass[8] = -1;
   \   0000001E   0x7201             STRB     R1,[R0, #+8]
    178          		break;
   \   00000020   0x4770             BX       LR
    179          	default:
    180          		s->secondary_state.compass_slave_id  = 0;
   \                     ??inv_icm20948_register_aux_compass_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6058             STR      R0,[R3, #+4]
    181          		s->secondary_state.compass_chip_addr = 0;
   \   00000026   0x6018             STR      R0,[R3, #+0]
    182          		s->secondary_state.compass_state = INV_ICM20948_COMPASS_RESET;
   \   00000028   0x7218             STRB     R0,[R3, #+8]
    183          	}
    184          }
   \   0000002A   0x4770             BX       LR               ;; return
    185          
    186          /*
    187           *  inv_icm20948_setup_compass_akm() - Configure akm series compass.
    188           */

   \                                 In section .text, align 2, keep-with-next
    189          int inv_icm20948_setup_compass_akm(struct inv_icm20948 * s)
    190          {
   \                     inv_icm20948_setup_compass_akm: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
    191          	int result;
    192          	unsigned char data[4];
    193          #if (MEMS_CHIP != HW_ICM20948)
    194          	uint8_t sens, cmd;
    195          #endif
    196          	//reset variable to initial values
    197          	memset(s->secondary_state.final_matrix, 0, sizeof(s->secondary_state.final_matrix));
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2124             MOVS     R1,#+36
   \   0000000A   0xF104 0x0050      ADD      R0,R4,#+80
   \   0000000E   0x.... 0x....      BL       __aeabi_memset4
    198          	memset(s->secondary_state.compass_sens, 0, sizeof(s->secondary_state.compass_sens));
   \   00000012   0xF104 0x054D      ADD      R5,R4,#+77
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2103             MOVS     R1,#+3
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       __aeabi_memset
    199          	s->secondary_state.scale = 0;
   \   00000020   0xF104 0x0674      ADD      R6,R4,#+116
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x60B0             STR      R0,[R6, #+8]
    200          	s->secondary_state.dmp_on = 1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x7330             STRB     R0,[R6, #+12]
    201          	s->secondary_state.secondary_resume_compass_state = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7370             STRB     R0,[R6, #+13]
    202          	
    203          	/* Read WHOAMI through I2C SLV for compass */
    204          	result = inv_icm20948_execute_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, REG_AKM_ID, 1, data);
   \   00000030   0xA802             ADD      R0,SP,#+8
   \   00000032   0x9001             STR      R0,[SP, #+4]
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x6930             LDR      R0,[R6, #+16]
   \   0000003C   0x4602             MOV      R2,R0
   \   0000003E   0xB2D2             UXTB     R2,R2
   \   00000040   0x4619             MOV      R1,R3
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       inv_icm20948_execute_read_secondary
    205          	if (result) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD125             BNE.N    ??inv_icm20948_setup_compass_akm_0
    206                  // inv_log("Read secondary error: Compass.\r\n");
    207          		return result;
    208              }
    209          	if (data[0] != DATA_AKM_ID) {
   \   0000004C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000050   0x2848             CMP      R0,#+72
   \   00000052   0xD002             BEQ.N    ??inv_icm20948_setup_compass_akm_1
    210                  // inv_log("Compass not found!!\r\n");
    211          		return -1;
   \   00000054   0xF04F 0x30FF      MOV      R0,#-1
   \   00000058   0xE01E             B.N      ??inv_icm20948_setup_compass_akm_0
    212              }
    213              // inv_log("Compass found.\r\n");
    214          
    215          	/* setup upper and lower limit of self-test */
    216          #if (MEMS_CHIP == HW_ICM20948)
    217          	s->secondary_state.st_upper = AK09916_ST_Upper;
   \                     ??inv_icm20948_setup_compass_akm_1: (+1)
   \   0000005A   0x.... 0x....      ADR.W    R0,AK09916_ST_Upper
   \   0000005E   0x6030             STR      R0,[R6, #+0]
    218          	s->secondary_state.st_lower = AK09916_ST_Lower;
   \   00000060   0x.... 0x....      ADR.W    R0,AK09916_ST_Lower
   \   00000064   0x6070             STR      R0,[R6, #+4]
    219          #else
    220          	if (HW_AK8975 == s->secondary_state.compass_slave_id) {
    221          		s->secondary_state.st_upper = AKM8975_ST_Upper;
    222          		s->secondary_state.st_lower = AKM8975_ST_Lower;
    223          	} else if (HW_AK8972 == s->secondary_state.compass_slave_id) {
    224          		s->secondary_state.st_upper = AKM8972_ST_Upper;
    225          		s->secondary_state.st_lower = AKM8972_ST_Lower;
    226          	} else if (HW_AK8963 == s->secondary_state.compass_slave_id) {
    227          		s->secondary_state.st_upper = AKM8963_ST_Upper;
    228          		s->secondary_state.st_lower = AKM8963_ST_Lower;
    229          	} else if (HW_AK09911 == s->secondary_state.compass_slave_id) {
    230          		s->secondary_state.st_upper = AK09911_ST_Upper;
    231          		s->secondary_state.st_lower = AK09911_ST_Lower;
    232          	} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
    233          		s->secondary_state.st_upper = AK09912_ST_Upper;
    234          		s->secondary_state.st_lower = AK09912_ST_Lower;
    235          	} else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
    236          		s->secondary_state.st_upper = AK09916_ST_Upper;
    237          		s->secondary_state.st_lower = AK09916_ST_Lower;
    238          	} else {
    239          		return -1;
    240          	}
    241          #endif
    242          	
    243          
    244          #if (MEMS_CHIP == HW_ICM20948)
    245          	/* Read conf and configure compass through I2C SLV for compass and subsequent channel */
    246          	s->secondary_state.mode_reg_addr = REG_AK09916_CNTL2;
   \   00000066   0x2031             MOVS     R0,#+49
   \   00000068   0x73B0             STRB     R0,[R6, #+14]
    247          	// no sensitivity adjustment value
    248          	s->secondary_state.compass_sens[0] = 128;
   \   0000006A   0x2080             MOVS     R0,#+128
   \   0000006C   0x7028             STRB     R0,[R5, #+0]
    249          	s->secondary_state.compass_sens[1] = 128;
   \   0000006E   0x7068             STRB     R0,[R5, #+1]
    250          	s->secondary_state.compass_sens[2] = 128;
   \   00000070   0x70A8             STRB     R0,[R5, #+2]
    251          #else
    252          	/* Read conf and configure compass through I2C SLV for compass and subsequent channel */
    253          	if (HW_AK09916 == s->secondary_state.compass_slave_id) {
    254          		s->secondary_state.mode_reg_addr = REG_AK09916_CNTL2;
    255          		// no sensitivity adjustment value
    256          		s->secondary_state.compass_sens[0] = 128;
    257          		s->secondary_state.compass_sens[1] = 128;
    258          		s->secondary_state.compass_sens[2] = 128;
    259          	}
    260          	else {
    261          		// Fuse ROM access not possible for ak9916
    262          		/* set AKM to Fuse ROM access mode */
    263          		if (HW_AK09911 == s->secondary_state.compass_slave_id) {
    264          			s->secondary_state.mode_reg_addr = REG_AK09911_CNTL2;
    265          			sens = REG_AK09911_SENSITIVITY;
    266          			cmd = DATA_AK09911_MODE_FR;
    267          		} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
    268          			s->secondary_state.mode_reg_addr = REG_AK09912_CNTL2;
    269          			sens = REG_AK09912_SENSITIVITY;
    270          			cmd = DATA_AK09912_MODE_FR;
    271          		} else {
    272          			s->secondary_state.mode_reg_addr = REG_AKM_MODE;
    273          			sens = REG_AKM_SENSITIVITY;
    274          			cmd = DATA_AKM_MODE_FR;
    275          		}
    276          
    277          		result = inv_icm20948_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, sens, THREE_AXES);
    278          		if (result)
    279          			return result;
    280          		// activate FUSE_ROM mode to CNTL2
    281          		result = inv_icm20948_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, 
    282          				s->secondary_state.mode_reg_addr, cmd);
    283          
    284          		if (result)
    285          			return result;
    286          		// read sensitivity
    287          		result = inv_icm20948_read_mems_reg(s, REG_EXT_SLV_SENS_DATA_00, THREE_AXES, s->secondary_state.compass_sens);
    288          		if (result)
    289          			return result;
    290          	}
    291          	//aply noise suppression filter (only available for 9912)
    292          	if (HW_AK09912 == s->secondary_state.compass_slave_id) {
    293          		result = inv_icm20948_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, REG_AK09912_CNTL1,
    294                                               DATA_AK9912_NSF << DATA_AK9912_NSF_SHIFT);
    295          		if (result)
    296          			return result;
    297          	}
    298          #endif
    299          	/* Set compass in power down through I2C SLV for compass */
    300          	result = inv_icm20948_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, s->secondary_state.mode_reg_addr, DATA_AKM_MODE_PD);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x7BB3             LDRB     R3,[R6, #+14]
   \   00000078   0x6930             LDR      R0,[R6, #+16]
   \   0000007A   0x4602             MOV      R2,R0
   \   0000007C   0xB2D2             UXTB     R2,R2
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       inv_icm20948_execute_write_secondary
    301          	if (result)
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD106             BNE.N    ??inv_icm20948_setup_compass_akm_0
    302          		return result;
    303              
    304          	s->secondary_state.secondary_resume_compass_state = 1;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x7370             STRB     R0,[R6, #+13]
    305          	s->secondary_state.compass_state = INV_ICM20948_COMPASS_SETUP;
   \   0000008E   0x2002             MOVS     R0,#+2
   \   00000090   0x7630             STRB     R0,[R6, #+24]
    306          	return inv_icm20948_suspend_akm(s);
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       inv_icm20948_suspend_akm
   \                     ??inv_icm20948_setup_compass_akm_0: (+1)
   \   00000098   0xB004             ADD      SP,SP,#+16
   \   0000009A   0xBD70             POP      {R4-R6,PC}       ;; return
    307          }
    308          

   \                                 In section .text, align 2, keep-with-next
    309          int inv_icm20948_check_akm_self_test(struct inv_icm20948 * s)
    310          {
   \                     inv_icm20948_check_akm_self_test: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
    311          	int result;
    312          	unsigned char data[6], mode, addr;
    313          	unsigned char counter;
    314          	short x, y, z;
    315          	unsigned char *sens;
    316          	int shift;
    317          	unsigned char slv_ctrl[2];
    318          	unsigned char odr_cfg;
    319          #if (MEMS_CHIP != HW_ICM20948)
    320          	unsigned char cntl;
    321          #endif
    322          	addr = s->secondary_state.compass_chip_addr;
   \   00000008   0xF104 0x0574      ADD      R5,R4,#+116
   \   0000000C   0x692E             LDR      R6,[R5, #+16]
    323          	sens = s->secondary_state.compass_sens;
    324          
    325          	/* back up registers */
    326          	/* SLV0_CTRL */
    327          	result = inv_icm20948_read_mems_reg(s, REG_I2C_SLV0_CTRL, 1, &slv_ctrl[0]);
   \   0000000E   0xF240 0x1785      MOVW     R7,#+389
   \   00000012   0xF10D 0x030A      ADD      R3,SP,#+10
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x4639             MOV      R1,R7
   \   0000001A   0x.... 0x....      BL       inv_icm20948_read_mems_reg
    328          	if (result)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xF040 0x80F7      BNE.W    ??inv_icm20948_check_akm_self_test_0
    329          		return result;
    330          	result = inv_icm20948_write_single_mems_reg(s, REG_I2C_SLV0_CTRL, 0);
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x4639             MOV      R1,R7
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
    331          	if (result)
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF040 0x80EF      BNE.W    ??inv_icm20948_check_akm_self_test_0
    332          		return result;
    333          	/* SLV1_CTRL */
    334          	result = inv_icm20948_read_mems_reg(s, REG_I2C_SLV1_CTRL, 1, &slv_ctrl[1]);
   \   00000034   0xF240 0x1789      MOVW     R7,#+393
   \   00000038   0xF10D 0x030B      ADD      R3,SP,#+11
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x4639             MOV      R1,R7
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       inv_icm20948_read_mems_reg
    335          	if (result)
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xF040 0x80E3      BNE.W    ??inv_icm20948_check_akm_self_test_0
    336          		return result;
    337          	result = inv_icm20948_write_single_mems_reg(s, REG_I2C_SLV1_CTRL, 0);
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
    338          	if (result)
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xF040 0x80DB      BNE.W    ??inv_icm20948_check_akm_self_test_0
    339          		return result;
    340          	/* I2C_MST ODR */
    341          	result = inv_icm20948_read_mems_reg(s, REG_I2C_MST_ODR_CONFIG, 1, &odr_cfg);
   \   0000005C   0xAB02             ADD      R3,SP,#+8
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0xF44F 0x71C0      MOV      R1,#+384
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       inv_icm20948_read_mems_reg
    342          	if (result)
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xF040 0x80D1      BNE.W    ??inv_icm20948_check_akm_self_test_0
    343          		return result;
    344          	result = inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, 0);
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0xF44F 0x71C0      MOV      R1,#+384
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
    345          	if (result)
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xF040 0x80C8      BNE.W    ??inv_icm20948_check_akm_self_test_0
    346          		return result;
    347          
    348          #if (MEMS_CHIP == HW_ICM20948)
    349          	mode = REG_AK09916_CNTL2;
    350          #else
    351          	if (HW_AK09911 == s->secondary_state.compass_slave_id)
    352          		mode = REG_AK09911_CNTL2;
    353          	else if (HW_AK09912 == s->secondary_state.compass_slave_id)
    354          		mode = REG_AK09912_CNTL2;
    355          	else if (HW_AK09916 == s->secondary_state.compass_slave_id)
    356          		mode = REG_AK09916_CNTL2;
    357          	else
    358          		mode = REG_AKM_MODE;
    359          #endif
    360          	/* set to power down mode */
    361          	result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AKM_MODE_PD);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x9000             STR      R0,[SP, #+0]
   \   00000086   0x2331             MOVS     R3,#+49
   \   00000088   0x4632             MOV      R2,R6
   \   0000008A   0xB2D2             UXTB     R2,R2
   \   0000008C   0x4601             MOV      R1,R0
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       inv_icm20948_execute_write_secondary
   \   00000094   0x0007             MOVS     R7,R0
    362          	if (result)
   \   00000096   0xF040 0x80A1      BNE.W    ??inv_icm20948_check_akm_self_test_1
    363          		goto AKM_fail;
    364          		
    365          	/* write 1 to ASTC register */
    366          	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
    367          		(HW_AK09912 != s->secondary_state.compass_slave_id)) {
   \   0000009A   0x6968             LDR      R0,[R5, #+20]
   \   0000009C   0x2823             CMP      R0,#+35
   \   0000009E   0xD00D             BEQ.N    ??inv_icm20948_check_akm_self_test_2
   \   000000A0   0x2824             CMP      R0,#+36
   \   000000A2   0xD00B             BEQ.N    ??inv_icm20948_check_akm_self_test_2
    368          		result = inv_icm20948_execute_write_secondary(s, 0, addr, REG_AKM_ST_CTRL, DATA_AKM_SELF_TEST);
   \   000000A4   0x2040             MOVS     R0,#+64
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x230C             MOVS     R3,#+12
   \   000000AA   0x4632             MOV      R2,R6
   \   000000AC   0xB2D2             UXTB     R2,R2
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       inv_icm20948_execute_write_secondary
   \   000000B6   0x0007             MOVS     R7,R0
    369          		if (result)
   \   000000B8   0xF040 0x8090      BNE.W    ??inv_icm20948_check_akm_self_test_1
    370          			goto AKM_fail;
    371          	}
    372          #if (MEMS_CHIP == HW_ICM20948)
    373          	result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AK09916_MODE_ST);
   \                     ??inv_icm20948_check_akm_self_test_2: (+1)
   \   000000BC   0x2010             MOVS     R0,#+16
   \   000000BE   0x9000             STR      R0,[SP, #+0]
   \   000000C0   0x2331             MOVS     R3,#+49
   \   000000C2   0x4632             MOV      R2,R6
   \   000000C4   0xB2D2             UXTB     R2,R2
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       inv_icm20948_execute_write_secondary
   \   000000CE   0x0007             MOVS     R7,R0
    374          #else
    375          	/* set self test mode */
    376          	if (HW_AK09911 == s->secondary_state.compass_slave_id)
    377          		result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AK09911_MODE_ST);
    378          	else if (HW_AK09912 == s->secondary_state.compass_slave_id)
    379          		result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AK09912_MODE_ST);
    380          	else if (HW_AK09916 == s->secondary_state.compass_slave_id)
    381          		result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AK09916_MODE_ST);
    382          	else
    383          		result = inv_icm20948_execute_write_secondary(s, 0, addr, mode,	DATA_AKM_MODE_ST);
    384          #endif
    385          	if (result)
   \   000000D0   0xF040 0x8084      BNE.W    ??inv_icm20948_check_akm_self_test_1
    386          		goto AKM_fail;
    387          	counter = DEF_ST_COMPASS_TRY_TIMES;
   \   000000D4   0xF04F 0x080A      MOV      R8,#+10
   \   000000D8   0xE001             B.N      ??inv_icm20948_check_akm_self_test_3
    388          	while (counter > 0) {
    389          //		usleep_range(DEF_ST_COMPASS_WAIT_MIN, DEF_ST_COMPASS_WAIT_MAX);
    390                  inv_icm20948_sleep_us(15000);
    391          
    392          #if (MEMS_CHIP == HW_ICM20948)
    393          		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_STATUS1, 1, data);
    394          #else
    395          		if (HW_AK09911 == s->secondary_state.compass_slave_id)
    396          			result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09911_STATUS1, 1, data);
    397          		else if (HW_AK09912 == s->secondary_state.compass_slave_id)
    398          			result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09912_STATUS1, 1, data);
    399          		else if (HW_AK09916 == s->secondary_state.compass_slave_id)
    400          			result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_STATUS1, 1, data);
    401          		else
    402          			result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AKM_STATUS, 1, data);
    403          #endif
    404          		if (result)
    405          			goto AKM_fail;
    406          		if ((data[0] & DATA_AKM_DRDY) == 0)
    407          			counter--;
   \                     ??inv_icm20948_check_akm_self_test_4: (+1)
   \   000000DA   0xF1A8 0x0801      SUB      R8,R8,#+1
   \                     ??inv_icm20948_check_akm_self_test_3: (+1)
   \   000000DE   0x4640             MOV      R0,R8
   \   000000E0   0xB2C0             UXTB     R0,R0
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD017             BEQ.N    ??inv_icm20948_check_akm_self_test_5
   \   000000E6   0xF643 0x2098      MOVW     R0,#+15000
   \   000000EA   0x.... 0x....      BL       inv_icm20948_sleep_us
   \   000000EE   0xA803             ADD      R0,SP,#+12
   \   000000F0   0x9001             STR      R0,[SP, #+4]
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0x9000             STR      R0,[SP, #+0]
   \   000000F6   0x2310             MOVS     R3,#+16
   \   000000F8   0x4632             MOV      R2,R6
   \   000000FA   0xB2D2             UXTB     R2,R2
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       inv_icm20948_execute_read_secondary
   \   00000104   0x0007             MOVS     R7,R0
   \   00000106   0xD169             BNE.N    ??inv_icm20948_check_akm_self_test_1
   \   00000108   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000010C   0x07C0             LSLS     R0,R0,#+31
   \   0000010E   0xD5E4             BPL.N    ??inv_icm20948_check_akm_self_test_4
    408          		else
    409          			counter = 0;
   \   00000110   0xF04F 0x0800      MOV      R8,#+0
   \   00000114   0xE7E3             B.N      ??inv_icm20948_check_akm_self_test_3
    410          	}
    411          	if ((data[0] & DATA_AKM_DRDY) == 0) {
   \                     ??inv_icm20948_check_akm_self_test_5: (+1)
   \   00000116   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000011A   0x07C0             LSLS     R0,R0,#+31
   \   0000011C   0xD402             BMI.N    ??inv_icm20948_check_akm_self_test_6
    412          		result = -1;
   \   0000011E   0xF04F 0x37FF      MOV      R7,#-1
    413          		goto AKM_fail;
   \   00000122   0xE05B             B.N      ??inv_icm20948_check_akm_self_test_1
    414          	}
    415          #if (MEMS_CHIP == HW_ICM20948)
    416          	result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_MEASURE_DATA, BYTES_PER_SENSOR, data);
   \                     ??inv_icm20948_check_akm_self_test_6: (+1)
   \   00000124   0xA803             ADD      R0,SP,#+12
   \   00000126   0x9001             STR      R0,[SP, #+4]
   \   00000128   0x2006             MOVS     R0,#+6
   \   0000012A   0x9000             STR      R0,[SP, #+0]
   \   0000012C   0x2311             MOVS     R3,#+17
   \   0000012E   0x4632             MOV      R2,R6
   \   00000130   0xB2D2             UXTB     R2,R2
   \   00000132   0x2100             MOVS     R1,#+0
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       inv_icm20948_execute_read_secondary
   \   0000013A   0x0007             MOVS     R7,R0
    417          #else
    418          	if (HW_AK09911 == s->secondary_state.compass_slave_id) {
    419          		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09911_MEASURE_DATA, BYTES_PER_SENSOR, data);
    420          	} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
    421          		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09912_MEASURE_DATA, BYTES_PER_SENSOR, data);
    422          	} else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
    423          		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_MEASURE_DATA, BYTES_PER_SENSOR, data);
    424          	} else {
    425          		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AKM_MEASURE_DATA, BYTES_PER_SENSOR, data);
    426          	}
    427          #endif
    428          	if (result)
   \   0000013C   0xD14E             BNE.N    ??inv_icm20948_check_akm_self_test_1
    429          		goto AKM_fail;
    430          
    431              x = ((short)data[1])<<8|data[0];
   \   0000013E   0xAA03             ADD      R2,SP,#+12
   \   00000140   0x7850             LDRB     R0,[R2, #+1]
   \   00000142   0xF89D 0x100C      LDRB     R1,[SP, #+12]
   \   00000146   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
    432              y = ((short)data[3])<<8|data[2];
   \   0000014A   0xF89D 0x100F      LDRB     R1,[SP, #+15]
   \   0000014E   0x7893             LDRB     R3,[R2, #+2]
   \   00000150   0xEA43 0x2101      ORR      R1,R3,R1, LSL #+8
    433              z = ((short)data[5])<<8|data[4];
   \   00000154   0xF89D 0x3011      LDRB     R3,[SP, #+17]
   \   00000158   0x7912             LDRB     R2,[R2, #+4]
   \   0000015A   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
    434              
    435          	if (HW_AK09911 == s->secondary_state.compass_slave_id)
   \   0000015E   0x696B             LDR      R3,[R5, #+20]
   \   00000160   0x2B23             CMP      R3,#+35
   \   00000162   0xD101             BNE.N    ??inv_icm20948_check_akm_self_test_7
    436          		shift = 7;
   \   00000164   0x2307             MOVS     R3,#+7
   \   00000166   0xE000             B.N      ??inv_icm20948_check_akm_self_test_8
    437          	else
    438          		shift = 8;
   \                     ??inv_icm20948_check_akm_self_test_7: (+1)
   \   00000168   0x2308             MOVS     R3,#+8
    439          	x = ((x * (sens[0] + 128)) >> shift);
   \                     ??inv_icm20948_check_akm_self_test_8: (+1)
   \   0000016A   0xF104 0x074D      ADD      R7,R4,#+77
   \   0000016E   0xB200             SXTH     R0,R0
   \   00000170   0xF897 0xC000      LDRB     R12,[R7, #+0]
   \   00000174   0xF10C 0x0C80      ADD      R12,R12,#+128
   \   00000178   0xFB1C 0xF000      SMULBB   R0,R12,R0
   \   0000017C   0x4118             ASRS     R0,R0,R3
   \   0000017E   0xB200             SXTH     R0,R0
    440          	y = ((y * (sens[1] + 128)) >> shift);
   \   00000180   0xB209             SXTH     R1,R1
   \   00000182   0xF897 0xC001      LDRB     R12,[R7, #+1]
   \   00000186   0xF10C 0x0C80      ADD      R12,R12,#+128
   \   0000018A   0xFB1C 0xF101      SMULBB   R1,R12,R1
   \   0000018E   0x4119             ASRS     R1,R1,R3
   \   00000190   0xB209             SXTH     R1,R1
    441          	z = ((z * (sens[2] + 128)) >> shift);
   \   00000192   0xB212             SXTH     R2,R2
   \   00000194   0x78BF             LDRB     R7,[R7, #+2]
   \   00000196   0x3780             ADDS     R7,R7,#+128
   \   00000198   0xFB17 0xF202      SMULBB   R2,R7,R2
   \   0000019C   0x411A             ASRS     R2,R2,R3
   \   0000019E   0xB212             SXTH     R2,R2
    442          #if (MEMS_CHIP == HW_ICM20648)
    443          	if (HW_AK8963 == s->secondary_state.compass_slave_id) {
    444          		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AKM8963_CNTL1, 1, &cntl);
    445          		if (result)
    446          			goto AKM_fail;
    447          		if (0 == (cntl & DATA_AKM8963_BIT)) {
    448          			x <<= DEF_ST_COMPASS_8963_SHIFT;
    449          			y <<= DEF_ST_COMPASS_8963_SHIFT;
    450          			z <<= DEF_ST_COMPASS_8963_SHIFT;
    451          		}
    452          	}
    453          #endif
    454          
    455          	result = -1;
   \   000001A0   0xF04F 0x37FF      MOV      R7,#-1
    456          	if (x > s->secondary_state.st_upper[0] || x < s->secondary_state.st_lower[0])
   \   000001A4   0x682B             LDR      R3,[R5, #+0]
   \   000001A6   0xF9B3 0xC000      LDRSH    R12,[R3, #+0]
   \   000001AA   0x4584             CMP      R12,R0
   \   000001AC   0xDB16             BLT.N    ??inv_icm20948_check_akm_self_test_1
   \   000001AE   0xF8D5 0xC004      LDR      R12,[R5, #+4]
   \   000001B2   0xF9BC 0xE000      LDRSH    LR,[R12, #+0]
   \   000001B6   0x4570             CMP      R0,LR
   \   000001B8   0xDB10             BLT.N    ??inv_icm20948_check_akm_self_test_1
    457          		goto AKM_fail;
    458          	if (y > s->secondary_state.st_upper[1] || y < s->secondary_state.st_lower[1])
   \   000001BA   0xF9B3 0x0002      LDRSH    R0,[R3, #+2]
   \   000001BE   0x4288             CMP      R0,R1
   \   000001C0   0xDB0C             BLT.N    ??inv_icm20948_check_akm_self_test_1
   \   000001C2   0xF9BC 0x0002      LDRSH    R0,[R12, #+2]
   \   000001C6   0x4281             CMP      R1,R0
   \   000001C8   0xDB08             BLT.N    ??inv_icm20948_check_akm_self_test_1
    459          		goto AKM_fail;
    460          	if (z > s->secondary_state.st_upper[2] || z < s->secondary_state.st_lower[2])
   \   000001CA   0xF9B3 0x0004      LDRSH    R0,[R3, #+4]
   \   000001CE   0x4290             CMP      R0,R2
   \   000001D0   0xDB04             BLT.N    ??inv_icm20948_check_akm_self_test_1
   \   000001D2   0xF9BC 0x0004      LDRSH    R0,[R12, #+4]
   \   000001D6   0x4282             CMP      R2,R0
   \   000001D8   0xDB00             BLT.N    ??inv_icm20948_check_akm_self_test_1
    461          		goto AKM_fail;
    462          	result = 0;
   \   000001DA   0x2700             MOVS     R7,#+0
    463          AKM_fail:
    464          	/*write 0 to ASTC register */
    465          	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
    466          		(HW_AK09912 != s->secondary_state.compass_slave_id) &&
    467          		(HW_AK09916 != s->secondary_state.compass_slave_id)) {
   \                     ??inv_icm20948_check_akm_self_test_1: (+1)
   \   000001DC   0x6968             LDR      R0,[R5, #+20]
   \   000001DE   0x2823             CMP      R0,#+35
   \   000001E0   0xD00D             BEQ.N    ??inv_icm20948_check_akm_self_test_9
   \   000001E2   0x2824             CMP      R0,#+36
   \   000001E4   0xD00B             BEQ.N    ??inv_icm20948_check_akm_self_test_9
   \   000001E6   0x2825             CMP      R0,#+37
   \   000001E8   0xD009             BEQ.N    ??inv_icm20948_check_akm_self_test_9
    468          		result |= inv_icm20948_execute_write_secondary(s, 0, addr, REG_AKM_ST_CTRL, 0);
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0x9000             STR      R0,[SP, #+0]
   \   000001EE   0x230C             MOVS     R3,#+12
   \   000001F0   0x4632             MOV      R2,R6
   \   000001F2   0xB2D2             UXTB     R2,R2
   \   000001F4   0x4601             MOV      R1,R0
   \   000001F6   0x4620             MOV      R0,R4
   \   000001F8   0x.... 0x....      BL       inv_icm20948_execute_write_secondary
   \   000001FC   0x4307             ORRS     R7,R0,R7
    469          	}
    470          	/*set to power down mode */
    471          	result |= inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AKM_MODE_PD);
   \                     ??inv_icm20948_check_akm_self_test_9: (+1)
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x9000             STR      R0,[SP, #+0]
   \   00000202   0x2331             MOVS     R3,#+49
   \   00000204   0x4632             MOV      R2,R6
   \   00000206   0xB2D2             UXTB     R2,R2
   \   00000208   0x4601             MOV      R1,R0
   \   0000020A   0x4620             MOV      R0,R4
   \   0000020C   0x.... 0x....      BL       inv_icm20948_execute_write_secondary
   \   00000210   0x4338             ORRS     R0,R0,R7
    472          
    473              return result;
   \                     ??inv_icm20948_check_akm_self_test_0: (+1)
   \   00000212   0xB006             ADD      SP,SP,#+24
   \   00000214   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    474          }
    475          
    476          /*
    477           *  inv_icm20948_write_akm_scale() - Configure the akm scale range.
    478           */

   \                                 In section .text, align 2, keep-with-next
    479          int inv_icm20948_write_akm_scale(struct inv_icm20948 * s, int data)
    480          {
   \                     inv_icm20948_write_akm_scale: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    481          	char d, en;
    482          	int result;
    483              
    484          	if (HW_AK8963 != s->secondary_state.compass_slave_id)
   \   00000002   0xF100 0x047C      ADD      R4,R0,#+124
   \   00000006   0x68E2             LDR      R2,[R4, #+12]
   \   00000008   0x2A20             CMP      R2,#+32
   \   0000000A   0xD001             BEQ.N    ??inv_icm20948_write_akm_scale_0
    485          		return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    486          	en = !!data;
   \                     ??inv_icm20948_write_akm_scale_0: (+1)
   \   00000010   0x460D             MOV      R5,R1
   \   00000012   0x1E6D             SUBS     R5,R5,#+1
   \   00000014   0x41AD             SBCS     R5,R5,R5
   \   00000016   0x43ED             MVNS     R5,R5
   \   00000018   0x0FED             LSRS     R5,R5,#+31
    487          	if (s->secondary_state.scale == en)
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x42A9             CMP      R1,R5
   \   0000001E   0xD101             BNE.N    ??inv_icm20948_write_akm_scale_1
    488          		return 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
    489          	d = (DATA_AKM_MODE_SM | (en << DATA_AKM8963_SCALE_SHIFT));
    490          
    491          	result = inv_icm20948_write_single_mems_reg(s, REG_I2C_SLV1_DO, d);
   \                     ??inv_icm20948_write_akm_scale_1: (+1)
   \   00000024   0x0129             LSLS     R1,R5,#+4
   \   00000026   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000002A   0x460A             MOV      R2,R1
   \   0000002C   0xF44F 0x71C5      MOV      R1,#+394
   \   00000030   0x.... 0x....      BL       inv_icm20948_write_single_mems_reg
    492          	if (result)
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??inv_icm20948_write_akm_scale_2
    493          		return result;
    494          
    495          	s->secondary_state.scale = en;
   \   00000038   0x6025             STR      R5,[R4, #+0]
    496              
    497          	return 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??inv_icm20948_write_akm_scale_2: (+1)
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    498          }
    499          
    500          /*
    501           *  inv_icm20948_read_akm_scale() - show AKM scale.
    502           */

   \                                 In section .text, align 2, keep-with-next
    503          int inv_icm20948_read_akm_scale(struct inv_icm20948 * s, int *scale)
    504          {
    505          #if (MEMS_CHIP == HW_ICM20948)
    506          	(void)s;
    507          	*scale = DATA_AK09916_SCALE;
   \                     inv_icm20948_read_akm_scale: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3  ;; 0x9999999
   \   00000002   0x6008             STR      R0,[R1, #+0]
    508          #else
    509          	if (HW_AK8975 == s->secondary_state.compass_slave_id)
    510          		*scale = DATA_AKM8975_SCALE;
    511          	else if (HW_AK8972 == s->secondary_state.compass_slave_id)
    512          		*scale = DATA_AKM8972_SCALE;
    513          	else if (HW_AK8963 == s->secondary_state.compass_slave_id)
    514          		if (s->secondary_state.scale)
    515          			*scale = DATA_AKM8963_SCALE1;
    516          		else
    517          			*scale = DATA_AKM8963_SCALE0;
    518          	else if (HW_AK09911 == s->secondary_state.compass_slave_id)
    519          		*scale = DATA_AK09911_SCALE;
    520          	else if (HW_AK09912 == s->secondary_state.compass_slave_id)
    521          		*scale = DATA_AK09912_SCALE;
    522          	else if (HW_AK09916 == s->secondary_state.compass_slave_id)
    523          		*scale = DATA_AK09916_SCALE;
    524          	else
    525          		return -1;
    526          #endif
    527          	return 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR               ;; return
    528          }
    529          

   \                                 In section .text, align 2, keep-with-next
    530          int inv_icm20948_suspend_akm(struct inv_icm20948 * s)
    531          {
   \                     inv_icm20948_suspend_akm: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    532          	int result;
    533              
    534          	if (!s->secondary_state.secondary_resume_compass_state)
   \   00000004   0xF894 0x0081      LDRB     R0,[R4, #+129]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE.N    ??inv_icm20948_suspend_akm_0
    535          		return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    536              
    537          	/* slave 0 is disabled */
    538          	result = inv_icm20948_secondary_stop_channel(s, COMPASS_I2C_SLV_READ);
   \                     ??inv_icm20948_suspend_akm_0: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       inv_icm20948_secondary_stop_channel
   \   00000018   0x4605             MOV      R5,R0
    539          	/* slave 1 is disabled */
    540          	result |= inv_icm20948_secondary_stop_channel(s, COMPASS_I2C_SLV_WRITE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       inv_icm20948_secondary_stop_channel
   \   00000022   0x4328             ORRS     R0,R0,R5
    541          	if (result)
   \   00000024   0xD105             BNE.N    ??inv_icm20948_suspend_akm_1
    542          		return result;
    543          	
    544          	// Switch off I2C Interface as compass is alone
    545          	result |= inv_icm20948_secondary_disable_i2c(s);
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       inv_icm20948_secondary_disable_i2c
    546          	
    547          	s->secondary_state.secondary_resume_compass_state = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF884 0x1081      STRB     R1,[R4, #+129]
    548              
    549          	return result;
   \                     ??inv_icm20948_suspend_akm_1: (+1)
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    550          }
    551          

   \                                 In section .text, align 2, keep-with-next
    552          int inv_icm20948_resume_akm(struct inv_icm20948 * s)
    553          {
   \                     inv_icm20948_resume_akm: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    554          	int result;
    555          	uint8_t reg_addr, bytes;
    556              unsigned char lDataToWrite;
    557              
    558          	if (s->secondary_state.secondary_resume_compass_state)
   \   00000004   0xF104 0x0580      ADD      R5,R4,#+128
   \   00000008   0x7868             LDRB     R0,[R5, #+1]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??inv_icm20948_resume_akm_0
    559          		return 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
    560              
    561          	/* slave 0 is used to read data from compass */
    562          	/*read mode */
    563          #if (MEMS_CHIP == HW_ICM20948)
    564          	if (s->secondary_state.dmp_on) {
   \                     ??inv_icm20948_resume_akm_0: (+1)
   \   00000012   0x7828             LDRB     R0,[R5, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??inv_icm20948_resume_akm_1
    565          		reg_addr = REG_AK09916_DMP_READ;
   \   00000018   0x2303             MOVS     R3,#+3
    566          		bytes = DATA_AKM_99_BYTES_DMP;
   \   0000001A   0x200A             MOVS     R0,#+10
   \   0000001C   0xE001             B.N      ??inv_icm20948_resume_akm_2
    567          	} else {
    568          		reg_addr = REG_AK09916_STATUS1;
   \                     ??inv_icm20948_resume_akm_1: (+1)
   \   0000001E   0x2310             MOVS     R3,#+16
    569          		bytes = DATA_AKM_99_BYTES_DMP - 1;
   \   00000020   0x2009             MOVS     R0,#+9
    570          	}
    571          #else
    572          	/* AKM status register address is 1 */
    573          	if (HW_AK09911 == s->secondary_state.compass_slave_id) {
    574          		if (s->secondary_state.dmp_on) {
    575          			reg_addr = REG_AK09911_DMP_READ;
    576          			bytes = DATA_AKM_99_BYTES_DMP;
    577          		} else {
    578          			reg_addr = REG_AK09911_STATUS1;
    579          			bytes = DATA_AKM_99_BYTES_DMP - 1;
    580          		}
    581          	} else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
    582          		if (s->secondary_state.dmp_on) {
    583          			reg_addr = REG_AK09912_DMP_READ;
    584          			bytes = DATA_AKM_99_BYTES_DMP;
    585          		} else {
    586          			reg_addr = REG_AK09912_STATUS1;
    587          			bytes = DATA_AKM_99_BYTES_DMP - 1;
    588          		}
    589          	} else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
    590          		if (s->secondary_state.dmp_on) {
    591          			reg_addr = REG_AK09916_DMP_READ;
    592          			bytes = DATA_AKM_99_BYTES_DMP;
    593          		} else {
    594          			reg_addr = REG_AK09916_STATUS1;
    595          			bytes = DATA_AKM_99_BYTES_DMP - 1;
    596          		}
    597          	} else {
    598          		if (s->secondary_state.dmp_on) {
    599          			reg_addr = REG_AKM_INFO;
    600          			bytes = DATA_AKM_89_BYTES_DMP;
    601          		} else {
    602          			reg_addr = REG_AKM_STATUS;
    603          			bytes = DATA_AKM_89_BYTES_DMP - 1;
    604          		}
    605          	}
    606          #endif
    607          	/* slave 0 is enabled, read 10 or 8 bytes from here depending on compass type, swap bytes to feed DMP */
    608          	result = inv_icm20948_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, reg_addr, INV_MPU_BIT_GRP | INV_MPU_BIT_BYTE_SW | bytes);
   \                     ??inv_icm20948_resume_akm_2: (+1)
   \   00000022   0xF040 0x0050      ORR      R0,R0,#0x50
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x4602             MOV      R2,R0
   \   0000002C   0xB2D2             UXTB     R2,R2
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       inv_icm20948_read_secondary
    609          	if (result)
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD110             BNE.N    ??inv_icm20948_resume_akm_3
    610          		return result;
    611          #if (MEMS_CHIP == HW_ICM20948)
    612          	lDataToWrite = DATA_AKM_MODE_SM;
    613          #else
    614          	/* slave 1 is used to write one-shot accquisition configuration to compass */
    615          	/* output data for slave 1 is fixed, single measure mode */
    616          	s->secondary_state.scale = 1;
    617          	if (HW_AK8975 == s->secondary_state.compass_slave_id) {
    618          		lDataToWrite = DATA_AKM_MODE_SM;
    619          	} else if (HW_AK8972 == s->secondary_state.compass_slave_id) {
    620          		lDataToWrite = DATA_AKM_MODE_SM;
    621          	} else if (HW_AK8963 == s->secondary_state.compass_slave_id) {
    622          		lDataToWrite = DATA_AKM_MODE_SM |
    623          			(s->secondary_state.scale << DATA_AKM8963_SCALE_SHIFT);
    624          	}  else if (HW_AK09911 == s->secondary_state.compass_slave_id) {
    625          		lDataToWrite = DATA_AKM_MODE_SM;
    626          	}  else if (HW_AK09912 == s->secondary_state.compass_slave_id) {
    627          		lDataToWrite = DATA_AKM_MODE_SM;
    628          	}  else if (HW_AK09916 == s->secondary_state.compass_slave_id) {
    629          		lDataToWrite = DATA_AKM_MODE_SM;
    630          	} else {
    631          		return -1;
    632          	}
    633          #endif
    634          	result = inv_icm20948_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, s->secondary_state.mode_reg_addr, lDataToWrite);
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0x78AB             LDRB     R3,[R5, #+2]
   \   00000040   0x6868             LDR      R0,[R5, #+4]
   \   00000042   0x4602             MOV      R2,R0
   \   00000044   0xB2D2             UXTB     R2,R2
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       inv_icm20948_write_secondary
    635          	if (result)
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD104             BNE.N    ??inv_icm20948_resume_akm_3
    636          		return result;
    637          	
    638          	result |= inv_icm20948_secondary_enable_i2c(s);
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       inv_icm20948_secondary_enable_i2c
    639          
    640              s->secondary_state.secondary_resume_compass_state = 1;
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x7069             STRB     R1,[R5, #+1]
    641              
    642          	return result;
   \                     ??inv_icm20948_resume_akm_3: (+1)
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    643          }
    644          

   \                                 In section .text, align 2, keep-with-next
    645          char inv_icm20948_compass_getstate(struct inv_icm20948 * s)
    646          {
    647          	return s->secondary_state.secondary_resume_compass_state;
   \                     inv_icm20948_compass_getstate: (+1)
   \   00000000   0xF990 0x0081      LDRSB    R0,[R0, #+129]
   \   00000004   0x4770             BX       LR               ;; return
    648          }
    649          

   \                                 In section .text, align 2, keep-with-next
    650          int inv_icm20948_compass_isconnected(struct inv_icm20948 * s)
    651          {
    652          	if(s->secondary_state.compass_state == INV_ICM20948_COMPASS_SETUP) {
   \                     inv_icm20948_compass_isconnected: (+1)
   \   00000000   0xF990 0x008C      LDRSB    R0,[R0, #+140]
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD101             BNE.N    ??inv_icm20948_compass_isconnected_0
    653          		return 1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
    654          	} else {
    655          		return 0;
   \                     ??inv_icm20948_compass_isconnected_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    656          	}
    657          }
    658          
    659          /**
    660          *  @brief      Set up the soft-iron matrix for compass in DMP.
    661          *  @param[in]  Accel/Gyro mounting matrix
    662          *  @param[in]  Compass mounting matrix
    663          *  @return     0 if successful.
    664          */
    665          

   \                                 In section .text, align 2, keep-with-next
    666          int inv_icm20948_compass_dmp_cal(struct inv_icm20948 * s, const signed char *m, const signed char *compass_m)
    667          {
   \                     inv_icm20948_compass_dmp_cal: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB099             SUB      SP,SP,#+100
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4616             MOV      R6,R2
    668          	int8_t trans[NINE_ELEM];
    669          	int tmp_m[NINE_ELEM];
    670          	int i, j, k;
    671          	int sens[THREE_AXES];
    672          	int scale;
    673          	int shift;
    674              int current_compass_matrix[NINE_ELEM];
    675              
    676          	for (i = 0; i < THREE_AXES; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xAB03             ADD      R3,SP,#+12
   \   0000000E   0xE00B             B.N      ??inv_icm20948_compass_dmp_cal_0
    677          		for (j = 0; j < THREE_AXES; j++)
    678          			trans[THREE_AXES * j + i] = m[THREE_AXES * i + j];
   \                     ??inv_icm20948_compass_dmp_cal_1: (+1)
   \   00000010   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   00000014   0x18AA             ADDS     R2,R5,R2
   \   00000016   0x5C8A             LDRB     R2,[R1, R2]
   \   00000018   0xEB05 0x0745      ADD      R7,R5,R5, LSL #+1
   \   0000001C   0x19C7             ADDS     R7,R0,R7
   \   0000001E   0x55DA             STRB     R2,[R3, R7]
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \                     ??inv_icm20948_compass_dmp_cal_2: (+1)
   \   00000022   0x2D03             CMP      R5,#+3
   \   00000024   0xDBF4             BLT.N    ??inv_icm20948_compass_dmp_cal_1
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_compass_dmp_cal_0: (+1)
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xDA01             BGE.N    ??inv_icm20948_compass_dmp_cal_3
   \   0000002C   0x2500             MOVS     R5,#+0
   \   0000002E   0xE7F8             B.N      ??inv_icm20948_compass_dmp_cal_2
    679          	
    680              switch (s->secondary_state.compass_slave_id) 
    681              {
    682          #if (MEMS_CHIP == HW_ICM20648)
    683                  case HW_AK8972:
    684                      scale = DATA_AKM8972_SCALE;
    685                      shift = AK89XX_SHIFT;
    686                      break;
    687                  case HW_AK8975:
    688                      scale = DATA_AKM8975_SCALE;
    689                      shift = AK89XX_SHIFT;
    690                      break;
    691                  case HW_AK8963:
    692                      scale = DATA_AKM8963_SCALE1;
    693                      shift = AK89XX_SHIFT;
    694                      break;
    695                  case HW_AK09911:
    696                      scale = DATA_AK09911_SCALE;
    697                      shift = AK99XX_SHIFT;
    698                      break;
    699                  case HW_AK09912:        
    700                      scale = DATA_AK09912_SCALE;
    701                      shift = AK89XX_SHIFT;
    702                      break;
    703          #else
    704                  case HW_AK09916:
    705                      scale = DATA_AK09916_SCALE;
    706                      shift = AK89XX_SHIFT;
    707                      break;
    708          #endif
    709          		default:
    710          				scale = DATA_AKM8963_SCALE1;
    711          				shift = AK89XX_SHIFT;
    712          				break;
    713              }
    714              
    715          	for (i = 0; i < THREE_AXES; i++) {
   \                     ??inv_icm20948_compass_dmp_cal_3: (+1)
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0x466F             MOV      R7,SP
   \   00000034   0xE00C             B.N      ??inv_icm20948_compass_dmp_cal_4
    716          		sens[i] = s->secondary_state.compass_sens[i] + 128;
   \                     ??inv_icm20948_compass_dmp_cal_5: (+1)
   \   00000036   0x1960             ADDS     R0,R4,R5
   \   00000038   0xF890 0x004D      LDRB     R0,[R0, #+77]
   \   0000003C   0x3080             ADDS     R0,R0,#+128
   \   0000003E   0xF847 0x0025      STR      R0,[R7, R5, LSL #+2]
    717          		sens[i] = inv_icm20948_convert_mult_q30_fxp(sens[i] << shift, scale);
   \   00000042   0x....             LDR.N    R1,??DataTable3  ;; 0x9999999
   \   00000044   0x0580             LSLS     R0,R0,#+22
   \   00000046   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   0000004A   0xF847 0x0025      STR      R0,[R7, R5, LSL #+2]
    718          	}
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??inv_icm20948_compass_dmp_cal_4: (+1)
   \   00000050   0x2D03             CMP      R5,#+3
   \   00000052   0xDBF0             BLT.N    ??inv_icm20948_compass_dmp_cal_5
    719          	for (i = 0; i < NINE_ELEM; i++) {
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x466B             MOV      R3,SP
   \   00000058   0xE011             B.N      ??inv_icm20948_compass_dmp_cal_6
    720          		current_compass_matrix[i] = compass_m[i] * sens[i % THREE_AXES];
   \                     ??inv_icm20948_compass_dmp_cal_7: (+1)
   \   0000005A   0x5631             LDRSB    R1,[R6, R0]
   \   0000005C   0x2203             MOVS     R2,#+3
   \   0000005E   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   00000062   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \   00000066   0x1A82             SUBS     R2,R0,R2
   \   00000068   0xF853 0x2022      LDR      R2,[R3, R2, LSL #+2]
   \   0000006C   0x4351             MULS     R1,R2,R1
   \   0000006E   0xAA06             ADD      R2,SP,#+24
   \   00000070   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    721          		tmp_m[i] = 0;
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0xAA0F             ADD      R2,SP,#+60
   \   00000078   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    722          	}
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_compass_dmp_cal_6: (+1)
   \   0000007E   0x2809             CMP      R0,#+9
   \   00000080   0xDBEB             BLT.N    ??inv_icm20948_compass_dmp_cal_7
    723              
    724              for (i = 0; i < THREE_AXES; i++) {
   \   00000082   0x2700             MOVS     R7,#+0
   \   00000084   0xE000             B.N      ??inv_icm20948_compass_dmp_cal_8
   \                     ??inv_icm20948_compass_dmp_cal_9: (+1)
   \   00000086   0x1C7F             ADDS     R7,R7,#+1
   \                     ??inv_icm20948_compass_dmp_cal_8: (+1)
   \   00000088   0x2F03             CMP      R7,#+3
   \   0000008A   0xDA25             BGE.N    ??inv_icm20948_compass_dmp_cal_10
    725          		for (j = 0; j < THREE_AXES; j++) {
   \   0000008C   0x2500             MOVS     R5,#+0
   \   0000008E   0xEB07 0x0847      ADD      R8,R7,R7, LSL #+1
   \   00000092   0xE016             B.N      ??inv_icm20948_compass_dmp_cal_11
    726          			s->secondary_state.final_matrix[i * THREE_AXES + j] = 0;
    727          			for (k = 0; k < THREE_AXES; k++)
    728          				s->secondary_state.final_matrix[i * THREE_AXES + j] +=
    729          					inv_icm20948_convert_mult_q30_fxp(s->soft_iron_matrix[i * THREE_AXES + k],
    730                                           current_compass_matrix[j + k * THREE_AXES]);
   \                     ??inv_icm20948_compass_dmp_cal_12: (+1)
   \   00000094   0xA806             ADD      R0,SP,#+24
   \   00000096   0xEB06 0x0146      ADD      R1,R6,R6, LSL #+1
   \   0000009A   0x1949             ADDS     R1,R1,R5
   \   0000009C   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
   \   000000A0   0xEB06 0x0008      ADD      R0,R6,R8
   \   000000A4   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \   000000A8   0xF8D0 0x0288      LDR      R0,[R0, #+648]
   \   000000AC   0x.... 0x....      BL       inv_icm20948_convert_mult_q30_fxp
   \   000000B0   0xF8D9 0x1050      LDR      R1,[R9, #+80]
   \   000000B4   0x1840             ADDS     R0,R0,R1
   \   000000B6   0xF8C9 0x0050      STR      R0,[R9, #+80]
   \   000000BA   0x1C76             ADDS     R6,R6,#+1
   \                     ??inv_icm20948_compass_dmp_cal_13: (+1)
   \   000000BC   0x2E03             CMP      R6,#+3
   \   000000BE   0xDBE9             BLT.N    ??inv_icm20948_compass_dmp_cal_12
   \   000000C0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??inv_icm20948_compass_dmp_cal_11: (+1)
   \   000000C2   0x2D03             CMP      R5,#+3
   \   000000C4   0xDADF             BGE.N    ??inv_icm20948_compass_dmp_cal_9
   \   000000C6   0xEB05 0x0008      ADD      R0,R5,R8
   \   000000CA   0xEB04 0x0980      ADD      R9,R4,R0, LSL #+2
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF8C9 0x0050      STR      R0,[R9, #+80]
   \   000000D4   0x4606             MOV      R6,R0
   \   000000D6   0xE7F1             B.N      ??inv_icm20948_compass_dmp_cal_13
    731          		}
    732          	}
    733              
    734              for (i = 0; i < THREE_AXES; i++)
   \                     ??inv_icm20948_compass_dmp_cal_10: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xAA0F             ADD      R2,SP,#+60
   \   000000DC   0xE000             B.N      ??inv_icm20948_compass_dmp_cal_14
   \                     ??inv_icm20948_compass_dmp_cal_15: (+1)
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_compass_dmp_cal_14: (+1)
   \   000000E0   0x2803             CMP      R0,#+3
   \   000000E2   0xDA1E             BGE.N    ??inv_icm20948_compass_dmp_cal_16
    735          		for (j = 0; j < THREE_AXES; j++)
   \   000000E4   0x2500             MOVS     R5,#+0
   \   000000E6   0xE018             B.N      ??inv_icm20948_compass_dmp_cal_17
    736          			for (k = 0; k < THREE_AXES; k++)
    737          				tmp_m[THREE_AXES * i + j] +=
    738          					trans[THREE_AXES * i + k] *
    739          						s->secondary_state.final_matrix[THREE_AXES * k + j];
   \                     ??inv_icm20948_compass_dmp_cal_18: (+1)
   \   000000E8   0xEB00 0x0740      ADD      R7,R0,R0, LSL #+1
   \   000000EC   0x19E9             ADDS     R1,R5,R7
   \   000000EE   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
   \   000000F2   0xF10D 0x0C0C      ADD      R12,SP,#+12
   \   000000F6   0x19F7             ADDS     R7,R6,R7
   \   000000F8   0xF91C 0x7007      LDRSB    R7,[R12, R7]
   \   000000FC   0xEB06 0x0C46      ADD      R12,R6,R6, LSL #+1
   \   00000100   0x44AC             ADD      R12,R5,R12
   \   00000102   0xEB04 0x0C8C      ADD      R12,R4,R12, LSL #+2
   \   00000106   0xF8DC 0xC050      LDR      R12,[R12, #+80]
   \   0000010A   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   0000010E   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
   \   00000112   0x1C76             ADDS     R6,R6,#+1
   \                     ??inv_icm20948_compass_dmp_cal_19: (+1)
   \   00000114   0x2E03             CMP      R6,#+3
   \   00000116   0xDBE7             BLT.N    ??inv_icm20948_compass_dmp_cal_18
   \   00000118   0x1C6D             ADDS     R5,R5,#+1
   \                     ??inv_icm20948_compass_dmp_cal_17: (+1)
   \   0000011A   0x2D03             CMP      R5,#+3
   \   0000011C   0xDADF             BGE.N    ??inv_icm20948_compass_dmp_cal_15
   \   0000011E   0x2600             MOVS     R6,#+0
   \   00000120   0xE7F8             B.N      ??inv_icm20948_compass_dmp_cal_19
    740              
    741              return dmp_icm20948_set_compass_matrix(s, tmp_m);
   \                     ??inv_icm20948_compass_dmp_cal_16: (+1)
   \   00000122   0xA90F             ADD      R1,SP,#+60
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       dmp_icm20948_set_compass_matrix
   \   0000012A   0xB019             ADD      SP,SP,#+100
   \   0000012C   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    742          }
    743          
    744          /**
    745          *  @brief      Apply mounting matrix and scaling to raw compass data.
    746          *  @param[in]  Raw compass data
    747          *  @param[in]  Compensated compass data
    748          *  @return     0 if successful.
    749          */
    750          

   \                                 In section .text, align 2, keep-with-next
    751          int inv_icm20948_apply_raw_compass_matrix(struct inv_icm20948 * s, short *raw_data, long *compensated_out)
    752          {
   \                     inv_icm20948_apply_raw_compass_matrix: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x4603             MOV      R3,R0
   \   00000004   0x460C             MOV      R4,R1
    753          	int i, j;
    754          	long long tmp;
    755              
    756          	for (i = 0; i < THREE_AXES; i++) {
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0xE014             B.N      ??inv_icm20948_apply_raw_compass_matrix_0
    757          		tmp = 0;
    758          		for (j = 0; j < THREE_AXES; j++)
    759          			tmp  +=
    760          			(long long)s->secondary_state.final_matrix[i * THREE_AXES + j] * (((int)raw_data[j]) << 16);
   \                     ??inv_icm20948_apply_raw_compass_matrix_1: (+1)
   \   0000000A   0xEB05 0x0745      ADD      R7,R5,R5, LSL #+1
   \   0000000E   0x19F7             ADDS     R7,R6,R7
   \   00000010   0xEB03 0x0787      ADD      R7,R3,R7, LSL #+2
   \   00000014   0x6D3F             LDR      R7,[R7, #+80]
   \   00000016   0xF934 0xC016      LDRSH    R12,[R4, R6, LSL #+1]
   \   0000001A   0xEA4F 0x4C0C      LSL      R12,R12,#+16
   \   0000001E   0xFBCC 0x0107      SMLAL    R0,R1,R12,R7
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??inv_icm20948_apply_raw_compass_matrix_2: (+1)
   \   00000024   0x2E03             CMP      R6,#+3
   \   00000026   0xDBF0             BLT.N    ??inv_icm20948_apply_raw_compass_matrix_1
    761          		compensated_out[i] = (long)(tmp >> 30);
   \   00000028   0x0F80             LSRS     R0,R0,#+30
   \   0000002A   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   0000002E   0xF842 0x0025      STR      R0,[R2, R5, LSL #+2]
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \                     ??inv_icm20948_apply_raw_compass_matrix_0: (+1)
   \   00000034   0x2D03             CMP      R5,#+3
   \   00000036   0xDA03             BGE.N    ??inv_icm20948_apply_raw_compass_matrix_3
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0x4606             MOV      R6,R0
   \   0000003E   0xE7F1             B.N      ??inv_icm20948_apply_raw_compass_matrix_2
    762          	}
    763              
    764          	return 0;
   \                     ??inv_icm20948_apply_raw_compass_matrix_3: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBCF0             POP      {R4-R7}
   \   00000044   0x4770             BX       LR               ;; return
    765          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x09999999         DC32     0x9999999
    766          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   inv_icm20948_apply_raw_compass_matrix
      48   inv_icm20948_check_akm_self_test
        48   -> inv_icm20948_execute_read_secondary
        48   -> inv_icm20948_execute_write_secondary
        48   -> inv_icm20948_read_mems_reg
        48   -> inv_icm20948_sleep_us
        48   -> inv_icm20948_write_single_mems_reg
     128   inv_icm20948_compass_dmp_cal
       128   -> dmp_icm20948_set_compass_matrix
       128   -> inv_icm20948_convert_mult_q30_fxp
       0   inv_icm20948_compass_getstate
       0   inv_icm20948_compass_isconnected
       0   inv_icm20948_read_akm_scale
       0   inv_icm20948_register_aux_compass
      16   inv_icm20948_resume_akm
        16   -> inv_icm20948_read_secondary
        16   -> inv_icm20948_secondary_enable_i2c
        16   -> inv_icm20948_write_secondary
      32   inv_icm20948_setup_compass_akm
        32   -> __aeabi_memset
        32   -> __aeabi_memset4
        32   -> inv_icm20948_execute_read_secondary
        32   -> inv_icm20948_execute_write_secondary
        32   -> inv_icm20948_suspend_akm
      16   inv_icm20948_suspend_akm
        16   -> inv_icm20948_secondary_disable_i2c
        16   -> inv_icm20948_secondary_stop_channel
      16   inv_icm20948_write_akm_scale
        16   -> inv_icm20948_write_single_mems_reg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       8  AK09916_ST_Lower
       8  AK09916_ST_Upper
      70  inv_icm20948_apply_raw_compass_matrix
     536  inv_icm20948_check_akm_self_test
     304  inv_icm20948_compass_dmp_cal
       6  inv_icm20948_compass_getstate
      16  inv_icm20948_compass_isconnected
       8  inv_icm20948_read_akm_scale
      44  inv_icm20948_register_aux_compass
      94  inv_icm20948_resume_akm
     156  inv_icm20948_setup_compass_akm
      52  inv_icm20948_suspend_akm
      62  inv_icm20948_write_akm_scale

 
 1 368 bytes in section .text
 
 1 368 bytes of CODE memory

Errors: none
Warnings: none
