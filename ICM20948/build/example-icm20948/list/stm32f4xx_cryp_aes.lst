###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:34
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\stm32f4xx_cryp_aes.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\stm32f4xx_cryp_aes.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\stm32f4x\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_aes.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_cryp_aes.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    21-October-2015
      7            * @brief   This file provides high level functions to encrypt and decrypt an 
      8            *          input message using AES in ECB/CBC/CTR/GCM/CCM modes.
      9            *          It uses the stm32f4xx_cryp.c/.h drivers to access the STM32F4xx CRYP
     10            *          peripheral.
     11            *          AES-ECB/CBC/CTR/GCM/CCM modes are available on STM32F437x Devices.
     12            *          For STM32F41xx Devices, only AES-ECB/CBC/CTR modes are available.
     13            *
     14          @verbatim
     15           ===================================================================
     16                            ##### How to use this driver #####
     17           ===================================================================
     18           [..]
     19             (#) Enable The CRYP controller clock using 
     20                RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_CRYP, ENABLE); function.
     21            
     22             (#) Encrypt and decrypt using AES in ECB Mode using CRYP_AES_ECB() function.
     23            
     24             (#) Encrypt and decrypt using AES in CBC Mode using CRYP_AES_CBC() function.
     25            
     26             (#) Encrypt and decrypt using AES in CTR Mode using CRYP_AES_CTR() function.
     27          
     28             (#) Encrypt and decrypt using AES in GCM Mode using CRYP_AES_GCM() function.
     29             
     30             (#) Encrypt and decrypt using AES in CCM Mode using CRYP_AES_CCM() function.
     31               
     32          @endverbatim
     33            *
     34            ******************************************************************************
     35            * @attention
     36            *
     37            * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
     38            *
     39            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     40            * You may not use this file except in compliance with the License.
     41            * You may obtain a copy of the License at:
     42            *
     43            *        http://www.st.com/software_license_agreement_liberty_v2
     44            *
     45            * Unless required by applicable law or agreed to in writing, software 
     46            * distributed under the License is distributed on an "AS IS" BASIS, 
     47            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     48            * See the License for the specific language governing permissions and
     49            * limitations under the License.
     50            *
     51            ******************************************************************************  
     52            */
     53          
     54          /* Includes ------------------------------------------------------------------*/
     55          #include "stm32f4xx_cryp.h"
     56          
     57          /** @addtogroup STM32F4xx_StdPeriph_Driver
     58            * @{
     59            */
     60          
     61          /** @defgroup CRYP 
     62            * @brief CRYP driver modules
     63            * @{
     64            */
     65          
     66          /* Private typedef -----------------------------------------------------------*/
     67          /* Private define ------------------------------------------------------------*/
     68          #define AESBUSY_TIMEOUT    ((uint32_t) 0x00010000)
     69          
     70          /* Private macro -------------------------------------------------------------*/
     71          /* Private variables ---------------------------------------------------------*/
     72          /* Private function prototypes -----------------------------------------------*/
     73          /* Private functions ---------------------------------------------------------*/
     74          
     75          /** @defgroup CRYP_Private_Functions
     76            * @{
     77            */ 
     78          
     79          /** @defgroup CRYP_Group6 High Level AES functions
     80           *  @brief   High Level AES functions 
     81           *
     82          @verbatim   
     83           ===============================================================================
     84                                 ##### High Level AES functions #####
     85           ===============================================================================
     86          
     87          @endverbatim
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Encrypt and decrypt using AES in ECB Mode
     93            * @param  Mode: encryption or decryption Mode.
     94            *          This parameter can be one of the following values:
     95            *            @arg MODE_ENCRYPT: Encryption
     96            *            @arg MODE_DECRYPT: Decryption
     97            * @param  Key: Key used for AES algorithm.
     98            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
     99            * @param  Input: pointer to the Input buffer.
    100            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    101            * @param  Output: pointer to the returned buffer.
    102            * @retval An ErrorStatus enumeration value:
    103            *          - SUCCESS: Operation done
    104            *          - ERROR: Operation failed
    105            */

   \                                 In section .text, align 2, keep-with-next
    106          ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
    107                                   uint8_t* Input, uint32_t Ilength, uint8_t* Output)
    108          {
   \                     CRYP_AES_ECB: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB08E             SUB      SP,SP,#+56
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4692             MOV      R10,R2
    109            CRYP_InitTypeDef AES_CRYP_InitStructure;
    110            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    111            __IO uint32_t counter = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    112            uint32_t busystatus = 0;
    113            ErrorStatus status = SUCCESS;
   \   00000010   0x2501             MOVS     R5,#+1
    114            uint32_t keyaddr    = (uint32_t)Key;
    115            uint32_t inputaddr  = (uint32_t)Input;
   \   00000012   0x461C             MOV      R4,R3
    116            uint32_t outputaddr = (uint32_t)Output;
   \   00000014   0x9E17             LDR      R6,[SP, #+92]
    117            uint32_t i = 0;
   \   00000016   0x4607             MOV      R7,R0
    118          
    119            /* Crypto structures initialisation*/
    120            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   00000018   0xA805             ADD      R0,SP,#+20
   \   0000001A   0x.... 0x....      BL       CRYP_KeyStructInit
    121          
    122            switch(Keysize)
   \   0000001E   0xF1BA 0x0F80      CMP      R10,#+128
   \   00000022   0xD006             BEQ.N    ??CRYP_AES_ECB_0
   \   00000024   0xF1BA 0x0FC0      CMP      R10,#+192
   \   00000028   0xD01A             BEQ.N    ??CRYP_AES_ECB_1
   \   0000002A   0xF5BA 0x7F80      CMP      R10,#+256
   \   0000002E   0xD037             BEQ.N    ??CRYP_AES_ECB_2
   \   00000030   0xE05D             B.N      ??CRYP_AES_ECB_3
    123            {
    124              case 128:
    125              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_ECB_0: (+1)
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x9004             STR      R0,[SP, #+16]
    126              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000036   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000003A   0xBA00             REV      R0,R0
   \   0000003C   0x9009             STR      R0,[SP, #+36]
    127              keyaddr+=4;
   \   0000003E   0xF109 0x0004      ADD      R0,R9,#+4
    128              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xBA09             REV      R1,R1
   \   00000046   0x910A             STR      R1,[SP, #+40]
    129              keyaddr+=4;
   \   00000048   0xF100 0x0904      ADD      R9,R0,#+4
    130              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   0000004C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000050   0xBA00             REV      R0,R0
   \   00000052   0x900B             STR      R0,[SP, #+44]
    131              keyaddr+=4;
    132              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000054   0xF109 0x0004      ADD      R0,R9,#+4
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xBA00             REV      R0,R0
   \   0000005C   0x900C             STR      R0,[SP, #+48]
    133              break;
   \   0000005E   0xE046             B.N      ??CRYP_AES_ECB_3
    134              case 192:
    135              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_ECB_1: (+1)
   \   00000060   0xF44F 0x7080      MOV      R0,#+256
   \   00000064   0x9004             STR      R0,[SP, #+16]
    136              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   00000066   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000006A   0xBA00             REV      R0,R0
   \   0000006C   0x9007             STR      R0,[SP, #+28]
    137              keyaddr+=4;
   \   0000006E   0xF109 0x0004      ADD      R0,R9,#+4
    138              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xBA09             REV      R1,R1
   \   00000076   0x9108             STR      R1,[SP, #+32]
    139              keyaddr+=4;
   \   00000078   0x1D00             ADDS     R0,R0,#+4
    140              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0xBA09             REV      R1,R1
   \   0000007E   0x9109             STR      R1,[SP, #+36]
    141              keyaddr+=4;
   \   00000080   0x1D00             ADDS     R0,R0,#+4
    142              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xBA09             REV      R1,R1
   \   00000086   0x910A             STR      R1,[SP, #+40]
    143              keyaddr+=4;
   \   00000088   0xF100 0x0904      ADD      R9,R0,#+4
    144              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   0000008C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000090   0xBA00             REV      R0,R0
   \   00000092   0x900B             STR      R0,[SP, #+44]
    145              keyaddr+=4;
    146              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000094   0xF109 0x0004      ADD      R0,R9,#+4
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0xBA00             REV      R0,R0
   \   0000009C   0x900C             STR      R0,[SP, #+48]
    147              break;
   \   0000009E   0xE026             B.N      ??CRYP_AES_ECB_3
    148              case 256:
    149              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_ECB_2: (+1)
   \   000000A0   0xF44F 0x7000      MOV      R0,#+512
   \   000000A4   0x9004             STR      R0,[SP, #+16]
    150              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   000000A6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000AA   0xBA00             REV      R0,R0
   \   000000AC   0x9005             STR      R0,[SP, #+20]
    151              keyaddr+=4;
   \   000000AE   0xF109 0x0004      ADD      R0,R9,#+4
    152              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   000000B2   0x6801             LDR      R1,[R0, #+0]
   \   000000B4   0xBA09             REV      R1,R1
   \   000000B6   0x9106             STR      R1,[SP, #+24]
    153              keyaddr+=4;
   \   000000B8   0x1D00             ADDS     R0,R0,#+4
    154              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0xBA09             REV      R1,R1
   \   000000BE   0x9107             STR      R1,[SP, #+28]
    155              keyaddr+=4;
   \   000000C0   0x1D00             ADDS     R0,R0,#+4
    156              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000C2   0x6801             LDR      R1,[R0, #+0]
   \   000000C4   0xBA09             REV      R1,R1
   \   000000C6   0x9108             STR      R1,[SP, #+32]
    157              keyaddr+=4;
   \   000000C8   0x1D00             ADDS     R0,R0,#+4
    158              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000CA   0x6801             LDR      R1,[R0, #+0]
   \   000000CC   0xBA09             REV      R1,R1
   \   000000CE   0x9109             STR      R1,[SP, #+36]
    159              keyaddr+=4;
   \   000000D0   0x1D00             ADDS     R0,R0,#+4
    160              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xBA09             REV      R1,R1
   \   000000D6   0x910A             STR      R1,[SP, #+40]
    161              keyaddr+=4;
   \   000000D8   0xF100 0x0904      ADD      R9,R0,#+4
    162              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000DC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000E0   0xBA00             REV      R0,R0
   \   000000E2   0x900B             STR      R0,[SP, #+44]
    163              keyaddr+=4;
    164              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000E4   0xF109 0x0004      ADD      R0,R9,#+4
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0xBA00             REV      R0,R0
   \   000000EC   0x900C             STR      R0,[SP, #+48]
    165              break;
    166              default:
    167              break;
    168            }
    169          
    170            /*------------------ AES Decryption ------------------*/
    171            if(Mode == MODE_DECRYPT) /* AES decryption */
   \                     ??CRYP_AES_ECB_3: (+1)
   \   000000EE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F2   0xD123             BNE.N    ??CRYP_AES_ECB_4
    172            {
    173              /* Flush IN/OUT FIFOs */
    174              CRYP_FIFOFlush();
   \   000000F4   0x.... 0x....      BL       CRYP_FIFOFlush
    175          
    176              /* Crypto Init for Key preparation for decryption process */
    177              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   000000F8   0x2004             MOVS     R0,#+4
   \   000000FA   0x9001             STR      R0,[SP, #+4]
    178              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
   \   000000FC   0x2038             MOVS     R0,#+56
   \   000000FE   0x9002             STR      R0,[SP, #+8]
    179              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
   \   00000100   0x4638             MOV      R0,R7
   \   00000102   0x9003             STR      R0,[SP, #+12]
    180              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000104   0xA801             ADD      R0,SP,#+4
   \   00000106   0x.... 0x....      BL       CRYP_Init
    181          
    182              /* Key Initialisation */
    183              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   0000010A   0xA805             ADD      R0,SP,#+20
   \   0000010C   0x.... 0x....      BL       CRYP_KeyInit
    184          
    185              /* Enable Crypto processor */
    186              CRYP_Cmd(ENABLE);
   \   00000110   0x4628             MOV      R0,R5
   \   00000112   0x.... 0x....      BL       CRYP_Cmd
    187          
    188              /* wait until the Busy flag is RESET */
    189              do
    190              {
    191                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_ECB_5: (+1)
   \   00000116   0x2010             MOVS     R0,#+16
   \   00000118   0x.... 0x....      BL       CRYP_GetFlagStatus
    192                counter++;
   \   0000011C   0x9900             LDR      R1,[SP, #+0]
   \   0000011E   0x1C49             ADDS     R1,R1,#+1
   \   00000120   0x9100             STR      R1,[SP, #+0]
    193              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   00000122   0x9900             LDR      R1,[SP, #+0]
   \   00000124   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000128   0xD001             BEQ.N    ??CRYP_AES_ECB_6
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD1F3             BNE.N    ??CRYP_AES_ECB_5
    194          
    195              if (busystatus != RESET)
   \                     ??CRYP_AES_ECB_6: (+1)
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD001             BEQ.N    ??CRYP_AES_ECB_7
    196             {
    197                 status = ERROR;
   \   00000132   0x463D             MOV      R5,R7
   \   00000134   0xE007             B.N      ??CRYP_AES_ECB_8
    198              }
    199              else
    200              {
    201                /* Crypto Init for decryption process */  
    202                AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_AES_ECB_7: (+1)
   \   00000136   0x2004             MOVS     R0,#+4
   \   00000138   0x9001             STR      R0,[SP, #+4]
   \   0000013A   0xE004             B.N      ??CRYP_AES_ECB_8
    203              }
    204            }
    205            /*------------------ AES Encryption ------------------*/
    206            else /* AES encryption */
    207            {
    208          
    209              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \                     ??CRYP_AES_ECB_4: (+1)
   \   0000013C   0xA805             ADD      R0,SP,#+20
   \   0000013E   0x.... 0x....      BL       CRYP_KeyInit
    210          
    211              /* Crypto Init for Encryption process */
    212              AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
   \   00000142   0x4638             MOV      R0,R7
   \   00000144   0x9001             STR      R0,[SP, #+4]
    213            }
    214          
    215            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
   \                     ??CRYP_AES_ECB_8: (+1)
   \   00000146   0x2020             MOVS     R0,#+32
   \   00000148   0x9002             STR      R0,[SP, #+8]
    216            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   0000014A   0x2080             MOVS     R0,#+128
   \   0000014C   0x9003             STR      R0,[SP, #+12]
    217            CRYP_Init(&AES_CRYP_InitStructure);
   \   0000014E   0xA801             ADD      R0,SP,#+4
   \   00000150   0x.... 0x....      BL       CRYP_Init
    218          
    219            /* Flush IN/OUT FIFOs */
    220            CRYP_FIFOFlush();
   \   00000154   0x.... 0x....      BL       CRYP_FIFOFlush
    221          
    222            /* Enable Crypto processor */
    223            CRYP_Cmd(ENABLE);
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0x.... 0x....      BL       CRYP_Cmd
    224          
    225            if(CRYP_GetCmdStatus() == DISABLE)
   \   0000015E   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD13F             BNE.N    ??CRYP_AES_ECB_9
    226            {
    227              /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    228                 the CRYP peripheral (please check the device sales type. */
    229              return(ERROR);
   \   00000166   0x4638             MOV      R0,R7
   \   00000168   0xE03A             B.N      ??CRYP_AES_ECB_10
    230            }
    231            
    232            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
    233            {
    234          
    235              /* Write the Input block in the IN FIFO */
    236              CRYP_DataIn(*(uint32_t*)(inputaddr));
    237              inputaddr+=4;
    238              CRYP_DataIn(*(uint32_t*)(inputaddr));
    239              inputaddr+=4;
    240              CRYP_DataIn(*(uint32_t*)(inputaddr));
    241              inputaddr+=4;
    242              CRYP_DataIn(*(uint32_t*)(inputaddr));
    243              inputaddr+=4;
    244          
    245              /* Wait until the complete message has been processed */
    246              counter = 0;
    247              do
    248              {
    249                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    250                counter++;
    251              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    252          
    253              if (busystatus != RESET)
    254             {
    255                 status = ERROR;
    256              }
    257              else
    258              {
    259          
    260                /* Read the Output block from the Output FIFO */
    261                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_ECB_11: (+1)
   \   0000016A   0x.... 0x....      BL       CRYP_DataOut
   \   0000016E   0x6030             STR      R0,[R6, #+0]
    262                outputaddr+=4;
   \   00000170   0x1D36             ADDS     R6,R6,#+4
    263                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000172   0x.... 0x....      BL       CRYP_DataOut
   \   00000176   0x6030             STR      R0,[R6, #+0]
    264                outputaddr+=4;
   \   00000178   0x1D36             ADDS     R6,R6,#+4
    265                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000017A   0x.... 0x....      BL       CRYP_DataOut
   \   0000017E   0x6030             STR      R0,[R6, #+0]
    266                outputaddr+=4;
   \   00000180   0x1D36             ADDS     R6,R6,#+4
    267                *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
   \   00000182   0x.... 0x....      BL       CRYP_DataOut
   \   00000186   0x6030             STR      R0,[R6, #+0]
    268                outputaddr+=4;
   \   00000188   0x1D36             ADDS     R6,R6,#+4
    269              }
   \                     ??CRYP_AES_ECB_12: (+1)
   \   0000018A   0x3710             ADDS     R7,R7,#+16
   \                     ??CRYP_AES_ECB_13: (+1)
   \   0000018C   0x4547             CMP      R7,R8
   \   0000018E   0xD223             BCS.N    ??CRYP_AES_ECB_14
   \   00000190   0x0028             MOVS     R0,R5
   \   00000192   0xD021             BEQ.N    ??CRYP_AES_ECB_14
   \   00000194   0x6820             LDR      R0,[R4, #+0]
   \   00000196   0x.... 0x....      BL       CRYP_DataIn
   \   0000019A   0x1D24             ADDS     R4,R4,#+4
   \   0000019C   0x6820             LDR      R0,[R4, #+0]
   \   0000019E   0x.... 0x....      BL       CRYP_DataIn
   \   000001A2   0x1D24             ADDS     R4,R4,#+4
   \   000001A4   0x6820             LDR      R0,[R4, #+0]
   \   000001A6   0x.... 0x....      BL       CRYP_DataIn
   \   000001AA   0x1D24             ADDS     R4,R4,#+4
   \   000001AC   0x6820             LDR      R0,[R4, #+0]
   \   000001AE   0x.... 0x....      BL       CRYP_DataIn
   \   000001B2   0x1D24             ADDS     R4,R4,#+4
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_ECB_15: (+1)
   \   000001B8   0x2010             MOVS     R0,#+16
   \   000001BA   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000001BE   0x9900             LDR      R1,[SP, #+0]
   \   000001C0   0x1C49             ADDS     R1,R1,#+1
   \   000001C2   0x9100             STR      R1,[SP, #+0]
   \   000001C4   0x9900             LDR      R1,[SP, #+0]
   \   000001C6   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001CA   0xD001             BEQ.N    ??CRYP_AES_ECB_16
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD1F3             BNE.N    ??CRYP_AES_ECB_15
   \                     ??CRYP_AES_ECB_16: (+1)
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD0CA             BEQ.N    ??CRYP_AES_ECB_11
   \   000001D4   0x2500             MOVS     R5,#+0
   \   000001D6   0xE7D8             B.N      ??CRYP_AES_ECB_12
    270            }
    271          
    272            /* Disable Crypto */
    273            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_ECB_14: (+1)
   \   000001D8   0x2000             MOVS     R0,#+0
   \   000001DA   0x.... 0x....      BL       CRYP_Cmd
    274          
    275            return status; 
   \   000001DE   0x4628             MOV      R0,R5
   \                     ??CRYP_AES_ECB_10: (+1)
   \   000001E0   0xB00E             ADD      SP,SP,#+56
   \   000001E2   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??CRYP_AES_ECB_9: (+1)
   \   000001E6   0xF8DD 0x8058      LDR      R8,[SP, #+88]
   \   000001EA   0xE7CF             B.N      ??CRYP_AES_ECB_13
    276          }
    277          
    278          /**
    279            * @brief  Encrypt and decrypt using AES in CBC Mode
    280            * @param  Mode: encryption or decryption Mode.
    281            *          This parameter can be one of the following values:
    282            *            @arg MODE_ENCRYPT: Encryption
    283            *            @arg MODE_DECRYPT: Decryption
    284            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    285            * @param  Key: Key used for AES algorithm.
    286            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    287            * @param  Input: pointer to the Input buffer.
    288            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    289            * @param  Output: pointer to the returned buffer.
    290            * @retval An ErrorStatus enumeration value:
    291            *          - SUCCESS: Operation done
    292            *          - ERROR: Operation failed
    293            */

   \                                 In section .text, align 2, keep-with-next
    294          ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
    295                                   uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
    296                                   uint8_t *Output)
    297          {
   \                     CRYP_AES_CBC: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x468A             MOV      R10,R1
   \   0000000A   0x469B             MOV      R11,R3
    298            CRYP_InitTypeDef AES_CRYP_InitStructure;
    299            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    300            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    301            __IO uint32_t counter = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    302            uint32_t busystatus = 0;
    303            ErrorStatus status = SUCCESS;
   \   00000010   0x2501             MOVS     R5,#+1
    304            uint32_t keyaddr    = (uint32_t)Key;
   \   00000012   0x4614             MOV      R4,R2
    305            uint32_t inputaddr  = (uint32_t)Input;
   \   00000014   0x9E1A             LDR      R6,[SP, #+104]
    306            uint32_t outputaddr = (uint32_t)Output;
   \   00000016   0x9F1C             LDR      R7,[SP, #+112]
    307            uint32_t ivaddr = (uint32_t)InitVectors;
    308            uint32_t i = 0;
   \   00000018   0x4680             MOV      R8,R0
    309          
    310            /* Crypto structures initialisation*/
    311            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   0000001A   0xA805             ADD      R0,SP,#+20
   \   0000001C   0x.... 0x....      BL       CRYP_KeyStructInit
    312          
    313            switch(Keysize)
   \   00000020   0xF1BB 0x0F80      CMP      R11,#+128
   \   00000024   0xD006             BEQ.N    ??CRYP_AES_CBC_0
   \   00000026   0xF1BB 0x0FC0      CMP      R11,#+192
   \   0000002A   0xD015             BEQ.N    ??CRYP_AES_CBC_1
   \   0000002C   0xF5BB 0x7F80      CMP      R11,#+256
   \   00000030   0xD02D             BEQ.N    ??CRYP_AES_CBC_2
   \   00000032   0xE04E             B.N      ??CRYP_AES_CBC_3
    314            {
    315              case 128:
    316              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CBC_0: (+1)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x9004             STR      R0,[SP, #+16]
    317              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0xBA00             REV      R0,R0
   \   0000003C   0x9009             STR      R0,[SP, #+36]
    318              keyaddr+=4;
   \   0000003E   0x1D20             ADDS     R0,R4,#+4
    319              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xBA09             REV      R1,R1
   \   00000044   0x910A             STR      R1,[SP, #+40]
    320              keyaddr+=4;
   \   00000046   0x1D04             ADDS     R4,R0,#+4
    321              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0xBA00             REV      R0,R0
   \   0000004C   0x900B             STR      R0,[SP, #+44]
    322              keyaddr+=4;
    323              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000004E   0x1D20             ADDS     R0,R4,#+4
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xBA00             REV      R0,R0
   \   00000054   0x900C             STR      R0,[SP, #+48]
    324              break;
   \   00000056   0xE03C             B.N      ??CRYP_AES_CBC_3
    325              case 192:
    326              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CBC_1: (+1)
   \   00000058   0xF44F 0x7080      MOV      R0,#+256
   \   0000005C   0x9004             STR      R0,[SP, #+16]
    327              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xBA00             REV      R0,R0
   \   00000062   0x9007             STR      R0,[SP, #+28]
    328              keyaddr+=4;
   \   00000064   0x1D20             ADDS     R0,R4,#+4
    329              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xBA09             REV      R1,R1
   \   0000006A   0x9108             STR      R1,[SP, #+32]
    330              keyaddr+=4;
   \   0000006C   0x1D00             ADDS     R0,R0,#+4
    331              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xBA09             REV      R1,R1
   \   00000072   0x9109             STR      R1,[SP, #+36]
    332              keyaddr+=4;
   \   00000074   0x1D00             ADDS     R0,R0,#+4
    333              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xBA09             REV      R1,R1
   \   0000007A   0x910A             STR      R1,[SP, #+40]
    334              keyaddr+=4;
   \   0000007C   0x1D04             ADDS     R4,R0,#+4
    335              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0xBA00             REV      R0,R0
   \   00000082   0x900B             STR      R0,[SP, #+44]
    336              keyaddr+=4;
    337              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000084   0x1D20             ADDS     R0,R4,#+4
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xBA00             REV      R0,R0
   \   0000008A   0x900C             STR      R0,[SP, #+48]
    338              break;
   \   0000008C   0xE021             B.N      ??CRYP_AES_CBC_3
    339              case 256:
    340              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CBC_2: (+1)
   \   0000008E   0xF44F 0x7000      MOV      R0,#+512
   \   00000092   0x9004             STR      R0,[SP, #+16]
    341              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0xBA00             REV      R0,R0
   \   00000098   0x9005             STR      R0,[SP, #+20]
    342              keyaddr+=4;
   \   0000009A   0x1D20             ADDS     R0,R4,#+4
    343              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0xBA09             REV      R1,R1
   \   000000A0   0x9106             STR      R1,[SP, #+24]
    344              keyaddr+=4;
   \   000000A2   0x1D00             ADDS     R0,R0,#+4
    345              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xBA09             REV      R1,R1
   \   000000A8   0x9107             STR      R1,[SP, #+28]
    346              keyaddr+=4;
   \   000000AA   0x1D00             ADDS     R0,R0,#+4
    347              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xBA09             REV      R1,R1
   \   000000B0   0x9108             STR      R1,[SP, #+32]
    348              keyaddr+=4;
   \   000000B2   0x1D00             ADDS     R0,R0,#+4
    349              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0xBA09             REV      R1,R1
   \   000000B8   0x9109             STR      R1,[SP, #+36]
    350              keyaddr+=4;
   \   000000BA   0x1D00             ADDS     R0,R0,#+4
    351              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000BC   0x6801             LDR      R1,[R0, #+0]
   \   000000BE   0xBA09             REV      R1,R1
   \   000000C0   0x910A             STR      R1,[SP, #+40]
    352              keyaddr+=4;
   \   000000C2   0x1D04             ADDS     R4,R0,#+4
    353              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0xBA00             REV      R0,R0
   \   000000C8   0x900B             STR      R0,[SP, #+44]
    354              keyaddr+=4;
    355              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000CA   0x1D20             ADDS     R0,R4,#+4
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0xBA00             REV      R0,R0
   \   000000D0   0x900C             STR      R0,[SP, #+48]
    356              break;
    357              default:
    358              break;
    359            }
    360          
    361            /* CRYP Initialization Vectors */
    362            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_CBC_3: (+1)
   \   000000D2   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000D6   0xBA00             REV      R0,R0
   \   000000D8   0x900D             STR      R0,[SP, #+52]
    363            ivaddr+=4;
   \   000000DA   0xF10A 0x0004      ADD      R0,R10,#+4
    364            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0xBA09             REV      R1,R1
   \   000000E2   0x910E             STR      R1,[SP, #+56]
    365            ivaddr+=4;
   \   000000E4   0x1D00             ADDS     R0,R0,#+4
    366            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0xBA09             REV      R1,R1
   \   000000EA   0x910F             STR      R1,[SP, #+60]
    367            ivaddr+=4;
    368            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \   000000EC   0x1D00             ADDS     R0,R0,#+4
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xBA00             REV      R0,R0
   \   000000F2   0x9010             STR      R0,[SP, #+64]
    369          
    370          
    371            /*------------------ AES Decryption ------------------*/
    372            if(Mode == MODE_DECRYPT) /* AES decryption */
   \   000000F4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F8   0xD123             BNE.N    ??CRYP_AES_CBC_4
    373            {
    374              /* Flush IN/OUT FIFOs */
    375              CRYP_FIFOFlush();
   \   000000FA   0x.... 0x....      BL       CRYP_FIFOFlush
    376          
    377              /* Crypto Init for Key preparation for decryption process */
    378              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   000000FE   0x2004             MOVS     R0,#+4
   \   00000100   0x9001             STR      R0,[SP, #+4]
    379              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
   \   00000102   0x2038             MOVS     R0,#+56
   \   00000104   0x9002             STR      R0,[SP, #+8]
    380              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
   \   00000106   0x4640             MOV      R0,R8
   \   00000108   0x9003             STR      R0,[SP, #+12]
    381          
    382              CRYP_Init(&AES_CRYP_InitStructure);
   \   0000010A   0xA801             ADD      R0,SP,#+4
   \   0000010C   0x.... 0x....      BL       CRYP_Init
    383          
    384              /* Key Initialisation */
    385              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   00000110   0xA805             ADD      R0,SP,#+20
   \   00000112   0x.... 0x....      BL       CRYP_KeyInit
    386          
    387              /* Enable Crypto processor */
    388              CRYP_Cmd(ENABLE);
   \   00000116   0x4628             MOV      R0,R5
   \   00000118   0x.... 0x....      BL       CRYP_Cmd
    389          
    390              /* wait until the Busy flag is RESET */
    391              do
    392              {
    393                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CBC_5: (+1)
   \   0000011C   0x2010             MOVS     R0,#+16
   \   0000011E   0x.... 0x....      BL       CRYP_GetFlagStatus
    394                counter++;
   \   00000122   0x9900             LDR      R1,[SP, #+0]
   \   00000124   0x1C49             ADDS     R1,R1,#+1
   \   00000126   0x9100             STR      R1,[SP, #+0]
    395              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   00000128   0x9900             LDR      R1,[SP, #+0]
   \   0000012A   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000012E   0xD001             BEQ.N    ??CRYP_AES_CBC_6
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD1F3             BNE.N    ??CRYP_AES_CBC_5
    396          
    397              if (busystatus != RESET)
   \                     ??CRYP_AES_CBC_6: (+1)
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD001             BEQ.N    ??CRYP_AES_CBC_7
    398             {
    399                 status = ERROR;
   \   00000138   0x4645             MOV      R5,R8
   \   0000013A   0xE007             B.N      ??CRYP_AES_CBC_8
    400              }
    401              else
    402              {
    403                /* Crypto Init for decryption process */  
    404                AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \                     ??CRYP_AES_CBC_7: (+1)
   \   0000013C   0x2004             MOVS     R0,#+4
   \   0000013E   0x9001             STR      R0,[SP, #+4]
   \   00000140   0xE004             B.N      ??CRYP_AES_CBC_8
    405              }
    406            }
    407            /*------------------ AES Encryption ------------------*/
    408            else /* AES encryption */
    409            {
    410              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \                     ??CRYP_AES_CBC_4: (+1)
   \   00000142   0xA805             ADD      R0,SP,#+20
   \   00000144   0x.... 0x....      BL       CRYP_KeyInit
    411          
    412              /* Crypto Init for Encryption process */
    413              AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
   \   00000148   0x4640             MOV      R0,R8
   \   0000014A   0x9001             STR      R0,[SP, #+4]
    414            }
    415            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
   \                     ??CRYP_AES_CBC_8: (+1)
   \   0000014C   0x2028             MOVS     R0,#+40
   \   0000014E   0x9002             STR      R0,[SP, #+8]
    416            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000150   0x2080             MOVS     R0,#+128
   \   00000152   0x9003             STR      R0,[SP, #+12]
    417            CRYP_Init(&AES_CRYP_InitStructure);
   \   00000154   0xA801             ADD      R0,SP,#+4
   \   00000156   0x.... 0x....      BL       CRYP_Init
    418          
    419            /* CRYP Initialization Vectors */
    420            CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   0000015A   0xA80D             ADD      R0,SP,#+52
   \   0000015C   0x.... 0x....      BL       CRYP_IVInit
    421          
    422            /* Flush IN/OUT FIFOs */
    423            CRYP_FIFOFlush();
   \   00000160   0x.... 0x....      BL       CRYP_FIFOFlush
    424          
    425            /* Enable Crypto processor */
    426            CRYP_Cmd(ENABLE);
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0x.... 0x....      BL       CRYP_Cmd
    427          
    428            if(CRYP_GetCmdStatus() == DISABLE)
   \   0000016A   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD140             BNE.N    ??CRYP_AES_CBC_9
    429            {
    430              /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    431                 the CRYP peripheral (please check the device sales type. */
    432              return(ERROR);
   \   00000172   0x4640             MOV      R0,R8
   \   00000174   0xE03B             B.N      ??CRYP_AES_CBC_10
    433            }
    434            
    435            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
    436            {
    437          
    438              /* Write the Input block in the IN FIFO */
    439              CRYP_DataIn(*(uint32_t*)(inputaddr));
    440              inputaddr+=4;
    441              CRYP_DataIn(*(uint32_t*)(inputaddr));
    442              inputaddr+=4;
    443              CRYP_DataIn(*(uint32_t*)(inputaddr));
    444              inputaddr+=4;
    445              CRYP_DataIn(*(uint32_t*)(inputaddr));
    446              inputaddr+=4;
    447              /* Wait until the complete message has been processed */
    448              counter = 0;
    449              do
    450              {
    451                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    452                counter++;
    453              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    454          
    455              if (busystatus != RESET)
    456             {
    457                 status = ERROR;
    458              }
    459              else
    460              {
    461          
    462                /* Read the Output block from the Output FIFO */
    463                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_CBC_11: (+1)
   \   00000176   0x.... 0x....      BL       CRYP_DataOut
   \   0000017A   0x6038             STR      R0,[R7, #+0]
    464                outputaddr+=4;
   \   0000017C   0x1D3F             ADDS     R7,R7,#+4
    465                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000017E   0x.... 0x....      BL       CRYP_DataOut
   \   00000182   0x6038             STR      R0,[R7, #+0]
    466                outputaddr+=4;
   \   00000184   0x1D3F             ADDS     R7,R7,#+4
    467                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000186   0x.... 0x....      BL       CRYP_DataOut
   \   0000018A   0x6038             STR      R0,[R7, #+0]
    468                outputaddr+=4;
   \   0000018C   0x1D3F             ADDS     R7,R7,#+4
    469                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000018E   0x.... 0x....      BL       CRYP_DataOut
   \   00000192   0x6038             STR      R0,[R7, #+0]
    470                outputaddr+=4;
   \   00000194   0x1D3F             ADDS     R7,R7,#+4
    471              }
   \                     ??CRYP_AES_CBC_12: (+1)
   \   00000196   0xF108 0x0810      ADD      R8,R8,#+16
   \                     ??CRYP_AES_CBC_13: (+1)
   \   0000019A   0x45A0             CMP      R8,R4
   \   0000019C   0xD223             BCS.N    ??CRYP_AES_CBC_14
   \   0000019E   0x0028             MOVS     R0,R5
   \   000001A0   0xD021             BEQ.N    ??CRYP_AES_CBC_14
   \   000001A2   0x6830             LDR      R0,[R6, #+0]
   \   000001A4   0x.... 0x....      BL       CRYP_DataIn
   \   000001A8   0x1D36             ADDS     R6,R6,#+4
   \   000001AA   0x6830             LDR      R0,[R6, #+0]
   \   000001AC   0x.... 0x....      BL       CRYP_DataIn
   \   000001B0   0x1D36             ADDS     R6,R6,#+4
   \   000001B2   0x6830             LDR      R0,[R6, #+0]
   \   000001B4   0x.... 0x....      BL       CRYP_DataIn
   \   000001B8   0x1D36             ADDS     R6,R6,#+4
   \   000001BA   0x6830             LDR      R0,[R6, #+0]
   \   000001BC   0x.... 0x....      BL       CRYP_DataIn
   \   000001C0   0x1D36             ADDS     R6,R6,#+4
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CBC_15: (+1)
   \   000001C6   0x2010             MOVS     R0,#+16
   \   000001C8   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000001CC   0x9900             LDR      R1,[SP, #+0]
   \   000001CE   0x1C49             ADDS     R1,R1,#+1
   \   000001D0   0x9100             STR      R1,[SP, #+0]
   \   000001D2   0x9900             LDR      R1,[SP, #+0]
   \   000001D4   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001D8   0xD001             BEQ.N    ??CRYP_AES_CBC_16
   \   000001DA   0x2800             CMP      R0,#+0
   \   000001DC   0xD1F3             BNE.N    ??CRYP_AES_CBC_15
   \                     ??CRYP_AES_CBC_16: (+1)
   \   000001DE   0x2800             CMP      R0,#+0
   \   000001E0   0xD0C9             BEQ.N    ??CRYP_AES_CBC_11
   \   000001E2   0x2500             MOVS     R5,#+0
   \   000001E4   0xE7D7             B.N      ??CRYP_AES_CBC_12
    472            }
    473          
    474            /* Disable Crypto */
    475            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_CBC_14: (+1)
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0x.... 0x....      BL       CRYP_Cmd
    476          
    477            return status;
   \   000001EC   0x4628             MOV      R0,R5
   \                     ??CRYP_AES_CBC_10: (+1)
   \   000001EE   0xB011             ADD      SP,SP,#+68
   \   000001F0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??CRYP_AES_CBC_9: (+1)
   \   000001F4   0x9C1B             LDR      R4,[SP, #+108]
   \   000001F6   0xE7D0             B.N      ??CRYP_AES_CBC_13
    478          }
    479          
    480          /**
    481            * @brief  Encrypt and decrypt using AES in CTR Mode
    482            * @param  Mode: encryption or decryption Mode.
    483            *           This parameter can be one of the following values:
    484            *            @arg MODE_ENCRYPT: Encryption
    485            *            @arg MODE_DECRYPT: Decryption
    486            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    487            * @param  Key: Key used for AES algorithm.
    488            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    489            * @param  Input: pointer to the Input buffer.
    490            * @param  Ilength: length of the Input buffer, must be a multiple of 16.
    491            * @param  Output: pointer to the returned buffer.
    492            * @retval An ErrorStatus enumeration value:
    493            *          - SUCCESS: Operation done
    494            *          - ERROR: Operation failed
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
    497                                   uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
    498                                   uint8_t *Output)
    499          {
   \                     CRYP_AES_CTR: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x468A             MOV      R10,R1
   \   0000000A   0x469B             MOV      R11,R3
    500            CRYP_InitTypeDef AES_CRYP_InitStructure;
    501            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    502            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    503            __IO uint32_t counter = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    504            uint32_t busystatus = 0;
    505            ErrorStatus status = SUCCESS;
   \   00000010   0x2501             MOVS     R5,#+1
    506            uint32_t keyaddr    = (uint32_t)Key;
   \   00000012   0x4614             MOV      R4,R2
    507            uint32_t inputaddr  = (uint32_t)Input;
   \   00000014   0x9E1A             LDR      R6,[SP, #+104]
    508            uint32_t outputaddr = (uint32_t)Output;
   \   00000016   0x9F1C             LDR      R7,[SP, #+112]
    509            uint32_t ivaddr     = (uint32_t)InitVectors;
    510            uint32_t i = 0;
   \   00000018   0x4680             MOV      R8,R0
    511          
    512            /* Crypto structures initialisation*/
    513            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   0000001A   0xA801             ADD      R0,SP,#+4
   \   0000001C   0x.... 0x....      BL       CRYP_KeyStructInit
    514          
    515            switch(Keysize)
   \   00000020   0xF1BB 0x0F80      CMP      R11,#+128
   \   00000024   0xD006             BEQ.N    ??CRYP_AES_CTR_0
   \   00000026   0xF1BB 0x0FC0      CMP      R11,#+192
   \   0000002A   0xD015             BEQ.N    ??CRYP_AES_CTR_1
   \   0000002C   0xF5BB 0x7F80      CMP      R11,#+256
   \   00000030   0xD02D             BEQ.N    ??CRYP_AES_CTR_2
   \   00000032   0xE04E             B.N      ??CRYP_AES_CTR_3
    516            {
    517              case 128:
    518              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CTR_0: (+1)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x900C             STR      R0,[SP, #+48]
    519              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0xBA00             REV      R0,R0
   \   0000003C   0x9005             STR      R0,[SP, #+20]
    520              keyaddr+=4;
   \   0000003E   0x1D20             ADDS     R0,R4,#+4
    521              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xBA09             REV      R1,R1
   \   00000044   0x9106             STR      R1,[SP, #+24]
    522              keyaddr+=4;
   \   00000046   0x1D04             ADDS     R4,R0,#+4
    523              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0xBA00             REV      R0,R0
   \   0000004C   0x9007             STR      R0,[SP, #+28]
    524              keyaddr+=4;
    525              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000004E   0x1D20             ADDS     R0,R4,#+4
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xBA00             REV      R0,R0
   \   00000054   0x9008             STR      R0,[SP, #+32]
    526              break;
   \   00000056   0xE03C             B.N      ??CRYP_AES_CTR_3
    527              case 192:
    528              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CTR_1: (+1)
   \   00000058   0xF44F 0x7080      MOV      R0,#+256
   \   0000005C   0x900C             STR      R0,[SP, #+48]
    529              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xBA00             REV      R0,R0
   \   00000062   0x9003             STR      R0,[SP, #+12]
    530              keyaddr+=4;
   \   00000064   0x1D20             ADDS     R0,R4,#+4
    531              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xBA09             REV      R1,R1
   \   0000006A   0x9104             STR      R1,[SP, #+16]
    532              keyaddr+=4;
   \   0000006C   0x1D00             ADDS     R0,R0,#+4
    533              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xBA09             REV      R1,R1
   \   00000072   0x9105             STR      R1,[SP, #+20]
    534              keyaddr+=4;
   \   00000074   0x1D00             ADDS     R0,R0,#+4
    535              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xBA09             REV      R1,R1
   \   0000007A   0x9106             STR      R1,[SP, #+24]
    536              keyaddr+=4;
   \   0000007C   0x1D04             ADDS     R4,R0,#+4
    537              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0xBA00             REV      R0,R0
   \   00000082   0x9007             STR      R0,[SP, #+28]
    538              keyaddr+=4;
    539              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000084   0x1D20             ADDS     R0,R4,#+4
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xBA00             REV      R0,R0
   \   0000008A   0x9008             STR      R0,[SP, #+32]
    540              break;
   \   0000008C   0xE021             B.N      ??CRYP_AES_CTR_3
    541              case 256:
    542              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CTR_2: (+1)
   \   0000008E   0xF44F 0x7000      MOV      R0,#+512
   \   00000092   0x900C             STR      R0,[SP, #+48]
    543              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0xBA00             REV      R0,R0
   \   00000098   0x9001             STR      R0,[SP, #+4]
    544              keyaddr+=4;
   \   0000009A   0x1D20             ADDS     R0,R4,#+4
    545              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0xBA09             REV      R1,R1
   \   000000A0   0x9102             STR      R1,[SP, #+8]
    546              keyaddr+=4;
   \   000000A2   0x1D00             ADDS     R0,R0,#+4
    547              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0xBA09             REV      R1,R1
   \   000000A8   0x9103             STR      R1,[SP, #+12]
    548              keyaddr+=4;
   \   000000AA   0x1D00             ADDS     R0,R0,#+4
    549              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xBA09             REV      R1,R1
   \   000000B0   0x9104             STR      R1,[SP, #+16]
    550              keyaddr+=4;
   \   000000B2   0x1D00             ADDS     R0,R0,#+4
    551              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0xBA09             REV      R1,R1
   \   000000B8   0x9105             STR      R1,[SP, #+20]
    552              keyaddr+=4;
   \   000000BA   0x1D00             ADDS     R0,R0,#+4
    553              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000BC   0x6801             LDR      R1,[R0, #+0]
   \   000000BE   0xBA09             REV      R1,R1
   \   000000C0   0x9106             STR      R1,[SP, #+24]
    554              keyaddr+=4;
   \   000000C2   0x1D04             ADDS     R4,R0,#+4
    555              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0xBA00             REV      R0,R0
   \   000000C8   0x9007             STR      R0,[SP, #+28]
    556              keyaddr+=4;
    557              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000CA   0x1D20             ADDS     R0,R4,#+4
   \   000000CC   0x6800             LDR      R0,[R0, #+0]
   \   000000CE   0xBA00             REV      R0,R0
   \   000000D0   0x9008             STR      R0,[SP, #+32]
    558              break;
    559              default:
    560              break;
    561            }
    562            /* CRYP Initialization Vectors */
    563            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_CTR_3: (+1)
   \   000000D2   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000000D6   0xBA00             REV      R0,R0
   \   000000D8   0x900D             STR      R0,[SP, #+52]
    564            ivaddr+=4;
   \   000000DA   0xF10A 0x0004      ADD      R0,R10,#+4
    565            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0xBA09             REV      R1,R1
   \   000000E2   0x910E             STR      R1,[SP, #+56]
    566            ivaddr+=4;
   \   000000E4   0x1D00             ADDS     R0,R0,#+4
    567            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \   000000E6   0x6801             LDR      R1,[R0, #+0]
   \   000000E8   0xBA09             REV      R1,R1
   \   000000EA   0x910F             STR      R1,[SP, #+60]
    568            ivaddr+=4;
    569            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \   000000EC   0x1D00             ADDS     R0,R0,#+4
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xBA00             REV      R0,R0
   \   000000F2   0x9010             STR      R0,[SP, #+64]
    570          
    571            /* Key Initialisation */
    572            CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   000000F4   0xA801             ADD      R0,SP,#+4
   \   000000F6   0x.... 0x....      BL       CRYP_KeyInit
    573          
    574            /*------------------ AES Decryption ------------------*/
    575            if(Mode == MODE_DECRYPT) /* AES decryption */
   \   000000FA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000FE   0xD102             BNE.N    ??CRYP_AES_CTR_4
    576            {
    577              /* Crypto Init for decryption process */
    578              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   00000100   0x2004             MOVS     R0,#+4
   \   00000102   0x9009             STR      R0,[SP, #+36]
   \   00000104   0xE001             B.N      ??CRYP_AES_CTR_5
    579            }
    580            /*------------------ AES Encryption ------------------*/
    581            else /* AES encryption */
    582            {
    583              /* Crypto Init for Encryption process */
    584              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \                     ??CRYP_AES_CTR_4: (+1)
   \   00000106   0x4640             MOV      R0,R8
   \   00000108   0x9009             STR      R0,[SP, #+36]
    585            }
    586            AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
   \                     ??CRYP_AES_CTR_5: (+1)
   \   0000010A   0x2030             MOVS     R0,#+48
   \   0000010C   0x900A             STR      R0,[SP, #+40]
    587            AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   0000010E   0x2080             MOVS     R0,#+128
   \   00000110   0x900B             STR      R0,[SP, #+44]
    588            CRYP_Init(&AES_CRYP_InitStructure);
   \   00000112   0xA809             ADD      R0,SP,#+36
   \   00000114   0x.... 0x....      BL       CRYP_Init
    589          
    590            /* CRYP Initialization Vectors */
    591            CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000118   0xA80D             ADD      R0,SP,#+52
   \   0000011A   0x.... 0x....      BL       CRYP_IVInit
    592          
    593            /* Flush IN/OUT FIFOs */
    594            CRYP_FIFOFlush();
   \   0000011E   0x.... 0x....      BL       CRYP_FIFOFlush
    595          
    596            /* Enable Crypto processor */
    597            CRYP_Cmd(ENABLE);
   \   00000122   0x4628             MOV      R0,R5
   \   00000124   0x.... 0x....      BL       CRYP_Cmd
    598          
    599            if(CRYP_GetCmdStatus() == DISABLE)
   \   00000128   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD140             BNE.N    ??CRYP_AES_CTR_6
    600            {
    601              /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    602                 the CRYP peripheral (please check the device sales type. */
    603              return(ERROR);
   \   00000130   0x4640             MOV      R0,R8
   \   00000132   0xE03B             B.N      ??CRYP_AES_CTR_7
    604            }
    605            
    606            for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
    607            {
    608          
    609              /* Write the Input block in the IN FIFO */
    610              CRYP_DataIn(*(uint32_t*)(inputaddr));
    611              inputaddr+=4;
    612              CRYP_DataIn(*(uint32_t*)(inputaddr));
    613              inputaddr+=4;
    614              CRYP_DataIn(*(uint32_t*)(inputaddr));
    615              inputaddr+=4;
    616              CRYP_DataIn(*(uint32_t*)(inputaddr));
    617              inputaddr+=4;
    618              /* Wait until the complete message has been processed */
    619              counter = 0;
    620              do
    621              {
    622                busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    623                counter++;
    624              }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    625          
    626              if (busystatus != RESET)
    627             {
    628                 status = ERROR;
    629              }
    630              else
    631              {
    632          
    633                /* Read the Output block from the Output FIFO */
    634                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \                     ??CRYP_AES_CTR_8: (+1)
   \   00000134   0x.... 0x....      BL       CRYP_DataOut
   \   00000138   0x6038             STR      R0,[R7, #+0]
    635                outputaddr+=4;
   \   0000013A   0x1D3F             ADDS     R7,R7,#+4
    636                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000013C   0x.... 0x....      BL       CRYP_DataOut
   \   00000140   0x6038             STR      R0,[R7, #+0]
    637                outputaddr+=4;
   \   00000142   0x1D3F             ADDS     R7,R7,#+4
    638                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000144   0x.... 0x....      BL       CRYP_DataOut
   \   00000148   0x6038             STR      R0,[R7, #+0]
    639                outputaddr+=4;
   \   0000014A   0x1D3F             ADDS     R7,R7,#+4
    640                *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000014C   0x.... 0x....      BL       CRYP_DataOut
   \   00000150   0x6038             STR      R0,[R7, #+0]
    641                outputaddr+=4;
   \   00000152   0x1D3F             ADDS     R7,R7,#+4
    642              }
   \                     ??CRYP_AES_CTR_9: (+1)
   \   00000154   0xF108 0x0810      ADD      R8,R8,#+16
   \                     ??CRYP_AES_CTR_10: (+1)
   \   00000158   0x45A0             CMP      R8,R4
   \   0000015A   0xD223             BCS.N    ??CRYP_AES_CTR_11
   \   0000015C   0x0028             MOVS     R0,R5
   \   0000015E   0xD021             BEQ.N    ??CRYP_AES_CTR_11
   \   00000160   0x6830             LDR      R0,[R6, #+0]
   \   00000162   0x.... 0x....      BL       CRYP_DataIn
   \   00000166   0x1D36             ADDS     R6,R6,#+4
   \   00000168   0x6830             LDR      R0,[R6, #+0]
   \   0000016A   0x.... 0x....      BL       CRYP_DataIn
   \   0000016E   0x1D36             ADDS     R6,R6,#+4
   \   00000170   0x6830             LDR      R0,[R6, #+0]
   \   00000172   0x.... 0x....      BL       CRYP_DataIn
   \   00000176   0x1D36             ADDS     R6,R6,#+4
   \   00000178   0x6830             LDR      R0,[R6, #+0]
   \   0000017A   0x.... 0x....      BL       CRYP_DataIn
   \   0000017E   0x1D36             ADDS     R6,R6,#+4
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CTR_12: (+1)
   \   00000184   0x2010             MOVS     R0,#+16
   \   00000186   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000018A   0x9900             LDR      R1,[SP, #+0]
   \   0000018C   0x1C49             ADDS     R1,R1,#+1
   \   0000018E   0x9100             STR      R1,[SP, #+0]
   \   00000190   0x9900             LDR      R1,[SP, #+0]
   \   00000192   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000196   0xD001             BEQ.N    ??CRYP_AES_CTR_13
   \   00000198   0x2800             CMP      R0,#+0
   \   0000019A   0xD1F3             BNE.N    ??CRYP_AES_CTR_12
   \                     ??CRYP_AES_CTR_13: (+1)
   \   0000019C   0x2800             CMP      R0,#+0
   \   0000019E   0xD0C9             BEQ.N    ??CRYP_AES_CTR_8
   \   000001A0   0x2500             MOVS     R5,#+0
   \   000001A2   0xE7D7             B.N      ??CRYP_AES_CTR_9
    643            }
    644            /* Disable Crypto */
    645            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_CTR_11: (+1)
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0x.... 0x....      BL       CRYP_Cmd
    646          
    647            return status;
   \   000001AA   0x4628             MOV      R0,R5
   \                     ??CRYP_AES_CTR_7: (+1)
   \   000001AC   0xB011             ADD      SP,SP,#+68
   \   000001AE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??CRYP_AES_CTR_6: (+1)
   \   000001B2   0x9C1B             LDR      R4,[SP, #+108]
   \   000001B4   0xE7D0             B.N      ??CRYP_AES_CTR_10
    648          }
    649          
    650          /**
    651            * @brief  Encrypt and decrypt using AES in GCM Mode. The GCM and CCM modes
    652            *         are available only on STM32F437x Devices.
    653            * @param  Mode: encryption or decryption Mode.
    654            *          This parameter can be one of the following values:
    655            *            @arg MODE_ENCRYPT: Encryption
    656            *            @arg MODE_DECRYPT: Decryption
    657            * @param  InitVectors: Initialisation Vectors used for AES algorithm.
    658            * @param  Key: Key used for AES algorithm.
    659            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
    660            * @param  Input: pointer to the Input buffer.
    661            * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
    662            * @param  Header: pointer to the header buffer.
    663            * @param  Hlength: length of the header buffer in bytes, must be a multiple of 16.  
    664            * @param  Output: pointer to the returned buffer.
    665            * @param  AuthTAG: pointer to the authentication TAG buffer.
    666            * @retval An ErrorStatus enumeration value:
    667            *          - SUCCESS: Operation done
    668            *          - ERROR: Operation failed
    669            */

   \                                 In section .text, align 2, keep-with-next
    670          ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
    671                                   uint8_t *Key, uint16_t Keysize,
    672                                   uint8_t *Input, uint32_t ILength,
    673                                   uint8_t *Header, uint32_t HLength,
    674                                   uint8_t *Output, uint8_t *AuthTAG)
    675          {
   \                     CRYP_AES_GCM: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xB096             SUB      SP,SP,#+88
   \   00000006   0x4682             MOV      R10,R0
    676            CRYP_InitTypeDef AES_CRYP_InitStructure;
    677            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
    678            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
    679            __IO uint32_t counter = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    680            uint32_t busystatus = 0;
    681            ErrorStatus status = SUCCESS;
   \   0000000C   0x2401             MOVS     R4,#+1
    682            uint32_t keyaddr    = (uint32_t)Key;
   \   0000000E   0x9D17             LDR      R5,[SP, #+92]
    683            uint32_t inputaddr  = (uint32_t)Input;
   \   00000010   0x9E22             LDR      R6,[SP, #+136]
    684            uint32_t outputaddr = (uint32_t)Output;
   \   00000012   0x9F26             LDR      R7,[SP, #+152]
    685            uint32_t ivaddr     = (uint32_t)InitVectors;
   \   00000014   0x9816             LDR      R0,[SP, #+88]
   \   00000016   0x9001             STR      R0,[SP, #+4]
    686            uint32_t headeraddr = (uint32_t)Header;
   \   00000018   0xF8DD 0x8090      LDR      R8,[SP, #+144]
    687            uint32_t tagaddr = (uint32_t)AuthTAG;
   \   0000001C   0xF8DD 0x909C      LDR      R9,[SP, #+156]
    688            uint64_t headerlength = HLength * 8;/* header length in bits */
   \   00000020   0x9825             LDR      R0,[SP, #+148]
   \   00000022   0x00C0             LSLS     R0,R0,#+3
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xE9CD 0x0108      STRD     R0,R1,[SP, #+32]
    689            uint64_t inputlength = ILength * 8;/* input length in bits */
   \   0000002A   0x9823             LDR      R0,[SP, #+140]
   \   0000002C   0x00C0             LSLS     R0,R0,#+3
   \   0000002E   0xE9CD 0x0106      STRD     R0,R1,[SP, #+24]
    690            uint32_t loopcounter = 0;
   \   00000032   0x468B             MOV      R11,R1
    691          
    692            /* Crypto structures initialisation*/
    693            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   00000034   0xA80A             ADD      R0,SP,#+40
   \   00000036   0x.... 0x....      BL       CRYP_KeyStructInit
    694          
    695            switch(Keysize)
   \   0000003A   0xF8BD 0x0060      LDRH     R0,[SP, #+96]
   \   0000003E   0x2880             CMP      R0,#+128
   \   00000040   0xD005             BEQ.N    ??CRYP_AES_GCM_0
   \   00000042   0x28C0             CMP      R0,#+192
   \   00000044   0xD015             BEQ.N    ??CRYP_AES_GCM_1
   \   00000046   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000004A   0xD02D             BEQ.N    ??CRYP_AES_GCM_2
   \   0000004C   0xE04E             B.N      ??CRYP_AES_GCM_3
    696            {
    697              case 128:
    698              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_GCM_0: (+1)
   \   0000004E   0x4658             MOV      R0,R11
   \   00000050   0x9005             STR      R0,[SP, #+20]
    699              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000052   0x6828             LDR      R0,[R5, #+0]
   \   00000054   0xBA00             REV      R0,R0
   \   00000056   0x900E             STR      R0,[SP, #+56]
    700              keyaddr+=4;
   \   00000058   0x1D28             ADDS     R0,R5,#+4
    701              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xBA09             REV      R1,R1
   \   0000005E   0x910F             STR      R1,[SP, #+60]
    702              keyaddr+=4;
   \   00000060   0x1D05             ADDS     R5,R0,#+4
    703              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000062   0x6828             LDR      R0,[R5, #+0]
   \   00000064   0xBA00             REV      R0,R0
   \   00000066   0x9010             STR      R0,[SP, #+64]
    704              keyaddr+=4;
    705              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   00000068   0x1D28             ADDS     R0,R5,#+4
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xBA00             REV      R0,R0
   \   0000006E   0x9011             STR      R0,[SP, #+68]
    706              break;
   \   00000070   0xE03C             B.N      ??CRYP_AES_GCM_3
    707              case 192:
    708              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_GCM_1: (+1)
   \   00000072   0xF44F 0x7080      MOV      R0,#+256
   \   00000076   0x9005             STR      R0,[SP, #+20]
    709              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0xBA00             REV      R0,R0
   \   0000007C   0x900C             STR      R0,[SP, #+48]
    710              keyaddr+=4;
   \   0000007E   0x1D28             ADDS     R0,R5,#+4
    711              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0xBA09             REV      R1,R1
   \   00000084   0x910D             STR      R1,[SP, #+52]
    712              keyaddr+=4;
   \   00000086   0x1D00             ADDS     R0,R0,#+4
    713              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xBA09             REV      R1,R1
   \   0000008C   0x910E             STR      R1,[SP, #+56]
    714              keyaddr+=4;
   \   0000008E   0x1D00             ADDS     R0,R0,#+4
    715              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0xBA09             REV      R1,R1
   \   00000094   0x910F             STR      R1,[SP, #+60]
    716              keyaddr+=4;
   \   00000096   0x1D05             ADDS     R5,R0,#+4
    717              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000098   0x6828             LDR      R0,[R5, #+0]
   \   0000009A   0xBA00             REV      R0,R0
   \   0000009C   0x9010             STR      R0,[SP, #+64]
    718              keyaddr+=4;
    719              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000009E   0x1D28             ADDS     R0,R5,#+4
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xBA00             REV      R0,R0
   \   000000A4   0x9011             STR      R0,[SP, #+68]
    720              break;
   \   000000A6   0xE021             B.N      ??CRYP_AES_GCM_3
    721              case 256:
    722              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_GCM_2: (+1)
   \   000000A8   0xF44F 0x7000      MOV      R0,#+512
   \   000000AC   0x9005             STR      R0,[SP, #+20]
    723              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   000000AE   0x6828             LDR      R0,[R5, #+0]
   \   000000B0   0xBA00             REV      R0,R0
   \   000000B2   0x900A             STR      R0,[SP, #+40]
    724              keyaddr+=4;
   \   000000B4   0x1D28             ADDS     R0,R5,#+4
    725              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   000000B6   0x6801             LDR      R1,[R0, #+0]
   \   000000B8   0xBA09             REV      R1,R1
   \   000000BA   0x910B             STR      R1,[SP, #+44]
    726              keyaddr+=4;
   \   000000BC   0x1D00             ADDS     R0,R0,#+4
    727              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000000BE   0x6801             LDR      R1,[R0, #+0]
   \   000000C0   0xBA09             REV      R1,R1
   \   000000C2   0x910C             STR      R1,[SP, #+48]
    728              keyaddr+=4;
   \   000000C4   0x1D00             ADDS     R0,R0,#+4
    729              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000000C6   0x6801             LDR      R1,[R0, #+0]
   \   000000C8   0xBA09             REV      R1,R1
   \   000000CA   0x910D             STR      R1,[SP, #+52]
    730              keyaddr+=4;
   \   000000CC   0x1D00             ADDS     R0,R0,#+4
    731              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000000CE   0x6801             LDR      R1,[R0, #+0]
   \   000000D0   0xBA09             REV      R1,R1
   \   000000D2   0x910E             STR      R1,[SP, #+56]
    732              keyaddr+=4;
   \   000000D4   0x1D00             ADDS     R0,R0,#+4
    733              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0xBA09             REV      R1,R1
   \   000000DA   0x910F             STR      R1,[SP, #+60]
    734              keyaddr+=4;
   \   000000DC   0x1D05             ADDS     R5,R0,#+4
    735              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000000DE   0x6828             LDR      R0,[R5, #+0]
   \   000000E0   0xBA00             REV      R0,R0
   \   000000E2   0x9010             STR      R0,[SP, #+64]
    736              keyaddr+=4;
    737              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000000E4   0x1D28             ADDS     R0,R5,#+4
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0xBA00             REV      R0,R0
   \   000000EA   0x9011             STR      R0,[SP, #+68]
    738              break;
    739              default:
    740              break;
    741            }
    742            
    743            /* CRYP Initialization Vectors */
    744            AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
   \                     ??CRYP_AES_GCM_3: (+1)
   \   000000EC   0x9801             LDR      R0,[SP, #+4]
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xBA00             REV      R0,R0
   \   000000F2   0x9012             STR      R0,[SP, #+72]
    745            ivaddr+=4;
   \   000000F4   0x9801             LDR      R0,[SP, #+4]
   \   000000F6   0x1D00             ADDS     R0,R0,#+4
    746            AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
   \   000000F8   0x6801             LDR      R1,[R0, #+0]
   \   000000FA   0xBA09             REV      R1,R1
   \   000000FC   0x9113             STR      R1,[SP, #+76]
    747            ivaddr+=4;
   \   000000FE   0x1D00             ADDS     R0,R0,#+4
    748            AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
   \   00000100   0x6801             LDR      R1,[R0, #+0]
   \   00000102   0xBA09             REV      R1,R1
   \   00000104   0x9114             STR      R1,[SP, #+80]
    749            ivaddr+=4;
    750            AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
   \   00000106   0x1D00             ADDS     R0,R0,#+4
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0xBA00             REV      R0,R0
   \   0000010C   0x9015             STR      R0,[SP, #+84]
    751            
    752            /*------------------ AES Encryption ------------------*/
    753            if(Mode == MODE_ENCRYPT) /* AES encryption */
   \   0000010E   0xF44F 0x2500      MOV      R5,#+524288
   \   00000112   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000116   0xF040 0x80E6      BNE.W    ??CRYP_AES_GCM_4
    754            {
    755              /* Flush IN/OUT FIFOs */
    756              CRYP_FIFOFlush();
   \   0000011A   0x.... 0x....      BL       CRYP_FIFOFlush
    757              
    758              /* Key Initialisation */
    759              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   0000011E   0xA80A             ADD      R0,SP,#+40
   \   00000120   0x.... 0x....      BL       CRYP_KeyInit
    760              
    761              /* CRYP Initialization Vectors */
    762              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000124   0xA812             ADD      R0,SP,#+72
   \   00000126   0x.... 0x....      BL       CRYP_IVInit
    763              
    764              /* Crypto Init for Key preparation for decryption process */
    765              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \   0000012A   0x4658             MOV      R0,R11
   \   0000012C   0x9002             STR      R0,[SP, #+8]
    766              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
   \   0000012E   0x9503             STR      R5,[SP, #+12]
    767              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000130   0x2080             MOVS     R0,#+128
   \   00000132   0x9004             STR      R0,[SP, #+16]
    768              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000134   0xA802             ADD      R0,SP,#+8
   \   00000136   0x.... 0x....      BL       CRYP_Init
    769              
    770              /***************************** Init phase *********************************/
    771              /* Select init phase */
    772              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   0000013A   0x4658             MOV      R0,R11
   \   0000013C   0x.... 0x....      BL       CRYP_PhaseConfig
    773              
    774              /* Enable Crypto processor */
    775              CRYP_Cmd(ENABLE);
   \   00000140   0x4620             MOV      R0,R4
   \   00000142   0x.... 0x....      BL       CRYP_Cmd
    776              
    777              /* Wait for CRYPEN bit to be 0 */
    778              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_GCM_5: (+1)
   \   00000146   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000014A   0x2801             CMP      R0,#+1
   \   0000014C   0xD0FB             BEQ.N    ??CRYP_AES_GCM_5
    779              {
    780              }
    781              
    782              /***************************** header phase *******************************/
    783              if(HLength != 0)
   \   0000014E   0x9825             LDR      R0,[SP, #+148]
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD039             BEQ.N    ??CRYP_AES_GCM_6
    784              {
    785                /* Select header phase */
    786                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   00000154   0xF44F 0x3080      MOV      R0,#+65536
   \   00000158   0x.... 0x....      BL       CRYP_PhaseConfig
    787                
    788                /* Enable Crypto processor */
    789                CRYP_Cmd(ENABLE);
   \   0000015C   0x4620             MOV      R0,R4
   \   0000015E   0x.... 0x....      BL       CRYP_Cmd
    790                
    791                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000162   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD11A             BNE.N    ??CRYP_AES_GCM_7
   \   0000016A   0xE172             B.N      ??CRYP_AES_GCM_8
    792                {
    793                   /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    794                      the CRYP peripheral (please check the device sales type. */
    795                   return(ERROR);
    796                }
    797                
    798                for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
    799                {
    800                  /* Wait until the IFEM flag is reset */
    801                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_GCM_9: (+1)
   \   0000016C   0x4620             MOV      R0,R4
   \   0000016E   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD0FA             BEQ.N    ??CRYP_AES_GCM_9
    802                  {
    803                  }
    804                  
    805                  /* Write the Input block in the IN FIFO */
    806                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000176   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000017A   0x.... 0x....      BL       CRYP_DataIn
    807                  headeraddr+=4;
   \   0000017E   0xF108 0x0504      ADD      R5,R8,#+4
    808                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000182   0x6828             LDR      R0,[R5, #+0]
   \   00000184   0x.... 0x....      BL       CRYP_DataIn
    809                  headeraddr+=4;
   \   00000188   0x1D2D             ADDS     R5,R5,#+4
    810                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000018A   0x6828             LDR      R0,[R5, #+0]
   \   0000018C   0x.... 0x....      BL       CRYP_DataIn
    811                  headeraddr+=4;
   \   00000190   0x1D2D             ADDS     R5,R5,#+4
    812                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000192   0x6828             LDR      R0,[R5, #+0]
   \   00000194   0x.... 0x....      BL       CRYP_DataIn
    813                  headeraddr+=4;
   \   00000198   0xF105 0x0804      ADD      R8,R5,#+4
    814                }
   \   0000019C   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_GCM_7: (+1)
   \   000001A0   0x9825             LDR      R0,[SP, #+148]
   \   000001A2   0x4583             CMP      R11,R0
   \   000001A4   0xD3E2             BCC.N    ??CRYP_AES_GCM_9
    815                
    816                /* Wait until the complete message has been processed */
    817                counter = 0;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0x9000             STR      R0,[SP, #+0]
    818                do
    819                {
    820                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_GCM_10: (+1)
   \   000001AA   0x2010             MOVS     R0,#+16
   \   000001AC   0x.... 0x....      BL       CRYP_GetFlagStatus
    821                  counter++;
   \   000001B0   0x9900             LDR      R1,[SP, #+0]
   \   000001B2   0x1C49             ADDS     R1,R1,#+1
   \   000001B4   0x9100             STR      R1,[SP, #+0]
    822                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   000001B6   0x9900             LDR      R1,[SP, #+0]
   \   000001B8   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000001BC   0xD001             BEQ.N    ??CRYP_AES_GCM_11
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD1F3             BNE.N    ??CRYP_AES_GCM_10
    823          
    824                if (busystatus != RESET)
   \                     ??CRYP_AES_GCM_11: (+1)
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD000             BEQ.N    ??CRYP_AES_GCM_6
    825                {
    826                  status = ERROR;
   \   000001C6   0x2400             MOVS     R4,#+0
    827                }
    828              }
    829              
    830              /**************************** payload phase *******************************/
    831              if(ILength != 0)
   \                     ??CRYP_AES_GCM_6: (+1)
   \   000001C8   0x9823             LDR      R0,[SP, #+140]
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD051             BEQ.N    ??CRYP_AES_GCM_12
    832              {
    833                /* Select payload phase */
    834                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   000001CE   0xF44F 0x3000      MOV      R0,#+131072
   \   000001D2   0x.... 0x....      BL       CRYP_PhaseConfig
    835                
    836                /* Enable Crypto processor */
    837                CRYP_Cmd(ENABLE);
   \   000001D6   0x2001             MOVS     R0,#+1
   \   000001D8   0x.... 0x....      BL       CRYP_Cmd
    838                
    839                if(CRYP_GetCmdStatus() == DISABLE)
   \   000001DC   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xF000 0x8136      BEQ.W    ??CRYP_AES_GCM_8
    840                {
    841                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    842                     the CRYP peripheral (please check the device sales type. */
    843                  return(ERROR);
    844                }
    845                
    846                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \   000001E6   0xF04F 0x0B00      MOV      R11,#+0
   \   000001EA   0xE016             B.N      ??CRYP_AES_GCM_13
    847                {
    848                  /* Wait until the IFEM flag is reset */
    849                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
    850                  {
    851                  }
    852                  /* Write the Input block in the IN FIFO */
    853                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    854                  inputaddr+=4;
    855                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    856                  inputaddr+=4;
    857                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    858                  inputaddr+=4;
    859                  CRYP_DataIn(*(uint32_t*)(inputaddr));
    860                  inputaddr+=4;
    861                  
    862                  /* Wait until the complete message has been processed */
    863                  counter = 0;
    864                  do
    865                  {
    866                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
    867                    counter++;
    868                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
    869          
    870                  if (busystatus != RESET)
    871                  {
    872                    status = ERROR;
    873                  }
    874                  else
    875                  {
    876                    /* Wait until the OFNE flag is reset */
    877                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_14: (+1)
   \   000001EC   0x2004             MOVS     R0,#+4
   \   000001EE   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000001F2   0x2800             CMP      R0,#+0
   \   000001F4   0xD0FA             BEQ.N    ??CRYP_AES_GCM_14
    878                    {
    879                    }
    880                    
    881                    /* Read the Output block from the Output FIFO */
    882                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000001F6   0x.... 0x....      BL       CRYP_DataOut
   \   000001FA   0x6038             STR      R0,[R7, #+0]
    883                    outputaddr+=4;
   \   000001FC   0x1D3D             ADDS     R5,R7,#+4
    884                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000001FE   0x.... 0x....      BL       CRYP_DataOut
   \   00000202   0x6028             STR      R0,[R5, #+0]
    885                    outputaddr+=4;
   \   00000204   0x1D2D             ADDS     R5,R5,#+4
    886                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000206   0x.... 0x....      BL       CRYP_DataOut
   \   0000020A   0x6028             STR      R0,[R5, #+0]
    887                    outputaddr+=4;
   \   0000020C   0x1D2D             ADDS     R5,R5,#+4
    888                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000020E   0x.... 0x....      BL       CRYP_DataOut
   \   00000212   0x6028             STR      R0,[R5, #+0]
    889                    outputaddr+=4;
   \   00000214   0x1D2F             ADDS     R7,R5,#+4
    890                  }
   \                     ??CRYP_AES_GCM_15: (+1)
   \   00000216   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_GCM_13: (+1)
   \   0000021A   0x9823             LDR      R0,[SP, #+140]
   \   0000021C   0x4583             CMP      R11,R0
   \   0000021E   0xD228             BCS.N    ??CRYP_AES_GCM_12
   \   00000220   0x0020             MOVS     R0,R4
   \   00000222   0xD026             BEQ.N    ??CRYP_AES_GCM_12
   \                     ??CRYP_AES_GCM_16: (+1)
   \   00000224   0x2001             MOVS     R0,#+1
   \   00000226   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD0FA             BEQ.N    ??CRYP_AES_GCM_16
   \   0000022E   0x6830             LDR      R0,[R6, #+0]
   \   00000230   0x.... 0x....      BL       CRYP_DataIn
   \   00000234   0x1D35             ADDS     R5,R6,#+4
   \   00000236   0x6828             LDR      R0,[R5, #+0]
   \   00000238   0x.... 0x....      BL       CRYP_DataIn
   \   0000023C   0x1D2D             ADDS     R5,R5,#+4
   \   0000023E   0x6828             LDR      R0,[R5, #+0]
   \   00000240   0x.... 0x....      BL       CRYP_DataIn
   \   00000244   0x1D2D             ADDS     R5,R5,#+4
   \   00000246   0x6828             LDR      R0,[R5, #+0]
   \   00000248   0x.... 0x....      BL       CRYP_DataIn
   \   0000024C   0x1D2E             ADDS     R6,R5,#+4
   \   0000024E   0x2000             MOVS     R0,#+0
   \   00000250   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_GCM_17: (+1)
   \   00000252   0x2010             MOVS     R0,#+16
   \   00000254   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000258   0x9900             LDR      R1,[SP, #+0]
   \   0000025A   0x1C49             ADDS     R1,R1,#+1
   \   0000025C   0x9100             STR      R1,[SP, #+0]
   \   0000025E   0x9900             LDR      R1,[SP, #+0]
   \   00000260   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000264   0xD001             BEQ.N    ??CRYP_AES_GCM_18
   \   00000266   0x2800             CMP      R0,#+0
   \   00000268   0xD1F3             BNE.N    ??CRYP_AES_GCM_17
   \                     ??CRYP_AES_GCM_18: (+1)
   \   0000026A   0x2800             CMP      R0,#+0
   \   0000026C   0xD0BE             BEQ.N    ??CRYP_AES_GCM_14
   \   0000026E   0x2400             MOVS     R4,#+0
   \   00000270   0xE7D1             B.N      ??CRYP_AES_GCM_15
    891                }
    892              }
    893              
    894              /***************************** final phase ********************************/
    895              /* Select final phase */
    896              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_GCM_12: (+1)
   \   00000272   0xF44F 0x3040      MOV      R0,#+196608
   \   00000276   0x.... 0x....      BL       CRYP_PhaseConfig
    897              
    898              /* Enable Crypto processor */
    899              CRYP_Cmd(ENABLE);
   \   0000027A   0x2001             MOVS     R0,#+1
   \   0000027C   0x.... 0x....      BL       CRYP_Cmd
    900              
    901              if(CRYP_GetCmdStatus() == DISABLE)
   \   00000280   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000284   0x2800             CMP      R0,#+0
   \   00000286   0xF000 0x80E4      BEQ.W    ??CRYP_AES_GCM_8
    902              {
    903                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    904                   the CRYP peripheral (please check the device sales type. */
    905                return(ERROR);
    906              }
    907              
    908              /* Write number of bits concatenated with header in the IN FIFO */
    909              CRYP_DataIn(__REV(headerlength>>32));
   \   0000028A   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   0000028E   0xBA08             REV      R0,R1
   \   00000290   0x.... 0x....      BL       CRYP_DataIn
    910              CRYP_DataIn(__REV(headerlength));
   \   00000294   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000298   0xBA00             REV      R0,R0
   \   0000029A   0x.... 0x....      BL       CRYP_DataIn
    911              CRYP_DataIn(__REV(inputlength>>32));
   \   0000029E   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \   000002A2   0xBA08             REV      R0,R1
   \   000002A4   0x.... 0x....      BL       CRYP_DataIn
    912              CRYP_DataIn(__REV(inputlength));
   \   000002A8   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \   000002AC   0xBA00             REV      R0,R0
   \   000002AE   0x.... 0x....      BL       CRYP_DataIn
    913              /* Wait until the OFNE flag is reset */
    914              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_19: (+1)
   \   000002B2   0x2004             MOVS     R0,#+4
   \   000002B4   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000002B8   0x2800             CMP      R0,#+0
   \   000002BA   0xD0FA             BEQ.N    ??CRYP_AES_GCM_19
    915              {
    916              }
    917              
    918              tagaddr = (uint32_t)AuthTAG;
    919              /* Read the Auth TAG in the IN FIFO */
    920              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000002BC   0x.... 0x....      BL       CRYP_DataOut
   \   000002C0   0xF8C9 0x0000      STR      R0,[R9, #+0]
    921              tagaddr+=4;
   \   000002C4   0xF109 0x0504      ADD      R5,R9,#+4
    922              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000002C8   0x.... 0x....      BL       CRYP_DataOut
   \   000002CC   0x6028             STR      R0,[R5, #+0]
    923              tagaddr+=4;
   \   000002CE   0xF105 0x0904      ADD      R9,R5,#+4
    924              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000002D2   0x.... 0x....      BL       CRYP_DataOut
   \   000002D6   0xF8C9 0x0000      STR      R0,[R9, #+0]
    925              tagaddr+=4;
    926              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000002DA   0x.... 0x....      BL       CRYP_DataOut
   \   000002DE   0xF109 0x0104      ADD      R1,R9,#+4
   \   000002E2   0x6008             STR      R0,[R1, #+0]
    927              tagaddr+=4;
   \   000002E4   0xE0E4             B.N      ??CRYP_AES_GCM_20
    928            }
    929            /*------------------ AES Decryption ------------------*/
    930            else /* AES decryption */
    931            {
    932              /* Flush IN/OUT FIFOs */
    933              CRYP_FIFOFlush();
   \                     ??CRYP_AES_GCM_4: (+1)
   \   000002E6   0x.... 0x....      BL       CRYP_FIFOFlush
    934              
    935              /* Key Initialisation */
    936              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   000002EA   0xA80A             ADD      R0,SP,#+40
   \   000002EC   0x.... 0x....      BL       CRYP_KeyInit
    937              
    938              /* CRYP Initialization Vectors */
    939              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   000002F0   0xA812             ADD      R0,SP,#+72
   \   000002F2   0x.... 0x....      BL       CRYP_IVInit
    940              
    941              /* Crypto Init for Key preparation for decryption process */
    942              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   000002F6   0x2004             MOVS     R0,#+4
   \   000002F8   0x9002             STR      R0,[SP, #+8]
    943              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
   \   000002FA   0x9503             STR      R5,[SP, #+12]
    944              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   000002FC   0x2080             MOVS     R0,#+128
   \   000002FE   0x9004             STR      R0,[SP, #+16]
    945              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000300   0xA802             ADD      R0,SP,#+8
   \   00000302   0x.... 0x....      BL       CRYP_Init
    946              
    947              /***************************** Init phase *********************************/
    948              /* Select init phase */
    949              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   00000306   0x4658             MOV      R0,R11
   \   00000308   0x.... 0x....      BL       CRYP_PhaseConfig
    950              
    951              /* Enable Crypto processor */
    952              CRYP_Cmd(ENABLE);
   \   0000030C   0x4620             MOV      R0,R4
   \   0000030E   0x.... 0x....      BL       CRYP_Cmd
    953              
    954              /* Wait for CRYPEN bit to be 0 */
    955              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_GCM_21: (+1)
   \   00000312   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000316   0x2801             CMP      R0,#+1
   \   00000318   0xD0FB             BEQ.N    ??CRYP_AES_GCM_21
    956              {
    957              }
    958              
    959              /***************************** header phase *******************************/
    960              if(HLength != 0)
   \   0000031A   0x9825             LDR      R0,[SP, #+148]
   \   0000031C   0x2800             CMP      R0,#+0
   \   0000031E   0xD039             BEQ.N    ??CRYP_AES_GCM_22
    961              {
    962                /* Select header phase */
    963                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   00000320   0xF44F 0x3080      MOV      R0,#+65536
   \   00000324   0x.... 0x....      BL       CRYP_PhaseConfig
    964                
    965                /* Enable Crypto processor */
    966                CRYP_Cmd(ENABLE);
   \   00000328   0x4620             MOV      R0,R4
   \   0000032A   0x.... 0x....      BL       CRYP_Cmd
    967                
    968                if(CRYP_GetCmdStatus() == DISABLE)
   \   0000032E   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000332   0x2800             CMP      R0,#+0
   \   00000334   0xD11A             BNE.N    ??CRYP_AES_GCM_23
   \   00000336   0xE08C             B.N      ??CRYP_AES_GCM_8
    969                {
    970                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
    971                     the CRYP peripheral (please check the device sales type. */
    972                  return(ERROR);
    973                }
    974                
    975                for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
    976                {
    977                  /* Wait until the IFEM flag is reset */
    978                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_GCM_24: (+1)
   \   00000338   0x4620             MOV      R0,R4
   \   0000033A   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000033E   0x2800             CMP      R0,#+0
   \   00000340   0xD0FA             BEQ.N    ??CRYP_AES_GCM_24
    979                  {
    980                  }
    981                  
    982                  /* Write the Input block in the IN FIFO */
    983                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000342   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000346   0x.... 0x....      BL       CRYP_DataIn
    984                  headeraddr+=4;
   \   0000034A   0xF108 0x0504      ADD      R5,R8,#+4
    985                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000034E   0x6828             LDR      R0,[R5, #+0]
   \   00000350   0x.... 0x....      BL       CRYP_DataIn
    986                  headeraddr+=4;
   \   00000354   0x1D2D             ADDS     R5,R5,#+4
    987                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   00000356   0x6828             LDR      R0,[R5, #+0]
   \   00000358   0x.... 0x....      BL       CRYP_DataIn
    988                  headeraddr+=4;
   \   0000035C   0x1D2D             ADDS     R5,R5,#+4
    989                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   0000035E   0x6828             LDR      R0,[R5, #+0]
   \   00000360   0x.... 0x....      BL       CRYP_DataIn
    990                  headeraddr+=4;
   \   00000364   0xF105 0x0804      ADD      R8,R5,#+4
    991                }
   \   00000368   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_GCM_23: (+1)
   \   0000036C   0x9825             LDR      R0,[SP, #+148]
   \   0000036E   0x4583             CMP      R11,R0
   \   00000370   0xD3E2             BCC.N    ??CRYP_AES_GCM_24
    992                
    993                /* Wait until the complete message has been processed */
    994                counter = 0;
   \   00000372   0x2000             MOVS     R0,#+0
   \   00000374   0x9000             STR      R0,[SP, #+0]
    995                do
    996                {
    997                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_GCM_25: (+1)
   \   00000376   0x2010             MOVS     R0,#+16
   \   00000378   0x.... 0x....      BL       CRYP_GetFlagStatus
    998                  counter++;
   \   0000037C   0x9900             LDR      R1,[SP, #+0]
   \   0000037E   0x1C49             ADDS     R1,R1,#+1
   \   00000380   0x9100             STR      R1,[SP, #+0]
    999                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   00000382   0x9900             LDR      R1,[SP, #+0]
   \   00000384   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000388   0xD001             BEQ.N    ??CRYP_AES_GCM_26
   \   0000038A   0x2800             CMP      R0,#+0
   \   0000038C   0xD1F3             BNE.N    ??CRYP_AES_GCM_25
   1000          
   1001                if (busystatus != RESET)
   \                     ??CRYP_AES_GCM_26: (+1)
   \   0000038E   0x2800             CMP      R0,#+0
   \   00000390   0xD000             BEQ.N    ??CRYP_AES_GCM_22
   1002                {
   1003                  status = ERROR;
   \   00000392   0x2400             MOVS     R4,#+0
   1004                }
   1005              }
   1006              
   1007              /**************************** payload phase *******************************/
   1008              if(ILength != 0)
   \                     ??CRYP_AES_GCM_22: (+1)
   \   00000394   0x9823             LDR      R0,[SP, #+140]
   \   00000396   0x2800             CMP      R0,#+0
   \   00000398   0xD050             BEQ.N    ??CRYP_AES_GCM_27
   1009              {
   1010                /* Select payload phase */
   1011                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   0000039A   0xF44F 0x3000      MOV      R0,#+131072
   \   0000039E   0x.... 0x....      BL       CRYP_PhaseConfig
   1012          
   1013                /* Enable Crypto processor */
   1014                CRYP_Cmd(ENABLE);
   \   000003A2   0x2001             MOVS     R0,#+1
   \   000003A4   0x.... 0x....      BL       CRYP_Cmd
   1015                
   1016                if(CRYP_GetCmdStatus() == DISABLE)
   \   000003A8   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000003AC   0x2800             CMP      R0,#+0
   \   000003AE   0xD050             BEQ.N    ??CRYP_AES_GCM_8
   1017                {
   1018                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1019                     the CRYP peripheral (please check the device sales type. */
   1020                  return(ERROR);
   1021                }
   1022                
   1023                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \   000003B0   0xF04F 0x0B00      MOV      R11,#+0
   \   000003B4   0xE016             B.N      ??CRYP_AES_GCM_28
   1024                {
   1025                  /* Wait until the IFEM flag is reset */
   1026                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   1027                  {
   1028                  }
   1029                  /* Write the Input block in the IN FIFO */
   1030                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1031                  inputaddr+=4;
   1032                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1033                  inputaddr+=4;
   1034                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1035                  inputaddr+=4;
   1036                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1037                  inputaddr+=4;
   1038                  
   1039                  /* Wait until the complete message has been processed */
   1040                  counter = 0;
   1041                  do
   1042                  {
   1043                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1044                    counter++;
   1045                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1046          
   1047                  if (busystatus != RESET)
   1048                  {
   1049                    status = ERROR;
   1050                  }
   1051                  else
   1052                  {
   1053                    /* Wait until the OFNE flag is reset */
   1054                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_29: (+1)
   \   000003B6   0x2004             MOVS     R0,#+4
   \   000003B8   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000003BC   0x2800             CMP      R0,#+0
   \   000003BE   0xD0FA             BEQ.N    ??CRYP_AES_GCM_29
   1055                    {
   1056                    }
   1057                    
   1058                    /* Read the Output block from the Output FIFO */
   1059                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003C0   0x.... 0x....      BL       CRYP_DataOut
   \   000003C4   0x6038             STR      R0,[R7, #+0]
   1060                    outputaddr+=4;
   \   000003C6   0x1D3D             ADDS     R5,R7,#+4
   1061                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003C8   0x.... 0x....      BL       CRYP_DataOut
   \   000003CC   0x6028             STR      R0,[R5, #+0]
   1062                    outputaddr+=4;
   \   000003CE   0x1D2D             ADDS     R5,R5,#+4
   1063                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003D0   0x.... 0x....      BL       CRYP_DataOut
   \   000003D4   0x6028             STR      R0,[R5, #+0]
   1064                    outputaddr+=4;
   \   000003D6   0x1D2D             ADDS     R5,R5,#+4
   1065                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   000003D8   0x.... 0x....      BL       CRYP_DataOut
   \   000003DC   0x6028             STR      R0,[R5, #+0]
   1066                    outputaddr+=4;
   \   000003DE   0x1D2F             ADDS     R7,R5,#+4
   1067                  }
   \                     ??CRYP_AES_GCM_30: (+1)
   \   000003E0   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_GCM_28: (+1)
   \   000003E4   0x9823             LDR      R0,[SP, #+140]
   \   000003E6   0x4583             CMP      R11,R0
   \   000003E8   0xD228             BCS.N    ??CRYP_AES_GCM_27
   \   000003EA   0x0020             MOVS     R0,R4
   \   000003EC   0xD026             BEQ.N    ??CRYP_AES_GCM_27
   \                     ??CRYP_AES_GCM_31: (+1)
   \   000003EE   0x2001             MOVS     R0,#+1
   \   000003F0   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000003F4   0x2800             CMP      R0,#+0
   \   000003F6   0xD0FA             BEQ.N    ??CRYP_AES_GCM_31
   \   000003F8   0x6830             LDR      R0,[R6, #+0]
   \   000003FA   0x.... 0x....      BL       CRYP_DataIn
   \   000003FE   0x1D35             ADDS     R5,R6,#+4
   \   00000400   0x6828             LDR      R0,[R5, #+0]
   \   00000402   0x.... 0x....      BL       CRYP_DataIn
   \   00000406   0x1D2D             ADDS     R5,R5,#+4
   \   00000408   0x6828             LDR      R0,[R5, #+0]
   \   0000040A   0x.... 0x....      BL       CRYP_DataIn
   \   0000040E   0x1D2D             ADDS     R5,R5,#+4
   \   00000410   0x6828             LDR      R0,[R5, #+0]
   \   00000412   0x.... 0x....      BL       CRYP_DataIn
   \   00000416   0x1D2E             ADDS     R6,R5,#+4
   \   00000418   0x2000             MOVS     R0,#+0
   \   0000041A   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_GCM_32: (+1)
   \   0000041C   0x2010             MOVS     R0,#+16
   \   0000041E   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000422   0x9900             LDR      R1,[SP, #+0]
   \   00000424   0x1C49             ADDS     R1,R1,#+1
   \   00000426   0x9100             STR      R1,[SP, #+0]
   \   00000428   0x9900             LDR      R1,[SP, #+0]
   \   0000042A   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000042E   0xD001             BEQ.N    ??CRYP_AES_GCM_33
   \   00000430   0x2800             CMP      R0,#+0
   \   00000432   0xD1F3             BNE.N    ??CRYP_AES_GCM_32
   \                     ??CRYP_AES_GCM_33: (+1)
   \   00000434   0x2800             CMP      R0,#+0
   \   00000436   0xD0BE             BEQ.N    ??CRYP_AES_GCM_29
   \   00000438   0x2400             MOVS     R4,#+0
   \   0000043A   0xE7D1             B.N      ??CRYP_AES_GCM_30
   1068                }
   1069              }
   1070              
   1071              /***************************** final phase ********************************/
   1072              /* Select final phase */
   1073              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_GCM_27: (+1)
   \   0000043C   0xF44F 0x3040      MOV      R0,#+196608
   \   00000440   0x.... 0x....      BL       CRYP_PhaseConfig
   1074          
   1075              /* Enable Crypto processor */
   1076              CRYP_Cmd(ENABLE);
   \   00000444   0x2001             MOVS     R0,#+1
   \   00000446   0x.... 0x....      BL       CRYP_Cmd
   1077              
   1078              if(CRYP_GetCmdStatus() == DISABLE)
   \   0000044A   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000044E   0x2800             CMP      R0,#+0
   \   00000450   0xD101             BNE.N    ??CRYP_AES_GCM_34
   1079              {
   1080                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1081                   the CRYP peripheral (please check the device sales type. */
   1082                return(ERROR);
   \                     ??CRYP_AES_GCM_8: (+1)
   \   00000452   0x2000             MOVS     R0,#+0
   \   00000454   0xE030             B.N      ??CRYP_AES_GCM_35
   1083              }
   1084              
   1085              /* Write number of bits concatenated with header in the IN FIFO */
   1086              CRYP_DataIn(__REV(headerlength>>32));
   \                     ??CRYP_AES_GCM_34: (+1)
   \   00000456   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   0000045A   0xBA08             REV      R0,R1
   \   0000045C   0x.... 0x....      BL       CRYP_DataIn
   1087              CRYP_DataIn(__REV(headerlength));
   \   00000460   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000464   0xBA00             REV      R0,R0
   \   00000466   0x.... 0x....      BL       CRYP_DataIn
   1088              CRYP_DataIn(__REV(inputlength>>32));
   \   0000046A   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \   0000046E   0xBA08             REV      R0,R1
   \   00000470   0x.... 0x....      BL       CRYP_DataIn
   1089              CRYP_DataIn(__REV(inputlength));
   \   00000474   0xE9DD 0x0106      LDRD     R0,R1,[SP, #+24]
   \   00000478   0xBA00             REV      R0,R0
   \   0000047A   0x.... 0x....      BL       CRYP_DataIn
   1090              /* Wait until the OFNE flag is reset */
   1091              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_GCM_36: (+1)
   \   0000047E   0x2004             MOVS     R0,#+4
   \   00000480   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000484   0x2800             CMP      R0,#+0
   \   00000486   0xD0FA             BEQ.N    ??CRYP_AES_GCM_36
   1092              {
   1093              }
   1094              
   1095              tagaddr = (uint32_t)AuthTAG;
   1096              /* Read the Auth TAG in the IN FIFO */
   1097              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   00000488   0x.... 0x....      BL       CRYP_DataOut
   \   0000048C   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1098              tagaddr+=4;
   \   00000490   0xF109 0x0504      ADD      R5,R9,#+4
   1099              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   00000494   0x.... 0x....      BL       CRYP_DataOut
   \   00000498   0x6028             STR      R0,[R5, #+0]
   1100              tagaddr+=4;
   \   0000049A   0xF105 0x0904      ADD      R9,R5,#+4
   1101              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   0000049E   0x.... 0x....      BL       CRYP_DataOut
   \   000004A2   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1102              tagaddr+=4;
   1103              *(uint32_t*)(tagaddr) = CRYP_DataOut();
   \   000004A6   0x.... 0x....      BL       CRYP_DataOut
   \   000004AA   0xF109 0x0104      ADD      R1,R9,#+4
   \   000004AE   0x6008             STR      R0,[R1, #+0]
   1104              tagaddr+=4;
   1105            }
   1106            /* Disable Crypto */
   1107            CRYP_Cmd(DISABLE);
   \                     ??CRYP_AES_GCM_20: (+1)
   \   000004B0   0x2000             MOVS     R0,#+0
   \   000004B2   0x.... 0x....      BL       CRYP_Cmd
   1108          
   1109            return status;
   \   000004B6   0x4620             MOV      R0,R4
   \                     ??CRYP_AES_GCM_35: (+1)
   \   000004B8   0xB019             ADD      SP,SP,#+100
   \   000004BA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1110          }
   1111          
   1112          /**
   1113            * @brief  Encrypt and decrypt using AES in CCM Mode. The GCM and CCM modes
   1114            *         are available only on STM32F437x Devices.
   1115            * @param  Mode: encryption or decryption Mode.
   1116            *          This parameter can be one of the following values:
   1117            *            @arg MODE_ENCRYPT: Encryption
   1118            *            @arg MODE_DECRYPT: Decryption
   1119            * @param  Nonce: the nonce used for AES algorithm. It shall be unique for each processing.
   1120            * @param  Key: Key used for AES algorithm.
   1121            * @param  Keysize: length of the Key, must be a 128, 192 or 256.
   1122            * @param  Input: pointer to the Input buffer.
   1123            * @param  Ilength: length of the Input buffer in bytes, must be a multiple of 16.
   1124            * @param  Header: pointer to the header buffer.
   1125            * @param  Hlength: length of the header buffer in bytes.
   1126            * @param  HBuffer: pointer to temporary buffer used to append the header
   1127            *         HBuffer size must be equal to Hlength + 21
   1128            * @param  Output: pointer to the returned buffer.
   1129            * @param  AuthTAG: pointer to the authentication TAG buffer.
   1130            * @param  TAGSize: the size of the TAG (called also MAC).
   1131            * @retval An ErrorStatus enumeration value:
   1132            *          - SUCCESS: Operation done
   1133            *          - ERROR: Operation failed
   1134            */

   \                                 In section .text, align 2, keep-with-next
   1135          ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
   1136                                   uint8_t* Nonce, uint32_t NonceSize,
   1137                                   uint8_t *Key, uint16_t Keysize,
   1138                                   uint8_t *Input, uint32_t ILength,
   1139                                   uint8_t *Header, uint32_t HLength, uint8_t *HBuffer,
   1140                                   uint8_t *Output,
   1141                                   uint8_t *AuthTAG, uint32_t TAGSize)
   1142          {
   \                     CRYP_AES_CCM: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB0A1             SUB      SP,SP,#+132
   \   00000006   0x4692             MOV      R10,R2
   1143            CRYP_InitTypeDef AES_CRYP_InitStructure;
   1144            CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
   1145            CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
   1146            __IO uint32_t counter = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   1147            uint32_t busystatus = 0;
   1148            ErrorStatus status = SUCCESS;
   \   0000000C   0x2501             MOVS     R5,#+1
   1149            uint32_t keyaddr    = (uint32_t)Key;
   \   0000000E   0x461C             MOV      R4,R3
   1150            uint32_t inputaddr  = (uint32_t)Input;
   \   00000010   0x9E2D             LDR      R6,[SP, #+180]
   1151            uint32_t outputaddr = (uint32_t)Output;
   \   00000012   0x9F32             LDR      R7,[SP, #+200]
   \   00000014   0xF8DD 0x80BC      LDR      R8,[SP, #+188]
   1152            uint32_t headeraddr = (uint32_t)Header;
   1153            uint32_t tagaddr = (uint32_t)AuthTAG;
   \   00000018   0x9833             LDR      R0,[SP, #+204]
   \   0000001A   0x9014             STR      R0,[SP, #+80]
   1154            uint32_t headersize = HLength;
   \   0000001C   0xF8DD 0x90C0      LDR      R9,[SP, #+192]
   1155            uint32_t loopcounter = 0;
   \   00000020   0xF04F 0x0B00      MOV      R11,#+0
   1156            uint32_t bufferidx = 0;
   1157            uint8_t blockb0[16] = {0};/* Block B0 */
   \   00000024   0xA810             ADD      R0,SP,#+64
   \   00000026   0x2110             MOVS     R1,#+16
   \   00000028   0x.... 0x....      BL       __aeabi_memclr4
   1158            uint8_t ctr[16] = {0}; /* Counter */
   \   0000002C   0xA81D             ADD      R0,SP,#+116
   \   0000002E   0x2110             MOVS     R1,#+16
   \   00000030   0x.... 0x....      BL       __aeabi_memclr4
   1159            uint32_t temptag[4] = {0}; /* temporary TAG (MAC) */
   \   00000034   0xA815             ADD      R0,SP,#+84
   \   00000036   0x2110             MOVS     R1,#+16
   \   00000038   0x.... 0x....      BL       __aeabi_memclr4
   1160            uint32_t ctraddr = (uint32_t)ctr;
   1161            uint32_t b0addr = (uint32_t)blockb0;
   1162            
   1163            /************************ Formatting the header block ***********************/
   1164            if(headersize != 0)
   \   0000003C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000040   0xD034             BEQ.N    ??CRYP_AES_CCM_0
   \   00000042   0x9831             LDR      R0,[SP, #+196]
   1165            {
   1166              /* Check that the associated data (or header) length is lower than 2^16 - 2^8 = 65536 - 256 = 65280 */
   1167              if(headersize < 65280)
   \   00000044   0xF5B9 0x4F7F      CMP      R9,#+65280
   \   00000048   0xD208             BCS.N    ??CRYP_AES_CCM_1
   1168              {
   1169                HBuffer[bufferidx++] = (uint8_t) ((headersize >> 8) & 0xFF);
   \   0000004A   0xEA4F 0x2119      LSR      R1,R9,#+8
   \   0000004E   0x7001             STRB     R1,[R0, #+0]
   1170                HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
   \   00000050   0xF880 0x9001      STRB     R9,[R0, #+1]
   \   00000054   0x2102             MOVS     R1,#+2
   1171                headersize += 2;
   \   00000056   0xF109 0x0902      ADD      R9,R9,#+2
   \   0000005A   0xE013             B.N      ??CRYP_AES_CCM_2
   1172              }
   1173              else
   1174              {
   1175                /* header is encoded as 0xff || 0xfe || [headersize]32, i.e., six octets */
   1176                HBuffer[bufferidx++] = 0xFF;
   \                     ??CRYP_AES_CCM_1: (+1)
   \   0000005C   0x21FF             MOVS     R1,#+255
   \   0000005E   0x7001             STRB     R1,[R0, #+0]
   1177                HBuffer[bufferidx++] = 0xFE;
   \   00000060   0x21FE             MOVS     R1,#+254
   \   00000062   0x7041             STRB     R1,[R0, #+1]
   1178                HBuffer[bufferidx++] = headersize & 0xff000000;
   \   00000064   0x4659             MOV      R1,R11
   \   00000066   0x7081             STRB     R1,[R0, #+2]
   1179                HBuffer[bufferidx++] = headersize & 0x00ff0000;
   \   00000068   0x70C1             STRB     R1,[R0, #+3]
   1180                HBuffer[bufferidx++] = headersize & 0x0000ff00;
   \   0000006A   0x7101             STRB     R1,[R0, #+4]
   1181                HBuffer[bufferidx++] = headersize & 0x000000ff;
   \   0000006C   0xF880 0x9005      STRB     R9,[R0, #+5]
   \   00000070   0x2106             MOVS     R1,#+6
   1182                headersize += 6;
   \   00000072   0xF109 0x0906      ADD      R9,R9,#+6
   \   00000076   0xE005             B.N      ??CRYP_AES_CCM_2
   1183              }
   1184              /* Copy the header buffer in internal buffer "HBuffer" */
   1185              for(loopcounter = 0; loopcounter < headersize; loopcounter++)
   1186              {
   1187                HBuffer[bufferidx++] = Header[loopcounter];
   \                     ??CRYP_AES_CCM_3: (+1)
   \   00000078   0xF818 0x200B      LDRB     R2,[R8, R11]
   \   0000007C   0x5442             STRB     R2,[R0, R1]
   \   0000007E   0x1C49             ADDS     R1,R1,#+1
   1188              }
   \   00000080   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??CRYP_AES_CCM_2: (+1)
   \   00000084   0x45CB             CMP      R11,R9
   \   00000086   0xD3F7             BCC.N    ??CRYP_AES_CCM_3
   1189              /* Check if the header size is modulo 16 */
   1190              if ((headersize % 16) != 0)
   \   00000088   0xF019 0x0F0F      TST      R9,#0xF
   \   0000008C   0xD00D             BEQ.N    ??CRYP_AES_CCM_4
   1191              {
   1192                /* Padd the header buffer with 0s till the HBuffer length is modulo 16 */
   1193                for(loopcounter = headersize; loopcounter <= ((headersize/16) + 1) * 16; loopcounter++)
   \   0000008E   0x46CB             MOV      R11,R9
   \   00000090   0xE004             B.N      ??CRYP_AES_CCM_5
   1194                {
   1195                  HBuffer[loopcounter] = 0;
   \                     ??CRYP_AES_CCM_6: (+1)
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0xF800 0x100B      STRB     R1,[R0, R11]
   1196                }
   \   00000098   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??CRYP_AES_CCM_5: (+1)
   \   0000009C   0xF109 0x0110      ADD      R1,R9,#+16
   \   000000A0   0x0909             LSRS     R1,R1,#+4
   \   000000A2   0x0109             LSLS     R1,R1,#+4
   \   000000A4   0x4559             CMP      R1,R11
   \   000000A6   0xD2F4             BCS.N    ??CRYP_AES_CCM_6
   1197                /* Set the header size to modulo 16 */
   1198                headersize = ((headersize/16) + 1) * 16;
   \   000000A8   0x4689             MOV      R9,R1
   1199              }
   1200              /* set the pointer headeraddr to HBuffer */
   1201              headeraddr = (uint32_t)HBuffer;
   \                     ??CRYP_AES_CCM_4: (+1)
   \   000000AA   0x4680             MOV      R8,R0
   1202            }
   1203            /************************* Formatting the block B0 **************************/
   1204            if(headersize != 0)
   \                     ??CRYP_AES_CCM_0: (+1)
   \   000000AC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000B0   0xD002             BEQ.N    ??CRYP_AES_CCM_7
   1205            {
   1206              blockb0[0] = 0x40;
   \   000000B2   0x2040             MOVS     R0,#+64
   \   000000B4   0xF88D 0x0040      STRB     R0,[SP, #+64]
   1207            }
   1208            /* Flags byte */
   1209            blockb0[0] |= 0u | (((( (uint8_t) TAGSize - 2) / 2) & 0x07 ) << 3 ) | ( ( (uint8_t) (15 - NonceSize) - 1) & 0x07);
   \                     ??CRYP_AES_CCM_7: (+1)
   \   000000B8   0xA834             ADD      R0,SP,#+208
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x1E81             SUBS     R1,R0,#+2
   \   000000BE   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \   000000C2   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   000000C6   0x1049             ASRS     R1,R1,#+1
   \   000000C8   0x00C9             LSLS     R1,R1,#+3
   \   000000CA   0xF001 0x0138      AND      R1,R1,#0x38
   \   000000CE   0xF1CA 0x020E      RSB      R2,R10,#+14
   \   000000D2   0xF002 0x0207      AND      R2,R2,#0x7
   \   000000D6   0x4311             ORRS     R1,R2,R1
   \   000000D8   0x4308             ORRS     R0,R1,R0
   \   000000DA   0xF88D 0x0040      STRB     R0,[SP, #+64]
   1210            
   1211            for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xE005             B.N      ??CRYP_AES_CCM_8
   1212            {
   1213              blockb0[loopcounter+1] = Nonce[loopcounter];
   \                     ??CRYP_AES_CCM_9: (+1)
   \   000000E2   0x9922             LDR      R1,[SP, #+136]
   \   000000E4   0x5C09             LDRB     R1,[R1, R0]
   \   000000E6   0xAA10             ADD      R2,SP,#+64
   \   000000E8   0x4402             ADD      R2,R2,R0
   \   000000EA   0x7051             STRB     R1,[R2, #+1]
   1214            }
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \                     ??CRYP_AES_CCM_8: (+1)
   \   000000EE   0x4550             CMP      R0,R10
   \   000000F0   0xD3F7             BCC.N    ??CRYP_AES_CCM_9
   1215            for ( ; loopcounter < 13; loopcounter++)
   \                     ??CRYP_AES_CCM_10: (+1)
   \   000000F2   0x280D             CMP      R0,#+13
   \   000000F4   0xD205             BCS.N    ??CRYP_AES_CCM_11
   1216            {
   1217              blockb0[loopcounter+1] = 0;
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0xAA10             ADD      R2,SP,#+64
   \   000000FA   0x4402             ADD      R2,R2,R0
   \   000000FC   0x7051             STRB     R1,[R2, #+1]
   1218            }
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0xE7F7             B.N      ??CRYP_AES_CCM_10
   1219            
   1220            blockb0[14] = ((ILength >> 8) & 0xFF);
   \                     ??CRYP_AES_CCM_11: (+1)
   \   00000102   0xA810             ADD      R0,SP,#+64
   \   00000104   0x992E             LDR      R1,[SP, #+184]
   \   00000106   0x0A09             LSRS     R1,R1,#+8
   \   00000108   0x7381             STRB     R1,[R0, #+14]
   1221            blockb0[15] = (ILength & 0xFF);
   \   0000010A   0x992E             LDR      R1,[SP, #+184]
   \   0000010C   0x73C1             STRB     R1,[R0, #+15]
   1222            
   1223            /************************* Formatting the initial counter *******************/
   1224            /* Byte 0:
   1225               Bits 7 and 6 are reserved and shall be set to 0
   1226               Bits 3, 4, and 5 shall also be set to 0, to ensure that all the counter blocks
   1227               are distinct from B0
   1228               Bits 0, 1, and 2 contain the same encoding of q as in B0
   1229            */
   1230            ctr[0] = blockb0[0] & 0x07;
   \   0000010E   0xF89D 0x1040      LDRB     R1,[SP, #+64]
   \   00000112   0xF001 0x0107      AND      R1,R1,#0x7
   \   00000116   0xF88D 0x1074      STRB     R1,[SP, #+116]
   1231            /* byte 1 to NonceSize is the IV (Nonce) */
   1232            for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
   \   0000011A   0x46AB             MOV      R11,R5
   \   0000011C   0xA91D             ADD      R1,SP,#+116
   \   0000011E   0xE005             B.N      ??CRYP_AES_CCM_12
   1233            {
   1234              ctr[loopcounter] = blockb0[loopcounter];
   \                     ??CRYP_AES_CCM_13: (+1)
   \   00000120   0xF810 0x200B      LDRB     R2,[R0, R11]
   \   00000124   0xF801 0x200B      STRB     R2,[R1, R11]
   1235            }
   \   00000128   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??CRYP_AES_CCM_12: (+1)
   \   0000012C   0xF10A 0x0201      ADD      R2,R10,#+1
   \   00000130   0x4593             CMP      R11,R2
   \   00000132   0xD3F5             BCC.N    ??CRYP_AES_CCM_13
   1236            /* Set the LSB to 1 */
   1237            ctr[15] |= 0x01;
   \   00000134   0x7BC8             LDRB     R0,[R1, #+15]
   \   00000136   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000013A   0x73C8             STRB     R0,[R1, #+15]
   1238            
   1239            /* Crypto structures initialisation*/
   1240            CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
   \   0000013C   0xA808             ADD      R0,SP,#+32
   \   0000013E   0x.... 0x....      BL       CRYP_KeyStructInit
   1241            
   1242            switch(Keysize)
   \   00000142   0x982C             LDR      R0,[SP, #+176]
   \   00000144   0x2880             CMP      R0,#+128
   \   00000146   0xD005             BEQ.N    ??CRYP_AES_CCM_14
   \   00000148   0x28C0             CMP      R0,#+192
   \   0000014A   0xD015             BEQ.N    ??CRYP_AES_CCM_15
   \   0000014C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000150   0xD02D             BEQ.N    ??CRYP_AES_CCM_16
   \   00000152   0xE04E             B.N      ??CRYP_AES_CCM_17
   1243            {
   1244              case 128:
   1245              AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
   \                     ??CRYP_AES_CCM_14: (+1)
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x9007             STR      R0,[SP, #+28]
   1246              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   00000158   0x6820             LDR      R0,[R4, #+0]
   \   0000015A   0xBA00             REV      R0,R0
   \   0000015C   0x900C             STR      R0,[SP, #+48]
   1247              keyaddr+=4;
   \   0000015E   0x1D20             ADDS     R0,R4,#+4
   1248              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000160   0x6801             LDR      R1,[R0, #+0]
   \   00000162   0xBA09             REV      R1,R1
   \   00000164   0x910D             STR      R1,[SP, #+52]
   1249              keyaddr+=4;
   \   00000166   0x1D04             ADDS     R4,R0,#+4
   1250              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   00000168   0x6820             LDR      R0,[R4, #+0]
   \   0000016A   0xBA00             REV      R0,R0
   \   0000016C   0x900E             STR      R0,[SP, #+56]
   1251              keyaddr+=4;
   1252              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   0000016E   0x1D20             ADDS     R0,R4,#+4
   \   00000170   0x6800             LDR      R0,[R0, #+0]
   \   00000172   0xBA00             REV      R0,R0
   \   00000174   0x900F             STR      R0,[SP, #+60]
   1253              break;
   \   00000176   0xE03C             B.N      ??CRYP_AES_CCM_17
   1254              case 192:
   1255              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
   \                     ??CRYP_AES_CCM_15: (+1)
   \   00000178   0xF44F 0x7080      MOV      R0,#+256
   \   0000017C   0x9007             STR      R0,[SP, #+28]
   1256              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   0000017E   0x6820             LDR      R0,[R4, #+0]
   \   00000180   0xBA00             REV      R0,R0
   \   00000182   0x900A             STR      R0,[SP, #+40]
   1257              keyaddr+=4;
   \   00000184   0x1D20             ADDS     R0,R4,#+4
   1258              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   00000186   0x6801             LDR      R1,[R0, #+0]
   \   00000188   0xBA09             REV      R1,R1
   \   0000018A   0x910B             STR      R1,[SP, #+44]
   1259              keyaddr+=4;
   \   0000018C   0x1D00             ADDS     R0,R0,#+4
   1260              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   0000018E   0x6801             LDR      R1,[R0, #+0]
   \   00000190   0xBA09             REV      R1,R1
   \   00000192   0x910C             STR      R1,[SP, #+48]
   1261              keyaddr+=4;
   \   00000194   0x1D00             ADDS     R0,R0,#+4
   1262              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   00000196   0x6801             LDR      R1,[R0, #+0]
   \   00000198   0xBA09             REV      R1,R1
   \   0000019A   0x910D             STR      R1,[SP, #+52]
   1263              keyaddr+=4;
   \   0000019C   0x1D04             ADDS     R4,R0,#+4
   1264              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   0000019E   0x6820             LDR      R0,[R4, #+0]
   \   000001A0   0xBA00             REV      R0,R0
   \   000001A2   0x900E             STR      R0,[SP, #+56]
   1265              keyaddr+=4;
   1266              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000001A4   0x1D20             ADDS     R0,R4,#+4
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0xBA00             REV      R0,R0
   \   000001AA   0x900F             STR      R0,[SP, #+60]
   1267              break;
   \   000001AC   0xE021             B.N      ??CRYP_AES_CCM_17
   1268              case 256:
   1269              AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
   \                     ??CRYP_AES_CCM_16: (+1)
   \   000001AE   0xF44F 0x7000      MOV      R0,#+512
   \   000001B2   0x9007             STR      R0,[SP, #+28]
   1270              AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
   \   000001B4   0x6820             LDR      R0,[R4, #+0]
   \   000001B6   0xBA00             REV      R0,R0
   \   000001B8   0x9008             STR      R0,[SP, #+32]
   1271              keyaddr+=4;
   \   000001BA   0x1D20             ADDS     R0,R4,#+4
   1272              AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
   \   000001BC   0x6801             LDR      R1,[R0, #+0]
   \   000001BE   0xBA09             REV      R1,R1
   \   000001C0   0x9109             STR      R1,[SP, #+36]
   1273              keyaddr+=4;
   \   000001C2   0x1D00             ADDS     R0,R0,#+4
   1274              AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
   \   000001C4   0x6801             LDR      R1,[R0, #+0]
   \   000001C6   0xBA09             REV      R1,R1
   \   000001C8   0x910A             STR      R1,[SP, #+40]
   1275              keyaddr+=4;
   \   000001CA   0x1D00             ADDS     R0,R0,#+4
   1276              AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
   \   000001CC   0x6801             LDR      R1,[R0, #+0]
   \   000001CE   0xBA09             REV      R1,R1
   \   000001D0   0x910B             STR      R1,[SP, #+44]
   1277              keyaddr+=4;
   \   000001D2   0x1D00             ADDS     R0,R0,#+4
   1278              AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
   \   000001D4   0x6801             LDR      R1,[R0, #+0]
   \   000001D6   0xBA09             REV      R1,R1
   \   000001D8   0x910C             STR      R1,[SP, #+48]
   1279              keyaddr+=4;
   \   000001DA   0x1D00             ADDS     R0,R0,#+4
   1280              AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
   \   000001DC   0x6801             LDR      R1,[R0, #+0]
   \   000001DE   0xBA09             REV      R1,R1
   \   000001E0   0x910D             STR      R1,[SP, #+52]
   1281              keyaddr+=4;
   \   000001E2   0x1D04             ADDS     R4,R0,#+4
   1282              AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
   \   000001E4   0x6820             LDR      R0,[R4, #+0]
   \   000001E6   0xBA00             REV      R0,R0
   \   000001E8   0x900E             STR      R0,[SP, #+56]
   1283              keyaddr+=4;
   1284              AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
   \   000001EA   0x1D20             ADDS     R0,R4,#+4
   \   000001EC   0x6800             LDR      R0,[R0, #+0]
   \   000001EE   0xBA00             REV      R0,R0
   \   000001F0   0x900F             STR      R0,[SP, #+60]
   1285              break;
   1286              default:
   1287              break;
   1288            }
   1289            
   1290            /* CRYP Initialization Vectors */
   1291            AES_CRYP_IVInitStructure.CRYP_IV0Left = (__REV(*(uint32_t*)(ctraddr)));
   \                     ??CRYP_AES_CCM_17: (+1)
   \   000001F2   0xA81D             ADD      R0,SP,#+116
   \   000001F4   0x9001             STR      R0,[SP, #+4]
   \   000001F6   0x6800             LDR      R0,[R0, #+0]
   \   000001F8   0xBA00             REV      R0,R0
   \   000001FA   0x9019             STR      R0,[SP, #+100]
   1292            ctraddr+=4;
   \   000001FC   0x9801             LDR      R0,[SP, #+4]
   \   000001FE   0x1D00             ADDS     R0,R0,#+4
   \   00000200   0x9003             STR      R0,[SP, #+12]
   \   00000202   0x6801             LDR      R1,[R0, #+0]
   \   00000204   0xBA09             REV      R1,R1
   \   00000206   0x911A             STR      R1,[SP, #+104]
   1293            AES_CRYP_IVInitStructure.CRYP_IV0Right= (__REV(*(uint32_t*)(ctraddr)));
   1294            ctraddr+=4;
   \   00000208   0x1D04             ADDS     R4,R0,#+4
   \   0000020A   0x6820             LDR      R0,[R4, #+0]
   \   0000020C   0xBA00             REV      R0,R0
   \   0000020E   0x901B             STR      R0,[SP, #+108]
   \   00000210   0x1D20             ADDS     R0,R4,#+4
   \   00000212   0x6800             LDR      R0,[R0, #+0]
   \   00000214   0xBA00             REV      R0,R0
   \   00000216   0x901C             STR      R0,[SP, #+112]
   1295            AES_CRYP_IVInitStructure.CRYP_IV1Left = (__REV(*(uint32_t*)(ctraddr)));
   1296            ctraddr+=4;
   1297            AES_CRYP_IVInitStructure.CRYP_IV1Right= (__REV(*(uint32_t*)(ctraddr)));
   1298            
   1299            /*------------------ AES Encryption ------------------*/
   1300            if(Mode == MODE_ENCRYPT) /* AES encryption */
   \   00000218   0xA810             ADD      R0,SP,#+64
   \   0000021A   0x9002             STR      R0,[SP, #+8]
   \   0000021C   0xF100 0x0A04      ADD      R10,R0,#+4
   \   00000220   0xF04F 0x1B08      MOV      R11,#+524296
   \   00000224   0xF89D 0x0084      LDRB     R0,[SP, #+132]
   \   00000228   0x2801             CMP      R0,#+1
   \   0000022A   0xF040 0x80F7      BNE.W    ??CRYP_AES_CCM_18
   1301            {
   1302              /* Flush IN/OUT FIFOs */
   1303              CRYP_FIFOFlush();
   \   0000022E   0x.... 0x....      BL       CRYP_FIFOFlush
   1304              
   1305              /* Key Initialisation */
   1306              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   00000232   0xA808             ADD      R0,SP,#+32
   \   00000234   0x.... 0x....      BL       CRYP_KeyInit
   1307              
   1308              /* CRYP Initialization Vectors */
   1309              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000238   0xA819             ADD      R0,SP,#+100
   \   0000023A   0x.... 0x....      BL       CRYP_IVInit
   1310              
   1311              /* Crypto Init for Key preparation for decryption process */
   1312              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
   \   0000023E   0x2000             MOVS     R0,#+0
   \   00000240   0x9004             STR      R0,[SP, #+16]
   1313              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
   \   00000242   0xF8CD 0xB014      STR      R11,[SP, #+20]
   1314              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000246   0x2080             MOVS     R0,#+128
   \   00000248   0x9006             STR      R0,[SP, #+24]
   1315              CRYP_Init(&AES_CRYP_InitStructure);
   \   0000024A   0xA804             ADD      R0,SP,#+16
   \   0000024C   0x.... 0x....      BL       CRYP_Init
   1316              
   1317              /***************************** Init phase *********************************/
   1318              /* Select init phase */
   1319              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   00000250   0x2000             MOVS     R0,#+0
   \   00000252   0x.... 0x....      BL       CRYP_PhaseConfig
   1320              
   1321              b0addr = (uint32_t)blockb0;
   1322              /* Write the blockb0 block in the IN FIFO */
   1323              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   00000256   0x9802             LDR      R0,[SP, #+8]
   \   00000258   0x6800             LDR      R0,[R0, #+0]
   \   0000025A   0x.... 0x....      BL       CRYP_DataIn
   1324              b0addr+=4;
   1325              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   0000025E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000262   0x.... 0x....      BL       CRYP_DataIn
   1326              b0addr+=4;
   \   00000266   0xF10A 0x0A04      ADD      R10,R10,#+4
   1327              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   0000026A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000026E   0x.... 0x....      BL       CRYP_DataIn
   1328              b0addr+=4;
   1329              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   00000272   0xF10A 0x0004      ADD      R0,R10,#+4
   \   00000276   0x6800             LDR      R0,[R0, #+0]
   \   00000278   0x.... 0x....      BL       CRYP_DataIn
   1330              
   1331              /* Enable Crypto processor */
   1332              CRYP_Cmd(ENABLE);
   \   0000027C   0x4628             MOV      R0,R5
   \   0000027E   0x.... 0x....      BL       CRYP_Cmd
   1333              
   1334              /* Wait for CRYPEN bit to be 0 */
   1335              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_CCM_19: (+1)
   \   00000282   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000286   0x2801             CMP      R0,#+1
   \   00000288   0xD0FB             BEQ.N    ??CRYP_AES_CCM_19
   1336              {
   1337              }
   1338              /***************************** header phase *******************************/
   1339              if(headersize != 0)
   \   0000028A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000028E   0xD040             BEQ.N    ??CRYP_AES_CCM_20
   1340              {
   1341                /* Select header phase */
   1342                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   00000290   0xF44F 0x3080      MOV      R0,#+65536
   \   00000294   0x.... 0x....      BL       CRYP_PhaseConfig
   1343                
   1344                /* Enable Crypto processor */
   1345                CRYP_Cmd(ENABLE);
   \   00000298   0x4628             MOV      R0,R5
   \   0000029A   0x.... 0x....      BL       CRYP_Cmd
   1346                
   1347                if(CRYP_GetCmdStatus() == DISABLE)
   \   0000029E   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000002A2   0x2800             CMP      R0,#+0
   \   000002A4   0xF000 0x818B      BEQ.W    ??CRYP_AES_CCM_21
   1348                {
   1349                   /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1350                      the CRYP peripheral (please check the device sales type. */
   1351                   return(ERROR);
   1352                }
   1353                
   1354                for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
   \   000002A8   0xF04F 0x0B00      MOV      R11,#+0
   \   000002AC   0xE01E             B.N      ??CRYP_AES_CCM_22
   1355                {
   1356                  /* Wait until the IFEM flag is reset */
   1357                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_CCM_23: (+1)
   \   000002AE   0x4628             MOV      R0,R5
   \   000002B0   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000002B4   0x2800             CMP      R0,#+0
   \   000002B6   0xD0FA             BEQ.N    ??CRYP_AES_CCM_23
   1358                  {
   1359                  }
   1360                  
   1361                  /* Write the Input block in the IN FIFO */
   1362                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000002B8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000002BC   0x.... 0x....      BL       CRYP_DataIn
   1363                  headeraddr+=4;
   \   000002C0   0xF108 0x0804      ADD      R8,R8,#+4
   1364                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000002C4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000002C8   0x.... 0x....      BL       CRYP_DataIn
   1365                  headeraddr+=4;
   \   000002CC   0xF108 0x0804      ADD      R8,R8,#+4
   1366                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000002D0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000002D4   0x.... 0x....      BL       CRYP_DataIn
   1367                  headeraddr+=4;
   \   000002D8   0xF108 0x0804      ADD      R8,R8,#+4
   1368                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000002DC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000002E0   0x.... 0x....      BL       CRYP_DataIn
   1369                  headeraddr+=4;
   \   000002E4   0xF108 0x0804      ADD      R8,R8,#+4
   1370                }
   \   000002E8   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_CCM_22: (+1)
   \   000002EC   0x45CB             CMP      R11,R9
   \   000002EE   0xD3DE             BCC.N    ??CRYP_AES_CCM_23
   1371                
   1372                /* Wait until the complete message has been processed */
   1373                counter = 0;
   \   000002F0   0x2000             MOVS     R0,#+0
   \   000002F2   0x9000             STR      R0,[SP, #+0]
   1374                do
   1375                {
   1376                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CCM_24: (+1)
   \   000002F4   0x2010             MOVS     R0,#+16
   \   000002F6   0x.... 0x....      BL       CRYP_GetFlagStatus
   1377                  counter++;
   \   000002FA   0x9900             LDR      R1,[SP, #+0]
   \   000002FC   0x1C49             ADDS     R1,R1,#+1
   \   000002FE   0x9100             STR      R1,[SP, #+0]
   1378                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   00000300   0x9900             LDR      R1,[SP, #+0]
   \   00000302   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000306   0xD001             BEQ.N    ??CRYP_AES_CCM_25
   \   00000308   0x2800             CMP      R0,#+0
   \   0000030A   0xD1F3             BNE.N    ??CRYP_AES_CCM_24
   1379          
   1380                if (busystatus != RESET)
   \                     ??CRYP_AES_CCM_25: (+1)
   \   0000030C   0x2800             CMP      R0,#+0
   \   0000030E   0xD000             BEQ.N    ??CRYP_AES_CCM_20
   1381                {
   1382                  status = ERROR;
   \   00000310   0x2500             MOVS     R5,#+0
   1383                }
   1384              }
   1385              
   1386              /**************************** payload phase *******************************/
   1387              if(ILength != 0)
   \                     ??CRYP_AES_CCM_20: (+1)
   \   00000312   0x982E             LDR      R0,[SP, #+184]
   \   00000314   0x2800             CMP      R0,#+0
   \   00000316   0xD051             BEQ.N    ??CRYP_AES_CCM_26
   1388              {
   1389                /* Select payload phase */
   1390                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   00000318   0xF44F 0x3000      MOV      R0,#+131072
   \   0000031C   0x.... 0x....      BL       CRYP_PhaseConfig
   1391                
   1392                /* Enable Crypto processor */
   1393                CRYP_Cmd(ENABLE);
   \   00000320   0x2001             MOVS     R0,#+1
   \   00000322   0x.... 0x....      BL       CRYP_Cmd
   1394                
   1395                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000326   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   0000032A   0x2800             CMP      R0,#+0
   \   0000032C   0xF000 0x8147      BEQ.W    ??CRYP_AES_CCM_21
   1396                {
   1397                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1398                     the CRYP peripheral (please check the device sales type. */
   1399                  return(ERROR);
   1400                }
   1401                
   1402                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \   00000330   0xF04F 0x0B00      MOV      R11,#+0
   \   00000334   0xE016             B.N      ??CRYP_AES_CCM_27
   1403                {
   1404                  /* Wait until the IFEM flag is reset */
   1405                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   1406                  {
   1407                  }
   1408                  
   1409                  /* Write the Input block in the IN FIFO */
   1410                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1411                  inputaddr+=4;
   1412                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1413                  inputaddr+=4;
   1414                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1415                  inputaddr+=4;
   1416                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1417                  inputaddr+=4;
   1418                  
   1419                  /* Wait until the complete message has been processed */
   1420                  counter = 0;
   1421                  do
   1422                  {
   1423                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1424                    counter++;
   1425                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1426          
   1427                  if (busystatus != RESET)
   1428                  {
   1429                    status = ERROR;
   1430                  }
   1431                  else
   1432                  {
   1433                    /* Wait until the OFNE flag is reset */
   1434                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_28: (+1)
   \   00000336   0x2004             MOVS     R0,#+4
   \   00000338   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000033C   0x2800             CMP      R0,#+0
   \   0000033E   0xD0FA             BEQ.N    ??CRYP_AES_CCM_28
   1435                    {
   1436                    }
   1437                    
   1438                    /* Read the Output block from the Output FIFO */
   1439                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000340   0x.... 0x....      BL       CRYP_DataOut
   \   00000344   0x6038             STR      R0,[R7, #+0]
   1440                    outputaddr+=4;
   \   00000346   0x1D3F             ADDS     R7,R7,#+4
   1441                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000348   0x.... 0x....      BL       CRYP_DataOut
   \   0000034C   0x6038             STR      R0,[R7, #+0]
   1442                    outputaddr+=4;
   \   0000034E   0x1D3F             ADDS     R7,R7,#+4
   1443                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000350   0x.... 0x....      BL       CRYP_DataOut
   \   00000354   0x6038             STR      R0,[R7, #+0]
   1444                    outputaddr+=4;
   \   00000356   0x1D3F             ADDS     R7,R7,#+4
   1445                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000358   0x.... 0x....      BL       CRYP_DataOut
   \   0000035C   0x6038             STR      R0,[R7, #+0]
   1446                    outputaddr+=4;
   \   0000035E   0x1D3F             ADDS     R7,R7,#+4
   1447                  }
   \                     ??CRYP_AES_CCM_29: (+1)
   \   00000360   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_CCM_27: (+1)
   \   00000364   0x982E             LDR      R0,[SP, #+184]
   \   00000366   0x4583             CMP      R11,R0
   \   00000368   0xD228             BCS.N    ??CRYP_AES_CCM_26
   \   0000036A   0x0028             MOVS     R0,R5
   \   0000036C   0xD026             BEQ.N    ??CRYP_AES_CCM_26
   \                     ??CRYP_AES_CCM_30: (+1)
   \   0000036E   0x2001             MOVS     R0,#+1
   \   00000370   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000374   0x2800             CMP      R0,#+0
   \   00000376   0xD0FA             BEQ.N    ??CRYP_AES_CCM_30
   \   00000378   0x6830             LDR      R0,[R6, #+0]
   \   0000037A   0x.... 0x....      BL       CRYP_DataIn
   \   0000037E   0x1D36             ADDS     R6,R6,#+4
   \   00000380   0x6830             LDR      R0,[R6, #+0]
   \   00000382   0x.... 0x....      BL       CRYP_DataIn
   \   00000386   0x1D36             ADDS     R6,R6,#+4
   \   00000388   0x6830             LDR      R0,[R6, #+0]
   \   0000038A   0x.... 0x....      BL       CRYP_DataIn
   \   0000038E   0x1D36             ADDS     R6,R6,#+4
   \   00000390   0x6830             LDR      R0,[R6, #+0]
   \   00000392   0x.... 0x....      BL       CRYP_DataIn
   \   00000396   0x1D36             ADDS     R6,R6,#+4
   \   00000398   0x2000             MOVS     R0,#+0
   \   0000039A   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CCM_31: (+1)
   \   0000039C   0x2010             MOVS     R0,#+16
   \   0000039E   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000003A2   0x9900             LDR      R1,[SP, #+0]
   \   000003A4   0x1C49             ADDS     R1,R1,#+1
   \   000003A6   0x9100             STR      R1,[SP, #+0]
   \   000003A8   0x9900             LDR      R1,[SP, #+0]
   \   000003AA   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000003AE   0xD001             BEQ.N    ??CRYP_AES_CCM_32
   \   000003B0   0x2800             CMP      R0,#+0
   \   000003B2   0xD1F3             BNE.N    ??CRYP_AES_CCM_31
   \                     ??CRYP_AES_CCM_32: (+1)
   \   000003B4   0x2800             CMP      R0,#+0
   \   000003B6   0xD0BE             BEQ.N    ??CRYP_AES_CCM_28
   \   000003B8   0x2500             MOVS     R5,#+0
   \   000003BA   0xE7D1             B.N      ??CRYP_AES_CCM_29
   1448                }
   1449              }
   1450              
   1451              /***************************** final phase ********************************/
   1452              /* Select final phase */
   1453              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_CCM_26: (+1)
   \   000003BC   0xF44F 0x3040      MOV      R0,#+196608
   \   000003C0   0x.... 0x....      BL       CRYP_PhaseConfig
   1454              
   1455              /* Enable Crypto processor */
   1456              CRYP_Cmd(ENABLE);
   \   000003C4   0x2001             MOVS     R0,#+1
   \   000003C6   0x.... 0x....      BL       CRYP_Cmd
   1457              
   1458              if(CRYP_GetCmdStatus() == DISABLE)
   \   000003CA   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000003CE   0x2800             CMP      R0,#+0
   \   000003D0   0xF000 0x80F5      BEQ.W    ??CRYP_AES_CCM_21
   1459              {
   1460                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1461                   the CRYP peripheral (please check the device sales type. */
   1462                return(ERROR);
   1463              }
   1464              
   1465              ctraddr = (uint32_t)ctr;
   1466              /* Write the counter block in the IN FIFO */
   1467              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   000003D4   0x9801             LDR      R0,[SP, #+4]
   \   000003D6   0x6800             LDR      R0,[R0, #+0]
   \   000003D8   0x.... 0x....      BL       CRYP_DataIn
   1468              ctraddr+=4;
   \   000003DC   0x9803             LDR      R0,[SP, #+12]
   1469              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   000003DE   0x6800             LDR      R0,[R0, #+0]
   \   000003E0   0x.... 0x....      BL       CRYP_DataIn
   1470              ctraddr+=4;
   1471              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   000003E4   0x6820             LDR      R0,[R4, #+0]
   \   000003E6   0x.... 0x....      BL       CRYP_DataIn
   1472              ctraddr+=4;
   1473              /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
   1474              CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
   \   000003EA   0x1D20             ADDS     R0,R4,#+4
   \   000003EC   0x6800             LDR      R0,[R0, #+0]
   \   000003EE   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \   000003F2   0x.... 0x....      BL       CRYP_DataIn
   1475              
   1476              /* Wait until the OFNE flag is reset */
   1477              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_33: (+1)
   \   000003F6   0x2004             MOVS     R0,#+4
   \   000003F8   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000003FC   0x2800             CMP      R0,#+0
   \   000003FE   0xD0FA             BEQ.N    ??CRYP_AES_CCM_33
   1478              {
   1479              }
   1480              
   1481              /* Read the Auth TAG in the IN FIFO */
   1482              temptag[0] = CRYP_DataOut();
   \   00000400   0x.... 0x....      BL       CRYP_DataOut
   \   00000404   0x9015             STR      R0,[SP, #+84]
   1483              temptag[1] = CRYP_DataOut();
   \   00000406   0xAC15             ADD      R4,SP,#+84
   \   00000408   0x.... 0x....      BL       CRYP_DataOut
   \   0000040C   0x6060             STR      R0,[R4, #+4]
   1484              temptag[2] = CRYP_DataOut();
   \   0000040E   0x.... 0x....      BL       CRYP_DataOut
   \   00000412   0x60A0             STR      R0,[R4, #+8]
   1485              temptag[3] = CRYP_DataOut();
   \   00000414   0x.... 0x....      BL       CRYP_DataOut
   \   00000418   0x60E0             STR      R0,[R4, #+12]
   \   0000041A   0xE0F5             B.N      ??CRYP_AES_CCM_34
   1486            }
   1487            /*------------------ AES Decryption ------------------*/
   1488            else /* AES decryption */
   1489            {
   1490              /* Flush IN/OUT FIFOs */
   1491              CRYP_FIFOFlush();
   \                     ??CRYP_AES_CCM_18: (+1)
   \   0000041C   0x.... 0x....      BL       CRYP_FIFOFlush
   1492              
   1493              /* Key Initialisation */
   1494              CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
   \   00000420   0xA808             ADD      R0,SP,#+32
   \   00000422   0x.... 0x....      BL       CRYP_KeyInit
   1495              
   1496              /* CRYP Initialization Vectors */
   1497              CRYP_IVInit(&AES_CRYP_IVInitStructure);
   \   00000426   0xA819             ADD      R0,SP,#+100
   \   00000428   0x.... 0x....      BL       CRYP_IVInit
   1498              
   1499              /* Crypto Init for Key preparation for decryption process */
   1500              AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
   \   0000042C   0x2004             MOVS     R0,#+4
   \   0000042E   0x9004             STR      R0,[SP, #+16]
   1501              AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
   \   00000430   0xF8CD 0xB014      STR      R11,[SP, #+20]
   1502              AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
   \   00000434   0x2080             MOVS     R0,#+128
   \   00000436   0x9006             STR      R0,[SP, #+24]
   1503              CRYP_Init(&AES_CRYP_InitStructure);
   \   00000438   0xA804             ADD      R0,SP,#+16
   \   0000043A   0x.... 0x....      BL       CRYP_Init
   1504              
   1505              /***************************** Init phase *********************************/
   1506              /* Select init phase */
   1507              CRYP_PhaseConfig(CRYP_Phase_Init);
   \   0000043E   0x2000             MOVS     R0,#+0
   \   00000440   0x.... 0x....      BL       CRYP_PhaseConfig
   1508              
   1509              b0addr = (uint32_t)blockb0;
   1510              /* Write the blockb0 block in the IN FIFO */
   1511              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   00000444   0x9802             LDR      R0,[SP, #+8]
   \   00000446   0x6800             LDR      R0,[R0, #+0]
   \   00000448   0x.... 0x....      BL       CRYP_DataIn
   1512              b0addr+=4;
   1513              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   0000044C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000450   0x.... 0x....      BL       CRYP_DataIn
   1514              b0addr+=4;
   \   00000454   0xF10A 0x0A04      ADD      R10,R10,#+4
   1515              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   00000458   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000045C   0x.... 0x....      BL       CRYP_DataIn
   1516              b0addr+=4;
   1517              CRYP_DataIn((*(uint32_t*)(b0addr)));
   \   00000460   0xF10A 0x0004      ADD      R0,R10,#+4
   \   00000464   0x6800             LDR      R0,[R0, #+0]
   \   00000466   0x.... 0x....      BL       CRYP_DataIn
   1518              
   1519              /* Enable Crypto processor */
   1520              CRYP_Cmd(ENABLE);
   \   0000046A   0x4628             MOV      R0,R5
   \   0000046C   0x.... 0x....      BL       CRYP_Cmd
   1521              
   1522              /* Wait for CRYPEN bit to be 0 */
   1523              while(CRYP_GetCmdStatus() == ENABLE)
   \                     ??CRYP_AES_CCM_35: (+1)
   \   00000470   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000474   0x2801             CMP      R0,#+1
   \   00000476   0xD0FB             BEQ.N    ??CRYP_AES_CCM_35
   1524              {
   1525              }
   1526              
   1527              /***************************** header phase *******************************/
   1528              if(headersize != 0)
   \   00000478   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000047C   0xD040             BEQ.N    ??CRYP_AES_CCM_36
   1529              {
   1530                /* Select header phase */
   1531                CRYP_PhaseConfig(CRYP_Phase_Header);
   \   0000047E   0xF44F 0x3080      MOV      R0,#+65536
   \   00000482   0x.... 0x....      BL       CRYP_PhaseConfig
   1532                
   1533                /* Enable Crypto processor */
   1534                CRYP_Cmd(ENABLE);
   \   00000486   0x4628             MOV      R0,R5
   \   00000488   0x.... 0x....      BL       CRYP_Cmd
   1535                
   1536                if(CRYP_GetCmdStatus() == DISABLE)
   \   0000048C   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000490   0x2800             CMP      R0,#+0
   \   00000492   0xF000 0x8094      BEQ.W    ??CRYP_AES_CCM_21
   1537                {
   1538                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1539                     the CRYP peripheral (please check the device sales type. */
   1540                  return(ERROR);
   1541                }
   1542                
   1543                for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
   \   00000496   0xF04F 0x0B00      MOV      R11,#+0
   \   0000049A   0xE01E             B.N      ??CRYP_AES_CCM_37
   1544                {
   1545                  /* Wait until the IFEM flag is reset */
   1546                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   \                     ??CRYP_AES_CCM_38: (+1)
   \   0000049C   0x4628             MOV      R0,R5
   \   0000049E   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000004A2   0x2800             CMP      R0,#+0
   \   000004A4   0xD0FA             BEQ.N    ??CRYP_AES_CCM_38
   1547                  {
   1548                  }
   1549                  
   1550                  /* Write the Input block in the IN FIFO */
   1551                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000004A6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000004AA   0x.... 0x....      BL       CRYP_DataIn
   1552                  headeraddr+=4;
   \   000004AE   0xF108 0x0804      ADD      R8,R8,#+4
   1553                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000004B2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000004B6   0x.... 0x....      BL       CRYP_DataIn
   1554                  headeraddr+=4;
   \   000004BA   0xF108 0x0804      ADD      R8,R8,#+4
   1555                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000004BE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000004C2   0x.... 0x....      BL       CRYP_DataIn
   1556                  headeraddr+=4;
   \   000004C6   0xF108 0x0804      ADD      R8,R8,#+4
   1557                  CRYP_DataIn(*(uint32_t*)(headeraddr));
   \   000004CA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000004CE   0x.... 0x....      BL       CRYP_DataIn
   1558                  headeraddr+=4;
   \   000004D2   0xF108 0x0804      ADD      R8,R8,#+4
   1559                }
   \   000004D6   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_CCM_37: (+1)
   \   000004DA   0x45CB             CMP      R11,R9
   \   000004DC   0xD3DE             BCC.N    ??CRYP_AES_CCM_38
   1560                
   1561                /* Wait until the complete message has been processed */
   1562                counter = 0;
   \   000004DE   0x2000             MOVS     R0,#+0
   \   000004E0   0x9000             STR      R0,[SP, #+0]
   1563                do
   1564                {
   1565                  busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   \                     ??CRYP_AES_CCM_39: (+1)
   \   000004E2   0x2010             MOVS     R0,#+16
   \   000004E4   0x.... 0x....      BL       CRYP_GetFlagStatus
   1566                  counter++;
   \   000004E8   0x9900             LDR      R1,[SP, #+0]
   \   000004EA   0x1C49             ADDS     R1,R1,#+1
   \   000004EC   0x9100             STR      R1,[SP, #+0]
   1567                }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   \   000004EE   0x9900             LDR      R1,[SP, #+0]
   \   000004F0   0xF5B1 0x3F80      CMP      R1,#+65536
   \   000004F4   0xD001             BEQ.N    ??CRYP_AES_CCM_40
   \   000004F6   0x2800             CMP      R0,#+0
   \   000004F8   0xD1F3             BNE.N    ??CRYP_AES_CCM_39
   1568          
   1569                if (busystatus != RESET)
   \                     ??CRYP_AES_CCM_40: (+1)
   \   000004FA   0x2800             CMP      R0,#+0
   \   000004FC   0xD000             BEQ.N    ??CRYP_AES_CCM_36
   1570                {
   1571                  status = ERROR;
   \   000004FE   0x2500             MOVS     R5,#+0
   1572                }
   1573              }
   1574              
   1575              /**************************** payload phase *******************************/
   1576              if(ILength != 0)
   \                     ??CRYP_AES_CCM_36: (+1)
   \   00000500   0x982E             LDR      R0,[SP, #+184]
   \   00000502   0x2800             CMP      R0,#+0
   \   00000504   0xD050             BEQ.N    ??CRYP_AES_CCM_41
   1577              {
   1578                /* Select payload phase */
   1579                CRYP_PhaseConfig(CRYP_Phase_Payload);
   \   00000506   0xF44F 0x3000      MOV      R0,#+131072
   \   0000050A   0x.... 0x....      BL       CRYP_PhaseConfig
   1580          
   1581                /* Enable Crypto processor */
   1582                CRYP_Cmd(ENABLE);
   \   0000050E   0x2001             MOVS     R0,#+1
   \   00000510   0x.... 0x....      BL       CRYP_Cmd
   1583                
   1584                if(CRYP_GetCmdStatus() == DISABLE)
   \   00000514   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   00000518   0x2800             CMP      R0,#+0
   \   0000051A   0xD050             BEQ.N    ??CRYP_AES_CCM_21
   1585                {
   1586                  /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1587                     the CRYP peripheral (please check the device sales type. */
   1588                  return(ERROR);
   1589                }
   1590                
   1591                for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
   \   0000051C   0xF04F 0x0B00      MOV      R11,#+0
   \   00000520   0xE016             B.N      ??CRYP_AES_CCM_42
   1592                {
   1593                  /* Wait until the IFEM flag is reset */
   1594                  while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
   1595                  {
   1596                  }
   1597                  
   1598                  /* Write the Input block in the IN FIFO */
   1599                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1600                  inputaddr+=4;
   1601                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1602                  inputaddr+=4;
   1603                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1604                  inputaddr+=4;
   1605                  CRYP_DataIn(*(uint32_t*)(inputaddr));
   1606                  inputaddr+=4;
   1607                  
   1608                  /* Wait until the complete message has been processed */
   1609                  counter = 0;
   1610                  do
   1611                  {
   1612                    busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
   1613                    counter++;
   1614                  }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
   1615          
   1616                  if (busystatus != RESET)
   1617                  {
   1618                    status = ERROR;
   1619                  }
   1620                  else
   1621                  {
   1622                    /* Wait until the OFNE flag is reset */
   1623                    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_43: (+1)
   \   00000522   0x2004             MOVS     R0,#+4
   \   00000524   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000528   0x2800             CMP      R0,#+0
   \   0000052A   0xD0FA             BEQ.N    ??CRYP_AES_CCM_43
   1624                    {
   1625                    }
   1626                    
   1627                    /* Read the Output block from the Output FIFO */
   1628                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000052C   0x.... 0x....      BL       CRYP_DataOut
   \   00000530   0x6038             STR      R0,[R7, #+0]
   1629                    outputaddr+=4;
   \   00000532   0x1D3F             ADDS     R7,R7,#+4
   1630                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000534   0x.... 0x....      BL       CRYP_DataOut
   \   00000538   0x6038             STR      R0,[R7, #+0]
   1631                    outputaddr+=4;
   \   0000053A   0x1D3F             ADDS     R7,R7,#+4
   1632                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   0000053C   0x.... 0x....      BL       CRYP_DataOut
   \   00000540   0x6038             STR      R0,[R7, #+0]
   1633                    outputaddr+=4;
   \   00000542   0x1D3F             ADDS     R7,R7,#+4
   1634                    *(uint32_t*)(outputaddr) = CRYP_DataOut();
   \   00000544   0x.... 0x....      BL       CRYP_DataOut
   \   00000548   0x6038             STR      R0,[R7, #+0]
   1635                    outputaddr+=4;
   \   0000054A   0x1D3F             ADDS     R7,R7,#+4
   1636                  }
   \                     ??CRYP_AES_CCM_44: (+1)
   \   0000054C   0xF10B 0x0B10      ADD      R11,R11,#+16
   \                     ??CRYP_AES_CCM_42: (+1)
   \   00000550   0x982E             LDR      R0,[SP, #+184]
   \   00000552   0x4583             CMP      R11,R0
   \   00000554   0xD228             BCS.N    ??CRYP_AES_CCM_41
   \   00000556   0x0028             MOVS     R0,R5
   \   00000558   0xD026             BEQ.N    ??CRYP_AES_CCM_41
   \                     ??CRYP_AES_CCM_45: (+1)
   \   0000055A   0x2001             MOVS     R0,#+1
   \   0000055C   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   00000560   0x2800             CMP      R0,#+0
   \   00000562   0xD0FA             BEQ.N    ??CRYP_AES_CCM_45
   \   00000564   0x6830             LDR      R0,[R6, #+0]
   \   00000566   0x.... 0x....      BL       CRYP_DataIn
   \   0000056A   0x1D36             ADDS     R6,R6,#+4
   \   0000056C   0x6830             LDR      R0,[R6, #+0]
   \   0000056E   0x.... 0x....      BL       CRYP_DataIn
   \   00000572   0x1D36             ADDS     R6,R6,#+4
   \   00000574   0x6830             LDR      R0,[R6, #+0]
   \   00000576   0x.... 0x....      BL       CRYP_DataIn
   \   0000057A   0x1D36             ADDS     R6,R6,#+4
   \   0000057C   0x6830             LDR      R0,[R6, #+0]
   \   0000057E   0x.... 0x....      BL       CRYP_DataIn
   \   00000582   0x1D36             ADDS     R6,R6,#+4
   \   00000584   0x2000             MOVS     R0,#+0
   \   00000586   0x9000             STR      R0,[SP, #+0]
   \                     ??CRYP_AES_CCM_46: (+1)
   \   00000588   0x2010             MOVS     R0,#+16
   \   0000058A   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   0000058E   0x9900             LDR      R1,[SP, #+0]
   \   00000590   0x1C49             ADDS     R1,R1,#+1
   \   00000592   0x9100             STR      R1,[SP, #+0]
   \   00000594   0x9900             LDR      R1,[SP, #+0]
   \   00000596   0xF5B1 0x3F80      CMP      R1,#+65536
   \   0000059A   0xD001             BEQ.N    ??CRYP_AES_CCM_47
   \   0000059C   0x2800             CMP      R0,#+0
   \   0000059E   0xD1F3             BNE.N    ??CRYP_AES_CCM_46
   \                     ??CRYP_AES_CCM_47: (+1)
   \   000005A0   0x2800             CMP      R0,#+0
   \   000005A2   0xD0BE             BEQ.N    ??CRYP_AES_CCM_43
   \   000005A4   0x2500             MOVS     R5,#+0
   \   000005A6   0xE7D1             B.N      ??CRYP_AES_CCM_44
   1637                }
   1638              }
   1639              
   1640              /***************************** final phase ********************************/
   1641              /* Select final phase */
   1642              CRYP_PhaseConfig(CRYP_Phase_Final);
   \                     ??CRYP_AES_CCM_41: (+1)
   \   000005A8   0xF44F 0x3040      MOV      R0,#+196608
   \   000005AC   0x.... 0x....      BL       CRYP_PhaseConfig
   1643              
   1644              /* Enable Crypto processor */
   1645              CRYP_Cmd(ENABLE);
   \   000005B0   0x2001             MOVS     R0,#+1
   \   000005B2   0x.... 0x....      BL       CRYP_Cmd
   1646              
   1647              if(CRYP_GetCmdStatus() == DISABLE)
   \   000005B6   0x.... 0x....      BL       CRYP_GetCmdStatus
   \   000005BA   0x2800             CMP      R0,#+0
   \   000005BC   0xD101             BNE.N    ??CRYP_AES_CCM_48
   1648              {
   1649                /* The CRYP peripheral clock is not enabled or the device doesn't embed 
   1650                   the CRYP peripheral (please check the device sales type. */
   1651                return(ERROR);
   \                     ??CRYP_AES_CCM_21: (+1)
   \   000005BE   0x2000             MOVS     R0,#+0
   \   000005C0   0xE034             B.N      ??CRYP_AES_CCM_49
   1652              }
   1653              
   1654              ctraddr = (uint32_t)ctr;
   1655              /* Write the counter block in the IN FIFO */
   1656              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \                     ??CRYP_AES_CCM_48: (+1)
   \   000005C2   0x9801             LDR      R0,[SP, #+4]
   \   000005C4   0x6800             LDR      R0,[R0, #+0]
   \   000005C6   0x.... 0x....      BL       CRYP_DataIn
   1657              ctraddr+=4;
   \   000005CA   0x9803             LDR      R0,[SP, #+12]
   1658              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   000005CC   0x6800             LDR      R0,[R0, #+0]
   \   000005CE   0x.... 0x....      BL       CRYP_DataIn
   1659              ctraddr+=4;
   1660              CRYP_DataIn(*(uint32_t*)(ctraddr));
   \   000005D2   0x6820             LDR      R0,[R4, #+0]
   \   000005D4   0x.... 0x....      BL       CRYP_DataIn
   1661              ctraddr+=4;
   1662              /* Reset bit 0 (after 8-bit swap) is equivalent to reset bit 24 (before 8-bit swap) */
   1663              CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
   \   000005D8   0x1D20             ADDS     R0,R4,#+4
   \   000005DA   0x6800             LDR      R0,[R0, #+0]
   \   000005DC   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \   000005E0   0x.... 0x....      BL       CRYP_DataIn
   1664              
   1665              /* Wait until the OFNE flag is reset */
   1666              while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
   \                     ??CRYP_AES_CCM_50: (+1)
   \   000005E4   0x2004             MOVS     R0,#+4
   \   000005E6   0x.... 0x....      BL       CRYP_GetFlagStatus
   \   000005EA   0x2800             CMP      R0,#+0
   \   000005EC   0xD0FA             BEQ.N    ??CRYP_AES_CCM_50
   1667              {
   1668              }
   1669              
   1670              /* Read the Authentification TAG (MAC) in the IN FIFO */
   1671              temptag[0] = CRYP_DataOut();
   \   000005EE   0x.... 0x....      BL       CRYP_DataOut
   \   000005F2   0x9015             STR      R0,[SP, #+84]
   1672              temptag[1] = CRYP_DataOut();
   \   000005F4   0xAC15             ADD      R4,SP,#+84
   \   000005F6   0x.... 0x....      BL       CRYP_DataOut
   \   000005FA   0x6060             STR      R0,[R4, #+4]
   1673              temptag[2] = CRYP_DataOut();
   \   000005FC   0x.... 0x....      BL       CRYP_DataOut
   \   00000600   0x60A0             STR      R0,[R4, #+8]
   1674              temptag[3] = CRYP_DataOut();
   \   00000602   0x.... 0x....      BL       CRYP_DataOut
   \   00000606   0x60E0             STR      R0,[R4, #+12]
   1675            }
   1676            
   1677            /* Copy temporary authentication TAG in user TAG buffer */
   1678            for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
   \                     ??CRYP_AES_CCM_34: (+1)
   \   00000608   0xF04F 0x0B00      MOV      R11,#+0
   \   0000060C   0xE007             B.N      ??CRYP_AES_CCM_51
   1679            {
   1680              /* Set the authentication TAG buffer */
   1681              *((uint8_t*)tagaddr+loopcounter) = *((uint8_t*)temptag+loopcounter);
   \                     ??CRYP_AES_CCM_52: (+1)
   \   0000060E   0xA815             ADD      R0,SP,#+84
   \   00000610   0xF810 0x000B      LDRB     R0,[R0, R11]
   \   00000614   0x9914             LDR      R1,[SP, #+80]
   \   00000616   0xF801 0x000B      STRB     R0,[R1, R11]
   1682            }
   \   0000061A   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??CRYP_AES_CCM_51: (+1)
   \   0000061E   0x9834             LDR      R0,[SP, #+208]
   \   00000620   0x4583             CMP      R11,R0
   \   00000622   0xD3F4             BCC.N    ??CRYP_AES_CCM_52
   1683            
   1684            /* Disable Crypto */
   1685            CRYP_Cmd(DISABLE);
   \   00000624   0x2000             MOVS     R0,#+0
   \   00000626   0x.... 0x....      BL       CRYP_Cmd
   1686          
   1687            return status;
   \   0000062A   0x4628             MOV      R0,R5
   \                     ??CRYP_AES_CCM_49: (+1)
   \   0000062C   0xB023             ADD      SP,SP,#+140
   \   0000062E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1688          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   1689          
   1690          /**
   1691            * @}
   1692            */ 
   1693          
   1694          /**
   1695            * @}
   1696            */ 
   1697          
   1698          /**
   1699            * @}
   1700            */ 
   1701          
   1702          /**
   1703            * @}
   1704            */ 
   1705          
   1706          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
   1707          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     104   CRYP_AES_CBC
       104   -> CRYP_Cmd
       104   -> CRYP_DataIn
       104   -> CRYP_DataOut
       104   -> CRYP_FIFOFlush
       104   -> CRYP_GetCmdStatus
       104   -> CRYP_GetFlagStatus
       104   -> CRYP_IVInit
       104   -> CRYP_Init
       104   -> CRYP_KeyInit
       104   -> CRYP_KeyStructInit
     176   CRYP_AES_CCM
       176   -> CRYP_Cmd
       176   -> CRYP_DataIn
       176   -> CRYP_DataOut
       176   -> CRYP_FIFOFlush
       176   -> CRYP_GetCmdStatus
       176   -> CRYP_GetFlagStatus
       176   -> CRYP_IVInit
       176   -> CRYP_Init
       176   -> CRYP_KeyInit
       176   -> CRYP_KeyStructInit
       176   -> CRYP_PhaseConfig
       176   -> __aeabi_memclr4
     104   CRYP_AES_CTR
       104   -> CRYP_Cmd
       104   -> CRYP_DataIn
       104   -> CRYP_DataOut
       104   -> CRYP_FIFOFlush
       104   -> CRYP_GetCmdStatus
       104   -> CRYP_GetFlagStatus
       104   -> CRYP_IVInit
       104   -> CRYP_Init
       104   -> CRYP_KeyInit
       104   -> CRYP_KeyStructInit
      88   CRYP_AES_ECB
        88   -> CRYP_Cmd
        88   -> CRYP_DataIn
        88   -> CRYP_DataOut
        88   -> CRYP_FIFOFlush
        88   -> CRYP_GetCmdStatus
        88   -> CRYP_GetFlagStatus
        88   -> CRYP_Init
        88   -> CRYP_KeyInit
        88   -> CRYP_KeyStructInit
     136   CRYP_AES_GCM
       136   -> CRYP_Cmd
       136   -> CRYP_DataIn
       136   -> CRYP_DataOut
       136   -> CRYP_FIFOFlush
       136   -> CRYP_GetCmdStatus
       136   -> CRYP_GetFlagStatus
       136   -> CRYP_IVInit
       136   -> CRYP_Init
       136   -> CRYP_KeyInit
       136   -> CRYP_KeyStructInit
       136   -> CRYP_PhaseConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?_0
      16  ?_1
      16  ?_2
     504  CRYP_AES_CBC
    1586  CRYP_AES_CCM
     438  CRYP_AES_CTR
     492  CRYP_AES_ECB
    1214  CRYP_AES_GCM

 
    48 bytes in section .rodata
 4 234 bytes in section .text
 
 4 234 bytes of CODE  memory
    48 bytes of CONST memory

Errors: none
Warnings: none
