###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:32
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\board-hal\rtc_timer.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\board-hal\rtc_timer.c -D
#        IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D NUCLEO
#        -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000 -D
#        STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\rtc_timer.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\rtc_timer.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\board-hal\rtc_timer.c
      1          /*
      2           * ________________________________________________________________________________________________________
      3           * Copyright (c) 2016-2016 InvenSense Inc. All rights reserved.
      4           *
      5           * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      6           * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
      7           * and other intellectual property rights laws.
      8           *
      9           * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
     10           * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
     11           * from InvenSense is strictly prohibited.
     12           *
     13           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
     14           * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
     15           * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
     17           * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18           * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
     19           * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20           * OF THE SOFTWARE.
     21           * ________________________________________________________________________________________________________
     22           */
     23          
     24          #include "rtc_timer.h"
     25          
     26          #include "nvic_config.h"
     27          
     28          #include "stm32f4xx.h"
     29          #include <stddef.h>
     30          
     31          #define LSI_A_PREDIV 		0x1 /* to have room to correct LSI_S_PREDIV depending on measured LSI, res = 31.25 micro seconde */
     32          #define LSI_S_PREDIV 		0x3E7F /* to ensure by default  */
     33          
     34          #define LSE_A_PREDIV 		0x0
     35          #define LSE_S_PREDIV 		0x7FFF
     36          
     37          static int32_t rtc_timer_set_RTC_wakeup(uint32_t wake_period_us, uint32_t RTC_freq);
     38          static uint32_t rtc_timer_measure_LSI_frequency(void);
     39          static uint64_t rtc_timer_get_timestamp_us(void);
     40          
     41          /*
     42           * Callback for RTC IRQ handler
     43           */

   \                                 In section .bss, align 4
     44          static void (*sRtc_irq_handler_cb)(void);
     45          
     46          static struct
     47          {
     48          	uint32_t wu_period;// Wake Up period, 0 if not set
     49          	uint32_t freq;     // Measured RTC frequency
     50          	uint32_t sprediv;  // Value of S Prediv register
     51          	float reso_subsecond;  // Resolution of subsecond counter in us
     52          } rtc_config_state = {0};
   \                     rtc_config_state:
   \   00000000                      DS8 16
   \   00000010                      DS8 4
     53          
     54          /* Public functions  -------------------------------------------------*/
     55          

   \                                 In section .text, align 2, keep-with-next
     56          void rtc_timer_init(void (*rtc_irq_handler)(void), uint32_t wake_period, enum rtc_timer_clock use_clock)
     57          {
   \                     rtc_timer_init: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4690             MOV      R8,R2
     58          	EXTI_InitTypeDef  EXTI_InitStructure;
     59          	NVIC_InitTypeDef  NVIC_InitStructure;
     60          	RTC_InitTypeDef   RTC_InitStructure;
     61          	RTC_TimeTypeDef   RTC_TimeStructure;
     62          	uint32_t RTC_APrediv = LSI_A_PREDIV;
   \   0000000A   0x2601             MOVS     R6,#+1
     63          
     64          	sRtc_irq_handler_cb = rtc_irq_handler;
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable8
   \   00000010   0x6128             STR      R0,[R5, #+16]
     65          
     66          	/* Initiate and switch on RTC */
     67          	/* Enable the PWR clock */
     68          	/* Allow access to RTC */   
     69          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
   \   00000012   0x4631             MOV      R1,R6
   \   00000014   0xF04F 0x5080      MOV      R0,#+268435456
   \   00000018   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     70          	PWR_BackupAccessCmd(ENABLE);
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       PWR_BackupAccessCmd
     71           
     72          	if (use_clock == RTC_TIMER_CLOCK_LSE) {
   \   00000022   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0xD10F             BNE.N    ??rtc_timer_init_0
     73          		/* Enable the LSE OSC */
     74          		RCC_LSEConfig(RCC_LSE_ON);
   \   0000002A   0x.... 0x....      BL       RCC_LSEConfig
     75          
     76          		/* Wait till LSE is ready */  
     77          		while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) {
   \                     ??rtc_timer_init_1: (+1)
   \   0000002E   0x2041             MOVS     R0,#+65
   \   00000030   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD0FA             BEQ.N    ??rtc_timer_init_1
     78          		}
     79          
     80          		/* Select the RTC Clock Source */
     81          		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
   \   00000038   0xF44F 0x7080      MOV      R0,#+256
   \   0000003C   0x.... 0x....      BL       RCC_RTCCLKConfig
     82          
     83          		RTC_APrediv = LSE_A_PREDIV;
   \   00000040   0x2600             MOVS     R6,#+0
     84          		rtc_config_state.sprediv = LSE_S_PREDIV;
   \   00000042   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000046   0x60A8             STR      R0,[R5, #+8]
   \   00000048   0xE00D             B.N      ??rtc_timer_init_2
     85          	}
     86          	else {
     87          		/* The RTC Clock may varies due to LSI frequency dispersion. */   
     88          		/* Enable the LSI OSC */ 
     89          		RCC_LSICmd(ENABLE);
   \                     ??rtc_timer_init_0: (+1)
   \   0000004A   0x.... 0x....      BL       RCC_LSICmd
     90          
     91          		/* Wait till LSI is ready */  
     92          		while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET) {
   \                     ??rtc_timer_init_3: (+1)
   \   0000004E   0x2061             MOVS     R0,#+97
   \   00000050   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0FA             BEQ.N    ??rtc_timer_init_3
     93          		}
     94          
     95          		/* Select the RTC Clock Source */
     96          		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
   \   00000058   0xF44F 0x7000      MOV      R0,#+512
   \   0000005C   0x.... 0x....      BL       RCC_RTCCLKConfig
     97          
     98          		RTC_APrediv = LSI_A_PREDIV;
     99          		rtc_config_state.sprediv = LSI_S_PREDIV;
   \   00000060   0xF643 0x607F      MOVW     R0,#+15999
   \   00000064   0x60A8             STR      R0,[R5, #+8]
    100          	}
    101          	/* Enable the RTC Clock */
    102              RCC_RTCCLKCmd(ENABLE);
   \                     ??rtc_timer_init_2: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x.... 0x....      BL       RCC_RTCCLKCmd
    103          
    104          	/* RTC Wakeup Interrupt Generation: Clock Source: RTCCLK_Div2, Wakeup Time Base: ~1ms
    105          	 Wakeup Time Base (s) = (Divider / (LSE or LSI = 32k)) * WakeUpCounter
    106          	 WakeUpCounter = SCHEDULER_PERIOD (µs) * 1e-6 * (LSE = 32768 or LSI = 32000) / 4
    107          	*/
    108          	RTC_InitStructure.RTC_AsynchPrediv = RTC_APrediv;
   \   0000006C   0x9603             STR      R6,[SP, #+12]
    109          	RTC_InitStructure.RTC_SynchPrediv  = rtc_config_state.sprediv;
   \   0000006E   0x68A8             LDR      R0,[R5, #+8]
   \   00000070   0x9004             STR      R0,[SP, #+16]
    110          	RTC_InitStructure.RTC_HourFormat   = RTC_HourFormat_24;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x9002             STR      R0,[SP, #+8]
    111          	RTC_Init(&RTC_InitStructure);
   \   00000076   0xA802             ADD      R0,SP,#+8
   \   00000078   0x.... 0x....      BL       RTC_Init
    112              
    113          	/* Wait for RTC APB registers synchronisation */
    114          	RTC_WaitForSynchro();
   \   0000007C   0x.... 0x....      BL       RTC_WaitForSynchro
    115              
    116          	RTC_WakeUpCmd(DISABLE);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x.... 0x....      BL       RTC_WakeUpCmd
    117          	RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div2);
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0x.... 0x....      BL       RTC_WakeUpClockConfig
    118          
    119          	if (use_clock == RTC_TIMER_CLOCK_LSE) {
   \   0000008C   0x1C77             ADDS     R7,R6,#+1
   \   0000008E   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000092   0xD103             BNE.N    ??rtc_timer_init_4
    120          		rtc_config_state.freq = 32768;
   \   00000094   0xF44F 0x4000      MOV      R0,#+32768
   \   00000098   0x6068             STR      R0,[R5, #+4]
   \   0000009A   0xE00D             B.N      ??rtc_timer_init_5
    121          	}
    122          	else {
    123          		/* Measure the LSI Freq to adapt the wake up counter */
    124          		rtc_config_state.freq = rtc_timer_measure_LSI_frequency();
   \                     ??rtc_timer_init_4: (+1)
   \   0000009C   0x.... 0x....      BL       rtc_timer_measure_LSI_frequency
   \   000000A0   0x6068             STR      R0,[R5, #+4]
    125          		/* Correct calendar clock for timestamping */
    126          		rtc_config_state.sprediv = rtc_config_state.freq/(RTC_APrediv + 1) - 1;
   \   000000A2   0xFBB0 0xF0F7      UDIV     R0,R0,R7
   \   000000A6   0x1E40             SUBS     R0,R0,#+1
   \   000000A8   0x60A8             STR      R0,[R5, #+8]
    127          		RTC_InitStructure.RTC_AsynchPrediv = RTC_APrediv;
   \   000000AA   0x9603             STR      R6,[SP, #+12]
    128          		RTC_InitStructure.RTC_SynchPrediv  = rtc_config_state.sprediv;
   \   000000AC   0x9004             STR      R0,[SP, #+16]
    129          		RTC_InitStructure.RTC_HourFormat   = RTC_HourFormat_24;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x9002             STR      R0,[SP, #+8]
    130          		RTC_Init(&RTC_InitStructure);
   \   000000B2   0xA802             ADD      R0,SP,#+8
   \   000000B4   0x.... 0x....      BL       RTC_Init
    131              }
    132          	rtc_config_state.reso_subsecond = (1000000000ULL * (RTC_APrediv + 1)) / (uint64_t)rtc_config_state.freq; // ns
   \                     ??rtc_timer_init_5: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable8_1  ;; 0x3b9aca00
   \   000000BA   0xFBA0 0x0107      UMULL    R0,R1,R0,R7
   \   000000BE   0x686A             LDR      R2,[R5, #+4]
   \   000000C0   0x2300             MOVS     R3,#+0
   \   000000C2   0x.... 0x....      BL       __aeabi_uldivmod
   \   000000C6   0x.... 0x....      BL       __aeabi_ul2f
   \   000000CA   0x60E8             STR      R0,[R5, #+12]
    133          
    134          	/* Set the time to 00h 00mn 00s AM */
    135          	RTC_TimeStructure.RTC_H12     = RTC_H12_AM;
   \   000000CC   0x2000             MOVS     R0,#+0
    136          	RTC_TimeStructure.RTC_Hours   = 0;
   \   000000CE   0x9000             STR      R0,[SP, #+0]
    137          	RTC_TimeStructure.RTC_Minutes = 0;
    138          	RTC_TimeStructure.RTC_Seconds = 0;  
    139          	RTC_SetTime(RTC_Format_BCD, &RTC_TimeStructure);
   \   000000D0   0x4669             MOV      R1,SP
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0x.... 0x....      BL       RTC_SetTime
    140              
    141          	rtc_timer_set_RTC_wakeup(wake_period, rtc_config_state.freq);
   \   000000D8   0x6869             LDR      R1,[R5, #+4]
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       rtc_timer_set_RTC_wakeup
    142          	rtc_config_state.wu_period = wake_period;
   \   000000E0   0x602C             STR      R4,[R5, #+0]
    143             
    144          	RTC_ClearFlag(RTC_FLAG_WUTF);
   \   000000E2   0xF44F 0x6080      MOV      R0,#+1024
   \   000000E6   0x.... 0x....      BL       RTC_ClearFlag
    145              
    146          	/* Prepare the Wakeup Interrupt */
    147          	RTC_ITConfig(RTC_IT_WUT, ENABLE);
   \   000000EA   0x2101             MOVS     R1,#+1
   \   000000EC   0xF44F 0x4080      MOV      R0,#+16384
   \   000000F0   0x.... 0x....      BL       RTC_ITConfig
    148          
    149          	/* Connect EXTI_Line22 to the RTC Wakeup event */
    150          	EXTI_ClearITPendingBit(EXTI_Line22);
   \   000000F4   0xF44F 0x0080      MOV      R0,#+4194304
   \   000000F8   0x.... 0x....      BL       EXTI_ClearITPendingBit
    151          	EXTI_InitStructure.EXTI_Line = EXTI_Line22;
   \   000000FC   0xF44F 0x0080      MOV      R0,#+4194304
   \   00000100   0x9005             STR      R0,[SP, #+20]
    152          	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0xF88D 0x0018      STRB     R0,[SP, #+24]
    153          	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
   \   00000108   0x2008             MOVS     R0,#+8
   \   0000010A   0xF88D 0x0019      STRB     R0,[SP, #+25]
    154          	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xF88D 0x001A      STRB     R0,[SP, #+26]
    155          	EXTI_Init(&EXTI_InitStructure);
   \   00000114   0xA805             ADD      R0,SP,#+20
   \   00000116   0x.... 0x....      BL       EXTI_Init
    156          
    157          	/* Enable the RTC Wakeup Interrupt */
    158          	NVIC_InitStructure.NVIC_IRQChannel = RTC_WKUP_IRQn;
   \   0000011A   0x2003             MOVS     R0,#+3
   \   0000011C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    159          	/* I2cMaster IRQ task could take more than 1ms so the RTC interrupt priority must be highest to keep the clock fonctional */
    160          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_RTC;
   \   00000120   0x2005             MOVS     R0,#+5
   \   00000122   0xF88D 0x0005      STRB     R0,[SP, #+5]
    161          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; 
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xF88D 0x0006      STRB     R0,[SP, #+6]
    162          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xF88D 0x0007      STRB     R0,[SP, #+7]
    163          	NVIC_Init(&NVIC_InitStructure);
   \   00000132   0xA801             ADD      R0,SP,#+4
   \   00000134   0x.... 0x....      BL       NVIC_Init
    164          
    165          	RTC_WakeUpCmd(ENABLE);
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0x.... 0x....      BL       RTC_WakeUpCmd
    166          }
   \   0000013E   0xB008             ADD      SP,SP,#+32
   \   00000140   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void rtc_timer_update_irq_callback(void (*rtc_irq_handler)(void))
    169          {
    170          	sRtc_irq_handler_cb = rtc_irq_handler;
   \                     rtc_timer_update_irq_callback: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable8
   \   00000002   0x6108             STR      R0,[R1, #+16]
    171          }
   \   00000004   0x4770             BX       LR               ;; return
    172          

   \                                 In section .text, align 2, keep-with-next
    173          int32_t rtc_timer_update_wake_period(uint32_t wake_period) 
    174          {
   \                     rtc_timer_update_wake_period: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    175          	uint32_t wake_state;
    176          	int32_t error = 0;
    177          
    178          	if (wake_period == rtc_config_state.wu_period)
   \   00000004   0x....             LDR.N    R5,??DataTable8
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD101             BNE.N    ??rtc_timer_update_wake_period_0
    179          		return 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBDF2             POP      {R1,R4-R7,PC}
    180          	/* Check if RTC is enabled */
    181          	wake_state = (RTC->CR & RTC_CR_WUTE);
   \                     ??rtc_timer_update_wake_period_0: (+1)
   \   00000010   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40002808
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF400 0x6680      AND      R6,R0,#0x400
    182          	/* Disable in any case */
    183          	if (RTC_WakeUpCmd(DISABLE) != SUCCESS)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       RTC_WakeUpCmd
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD124             BNE.N    ??rtc_timer_update_wake_period_1
    184          		return -1;
    185          	RTC_ClearFlag(RTC_FLAG_WUTF);
   \   00000022   0xF44F 0x6080      MOV      R0,#+1024
   \   00000026   0x.... 0x....      BL       RTC_ClearFlag
    186          
    187          	RTC_ITConfig(RTC_IT_WUT, DISABLE);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000030   0x.... 0x....      BL       RTC_ITConfig
    188          	// b) Clear the RTC Wakeup (WUTF) flag
    189          	RTC_ClearITPendingBit(RTC_IT_WUT);
   \   00000034   0xF44F 0x4080      MOV      R0,#+16384
   \   00000038   0x.... 0x....      BL       RTC_ClearITPendingBit
    190          	// c) Clear the PWR Wakeup (WUF) flag
    191          	PWR_ClearFlag(PWR_FLAG_WU);
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       PWR_ClearFlag
    192          	// d) Enable the RTC Wakeup interrupt
    193          	RTC_ITConfig(RTC_IT_WUT, ENABLE);
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0xF44F 0x4080      MOV      R0,#+16384
   \   00000048   0x.... 0x....      BL       RTC_ITConfig
    194          	// e) Re-enter the low power mode
    195          	  // Will be done after all processing needed for the product
    196          
    197          	error = rtc_timer_set_RTC_wakeup(wake_period, rtc_config_state.freq);
   \   0000004C   0x6869             LDR      R1,[R5, #+4]
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       rtc_timer_set_RTC_wakeup
   \   00000054   0x4607             MOV      R7,R0
    198          	rtc_config_state.wu_period = wake_period;
   \   00000056   0x602C             STR      R4,[R5, #+0]
    199          	/* Enable again if it was enabled, if error old value is still programmed */
    200          	if (wake_state == RTC_CR_WUTE)
   \   00000058   0xF5B6 0x6F80      CMP      R6,#+1024
   \   0000005C   0xD109             BNE.N    ??rtc_timer_update_wake_period_2
    201          	{
    202          		RTC_WaitForSynchro();
   \   0000005E   0x.... 0x....      BL       RTC_WaitForSynchro
    203          		if (RTC_WakeUpCmd(ENABLE) != SUCCESS)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       RTC_WakeUpCmd
   \   00000068   0x2801             CMP      R0,#+1
   \   0000006A   0xD002             BEQ.N    ??rtc_timer_update_wake_period_2
    204          			return -1;
   \                     ??rtc_timer_update_wake_period_1: (+1)
   \   0000006C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}
    205          	}
    206          
    207          	return error;
   \                     ??rtc_timer_update_wake_period_2: (+1)
   \   00000072   0x4638             MOV      R0,R7
   \   00000074   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    208          }
    209          

   \                                 In section .text, align 2, keep-with-next
    210          uint64_t rtc_timer_get_time_us(void)
    211          {
   \                     rtc_timer_get_time_us: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    212          	static uint64_t timestamp_monotonic_us = 0;
    213          
    214          	uint64_t ts = rtc_timer_get_timestamp_us();
   \   00000002   0x.... 0x....      BL       rtc_timer_get_timestamp_us
   \   00000006   0x2314             MOVS     R3,#+20
   \   00000008   0xE002             B.N      ??rtc_timer_get_time_us_0
    215          
    216          	while (ts < timestamp_monotonic_us) {
    217          		ts += 24ULL * 3600ULL * 1000000ULL;
   \                     ??rtc_timer_get_time_us_1: (+1)
   \   0000000A   0x....             LDR.N    R2,??DataTable8_3  ;; 0x1dd76000
   \   0000000C   0x1880             ADDS     R0,R0,R2
   \   0000000E   0x4159             ADCS     R1,R1,R3
    218          	}
   \                     ??rtc_timer_get_time_us_0: (+1)
   \   00000010   0x....             LDR.N    R2,??DataTable8_4
   \   00000012   0xE9D2 0x4500      LDRD     R4,R5,[R2, #+0]
   \   00000016   0x42A9             CMP      R1,R5
   \   00000018   0xD3F7             BCC.N    ??rtc_timer_get_time_us_1
   \   0000001A   0xD801             BHI.N    ??rtc_timer_get_time_us_2
   \   0000001C   0x42A0             CMP      R0,R4
   \   0000001E   0xD3F4             BCC.N    ??rtc_timer_get_time_us_1
    219          
    220          	timestamp_monotonic_us = ts;
   \                     ??rtc_timer_get_time_us_2: (+1)
   \   00000020   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    221          
    222          	return timestamp_monotonic_us;
   \   00000024   0xBD34             POP      {R2,R4,R5,PC}    ;; return
    223          }

   \                                 In section .bss, align 8
   \                     `rtc_timer_get_time_us::timestamp_monotonic_us`:
   \   00000000                      DS8 8
    224          
    225          /* Interrupt management ------------------------------------------------------*/
    226          
    227          /**
    228            * @brief  RTC IT wake up handler
    229            * @param  None
    230            * @retval None
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          void RTC_WKUP_IRQHandler(void)
    233          {
   \                     RTC_WKUP_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    234          	if(RTC_GetITStatus(RTC_IT_WUT) != RESET)
   \   00000002   0xF44F 0x4080      MOV      R0,#+16384
   \   00000006   0x.... 0x....      BL       RTC_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD015             BEQ.N    ??RTC_WKUP_IRQHandler_0
    235          	{
    236          		// Feature #8135 : Integrate Safe RTC alternate function wakeup flag clearing sequence
    237          		// Extracted from stm32f401 errata sheet
    238          		/*
    239          		  ST recommendation :
    240          
    241          		  When using RTC wakeup to wake up the device from the low-power modes:
    242          		  a) Disable the RTC Wakeup interrupt (WUTIE bit in the RTC_CR register)
    243          		  b) Clear the RTC Wakeup (WUTF) flag
    244          		  c) Clear the PWR Wakeup (WUF) flag
    245          		  d) Enable the RTC Wakeup interrupt
    246          		  e) Re-enter the low power mode
    247          		*/
    248          
    249          		// a) Disable the RTC Wakeup interrupt (WUTIE bit in the RTC_CR register)
    250          		RTC_ITConfig(RTC_IT_WUT, DISABLE);
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF44F 0x4080      MOV      R0,#+16384
   \   00000014   0x.... 0x....      BL       RTC_ITConfig
    251          		// b) Clear the RTC Wakeup (WUTF) flag
    252          		RTC_ClearITPendingBit(RTC_IT_WUT);
   \   00000018   0xF44F 0x4080      MOV      R0,#+16384
   \   0000001C   0x.... 0x....      BL       RTC_ClearITPendingBit
    253          		// c) Clear the PWR Wakeup (WUF) flag
    254          		PWR_ClearFlag(PWR_FLAG_WU);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       PWR_ClearFlag
    255          		// d) Enable the RTC Wakeup interrupt
    256          		RTC_ITConfig(RTC_IT_WUT, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF44F 0x4080      MOV      R0,#+16384
   \   0000002C   0x.... 0x....      BL       RTC_ITConfig
   \   00000030   0x....             LDR.N    R0,??DataTable8
   \   00000032   0x6900             LDR      R0,[R0, #+16]
   \   00000034   0x0001             MOVS     R1,R0
   \   00000036   0xD000             BEQ.N    ??RTC_WKUP_IRQHandler_0
    257          		// e) Re-enter the low power mode
    258          		  // Will be done after all processing needed for the product
    259          
    260          		if(sRtc_irq_handler_cb != NULL)
    261          			sRtc_irq_handler_cb();
   \   00000038   0x4780             BLX      R0
    262          	}
    263          
    264          	// CLear the exti 22
    265          	EXTI_ClearITPendingBit(EXTI_Line22);
   \                     ??RTC_WKUP_IRQHandler_0: (+1)
   \   0000003A   0xF44F 0x0080      MOV      R0,#+4194304
   \   0000003E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000042   0x.... 0x....      B.W      EXTI_ClearITPendingBit
    266          }
    267          
    268          /* Private function  -----------------------------------------------*/
    269          

   \                                 In section .bss, align 4
    270          static volatile uint32_t CaptureNumber = 0;
    271          static volatile uint32_t PeriodValue = 0;
    272          static volatile uint16_t tmpCC4[2] = {0, 0};
   \                     tmpCC4:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
    273          
    274          /**
    275            * @brief  Get timestamps from RTC calendar counters in microsecond
    276            * @retval timestamps in microsecond on 24 hours
    277            */

   \                                 In section .text, align 2, keep-with-next
    278          static uint64_t rtc_timer_get_timestamp_us(void)
    279          {
   \                     rtc_timer_get_timestamp_us: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    280          	uint32_t counter_subsec;
    281          	uint64_t subsecond_us;
    282          	uint64_t base_us;
    283          
    284          	RTC_TimeTypeDef RTC_TimeStruct;
    285          	//Wait until shadow registers are synchronized
    286          	RTC_WaitForSynchro();
   \   00000004   0x.... 0x....      BL       RTC_WaitForSynchro
    287          	RTC_GetTime(RTC_Format_BIN, &RTC_TimeStruct);
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       RTC_GetTime
    288          	counter_subsec = RTC_GetSubSecond(); /* downcounter from S_PREDIV to 0 */
   \   00000010   0x.... 0x....      BL       RTC_GetSubSecond
    289              
    290          	base_us = ((uint64_t)(rtc_config_state.sprediv - counter_subsec) * (uint64_t)rtc_config_state.reso_subsecond) / 1000ULL;
    291          	subsecond_us = (uint64_t)RTC_TimeStruct.RTC_Hours * 3600ULL * 1000000ULL
    292          				  + (uint64_t)RTC_TimeStruct.RTC_Minutes * 60ULL * 1000000ULL
    293          				  + (uint64_t)RTC_TimeStruct.RTC_Seconds * 1000000ULL
    294          				  + base_us;
    295          
    296          	return subsecond_us;
   \   00000014   0x....             LDR.N    R1,??DataTable8
   \   00000016   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000001A   0x....             LDR.N    R3,??DataTable8_5  ;; 0xd693a400
   \   0000001C   0xF89D 0x4001      LDRB     R4,[SP, #+1]
   \   00000020   0x....             LDR.N    R5,??DataTable8_6  ;; 0x3938700
   \   00000022   0xFBA5 0x4504      UMULL    R4,R5,R5,R4
   \   00000026   0xFBE3 0x4502      UMLAL    R4,R5,R3,R2
   \   0000002A   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   0000002E   0x....             LDR.N    R3,??DataTable8_7  ;; 0xf4240
   \   00000030   0xFBE3 0x4502      UMLAL    R4,R5,R3,R2
   \   00000034   0x688A             LDR      R2,[R1, #+8]
   \   00000036   0x1A16             SUBS     R6,R2,R0
   \   00000038   0x68C8             LDR      R0,[R1, #+12]
   \   0000003A   0x.... 0x....      BL       __aeabi_f2ulz
   \   0000003E   0xFBA0 0x2306      UMULL    R2,R3,R0,R6
   \   00000042   0xFB01 0x3306      MLA      R3,R1,R6,R3
   \   00000046   0x4610             MOV      R0,R2
   \   00000048   0x4619             MOV      R1,R3
   \   0000004A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000054   0x1820             ADDS     R0,R4,R0
   \   00000056   0x4169             ADCS     R1,R5,R1
   \   00000058   0xBD7C             POP      {R2-R6,PC}       ;; return
    297          }
    298          
    299          /**
    300           * @brief Set RTC calibrated wake up counter
    301           * @details
    302           * @param wake_period_us required wake up period in uS
    303           * @param RTC_freq in Hz
    304           * @retval error code (<0 if error)
    305           */

   \                                 In section .text, align 4, keep-with-next
    306          static int32_t rtc_timer_set_RTC_wakeup(uint32_t wake_period_us, uint32_t RTC_freq)
    307          {
   \                     rtc_timer_set_RTC_wakeup: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    308          	uint32_t value;
    309          	uint32_t freqHz;
    310          	uint32_t RTC_div_wake;
    311          	uint32_t divider;
    312          
    313          	if (wake_period_us == 0)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??rtc_timer_set_RTC_wakeup_1
    314          		return -1;
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD02             POP      {R1,PC}
    315          		
    316          	freqHz = 1000000/wake_period_us;
   \                     ??rtc_timer_set_RTC_wakeup_1: (+1)
   \   0000000C   0x....             LDR.N    R2,??DataTable8_7  ;; 0xf4240
   \   0000000E   0xFBB2 0xF0F0      UDIV     R0,R2,R0
    317          	if (freqHz == 0)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD102             BNE.N    ??rtc_timer_set_RTC_wakeup_2
    318          		return -1;
   \   00000016   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001A   0xBD02             POP      {R1,PC}
    319          
    320          	RTC_div_wake = (RTC->CR & 0x07);
   \                     ??rtc_timer_set_RTC_wakeup_2: (+1)
   \   0000001C   0x....             LDR.N    R2,??DataTable8_2  ;; 0x40002808
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0xF002 0x0207      AND      R2,R2,#0x7
    321          
    322          	switch (RTC_div_wake) 
   \   00000024   0x2A03             CMP      R2,#+3
   \   00000026   0xD812             BHI.N    ??rtc_timer_set_RTC_wakeup_3
   \   00000028   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??rtc_timer_set_RTC_wakeup_0:
   \   0000002C   0x02 0x0B          DC8      0x2,0xB,0xD,0xF
   \              0x0D 0x0F    
    323          	{
    324          		case RTC_WakeUpClock_RTCCLK_Div16:
    325          			divider = 16;
   \                     ??rtc_timer_set_RTC_wakeup_4: (+1)
   \   00000030   0x2210             MOVS     R2,#+16
    326          			break;
    327          		case RTC_WakeUpClock_RTCCLK_Div8:
    328          			divider = 8;
    329          			break;
    330          		case RTC_WakeUpClock_RTCCLK_Div4:
    331          			divider = 4;
    332          			break;
    333          		case RTC_WakeUpClock_RTCCLK_Div2:
    334          			divider = 2;
    335          			break;
    336          		default:
    337          			return -1;
    338          	}
    339          
    340          	value = RTC_freq/(freqHz * divider)-1; // Wakeup Time Base
   \                     ??rtc_timer_set_RTC_wakeup_5: (+1)
   \   00000032   0x4350             MULS     R0,R2,R0
   \   00000034   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000038   0x1E40             SUBS     R0,R0,#+1
    341          	if (value < 1)
   \   0000003A   0xD10B             BNE.N    ??rtc_timer_set_RTC_wakeup_6
    342          		return -1;
   \   0000003C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000040   0xBD02             POP      {R1,PC}
   \                     ??rtc_timer_set_RTC_wakeup_7: (+1)
   \   00000042   0x2208             MOVS     R2,#+8
   \   00000044   0xE7F5             B.N      ??rtc_timer_set_RTC_wakeup_5
   \                     ??rtc_timer_set_RTC_wakeup_8: (+1)
   \   00000046   0x2204             MOVS     R2,#+4
   \   00000048   0xE7F3             B.N      ??rtc_timer_set_RTC_wakeup_5
   \                     ??rtc_timer_set_RTC_wakeup_9: (+1)
   \   0000004A   0x2202             MOVS     R2,#+2
   \   0000004C   0xE7F1             B.N      ??rtc_timer_set_RTC_wakeup_5
   \                     ??rtc_timer_set_RTC_wakeup_3: (+1)
   \   0000004E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000052   0xBD02             POP      {R1,PC}
    343          
    344          	RTC_SetWakeUpCounter(value);
   \                     ??rtc_timer_set_RTC_wakeup_6: (+1)
   \   00000054   0x.... 0x....      BL       RTC_SetWakeUpCounter
    345          
    346          	return 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD02             POP      {R1,PC}          ;; return
    347          }
    348          
    349          /**
    350            * @brief  Configures TIM5 to measure the LSI oscillator frequency. 
    351            * @param  None
    352            * @retval LSI Frequency in Hz
    353            */

   \                                 In section .text, align 2, keep-with-next
    354          static uint32_t rtc_timer_measure_LSI_frequency(void)
    355          {
   \                     rtc_timer_measure_LSI_frequency: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    356          	NVIC_InitTypeDef   NVIC_InitStructure;
    357          	TIM_ICInitTypeDef  TIM_ICInitStructure;
    358          	RCC_ClocksTypeDef  RCC_ClockFreq;
    359          	uint32_t LSI_Freq;
    360          
    361          	/* TIM5 configuration *******************************************************/ 
    362          	/* Enable TIM5 clock */
    363          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2008             MOVS     R0,#+8
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    364          
    365          	/* Connect internally the TIM5_CH4 Input Capture to the LSI clock output */
    366          	TIM_RemapConfig(TIM5, TIM5_LSI);
   \   0000000C   0x....             LDR.N    R4,??DataTable8_8  ;; 0x40000c00
   \   0000000E   0x2140             MOVS     R1,#+64
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       TIM_RemapConfig
    367          
    368          	/* Configure TIM5 presclaer */
    369          	TIM_PrescalerConfig(TIM5, 0, TIM_PSCReloadMode_Immediate);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       TIM_PrescalerConfig
    370          
    371          	/* TIM5 configuration: Input Capture mode ---------------------
    372          	   The LSI oscillator is connected to TIM5 CH4
    373          	   The Rising edge is used as active edge,
    374          	   The TIM5 CCR4 is used to compute the frequency value 
    375          	------------------------------------------------------------ */
    376          	TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    377          	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    378          	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    379          	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV8;
   \   00000032   0x200C             MOVS     R0,#+12
   \   00000034   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    380          	TIM_ICInitStructure.TIM_ICFilter = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    381          	TIM_ICInit(TIM5, &TIM_ICInitStructure);
   \   0000003E   0xA901             ADD      R1,SP,#+4
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       TIM_ICInit
    382          
    383          	/* Enable TIM5 Interrupt channel */
    384          	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
    385          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_RTC;
   \   0000004C   0x2005             MOVS     R0,#+5
   \   0000004E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    386          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF88D 0x0002      STRB     R0,[SP, #+2]
    387          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    388          	NVIC_Init(&NVIC_InitStructure);
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x.... 0x....      BL       NVIC_Init
    389          
    390          	/* Enable TIM5 counter */
    391          	TIM_Cmd(TIM5, ENABLE);
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       TIM_Cmd
    392          
    393          	/* Reset the flags */
    394          	TIM5->SR = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8220             STRH     R0,[R4, #+16]
    395              
    396          	CaptureNumber = 0;
   \   00000070   0x....             LDR.N    R5,??DataTable8_9
   \   00000072   0x6068             STR      R0,[R5, #+4]
    397              
    398          	/* Enable the CC4 Interrupt Request */  
    399          	TIM_ITConfig(TIM5, TIM_IT_CC4, ENABLE);
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x2110             MOVS     R1,#+16
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       TIM_ITConfig
    400          
    401          	/* Wait until the TIM5 get 2 LSI edges (refer to TIM5_IRQHandler() in 
    402          	  stm32f4xx_it.c file) ******************************************************/
    403          
    404          	while(CaptureNumber < 2)
   \                     ??rtc_timer_measure_LSI_frequency_0: (+1)
   \   0000007E   0x6868             LDR      R0,[R5, #+4]
   \   00000080   0x2802             CMP      R0,#+2
   \   00000082   0xD3FC             BCC.N    ??rtc_timer_measure_LSI_frequency_0
    405          		;
    406          		
    407          	/* Disable TIM5 clock */
    408          	/* Deinitialize the TIM5 peripheral registers to their default reset values */
    409          	/* After reset, the peripheral clock (used for registers read/write access) */
    410          	/* is disabled and the application software has to enable this clock before */
    411          	/* using it. */
    412          	/* Enable the CC4 Interrupt Request */  
    413          	TIM_ITConfig(TIM5, TIM_IT_CC4, DISABLE);
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x2110             MOVS     R1,#+16
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       TIM_ITConfig
    414          	TIM_DeInit(TIM5);
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       TIM_DeInit
    415          
    416          	/* Deinitialize the NVIC interrupt for TIM5 channel */
    417          	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
   \   00000094   0x2032             MOVS     R0,#+50
   \   00000096   0xF88D 0x0000      STRB     R0,[SP, #+0]
    418          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_PRIORITY_RTC;
   \   0000009A   0x2005             MOVS     R0,#+5
   \   0000009C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    419          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    420          	NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
    421          	NVIC_Init(&NVIC_InitStructure);
   \   000000A6   0x4668             MOV      R0,SP
   \   000000A8   0x.... 0x....      BL       NVIC_Init
    422          
    423          	/* Disable TIM5 clock */
    424          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, DISABLE);
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x2008             MOVS     R0,#+8
   \   000000B0   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    425          
    426          	/* Compute the LSI frequency, depending on TIM5 input clock frequency (PCLK1)*/
    427          	/* Get SYSCLK, HCLK and PCLKx frequency */
    428          	RCC_GetClocksFreq(&RCC_ClockFreq);
   \   000000B4   0xA804             ADD      R0,SP,#+16
   \   000000B6   0x.... 0x....      BL       RCC_GetClocksFreq
    429          
    430          	/* Get PCLK1 prescaler */
    431          	if ((RCC->CFGR & RCC_CFGR_PPRE1) == 0)
   \   000000BA   0x9806             LDR      R0,[SP, #+24]
   \   000000BC   0x....             LDR.N    R1,??DataTable8_10  ;; 0x40023808
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0xF411 0x5FE0      TST      R1,#0x1C00
   \   000000C4   0xD104             BNE.N    ??rtc_timer_measure_LSI_frequency_1
    432          	{ 
    433          		/* PCLK1 prescaler equal to 1 => TIMCLK = PCLK1 */
    434          		LSI_Freq = ((RCC_ClockFreq.PCLK1_Frequency / PeriodValue) * 8);
   \   000000C6   0x68A9             LDR      R1,[R5, #+8]
   \   000000C8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000CC   0x00C0             LSLS     R0,R0,#+3
   \   000000CE   0xE004             B.N      ??rtc_timer_measure_LSI_frequency_2
    435          	}
    436          	else
    437          	{ /* PCLK1 prescaler different from 1 => TIMCLK = 2 * PCLK1 */
    438          		LSI_Freq = (((2 * RCC_ClockFreq.PCLK1_Frequency) / PeriodValue) * 8) ;
   \                     ??rtc_timer_measure_LSI_frequency_1: (+1)
   \   000000D0   0x0040             LSLS     R0,R0,#+1
   \   000000D2   0x68A9             LDR      R1,[R5, #+8]
   \   000000D4   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000D8   0x00C0             LSLS     R0,R0,#+3
    439          	}
    440          	return LSI_Freq;
   \                     ??rtc_timer_measure_LSI_frequency_2: (+1)
   \   000000DA   0xB009             ADD      SP,SP,#+36
   \   000000DC   0xBD30             POP      {R4,R5,PC}       ;; return
    441          }
    442          
    443          /**
    444            * @brief  This function handles TIM5 global interrupt request.
    445            * @param  None
    446            * @retval None
    447            */

   \                                 In section .text, align 2, keep-with-next
    448          void TIM5_IRQHandler(void)
    449          {
   \                     TIM5_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    450          	if ((TIM_GetITStatus(TIM5, TIM_IT_CC4) != RESET) && (CaptureNumber < 2))
   \   00000002   0x....             LDR.N    R5,??DataTable8_8  ;; 0x40000c00
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD017             BEQ.N    ??TIM5_IRQHandler_0
   \   00000010   0x....             LDR.N    R4,??DataTable8_9
   \   00000012   0x6860             LDR      R0,[R4, #+4]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD213             BCS.N    ??TIM5_IRQHandler_0
    451          	{
    452          		/* Get the Input Capture value */
    453          		tmpCC4[CaptureNumber++] = TIM_GetCapture4(TIM5);
   \   00000018   0x6866             LDR      R6,[R4, #+4]
   \   0000001A   0x1C70             ADDS     R0,R6,#+1
   \   0000001C   0x6060             STR      R0,[R4, #+4]
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       TIM_GetCapture4
   \   00000024   0xF824 0x0016      STRH     R0,[R4, R6, LSL #+1]
    454          
    455          		/* Clear CC4 Interrupt pending bit */
    456          		TIM_ClearITPendingBit(TIM5, TIM_IT_CC4);
   \   00000028   0x2110             MOVS     R1,#+16
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       TIM_ClearITPendingBit
    457          
    458          		if (CaptureNumber >= 2)
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD304             BCC.N    ??TIM5_IRQHandler_0
    459          		{
    460          			// Compute the period length 
    461          			uint16_t tmp_volatile_access = tmpCC4[0];
   \   00000036   0x8820             LDRH     R0,[R4, #+0]
    462          			PeriodValue = (uint16_t)(0xFFFF - tmp_volatile_access + tmpCC4[1] + 1);
   \   00000038   0x8861             LDRH     R1,[R4, #+2]
   \   0000003A   0x1A08             SUBS     R0,R1,R0
   \   0000003C   0xB280             UXTH     R0,R0
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
    463          		}
    464          	}
    465          }
   \                     ??TIM5_IRQHandler_0: (+1)
   \   00000040   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     rtc_config_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x1DD76000         DC32     0x1dd76000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     `rtc_timer_get_time_us::timestamp_monotonic_us`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0xD693A400         DC32     0xd693a400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x03938700         DC32     0x3938700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     tmpCC4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x40023808         DC32     0x40023808

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   RTC_WKUP_IRQHandler
         8   -- Indirect call
         0   -> EXTI_ClearITPendingBit
         8   -> PWR_ClearFlag
         8   -> RTC_ClearITPendingBit
         8   -> RTC_GetITStatus
         8   -> RTC_ITConfig
      16   TIM5_IRQHandler
        16   -> TIM_ClearITPendingBit
        16   -> TIM_GetCapture4
        16   -> TIM_GetITStatus
      16   rtc_timer_get_time_us
        16   -> rtc_timer_get_timestamp_us
      24   rtc_timer_get_timestamp_us
        24   -> RTC_GetSubSecond
        24   -> RTC_GetTime
        24   -> RTC_WaitForSynchro
        24   -> __aeabi_f2ulz
        24 __aeabi_uldivmod
      56   rtc_timer_init
        56   -> EXTI_ClearITPendingBit
        56   -> EXTI_Init
        56   -> NVIC_Init
        56   -> PWR_BackupAccessCmd
        56   -> RCC_APB1PeriphClockCmd
        56   -> RCC_GetFlagStatus
        56   -> RCC_LSEConfig
        56   -> RCC_LSICmd
        56   -> RCC_RTCCLKCmd
        56   -> RCC_RTCCLKConfig
        56   -> RTC_ClearFlag
        56   -> RTC_ITConfig
        56   -> RTC_Init
        56   -> RTC_SetTime
        56   -> RTC_WaitForSynchro
        56   -> RTC_WakeUpClockConfig
        56   -> RTC_WakeUpCmd
        56   -> __aeabi_ul2f
        56   -> rtc_timer_measure_LSI_frequency
        56   -> rtc_timer_set_RTC_wakeup
        56 __aeabi_uldivmod
      48   rtc_timer_measure_LSI_frequency
        48   -> NVIC_Init
        48   -> RCC_APB1PeriphClockCmd
        48   -> RCC_GetClocksFreq
        48   -> TIM_Cmd
        48   -> TIM_DeInit
        48   -> TIM_ICInit
        48   -> TIM_ITConfig
        48   -> TIM_PrescalerConfig
        48   -> TIM_RemapConfig
       8   rtc_timer_set_RTC_wakeup
         8   -> RTC_SetWakeUpCounter
       0   rtc_timer_update_irq_callback
      24   rtc_timer_update_wake_period
        24   -> PWR_ClearFlag
        24   -> RTC_ClearFlag
        24   -> RTC_ClearITPendingBit
        24   -> RTC_ITConfig
        24   -> RTC_WaitForSynchro
        24   -> RTC_WakeUpCmd
        24   -> rtc_timer_set_RTC_wakeup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      70  RTC_WKUP_IRQHandler
      66  TIM5_IRQHandler
      20  rtc_config_state
          sRtc_irq_handler_cb
      38  rtc_timer_get_time_us
      90  rtc_timer_get_timestamp_us
     324  rtc_timer_init
     222  rtc_timer_measure_LSI_frequency
      92  rtc_timer_set_RTC_wakeup
       6  rtc_timer_update_irq_callback
     118  rtc_timer_update_wake_period
       8  timestamp_monotonic_us
      12  tmpCC4
          CaptureNumber
          PeriodValue

 
    40 bytes in section .bss
 1 070 bytes in section .text
 
 1 070 bytes of CODE memory
    40 bytes of DATA memory

Errors: none
Warnings: none
