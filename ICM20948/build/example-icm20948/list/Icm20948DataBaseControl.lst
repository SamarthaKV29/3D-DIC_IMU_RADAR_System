###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataBaseControl.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataBaseControl.c
#        -D IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D
#        NUCLEO -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000
#        -D STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\Icm20948DataBaseControl.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\Icm20948DataBaseControl.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\Invn\Devices\Drivers\Icm20948\Icm20948DataBaseControl.c
      1          /*
      2          * ________________________________________________________________________________________________________
      3          * Copyright © 2014-2015 InvenSense Inc. Portions Copyright © 2014-2015 Movea. All rights reserved.
      4          * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      5          * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright and
      6          * other intellectual property rights laws.
      7          * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
      8          * and any use, reproduction, disclosure or distribution of the Software without an express license
      9          * agreement from InvenSense is strictly prohibited.
     10          * ________________________________________________________________________________________________________
     11          */
     12          
     13          #include "Icm20948.h"
     14          #include "Icm20948DataBaseControl.h"
     15          
     16          #include "Icm20948AuxCompassAkm.h"
     17          #include "Icm20948AuxTransport.h"
     18          
     19          #include "Icm20948Augmented.h"
     20          #include "Icm20948Dmp3Driver.h"
     21          
     22          #include <string.h>
     23          
     24          // BAC ped y ration for wearable, the value will influence pedometer result
     25          #define BAC_PED_Y_RATIO_WEARABLE 1073741824
     26          
     27          static int inv_enable_sensor_internal(struct inv_icm20948 * s, unsigned char androidSensor, unsigned char enable, char * mems_put_to_sleep);
     28          static unsigned char sensor_needs_compass(unsigned char androidSensor);
     29          static unsigned char sensor_needs_bac_algo(unsigned char androidSensor);
     30          static int inv_set_hw_smplrt_dmp_odrs(struct inv_icm20948 * s);
     31          static void inv_reGenerate_sensorControl(struct inv_icm20948 * s, const short *sen_num_2_ctrl, unsigned short *sensor_control, uint8_t header2_count);
     32          static short get_multiple_56_rate(unsigned short delayInMs);
     33          

   \                                 In section .text, align 2, keep-with-next
     34          unsigned long inv_icm20948_ctrl_androidSensor_enabled(struct inv_icm20948 * s, unsigned char androidSensor)
     35          {
     36          	return s->inv_androidSensorsOn_mask[(androidSensor>>5)] & (1L << (androidSensor&0x1F));
   \                     inv_icm20948_ctrl_androidSensor_enabled: (+1)
   \   00000000   0x114A             ASRS     R2,R1,#+5
   \   00000002   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \   00000006   0xF8D0 0x0160      LDR      R0,[R0, #+352]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xF001 0x011F      AND      R1,R1,#0x1F
   \   00000010   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000014   0x4008             ANDS     R0,R1,R0
   \   00000016   0x4770             BX       LR               ;; return
     37          }
     38          
     39          typedef	struct {
     40          	enum ANDROID_SENSORS AndroidSensor;
     41          	enum INV_SENSORS     InvSensor;
     42          }	MinDelayGenElementT;
     43          
     44          #define MinDelayGen(s, list) MinDelayGenActual(s, list, sizeof(list) / sizeof (MinDelayGenElementT))
     45          

   \                                 In section .text, align 2, keep-with-next
     46          static unsigned short MinDelayGenActual(struct inv_icm20948 *s, const MinDelayGenElementT *element, unsigned long elementQuan)
     47          {
   \                     MinDelayGenActual: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
     48          	unsigned short minDelay = (unsigned short) -1;
   \   00000008   0xF64F 0x77FF      MOVW     R7,#+65535
   \   0000000C   0xE013             B.N      ??MinDelayGenActual_0
     49          
     50          	while(elementQuan--) {
     51          		if (inv_icm20948_ctrl_androidSensor_enabled(s, element->AndroidSensor)) {
   \                     ??MinDelayGenActual_1: (+1)
   \   0000000E   0x7828             LDRB     R0,[R5, #+0]
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD00B             BEQ.N    ??MinDelayGenActual_2
     52          			unsigned short odrDelay = s->inv_dmp_odr_delays[element->InvSensor];
   \   0000001C   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000020   0xEB04 0x0040      ADD      R0,R4,R0, LSL #+1
   \   00000024   0xF8B0 0x0106      LDRH     R0,[R0, #+262]
     53          
     54          			if (minDelay > odrDelay)
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x463A             MOV      R2,R7
   \   0000002C   0x460F             MOV      R7,R1
   \   0000002E   0x4297             CMP      R7,R2
   \   00000030   0xD900             BLS.N    ??MinDelayGenActual_2
   \   00000032   0x4617             MOV      R7,R2
     55          					minDelay = odrDelay;
     56          		}
     57          		element++;
   \                     ??MinDelayGenActual_2: (+1)
   \   00000034   0x1CAD             ADDS     R5,R5,#+2
     58          	} // end while elements to process
   \                     ??MinDelayGenActual_0: (+1)
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x1E46             SUBS     R6,R0,#+1
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD1E7             BNE.N    ??MinDelayGenActual_1
     59          
     60          	return	minDelay;
   \   0000003E   0x4638             MOV      R0,R7
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     61          }
     62          

   \                                 In section .text, align 2, keep-with-next
     63          static int DividerRateSet(struct inv_icm20948 *s, unsigned short minDelay, unsigned short hwSampleRateDivider, enum INV_SENSORS InvSensor)
     64          {
   \                     DividerRateSet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4619             MOV      R1,R3
     65          	int result = 0;
   \   00000006   0x2300             MOVS     R3,#+0
     66          	
     67          	if (minDelay != 0xFFFF) {
   \   00000008   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000000C   0x42AC             CMP      R4,R5
   \   0000000E   0xD013             BEQ.N    ??DividerRateSet_0
     68          		unsigned short dmpOdrDivider = (minDelay * 1125L) / (hwSampleRateDivider * 1000L); // a divider from (1125Hz/hw_smplrt_divider).
   \   00000010   0xF240 0x4365      MOVW     R3,#+1125
   \   00000014   0x4363             MULS     R3,R3,R4
   \   00000016   0xF44F 0x747A      MOV      R4,#+1000
   \   0000001A   0x4354             MULS     R4,R4,R2
   \   0000001C   0xFB93 0xF3F4      SDIV     R3,R3,R4
   \   00000020   0xB29B             UXTH     R3,R3
     69          
     70          		s->inv_dmp_odr_dividers[InvSensor] = hwSampleRateDivider * dmpOdrDivider;
   \   00000022   0xFB12 0xF203      SMULBB   R2,R2,R3
   \   00000026   0xEB00 0x0441      ADD      R4,R0,R1, LSL #+1
   \   0000002A   0xF8A4 0x20BC      STRH     R2,[R4, #+188]
     71          		result |= dmp_icm20948_set_sensor_rate(s, InvSensor, (dmpOdrDivider - 1));
   \   0000002E   0x1E5A             SUBS     R2,R3,#+1
   \   00000030   0xB212             SXTH     R2,R2
   \   00000032   0x.... 0x....      BL       dmp_icm20948_set_sensor_rate
   \   00000036   0x4603             MOV      R3,R0
     72          	}
     73          	
     74          	return result;
   \                     ??DividerRateSet_0: (+1)
   \   00000038   0x4618             MOV      R0,R3
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     75          }
     76          

   \                                 In section .text, align 2, keep-with-next
     77          static unsigned short SampleRateDividerGet(unsigned short minDelay)
     78          {
     79          	unsigned short delay = min(INV_ODR_MIN_DELAY, minDelay); // because of GYRO_SMPLRT_DIV which relies on 8 bits, we can't have ODR value higher than 200ms
   \                     SampleRateDividerGet: (+1)
   \   00000000   0x28C9             CMP      R0,#+201
   \   00000002   0xDB00             BLT.N    ??SampleRateDividerGet_0
   \   00000004   0x20C8             MOVS     R0,#+200
     80          	return delay * 1125L / 1000L; // a divider from 1125Hz.
   \                     ??SampleRateDividerGet_0: (+1)
   \   00000006   0xF240 0x4165      MOVW     R1,#+1125
   \   0000000A   0x4348             MULS     R0,R1,R0
   \   0000000C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000010   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x4770             BX       LR               ;; return
     81          }
     82          
     83          
     84          
     85          /** @brief Get minimum ODR to be applied to accel engine based on all accel-based enabled sensors.
     86          * @return ODR in ms we expect to be applied to accel engine
     87          */

   \                                 In section .text, align 2, keep-with-next
     88          static unsigned short getMinDlyAccel(struct inv_icm20948 *s)
     89          {
   \                     getMinDlyAccel: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x4604             MOV      R4,R0
     90          	const MinDelayGenElementT MinDelayGenAccelList[] ={
     91          		{ANDROID_SENSOR_ACCELEROMETER,                      INV_SENSOR_ACCEL                },
     92          		{ANDROID_SENSOR_RAW_ACCELEROMETER,                  INV_SENSOR_ACCEL                },
     93          		{ANDROID_SENSOR_WAKEUP_ACCELEROMETER,               INV_SENSOR_WAKEUP_ACCEL         },
     94          		{ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR,        INV_SENSOR_GEOMAG               },
     95          		{ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR, INV_SENSOR_WAKEUP_GEOMAG        },
     96          		{ANDROID_SENSOR_STEP_DETECTOR,                      INV_SENSOR_STEP_COUNTER         },
     97          		{ANDROID_SENSOR_STEP_COUNTER,                       INV_SENSOR_STEP_COUNTER         },
     98          		{ANDROID_SENSOR_WAKEUP_STEP_DETECTOR,               INV_SENSOR_WAKEUP_STEP_COUNTER  },
     99          		{ANDROID_SENSOR_WAKEUP_STEP_COUNTER,                INV_SENSOR_WAKEUP_STEP_COUNTER  },
    100          		{ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION,          INV_SENSOR_WAKEUP_STEP_COUNTER  },
    101          		{ANDROID_SENSOR_WAKEUP_TILT_DETECTOR,               INV_SENSOR_WAKEUP_TILT_DETECTOR },
    102          		{ANDROID_SENSOR_GRAVITY,                            INV_SENSOR_SIXQ_accel           },
    103          		{ANDROID_SENSOR_GAME_ROTATION_VECTOR,               INV_SENSOR_SIXQ_accel           },
    104          		{ANDROID_SENSOR_LINEAR_ACCELERATION,                INV_SENSOR_SIXQ_accel           },
    105          		{ANDROID_SENSOR_WAKEUP_GRAVITY,                     INV_SENSOR_WAKEUP_SIXQ_accel    },
    106          		{ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR,        INV_SENSOR_WAKEUP_SIXQ_accel    },
    107          		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,         INV_SENSOR_WAKEUP_SIXQ_accel    },
    108          		{ANDROID_SENSOR_ORIENTATION,                        INV_SENSOR_NINEQ_accel          },
    109          		{ANDROID_SENSOR_ROTATION_VECTOR,                    INV_SENSOR_NINEQ_accel          },
    110          		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ_accel   },
    111          		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ_accel   }
    112          	};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      ADR.W    R1,?_0
   \   0000000C   0x222C             MOVS     R2,#+44
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    113          
    114          	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenAccelList);
   \   00000012   0x2215             MOVS     R2,#+21
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       MinDelayGenActual
   \   0000001C   0x4605             MOV      R5,R0
    115          
    116          	if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER))
   \   0000001E   0xF44F 0x7083      MOV      R0,#+262
   \   00000022   0x1826             ADDS     R6,R4,R0
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD010             BEQ.N    ??getMinDlyAccel_0
    117          		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
   \   00000030   0xF204 0x2746      ADDW     R7,R4,#+582
   \   00000034   0x212A             MOVS     R1,#+42
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0x8838             LDRH     R0,[R7, #+0]
   \   00000040   0xD005             BEQ.N    ??getMinDlyAccel_1
    118          			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(s->odr_acc_ms,s->odr_racc_ms);
   \   00000042   0x8879             LDRH     R1,[R7, #+2]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD900             BLS.N    ??getMinDlyAccel_2
   \   00000048   0x4608             MOV      R0,R1
   \                     ??getMinDlyAccel_2: (+1)
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
   \   0000004C   0xE00B             B.N      ??getMinDlyAccel_3
    119          		else
    120          			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = s->odr_acc_ms;
   \                     ??getMinDlyAccel_1: (+1)
   \   0000004E   0x8030             STRH     R0,[R6, #+0]
   \   00000050   0xE009             B.N      ??getMinDlyAccel_3
    121          	else
    122          		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
   \                     ??getMinDlyAccel_0: (+1)
   \   00000052   0x212A             MOVS     R1,#+42
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD003             BEQ.N    ??getMinDlyAccel_3
    123          			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = s->odr_racc_ms;
   \   0000005E   0xF204 0x2046      ADDW     R0,R4,#+582
   \   00000062   0x8840             LDRH     R0,[R0, #+2]
   \   00000064   0x8030             STRH     R0,[R6, #+0]
    124          
    125          	if (s->bac_status != 0)
   \                     ??getMinDlyAccel_3: (+1)
   \   00000066   0xF44F 0x70AA      MOV      R0,#+340
   \   0000006A   0x4420             ADD      R0,R4,R0
   \   0000006C   0x8801             LDRH     R1,[R0, #+0]
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0xD003             BEQ.N    ??getMinDlyAccel_4
    126          		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_ACTIVITY_CLASSIFIER]);
   \   00000072   0x8B72             LDRH     R2,[R6, #+26]
   \   00000074   0x4295             CMP      R5,R2
   \   00000076   0xD900             BLS.N    ??getMinDlyAccel_4
   \   00000078   0x4615             MOV      R5,R2
    127          	if (s->flip_pickup_status != 0)
   \                     ??getMinDlyAccel_4: (+1)
   \   0000007A   0x8881             LDRH     R1,[R0, #+4]
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD003             BEQ.N    ??getMinDlyAccel_5
    128          		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_FLIP_PICKUP]);
   \   00000080   0x8BB2             LDRH     R2,[R6, #+28]
   \   00000082   0x4295             CMP      R5,R2
   \   00000084   0xD900             BLS.N    ??getMinDlyAccel_5
   \   00000086   0x4615             MOV      R5,R2
    129          	if (s->b2s_status != 0)
   \                     ??getMinDlyAccel_5: (+1)
   \   00000088   0x8840             LDRH     R0,[R0, #+2]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD003             BEQ.N    ??getMinDlyAccel_6
    130          		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_BRING_TO_SEE]);
   \   0000008E   0x8BF1             LDRH     R1,[R6, #+30]
   \   00000090   0x428D             CMP      R5,R1
   \   00000092   0xD900             BLS.N    ??getMinDlyAccel_6
   \   00000094   0x460D             MOV      R5,R1
    131          	
    132          	/** To have correct algorithm performance and quick convergence of GMRV, it is advised to set accelerometer to 225Hz.
    133          	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
    134          	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR) 
    135          		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) )
   \                     ??getMinDlyAccel_6: (+1)
   \   00000096   0x2127             MOVS     R1,#+39
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD105             BNE.N    ??getMinDlyAccel_7
   \   000000A2   0x2114             MOVS     R1,#+20
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD002             BEQ.N    ??getMinDlyAccel_8
    136          		lMinOdr = min(lMinOdr, 5);
   \                     ??getMinDlyAccel_7: (+1)
   \   000000AE   0x2D05             CMP      R5,#+5
   \   000000B0   0xDB00             BLT.N    ??getMinDlyAccel_8
   \   000000B2   0x2505             MOVS     R5,#+5
    137          
    138          	/** To have correct algorithm performance and quick convergence of RV, it is advised to set accelerometer to 225Hz.
    139          	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
    140          	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) 
    141          		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
   \                     ??getMinDlyAccel_8: (+1)
   \   000000B4   0x211F             MOVS     R1,#+31
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD105             BNE.N    ??getMinDlyAccel_9
   \   000000C0   0x210B             MOVS     R1,#+11
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD002             BEQ.N    ??getMinDlyAccel_10
    142          		lMinOdr = min(lMinOdr, 5);
   \                     ??getMinDlyAccel_9: (+1)
   \   000000CC   0x2D05             CMP      R5,#+5
   \   000000CE   0xDB00             BLT.N    ??getMinDlyAccel_10
   \   000000D0   0x2505             MOVS     R5,#+5
    143          
    144          	return lMinOdr;
   \                     ??getMinDlyAccel_10: (+1)
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0xB00B             ADD      SP,SP,#+44
   \   000000D6   0xBDF0             POP      {R4-R7,PC}       ;; return
    145          }
    146          
    147          /** @brief Get minimum ODR to be applied to gyro engine based on all gyro-based enabled sensors.
    148          * @return ODR in ms we expect to be applied to gyro engine
    149          */

   \                                 In section .text, align 2, keep-with-next
    150          static unsigned short getMinDlyGyro(struct inv_icm20948 *s)
    151          {
   \                     getMinDlyGyro: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0
    152          	const MinDelayGenElementT MinDelayGenGyroList[] = {
    153          		{ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED,        INV_SENSOR_GYRO              },
    154          		{ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED, INV_SENSOR_WAKEUP_GYRO       },
    155          		{ANDROID_SENSOR_GYROSCOPE,                     INV_SENSOR_CALIB_GYRO        },
    156          		{ANDROID_SENSOR_RAW_GYROSCOPE,                 INV_SENSOR_GYRO              },
    157          		{ANDROID_SENSOR_WAKEUP_GYROSCOPE,              INV_SENSOR_WAKEUP_CALIB_GYRO },
    158          		{ANDROID_SENSOR_GRAVITY,                       INV_SENSOR_SIXQ              },
    159          		{ANDROID_SENSOR_GAME_ROTATION_VECTOR,          INV_SENSOR_SIXQ              },
    160          		{ANDROID_SENSOR_LINEAR_ACCELERATION,           INV_SENSOR_SIXQ              },
    161          		{ANDROID_SENSOR_WAKEUP_GRAVITY,                INV_SENSOR_WAKEUP_SIXQ       },
    162          		{ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR,   INV_SENSOR_WAKEUP_SIXQ       },
    163          		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,    INV_SENSOR_WAKEUP_SIXQ       },
    164          		{ANDROID_SENSOR_ORIENTATION,                   INV_SENSOR_NINEQ             },
    165          		{ANDROID_SENSOR_ROTATION_VECTOR,               INV_SENSOR_NINEQ             },
    166          		{ANDROID_SENSOR_WAKEUP_ORIENTATION,            INV_SENSOR_WAKEUP_NINEQ      },
    167          		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,        INV_SENSOR_WAKEUP_NINEQ      }
    168          	};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      ADR.W    R1,?_1
   \   0000000C   0x2220             MOVS     R2,#+32
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    169          
    170          	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenGyroList);
   \   00000012   0x220F             MOVS     R2,#+15
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       MinDelayGenActual
   \   0000001C   0x4605             MOV      R5,R0
    171          
    172          	if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED))
   \   0000001E   0x2110             MOVS     R1,#+16
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD012             BEQ.N    ??getMinDlyGyro_0
    173          		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
   \   0000002A   0xF204 0x264A      ADDW     R6,R4,#+586
   \   0000002E   0x212B             MOVS     R1,#+43
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0x8830             LDRH     R0,[R6, #+0]
   \   0000003A   0xD006             BEQ.N    ??getMinDlyGyro_1
    174          			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(s->odr_gyr_ms,s->odr_rgyr_ms);
   \   0000003C   0x8871             LDRH     R1,[R6, #+2]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD900             BLS.N    ??getMinDlyGyro_2
   \   00000042   0x4608             MOV      R0,R1
   \                     ??getMinDlyGyro_2: (+1)
   \   00000044   0xF8A4 0x0108      STRH     R0,[R4, #+264]
   \   00000048   0xE00D             B.N      ??getMinDlyGyro_3
    175          		else
    176          			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = s->odr_gyr_ms;
   \                     ??getMinDlyGyro_1: (+1)
   \   0000004A   0xF8A4 0x0108      STRH     R0,[R4, #+264]
   \   0000004E   0xE00A             B.N      ??getMinDlyGyro_3
    177          	else
    178          		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
   \                     ??getMinDlyGyro_0: (+1)
   \   00000050   0x212B             MOVS     R1,#+43
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD004             BEQ.N    ??getMinDlyGyro_3
    179          			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = s->odr_rgyr_ms;
   \   0000005C   0xF204 0x204A      ADDW     R0,R4,#+586
   \   00000060   0x8840             LDRH     R0,[R0, #+2]
   \   00000062   0xF8A4 0x0108      STRH     R0,[R4, #+264]
    180          
    181          	/** To have correct algorithm performance and quick convergence of RV, it is advised to set gyro to 225Hz.
    182          	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
    183          	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) 
    184          		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
   \                     ??getMinDlyGyro_3: (+1)
   \   00000066   0x211F             MOVS     R1,#+31
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD105             BNE.N    ??getMinDlyGyro_4
   \   00000072   0x210B             MOVS     R1,#+11
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD002             BEQ.N    ??getMinDlyGyro_5
    185          		lMinOdr	= min(lMinOdr, 5);
   \                     ??getMinDlyGyro_4: (+1)
   \   0000007E   0x2D05             CMP      R5,#+5
   \   00000080   0xDB00             BLT.N    ??getMinDlyGyro_5
   \   00000082   0x2505             MOVS     R5,#+5
    186          
    187          	return lMinOdr;
   \                     ??getMinDlyGyro_5: (+1)
   \   00000084   0x4628             MOV      R0,R5
   \   00000086   0xB008             ADD      SP,SP,#+32
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
    188          }
    189          
    190          /** @brief Get minimum ODR to be applied to compass engine based on all compass-based enabled sensors.
    191          * @return ODR in ms we expect to be applied to compass engine
    192          */

   \                                 In section .text, align 2, keep-with-next
    193          static unsigned short getMinDlyCompass(struct inv_icm20948 *s)
    194          {
   \                     getMinDlyCompass: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
    195          	const MinDelayGenElementT MinDelayGenCpassList[] = {
    196          		{ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED,        INV_SENSOR_COMPASS              },
    197          		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED, INV_SENSOR_WAKEUP_COMPASS       },
    198          		{ANDROID_SENSOR_GEOMAGNETIC_FIELD,                  INV_SENSOR_CALIB_COMPASS        },
    199          		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD,              INV_SENSOR_WAKEUP_CALIB_COMPASS },
    200          		{ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR,        INV_SENSOR_GEOMAG_cpass         },
    201          		{ANDROID_SENSOR_ORIENTATION,                        INV_SENSOR_NINEQ_cpass          },
    202          		{ANDROID_SENSOR_ROTATION_VECTOR,                    INV_SENSOR_NINEQ_cpass          },
    203          		{ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR, INV_SENSOR_WAKEUP_GEOMAG_cpass  },
    204          		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ_cpass   },
    205          		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ_cpass   }
    206          	};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      ADR.W    R1,?_2
   \   0000000C   0x2214             MOVS     R2,#+20
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    207          
    208          	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenCpassList);
   \   00000012   0x220A             MOVS     R2,#+10
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       MinDelayGenActual
   \   0000001C   0x4605             MOV      R5,R0
    209          
    210          	/** To have correct algorithm performance and quick convergence of GMRV, it is advised to set compass to 70Hz.
    211          	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
    212          	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR) 
    213          		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) )
   \   0000001E   0x2127             MOVS     R1,#+39
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD105             BNE.N    ??getMinDlyCompass_0
   \   0000002A   0x2114             MOVS     R1,#+20
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD002             BEQ.N    ??getMinDlyCompass_1
    214          		lMinOdr= min(lMinOdr, 15);
   \                     ??getMinDlyCompass_0: (+1)
   \   00000036   0x2D0F             CMP      R5,#+15
   \   00000038   0xDB00             BLT.N    ??getMinDlyCompass_1
   \   0000003A   0x250F             MOVS     R5,#+15
    215          	/** To have correct algorithm performance and quick convergence of RV, it is advised to set compass to 35Hz.
    216          	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
    217          	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) 
    218          		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
   \                     ??getMinDlyCompass_1: (+1)
   \   0000003C   0x211F             MOVS     R1,#+31
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD105             BNE.N    ??getMinDlyCompass_2
   \   00000048   0x210B             MOVS     R1,#+11
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ.N    ??getMinDlyCompass_3
    219          		lMinOdr = min(lMinOdr, 28);
   \                     ??getMinDlyCompass_2: (+1)
   \   00000054   0x2D1C             CMP      R5,#+28
   \   00000056   0xDB00             BLT.N    ??getMinDlyCompass_3
   \   00000058   0x251C             MOVS     R5,#+28
    220          
    221          	return lMinOdr;
   \                     ??getMinDlyCompass_3: (+1)
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0xB005             ADD      SP,SP,#+20
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
    222          }
    223          

   \                                 In section .text, align 2, keep-with-next
    224          int inv_icm20948_base_control_init(struct inv_icm20948 * s)
    225          {
   \                     inv_icm20948_base_control_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    226          	int result = 0;
    227          	unsigned int i;
    228          
    229          	memset(s->inv_dmp_odr_dividers, 0, sizeof(s->inv_dmp_odr_dividers));
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x214A             MOVS     R1,#+74
   \   00000008   0xF104 0x00BC      ADD      R0,R4,#+188
   \   0000000C   0x.... 0x....      BL       __aeabi_memset4
    230          	
    231          	for(i = 0; i < (sizeof(s->inv_dmp_odr_delays)/sizeof(unsigned short)); i++) {
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE005             B.N      ??inv_icm20948_base_control_init_0
    232          		if((i == INV_SENSOR_ACTIVITY_CLASSIFIER) ||
    233          		   (i == INV_SENSOR_STEP_COUNTER) ||
    234          		   (i == INV_SENSOR_WAKEUP_STEP_COUNTER) ||
    235          		   (i == INV_SENSOR_WAKEUP_TILT_DETECTOR) ||
    236          		   (i == INV_SENSOR_FLIP_PICKUP) )
    237          			s->inv_dmp_odr_delays[i] = INV_ODR_DEFAULT_BAC;
    238          		else if(i == INV_SENSOR_BRING_TO_SEE)
    239          			s->inv_dmp_odr_delays[i] = INV_ODR_DEFAULT_B2S;
    240          		else
    241          			s->inv_dmp_odr_delays[i] = INV_ODR_MIN_DELAY;
   \                     ??inv_icm20948_base_control_init_1: (+1)
   \   00000014   0x21C8             MOVS     R1,#+200
   \   00000016   0xEB04 0x0240      ADD      R2,R4,R0, LSL #+1
   \   0000001A   0xF8A2 0x1106      STRH     R1,[R2, #+262]
   \                     ??inv_icm20948_base_control_init_2: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_base_control_init_0: (+1)
   \   00000020   0x2825             CMP      R0,#+37
   \   00000022   0xD211             BCS.N    ??inv_icm20948_base_control_init_3
   \   00000024   0x280D             CMP      R0,#+13
   \   00000026   0xD009             BEQ.N    ??inv_icm20948_base_control_init_4
   \   00000028   0x280C             CMP      R0,#+12
   \   0000002A   0xD007             BEQ.N    ??inv_icm20948_base_control_init_4
   \   0000002C   0x281F             CMP      R0,#+31
   \   0000002E   0xD005             BEQ.N    ??inv_icm20948_base_control_init_4
   \   00000030   0x2820             CMP      R0,#+32
   \   00000032   0xD003             BEQ.N    ??inv_icm20948_base_control_init_4
   \   00000034   0x280E             CMP      R0,#+14
   \   00000036   0xD001             BEQ.N    ??inv_icm20948_base_control_init_4
   \   00000038   0x280F             CMP      R0,#+15
   \   0000003A   0xD1EB             BNE.N    ??inv_icm20948_base_control_init_1
   \                     ??inv_icm20948_base_control_init_4: (+1)
   \   0000003C   0x2112             MOVS     R1,#+18
   \   0000003E   0xEB04 0x0240      ADD      R2,R4,R0, LSL #+1
   \   00000042   0xF8A2 0x1106      STRH     R1,[R2, #+262]
   \   00000046   0xE7EA             B.N      ??inv_icm20948_base_control_init_2
    242          	}
    243          	for(i = 0; i < (sizeof(s->inv_androidSensorsOdr_boundaries)/sizeof(s->inv_androidSensorsOdr_boundaries[0])); i++) {
   \                     ??inv_icm20948_base_control_init_3: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE00A             B.N      ??inv_icm20948_base_control_init_5
    244          		if ((i == ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED) || (i == ANDROID_SENSOR_GEOMAGNETIC_FIELD) ||
    245          		    (i == ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED) || (i == ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD)) {
    246          			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR_CPASS;
    247          			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR_CPASS;
    248          		} else if ((i == ANDROID_SENSOR_GAME_ROTATION_VECTOR) || (i == ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR) ||
    249          		           (i == ANDROID_SENSOR_GRAVITY) || (i == ANDROID_SENSOR_WAKEUP_GRAVITY) ||
    250          		           (i == ANDROID_SENSOR_LINEAR_ACCELERATION) || (i == ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION) ||
    251          		           (i == ANDROID_SENSOR_ROTATION_VECTOR) || (i == ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) ||
    252          		           (i == ANDROID_SENSOR_ORIENTATION) || (i == ANDROID_SENSOR_WAKEUP_ORIENTATION)) {
    253          			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR_GRV;
    254          			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR_GRV;
    255          		} else {
    256          			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR;
   \                     ??inv_icm20948_base_control_init_6: (+1)
   \   0000004C   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \   00000050   0xF44F 0x72B4      MOV      R2,#+360
   \   00000054   0x4411             ADD      R1,R1,R2
   \   00000056   0x2205             MOVS     R2,#+5
   \   00000058   0x800A             STRH     R2,[R1, #+0]
    257          			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR;
   \   0000005A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000005E   0x804A             STRH     R2,[R1, #+2]
    258          		}
   \                     ??inv_icm20948_base_control_init_7: (+1)
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \                     ??inv_icm20948_base_control_init_5: (+1)
   \   00000062   0x2833             CMP      R0,#+51
   \   00000064   0xD230             BCS.N    ??inv_icm20948_base_control_init_8
   \   00000066   0x280E             CMP      R0,#+14
   \   00000068   0xD005             BEQ.N    ??inv_icm20948_base_control_init_9
   \   0000006A   0x2802             CMP      R0,#+2
   \   0000006C   0xD003             BEQ.N    ??inv_icm20948_base_control_init_9
   \   0000006E   0x2822             CMP      R0,#+34
   \   00000070   0xD001             BEQ.N    ??inv_icm20948_base_control_init_9
   \   00000072   0x2818             CMP      R0,#+24
   \   00000074   0xD10A             BNE.N    ??inv_icm20948_base_control_init_10
   \                     ??inv_icm20948_base_control_init_9: (+1)
   \   00000076   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \   0000007A   0xF44F 0x72B4      MOV      R2,#+360
   \   0000007E   0x4411             ADD      R1,R1,R2
   \   00000080   0x220E             MOVS     R2,#+14
   \   00000082   0x800A             STRH     R2,[R1, #+0]
   \   00000084   0xF44F 0x727A      MOV      R2,#+1000
   \   00000088   0x804A             STRH     R2,[R1, #+2]
   \   0000008A   0xE7E9             B.N      ??inv_icm20948_base_control_init_7
   \                     ??inv_icm20948_base_control_init_10: (+1)
   \   0000008C   0x280F             CMP      R0,#+15
   \   0000008E   0xD011             BEQ.N    ??inv_icm20948_base_control_init_11
   \   00000090   0x2823             CMP      R0,#+35
   \   00000092   0xD00F             BEQ.N    ??inv_icm20948_base_control_init_11
   \   00000094   0x2809             CMP      R0,#+9
   \   00000096   0xD00D             BEQ.N    ??inv_icm20948_base_control_init_11
   \   00000098   0x281D             CMP      R0,#+29
   \   0000009A   0xD00B             BEQ.N    ??inv_icm20948_base_control_init_11
   \   0000009C   0x280A             CMP      R0,#+10
   \   0000009E   0xD009             BEQ.N    ??inv_icm20948_base_control_init_11
   \   000000A0   0x281E             CMP      R0,#+30
   \   000000A2   0xD007             BEQ.N    ??inv_icm20948_base_control_init_11
   \   000000A4   0x280B             CMP      R0,#+11
   \   000000A6   0xD005             BEQ.N    ??inv_icm20948_base_control_init_11
   \   000000A8   0x281F             CMP      R0,#+31
   \   000000AA   0xD003             BEQ.N    ??inv_icm20948_base_control_init_11
   \   000000AC   0x2803             CMP      R0,#+3
   \   000000AE   0xD001             BEQ.N    ??inv_icm20948_base_control_init_11
   \   000000B0   0x2819             CMP      R0,#+25
   \   000000B2   0xD1CB             BNE.N    ??inv_icm20948_base_control_init_6
   \                     ??inv_icm20948_base_control_init_11: (+1)
   \   000000B4   0xEB04 0x0180      ADD      R1,R4,R0, LSL #+2
   \   000000B8   0xF44F 0x72B4      MOV      R2,#+360
   \   000000BC   0x4411             ADD      R1,R1,R2
   \   000000BE   0x2205             MOVS     R2,#+5
   \   000000C0   0x800A             STRH     R2,[R1, #+0]
   \   000000C2   0x2214             MOVS     R2,#+20
   \   000000C4   0x804A             STRH     R2,[R1, #+2]
   \   000000C6   0xE7CB             B.N      ??inv_icm20948_base_control_init_7
    259          	}
    260          	s->lLastHwSmplrtDividerAcc = 0;
   \                     ??inv_icm20948_base_control_init_8: (+1)
   \   000000C8   0xF204 0x2036      ADDW     R0,R4,#+566
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x8001             STRH     R1,[R0, #+0]
    261          	s->lLastHwSmplrtDividerGyr = 0;
   \   000000D0   0x8041             STRH     R1,[R0, #+2]
    262          	s->sBatchMode              = 0;
   \   000000D2   0x7101             STRB     R1,[R0, #+4]
    263          	s->header2_count           = 0;
   \   000000D4   0x7141             STRB     R1,[R0, #+5]
    264          	s->mems_put_to_sleep       = 1;
   \   000000D6   0x2101             MOVS     R1,#+1
   \   000000D8   0x7181             STRB     R1,[R0, #+6]
    265          	s->smd_status              = 0;
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0x8101             STRH     R1,[R0, #+8]
    266          	s->ped_int_status          = 0;
   \   000000DE   0x8141             STRH     R1,[R0, #+10]
    267          	s->b2s_status              = 0;
   \   000000E0   0xF8A4 0x1156      STRH     R1,[R4, #+342]
    268          	s->bac_request             = 0;
   \   000000E4   0x8181             STRH     R1,[R0, #+12]
    269          	s->odr_acc_ms = INV_ODR_MIN_DELAY;
   \   000000E6   0x21C8             MOVS     R1,#+200
   \   000000E8   0x8201             STRH     R1,[R0, #+16]
    270          	//s->odr_acc_wom_ms = INV_ODR_MIN_DELAY;
    271          	s->odr_racc_ms = INV_ODR_MIN_DELAY;
   \   000000EA   0x8241             STRH     R1,[R0, #+18]
    272          	s->odr_gyr_ms = INV_ODR_MIN_DELAY;
   \   000000EC   0x8281             STRH     R1,[R0, #+20]
    273          	s->odr_rgyr_ms = INV_ODR_MIN_DELAY;
   \   000000EE   0x82C1             STRH     R1,[R0, #+22]
    274          
    275          	return result;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xBD10             POP      {R4,PC}          ;; return
    276          }
    277          

   \                                 In section .text, align 2, keep-with-next
    278          static int inv_set_hw_smplrt_dmp_odrs(struct inv_icm20948 * s)
    279          {
   \                     inv_set_hw_smplrt_dmp_odrs: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB097             SUB      SP,SP,#+92
   \   00000006   0x4605             MOV      R5,R0
    280          	int result = 0;
   \   00000008   0xF04F 0x0B00      MOV      R11,#+0
    281          	unsigned short minDly, minDly_accel, minDly_gyro;
    282          	unsigned short minDly_cpass;
    283          	unsigned short minDly_pressure;
    284          	unsigned short hw_smplrt_divider = 0;
   \   0000000C   0x46DA             MOV      R10,R11
    285          	
    286          	const MinDelayGenElementT MinDelayGenPressureList[] = {
    287          		{ANDROID_SENSOR_PRESSURE,                           INV_SENSOR_PRESSURE             },
    288          		{ANDROID_SENSOR_WAKEUP_PRESSURE,                    INV_SENSOR_WAKEUP_PRESSURE      }
    289          	};
   \   0000000E   0xA807             ADD      R0,SP,#+28
   \   00000010   0x.... 0x....      ADR.W    R1,?_3
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x6002             STR      R2,[R0, #+0]
    290          	const MinDelayGenElementT MinDelayGenAccel2List[] = {
    291          		{ANDROID_SENSOR_ACCELEROMETER,                      INV_SENSOR_ACCEL                },
    292          		{ANDROID_SENSOR_WAKEUP_ACCELEROMETER,               INV_SENSOR_WAKEUP_ACCEL         },
    293          		{ANDROID_SENSOR_RAW_ACCELEROMETER,                  INV_SENSOR_ACCEL                },
    294          		{ANDROID_SENSOR_LINEAR_ACCELERATION,                INV_SENSOR_SIXQ_accel           },
    295          		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,         INV_SENSOR_WAKEUP_SIXQ_accel    }
    296          	};
   \   00000018   0xA813             ADD      R0,SP,#+76
   \   0000001A   0x.... 0x....      ADR.W    R1,?_4
   \   0000001E   0xC91C             LDM      R1!,{R2-R4}
   \   00000020   0xC01C             STM      R0!,{R2-R4}
    297          	const MinDelayGenElementT MinDelayGenAccel3List[] = {
    298          		{ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR,        INV_SENSOR_GEOMAG               },
    299          		{ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR, INV_SENSOR_WAKEUP_GEOMAG        }
    300          	};
   \   00000022   0xA806             ADD      R0,SP,#+24
   \   00000024   0x.... 0x....      ADR.W    R1,?_5
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x6002             STR      R2,[R0, #+0]
    301          	const MinDelayGenElementT MinDelayGenAccel4List[] = {
    302          		{ANDROID_SENSOR_STEP_DETECTOR,                      INV_SENSOR_STEP_COUNTER         },
    303          		{ANDROID_SENSOR_STEP_COUNTER,                       INV_SENSOR_STEP_COUNTER         },
    304          		{ANDROID_SENSOR_WAKEUP_STEP_DETECTOR,               INV_SENSOR_WAKEUP_STEP_COUNTER  },
    305          		{ANDROID_SENSOR_WAKEUP_STEP_COUNTER,                INV_SENSOR_WAKEUP_STEP_COUNTER  },
    306          		{ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION,          INV_SENSOR_WAKEUP_STEP_COUNTER  }
    307          	};
   \   0000002C   0xA810             ADD      R0,SP,#+64
   \   0000002E   0x.... 0x....      ADR.W    R1,?_6
   \   00000032   0xC91C             LDM      R1!,{R2-R4}
   \   00000034   0xC01C             STM      R0!,{R2-R4}
    308          	const MinDelayGenElementT MinDelayGenGyro2List[] = {
    309          		{ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED,             INV_SENSOR_GYRO                 },
    310          		{ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED,      INV_SENSOR_WAKEUP_GYRO          },
    311          		{ANDROID_SENSOR_GYROSCOPE,                          INV_SENSOR_CALIB_GYRO           },
    312          		{ANDROID_SENSOR_RAW_GYROSCOPE,                      INV_SENSOR_GYRO           },
    313          		{ANDROID_SENSOR_WAKEUP_GYROSCOPE,                   INV_SENSOR_WAKEUP_CALIB_GYRO    }
    314          	};
   \   00000036   0xA80D             ADD      R0,SP,#+52
   \   00000038   0x.... 0x....      ADR.W    R1,?_7
   \   0000003C   0xC91C             LDM      R1!,{R2-R4}
   \   0000003E   0xC01C             STM      R0!,{R2-R4}
    315          	const MinDelayGenElementT MinDelayGenGyro3List[] = {
    316          		{ANDROID_SENSOR_GYROSCOPE,                          INV_SENSOR_CALIB_GYRO           },
    317          		{ANDROID_SENSOR_WAKEUP_GYROSCOPE,                   INV_SENSOR_WAKEUP_CALIB_GYRO    }
    318          	};
   \   00000040   0xA805             ADD      R0,SP,#+20
   \   00000042   0x.... 0x....      ADR.W    R1,?_8
   \   00000046   0x680A             LDR      R2,[R1, #+0]
   \   00000048   0x6002             STR      R2,[R0, #+0]
    319          	const MinDelayGenElementT MinDelayGenGyro4List[] = {
    320          		{ANDROID_SENSOR_GRAVITY,                            INV_SENSOR_SIXQ                 },
    321          		{ANDROID_SENSOR_GAME_ROTATION_VECTOR,               INV_SENSOR_SIXQ                 },
    322          		{ANDROID_SENSOR_LINEAR_ACCELERATION,                INV_SENSOR_SIXQ                 },
    323          		{ANDROID_SENSOR_WAKEUP_GRAVITY,                     INV_SENSOR_WAKEUP_SIXQ          },
    324          		{ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR,        INV_SENSOR_WAKEUP_SIXQ          },
    325          		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,         INV_SENSOR_WAKEUP_SIXQ          }
    326          	};
   \   0000004A   0xA80A             ADD      R0,SP,#+40
   \   0000004C   0x.... 0x....      ADR.W    R1,?_9
   \   00000050   0xC91C             LDM      R1!,{R2-R4}
   \   00000052   0xC01C             STM      R0!,{R2-R4}
    327          	const MinDelayGenElementT MinDelayGenGyro5List[] = {
    328          		{ANDROID_SENSOR_ORIENTATION,                        INV_SENSOR_NINEQ                },
    329          		{ANDROID_SENSOR_ROTATION_VECTOR,                    INV_SENSOR_NINEQ                },
    330          		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ         },
    331          		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ         }
    332          	};
   \   00000054   0xA808             ADD      R0,SP,#+32
   \   00000056   0x.... 0x....      ADR.W    R1,?_10
   \   0000005A   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \   0000005E   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
    333          	const MinDelayGenElementT MinDelayGenCpass2List[] = {
    334          		{ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED,        INV_SENSOR_COMPASS              },
    335          		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED,	INV_SENSOR_WAKEUP_COMPASS       }
    336          	};
   \   00000062   0xA804             ADD      R0,SP,#+16
   \   00000064   0x.... 0x....      ADR.W    R1,?_11
   \   00000068   0x680A             LDR      R2,[R1, #+0]
   \   0000006A   0x6002             STR      R2,[R0, #+0]
    337          	const MinDelayGenElementT MinDelayGenCpass3List[] = {
    338          		{ANDROID_SENSOR_GEOMAGNETIC_FIELD,                  INV_SENSOR_CALIB_COMPASS        },
    339          		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD,              INV_SENSOR_WAKEUP_CALIB_COMPASS }
    340          	};
   \   0000006C   0xA803             ADD      R0,SP,#+12
   \   0000006E   0x.... 0x....      ADR.W    R1,?_12
   \   00000072   0x680A             LDR      R2,[R1, #+0]
   \   00000074   0x6002             STR      R2,[R0, #+0]
    341          	const MinDelayGenElementT MinDelayGenPressure2List[] = {
    342          		{ANDROID_SENSOR_PRESSURE,                           INV_SENSOR_PRESSURE             },
    343          		{ANDROID_SENSOR_WAKEUP_PRESSURE,                    INV_SENSOR_WAKEUP_PRESSURE      }
    344          	};
   \   00000076   0xA802             ADD      R0,SP,#+8
   \   00000078   0x.... 0x....      ADR.W    R1,?_13
   \   0000007C   0x680A             LDR      R2,[R1, #+0]
   \   0000007E   0x6002             STR      R2,[R0, #+0]
    345          	
    346          	// Engine ACCEL Based
    347          	minDly_accel = getMinDlyAccel(s);
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0x.... 0x....      BL       getMinDlyAccel
   \   00000086   0x4604             MOV      R4,R0
    348          
    349          	// Engine Gyro Based
    350          	minDly_gyro  = getMinDlyGyro(s);
   \   00000088   0x4628             MOV      R0,R5
   \   0000008A   0x.... 0x....      BL       getMinDlyGyro
   \   0000008E   0x4680             MOV      R8,R0
    351          
    352          	// Engine Cpass Based	
    353          	minDly_cpass = getMinDlyCompass(s);
   \   00000090   0x4628             MOV      R0,R5
   \   00000092   0x.... 0x....      BL       getMinDlyCompass
   \   00000096   0x9000             STR      R0,[SP, #+0]
    354          
    355          	// Engine Pressure Based	
    356          	minDly_pressure	=	MinDelayGen	(s, MinDelayGenPressureList);
   \   00000098   0x2202             MOVS     R2,#+2
   \   0000009A   0xA907             ADD      R1,SP,#+28
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0x.... 0x....      BL       MinDelayGenActual
   \   000000A2   0x4681             MOV      R9,R0
   \   000000A4   0x45A0             CMP      R8,R4
   \   000000A6   0xDA01             BGE.N    ??inv_set_hw_smplrt_dmp_odrs_0
   \   000000A8   0x4646             MOV      R6,R8
   \   000000AA   0xE000             B.N      ??inv_set_hw_smplrt_dmp_odrs_1
   \                     ??inv_set_hw_smplrt_dmp_odrs_0: (+1)
   \   000000AC   0x4626             MOV      R6,R4
    357          
    358          	// get min delay of all enabled sensors of all sensor engine groups
    359          	minDly = min(minDly_gyro, minDly_accel);
    360          	minDly = min(minDly, minDly_cpass);
   \                     ??inv_set_hw_smplrt_dmp_odrs_1: (+1)
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x4286             CMP      R6,R0
   \   000000B2   0xDB00             BLT.N    ??inv_set_hw_smplrt_dmp_odrs_2
   \   000000B4   0x4606             MOV      R6,R0
    361          	minDly = min(minDly, minDly_pressure);
   \                     ??inv_set_hw_smplrt_dmp_odrs_2: (+1)
   \   000000B6   0xB2B6             UXTH     R6,R6
   \   000000B8   0x454E             CMP      R6,R9
   \   000000BA   0xDB00             BLT.N    ??inv_set_hw_smplrt_dmp_odrs_3
   \   000000BC   0x464E             MOV      R6,R9
   \                     ??inv_set_hw_smplrt_dmp_odrs_3: (+1)
   \   000000BE   0x4630             MOV      R0,R6
   \   000000C0   0xF64F 0x77FF      MOVW     R7,#+65535
   \   000000C4   0x42B8             CMP      R0,R7
   \   000000C6   0xD00D             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_4
    362          	
    363          	// switch between low power and low noise at 500Hz boundary
    364          	if (minDly != 0xFFFF) {
    365          		// above 500Hz boundary, force LN mode
    366          		if (minDly==1) {
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD10B             BNE.N    ??inv_set_hw_smplrt_dmp_odrs_4
    367          			if (s->base_state.chip_lp_ln_mode == CHIP_LOW_POWER_ICM20948) {
   \   000000CC   0xF995 0x0019      LDRSB    R0,[R5, #+25]
   \   000000D0   0x2801             CMP      R0,#+1
   \   000000D2   0xD113             BNE.N    ??inv_set_hw_smplrt_dmp_odrs_5
    368          				s->go_back_lp_when_odr_low = 1;
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0xF205 0x2136      ADDW     R1,R5,#+566
   \   000000DA   0x7388             STRB     R0,[R1, #+14]
    369          				inv_icm20948_enter_low_noise_mode(s);
   \   000000DC   0x4628             MOV      R0,R5
   \   000000DE   0x.... 0x....      BL       inv_icm20948_enter_low_noise_mode
   \   000000E2   0xE00B             B.N      ??inv_set_hw_smplrt_dmp_odrs_5
    370          			}
    371          		} else { // below 500 Hz boundary, go back to originally requested mode
    372          			if (s->go_back_lp_when_odr_low) {
    373          				s->go_back_lp_when_odr_low = 0;
    374          				inv_icm20948_enter_duty_cycle_mode(s);
    375          			}	
    376          		}
    377          	} else // all sensors are turned OFF, force originally requested mode
    378          	{
    379          		if (s->go_back_lp_when_odr_low) {
   \                     ??inv_set_hw_smplrt_dmp_odrs_4: (+1)
   \   000000E4   0xF205 0x2036      ADDW     R0,R5,#+566
   \   000000E8   0x7B80             LDRB     R0,[R0, #+14]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD006             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_5
    380          			s->go_back_lp_when_odr_low = 0;
   \   000000EE   0x4650             MOV      R0,R10
   \   000000F0   0xF205 0x2136      ADDW     R1,R5,#+566
   \   000000F4   0x7388             STRB     R0,[R1, #+14]
    381          			inv_icm20948_enter_duty_cycle_mode(s);
   \   000000F6   0x4628             MOV      R0,R5
   \   000000F8   0x.... 0x....      BL       inv_icm20948_enter_duty_cycle_mode
    382          		}
    383          	}
    384          	
    385          	if (minDly_accel != 0xFFFF)    minDly_accel = minDly;
   \                     ??inv_set_hw_smplrt_dmp_odrs_5: (+1)
   \   000000FC   0x42BC             CMP      R4,R7
   \   000000FE   0xD000             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_6
   \   00000100   0x4634             MOV      R4,R6
    386          	if (minDly_gyro  != 0xFFFF)    minDly_gyro  = minDly;
   \                     ??inv_set_hw_smplrt_dmp_odrs_6: (+1)
   \   00000102   0x45B8             CMP      R8,R7
   \   00000104   0xD000             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_7
   \   00000106   0x46B0             MOV      R8,R6
    387          	if (minDly_cpass != 0xFFFF)    minDly_cpass = minDly;
   \                     ??inv_set_hw_smplrt_dmp_odrs_7: (+1)
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   \   0000010A   0x42B8             CMP      R0,R7
   \   0000010C   0xD000             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_8
   \   0000010E   0x9600             STR      R6,[SP, #+0]
    388          	if (minDly_pressure != 0xFFFF) minDly_pressure = minDly;
   \                     ??inv_set_hw_smplrt_dmp_odrs_8: (+1)
   \   00000110   0x45B9             CMP      R9,R7
   \   00000112   0xD000             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_9
   \   00000114   0x46B1             MOV      R9,R6
    389          
    390          	if (s->bac_request != 0) {
   \                     ??inv_set_hw_smplrt_dmp_odrs_9: (+1)
   \   00000116   0xF205 0x2036      ADDW     R0,R5,#+566
   \   0000011A   0x8980             LDRH     R0,[R0, #+12]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD01F             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_10
    391          		unsigned short lBACMinDly = min(INV_ODR_DEFAULT_BAC, minDly_accel);
   \   00000120   0x2C13             CMP      R4,#+19
   \   00000122   0xDB01             BLT.N    ??inv_set_hw_smplrt_dmp_odrs_11
   \   00000124   0x2012             MOVS     R0,#+18
   \   00000126   0xE000             B.N      ??inv_set_hw_smplrt_dmp_odrs_12
   \                     ??inv_set_hw_smplrt_dmp_odrs_11: (+1)
   \   00000128   0x4620             MOV      R0,R4
    392          		// estimate closest decimator value to have 56Hz multiple and apply it
    393          		lBACMinDly = 1000/(get_multiple_56_rate(lBACMinDly));
   \                     ??inv_set_hw_smplrt_dmp_odrs_12: (+1)
   \   0000012A   0x.... 0x....      BL       get_multiple_56_rate
   \   0000012E   0xF44F 0x717A      MOV      R1,#+1000
   \   00000132   0xFB91 0xF4F0      SDIV     R4,R1,R0
    394          		dmp_icm20948_set_bac_rate(s, get_multiple_56_rate(lBACMinDly));
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0xB280             UXTH     R0,R0
   \   0000013A   0x.... 0x....      BL       get_multiple_56_rate
   \   0000013E   0x4601             MOV      R1,R0
   \   00000140   0x4628             MOV      R0,R5
   \   00000142   0x.... 0x....      BL       dmp_icm20948_set_bac_rate
    395          		minDly_accel = lBACMinDly;
    396          		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
   \   00000146   0x4620             MOV      R0,R4
   \   00000148   0xB280             UXTH     R0,R0
   \   0000014A   0x.... 0x....      BL       SampleRateDividerGet
   \   0000014E   0x4682             MOV      R10,R0
    397          		result |= DividerRateSet(s, lBACMinDly, hw_smplrt_divider, INV_SENSOR_ACTIVITY_CLASSIFIER);
   \   00000150   0x230D             MOVS     R3,#+13
   \   00000152   0x4652             MOV      R2,R10
   \   00000154   0x4621             MOV      R1,R4
   \   00000156   0xB289             UXTH     R1,R1
   \   00000158   0x4628             MOV      R0,R5
   \   0000015A   0x.... 0x....      BL       DividerRateSet
   \   0000015E   0x4683             MOV      R11,R0
    398          	}
    399          	if (s->b2s_status != 0) {
   \                     ??inv_set_hw_smplrt_dmp_odrs_10: (+1)
   \   00000160   0xF8B5 0x0156      LDRH     R0,[R5, #+342]
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD021             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_13
    400          		unsigned short lB2SMinDly = min(INV_ODR_DEFAULT_B2S, minDly_accel);
   \   00000168   0xB2A4             UXTH     R4,R4
   \   0000016A   0x2C13             CMP      R4,#+19
   \   0000016C   0xDB01             BLT.N    ??inv_set_hw_smplrt_dmp_odrs_14
   \   0000016E   0x2012             MOVS     R0,#+18
   \   00000170   0xE000             B.N      ??inv_set_hw_smplrt_dmp_odrs_15
   \                     ??inv_set_hw_smplrt_dmp_odrs_14: (+1)
   \   00000172   0x4620             MOV      R0,R4
    401          		lB2SMinDly = 1000/(get_multiple_56_rate(lB2SMinDly));
   \                     ??inv_set_hw_smplrt_dmp_odrs_15: (+1)
   \   00000174   0x.... 0x....      BL       get_multiple_56_rate
   \   00000178   0xF44F 0x717A      MOV      R1,#+1000
   \   0000017C   0xFB91 0xF4F0      SDIV     R4,R1,R0
    402          		dmp_icm20948_set_b2s_rate(s, get_multiple_56_rate(lB2SMinDly));
   \   00000180   0x4620             MOV      R0,R4
   \   00000182   0xB280             UXTH     R0,R0
   \   00000184   0x.... 0x....      BL       get_multiple_56_rate
   \   00000188   0x4601             MOV      R1,R0
   \   0000018A   0x4628             MOV      R0,R5
   \   0000018C   0x.... 0x....      BL       dmp_icm20948_set_b2s_rate
    403          		minDly_accel = lB2SMinDly;
    404          		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
   \   00000190   0x4620             MOV      R0,R4
   \   00000192   0xB280             UXTH     R0,R0
   \   00000194   0x.... 0x....      BL       SampleRateDividerGet
   \   00000198   0x4682             MOV      R10,R0
    405          		result |= DividerRateSet(s, lB2SMinDly, hw_smplrt_divider, INV_SENSOR_BRING_TO_SEE);
   \   0000019A   0x230F             MOVS     R3,#+15
   \   0000019C   0x4652             MOV      R2,R10
   \   0000019E   0x4621             MOV      R1,R4
   \   000001A0   0xB289             UXTH     R1,R1
   \   000001A2   0x4628             MOV      R0,R5
   \   000001A4   0x.... 0x....      BL       DividerRateSet
   \   000001A8   0xEA40 0x0B0B      ORR      R11,R0,R11
   \                     ??inv_set_hw_smplrt_dmp_odrs_13: (+1)
   \   000001AC   0xB2A4             UXTH     R4,R4
   \   000001AE   0x42BC             CMP      R4,R7
   \   000001B0   0xD044             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_16
    406          	}
    407          
    408          	// set odrs for each enabled sensors
    409          
    410          	// Engine ACCEL Based
    411          	if (minDly_accel != 0xFFFF)	{ // 0xFFFF -- none accel based sensor enable
    412          		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
   \   000001B2   0x4620             MOV      R0,R4
   \   000001B4   0x.... 0x....      BL       SampleRateDividerGet
   \   000001B8   0x4682             MOV      R10,R0
    413          
    414          		if (hw_smplrt_divider != s->lLastHwSmplrtDividerAcc) {
   \   000001BA   0xF8B5 0x1236      LDRH     R1,[R5, #+566]
   \   000001BE   0x4288             CMP      R0,R1
   \   000001C0   0xD015             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_17
    415          			
    416          			result |= inv_icm20948_ctrl_set_accel_quaternion_gain(s, hw_smplrt_divider);
   \   000001C2   0x4651             MOV      R1,R10
   \   000001C4   0x4628             MOV      R0,R5
   \   000001C6   0x.... 0x....      BL       inv_icm20948_ctrl_set_accel_quaternion_gain
   \   000001CA   0xEA40 0x0B0B      ORR      R11,R0,R11
    417          			result |= inv_icm20948_ctrl_set_accel_cal_params(s, hw_smplrt_divider);
   \   000001CE   0x4651             MOV      R1,R10
   \   000001D0   0x4628             MOV      R0,R5
   \   000001D2   0x.... 0x....      BL       inv_icm20948_ctrl_set_accel_cal_params
   \   000001D6   0xEA40 0x0B0B      ORR      R11,R0,R11
    418          			result |= inv_icm20948_set_accel_divider(s, hw_smplrt_divider - 1);
   \   000001DA   0xF1AA 0x0101      SUB      R1,R10,#+1
   \   000001DE   0xB209             SXTH     R1,R1
   \   000001E0   0x4628             MOV      R0,R5
   \   000001E2   0x.... 0x....      BL       inv_icm20948_set_accel_divider
   \   000001E6   0xEA40 0x0B0B      ORR      R11,R0,R11
    419          			s->lLastHwSmplrtDividerAcc = hw_smplrt_divider;
   \   000001EA   0xF8A5 0xA236      STRH     R10,[R5, #+566]
    420          		}
    421          
    422          		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel2List), hw_smplrt_divider, INV_SENSOR_ACCEL);
   \                     ??inv_set_hw_smplrt_dmp_odrs_17: (+1)
   \   000001EE   0x2205             MOVS     R2,#+5
   \   000001F0   0xA913             ADD      R1,SP,#+76
   \   000001F2   0x4628             MOV      R0,R5
   \   000001F4   0x.... 0x....      BL       MinDelayGenActual
   \   000001F8   0x2300             MOVS     R3,#+0
   \   000001FA   0x4652             MOV      R2,R10
   \   000001FC   0x4601             MOV      R1,R0
   \   000001FE   0x4628             MOV      R0,R5
   \   00000200   0x.... 0x....      BL       DividerRateSet
   \   00000204   0xEA40 0x0B0B      ORR      R11,R0,R11
    423          		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel3List), hw_smplrt_divider, INV_SENSOR_GEOMAG);
   \   00000208   0x2202             MOVS     R2,#+2
   \   0000020A   0xA906             ADD      R1,SP,#+24
   \   0000020C   0x4628             MOV      R0,R5
   \   0000020E   0x.... 0x....      BL       MinDelayGenActual
   \   00000212   0x2307             MOVS     R3,#+7
   \   00000214   0x4652             MOV      R2,R10
   \   00000216   0x4601             MOV      R1,R0
   \   00000218   0x4628             MOV      R0,R5
   \   0000021A   0x.... 0x....      BL       DividerRateSet
   \   0000021E   0xEA40 0x0B0B      ORR      R11,R0,R11
    424          		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel4List), hw_smplrt_divider, INV_SENSOR_STEP_COUNTER);
   \   00000222   0x2205             MOVS     R2,#+5
   \   00000224   0xA910             ADD      R1,SP,#+64
   \   00000226   0x4628             MOV      R0,R5
   \   00000228   0x.... 0x....      BL       MinDelayGenActual
   \   0000022C   0x230C             MOVS     R3,#+12
   \   0000022E   0x4652             MOV      R2,R10
   \   00000230   0x4601             MOV      R1,R0
   \   00000232   0x4628             MOV      R0,R5
   \   00000234   0x.... 0x....      BL       DividerRateSet
   \   00000238   0xEA40 0x0B0B      ORR      R11,R0,R11
    425          		
    426          	}
    427          
    428          	// Engine Gyro Based
    429          	if (minDly_gyro != 0xFFFF) { // 0xFFFF -- none gyro based sensor enable
   \                     ??inv_set_hw_smplrt_dmp_odrs_16: (+1)
   \   0000023C   0x45B8             CMP      R8,R7
   \   0000023E   0xD047             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_18
    430          		hw_smplrt_divider = SampleRateDividerGet(minDly_gyro);
   \   00000240   0x4640             MOV      R0,R8
   \   00000242   0x.... 0x....      BL       SampleRateDividerGet
   \   00000246   0x4682             MOV      R10,R0
    431          
    432          		if (hw_smplrt_divider != s->lLastHwSmplrtDividerGyr) {
   \   00000248   0xF205 0x2136      ADDW     R1,R5,#+566
   \   0000024C   0x8849             LDRH     R1,[R1, #+2]
   \   0000024E   0x4288             CMP      R0,R1
   \   00000250   0xD00A             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_19
    433          			result |= inv_icm20948_set_gyro_divider(s, (unsigned char)(hw_smplrt_divider - 1));
   \   00000252   0x1E41             SUBS     R1,R0,#+1
   \   00000254   0xB2C9             UXTB     R1,R1
   \   00000256   0x4628             MOV      R0,R5
   \   00000258   0x.... 0x....      BL       inv_icm20948_set_gyro_divider
   \   0000025C   0xEA40 0x0B0B      ORR      R11,R0,R11
    434          			s->lLastHwSmplrtDividerGyr = hw_smplrt_divider;
   \   00000260   0xF205 0x2036      ADDW     R0,R5,#+566
   \   00000264   0xF8A0 0xA002      STRH     R10,[R0, #+2]
    435          		}
    436          
    437          		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro2List), hw_smplrt_divider, INV_SENSOR_GYRO);
   \                     ??inv_set_hw_smplrt_dmp_odrs_19: (+1)
   \   00000268   0x2205             MOVS     R2,#+5
   \   0000026A   0xA90D             ADD      R1,SP,#+52
   \   0000026C   0x4628             MOV      R0,R5
   \   0000026E   0x.... 0x....      BL       MinDelayGenActual
   \   00000272   0x2301             MOVS     R3,#+1
   \   00000274   0x4652             MOV      R2,R10
   \   00000276   0x4601             MOV      R1,R0
   \   00000278   0x4628             MOV      R0,R5
   \   0000027A   0x.... 0x....      BL       DividerRateSet
   \   0000027E   0xEA40 0x0B0B      ORR      R11,R0,R11
    438          		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro3List), hw_smplrt_divider, INV_SENSOR_CALIB_GYRO);
   \   00000282   0x2202             MOVS     R2,#+2
   \   00000284   0xA905             ADD      R1,SP,#+20
   \   00000286   0x4628             MOV      R0,R5
   \   00000288   0x.... 0x....      BL       MinDelayGenActual
   \   0000028C   0x230A             MOVS     R3,#+10
   \   0000028E   0x4652             MOV      R2,R10
   \   00000290   0x4601             MOV      R1,R0
   \   00000292   0x4628             MOV      R0,R5
   \   00000294   0x.... 0x....      BL       DividerRateSet
   \   00000298   0xEA40 0x0B0B      ORR      R11,R0,R11
    439          		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro4List), hw_smplrt_divider, INV_SENSOR_SIXQ);
   \   0000029C   0x2206             MOVS     R2,#+6
   \   0000029E   0xA90A             ADD      R1,SP,#+40
   \   000002A0   0x4628             MOV      R0,R5
   \   000002A2   0x.... 0x....      BL       MinDelayGenActual
   \   000002A6   0x2305             MOVS     R3,#+5
   \   000002A8   0x4652             MOV      R2,R10
   \   000002AA   0x4601             MOV      R1,R0
   \   000002AC   0x4628             MOV      R0,R5
   \   000002AE   0x.... 0x....      BL       DividerRateSet
   \   000002B2   0xEA40 0x0B0B      ORR      R11,R0,R11
    440          		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro5List), hw_smplrt_divider, INV_SENSOR_NINEQ);
   \   000002B6   0x2204             MOVS     R2,#+4
   \   000002B8   0xA908             ADD      R1,SP,#+32
   \   000002BA   0x4628             MOV      R0,R5
   \   000002BC   0x.... 0x....      BL       MinDelayGenActual
   \   000002C0   0x2306             MOVS     R3,#+6
   \   000002C2   0x4652             MOV      R2,R10
   \   000002C4   0x4601             MOV      R1,R0
   \   000002C6   0x4628             MOV      R0,R5
   \   000002C8   0x.... 0x....      BL       DividerRateSet
   \   000002CC   0xEA40 0x0B0B      ORR      R11,R0,R11
    441          	}
    442          
    443          	// Engine Cpass and Pressure Based	
    444          	if ((minDly_cpass != 0xFFFF) || (minDly_pressure != 0xFFFF)) {
   \                     ??inv_set_hw_smplrt_dmp_odrs_18: (+1)
   \   000002D0   0x9800             LDR      R0,[SP, #+0]
   \   000002D2   0x42B8             CMP      R0,R7
   \   000002D4   0xD101             BNE.N    ??inv_set_hw_smplrt_dmp_odrs_20
   \   000002D6   0x45B9             CMP      R9,R7
   \   000002D8   0xD045             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_21
    445          		unsigned int lI2cEffectiveDivider = 0;
   \                     ??inv_set_hw_smplrt_dmp_odrs_20: (+1)
   \   000002DA   0x2000             MOVS     R0,#+0
   \   000002DC   0x9001             STR      R0,[SP, #+4]
    446          
    447          		// if compass or pressure are alone, compute 1st stage divider, otherwise it will be taken from accel or gyro
    448          		if ( (minDly_accel == 0xFFFF) && (minDly_gyro == 0xFFFF) )
   \   000002DE   0x42BC             CMP      R4,R7
   \   000002E0   0xD105             BNE.N    ??inv_set_hw_smplrt_dmp_odrs_22
   \   000002E2   0x45B8             CMP      R8,R7
   \   000002E4   0xD103             BNE.N    ??inv_set_hw_smplrt_dmp_odrs_22
    449          			hw_smplrt_divider = SampleRateDividerGet(minDly);
   \   000002E6   0x4630             MOV      R0,R6
   \   000002E8   0x.... 0x....      BL       SampleRateDividerGet
   \   000002EC   0x4682             MOV      R10,R0
    450          
    451          		// Apply compass or pressure ODR to I2C and get effective ODR
    452          		// so that 2nd level of divider can take into account real frequency we can expect
    453          		// to determine its divider value
    454          		result |= inv_icm20948_secondary_set_odr(s, hw_smplrt_divider, &lI2cEffectiveDivider);
   \                     ??inv_set_hw_smplrt_dmp_odrs_22: (+1)
   \   000002EE   0xAA01             ADD      R2,SP,#+4
   \   000002F0   0x4651             MOV      R1,R10
   \   000002F2   0x4628             MOV      R0,R5
   \   000002F4   0x.... 0x....      BL       inv_icm20948_secondary_set_odr
   \   000002F8   0xEA40 0x0B0B      ORR      R11,R0,R11
    455          
    456          		// if compass or pressure are alone, recompute 1st stage divider based on configured divider for I2C
    457          		// otherwise divider is taken from accel or gyro, so there is no need to recompute effective divider value
    458          		// based on the divider we just applied
    459          		if ( (minDly_accel == 0xFFFF) && (minDly_gyro == 0xFFFF) )
   \   000002FC   0x42BC             CMP      R4,R7
   \   000002FE   0xD103             BNE.N    ??inv_set_hw_smplrt_dmp_odrs_23
   \   00000300   0x45B8             CMP      R8,R7
   \   00000302   0xD101             BNE.N    ??inv_set_hw_smplrt_dmp_odrs_23
    460          			hw_smplrt_divider = lI2cEffectiveDivider;
   \   00000304   0xF8DD 0xA004      LDR      R10,[SP, #+4]
    461          
    462          		if (minDly_cpass != 0xFFFF) {
   \                     ??inv_set_hw_smplrt_dmp_odrs_23: (+1)
   \   00000308   0x9800             LDR      R0,[SP, #+0]
   \   0000030A   0x42B8             CMP      R0,R7
   \   0000030C   0xD01B             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_24
    463          			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenCpass2List), hw_smplrt_divider, INV_SENSOR_COMPASS);
   \   0000030E   0x2202             MOVS     R2,#+2
   \   00000310   0xA904             ADD      R1,SP,#+16
   \   00000312   0x4628             MOV      R0,R5
   \   00000314   0x.... 0x....      BL       MinDelayGenActual
   \   00000318   0x2303             MOVS     R3,#+3
   \   0000031A   0x4652             MOV      R2,R10
   \   0000031C   0xB292             UXTH     R2,R2
   \   0000031E   0x4601             MOV      R1,R0
   \   00000320   0x4628             MOV      R0,R5
   \   00000322   0x.... 0x....      BL       DividerRateSet
   \   00000326   0xEA40 0x040B      ORR      R4,R0,R11
    464          			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenCpass3List), hw_smplrt_divider, INV_SENSOR_CALIB_COMPASS);
   \   0000032A   0x2202             MOVS     R2,#+2
   \   0000032C   0xA903             ADD      R1,SP,#+12
   \   0000032E   0x4628             MOV      R0,R5
   \   00000330   0x.... 0x....      BL       MinDelayGenActual
   \   00000334   0x230B             MOVS     R3,#+11
   \   00000336   0x4652             MOV      R2,R10
   \   00000338   0xB292             UXTH     R2,R2
   \   0000033A   0x4601             MOV      R1,R0
   \   0000033C   0x4628             MOV      R0,R5
   \   0000033E   0x.... 0x....      BL       DividerRateSet
   \   00000342   0xEA40 0x0B04      ORR      R11,R0,R4
    465          		}
    466          
    467          		if (minDly_pressure != 0xFFFF)
   \                     ??inv_set_hw_smplrt_dmp_odrs_24: (+1)
   \   00000346   0x45B9             CMP      R9,R7
   \   00000348   0xD00D             BEQ.N    ??inv_set_hw_smplrt_dmp_odrs_21
    468          			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenPressure2List), hw_smplrt_divider, INV_SENSOR_PRESSURE);
   \   0000034A   0x2202             MOVS     R2,#+2
   \   0000034C   0xA902             ADD      R1,SP,#+8
   \   0000034E   0x4628             MOV      R0,R5
   \   00000350   0x.... 0x....      BL       MinDelayGenActual
   \   00000354   0x2309             MOVS     R3,#+9
   \   00000356   0x4652             MOV      R2,R10
   \   00000358   0xB292             UXTH     R2,R2
   \   0000035A   0x4601             MOV      R1,R0
   \   0000035C   0x4628             MOV      R0,R5
   \   0000035E   0x.... 0x....      BL       DividerRateSet
   \   00000362   0xEA40 0x0B0B      ORR      R11,R0,R11
    469          	}
    470          
    471          	return result;
   \                     ??inv_set_hw_smplrt_dmp_odrs_21: (+1)
   \   00000366   0x4658             MOV      R0,R11
   \   00000368   0xB017             ADD      SP,SP,#+92
   \   0000036A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    472          }
    473          

   \                                 In section .text, align 2, keep-with-next
    474          static short get_multiple_56_rate(unsigned short delayInMs)
    475          {
    476          	short lfreq = 0;
   \                     get_multiple_56_rate: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    477          
    478          	// > 1KHz
    479          	if( delayInMs < 2 ){
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x2A02             CMP      R2,#+2
   \   00000006   0xDA02             BGE.N    ??get_multiple_56_rate_0
    480          	lfreq = DMP_ALGO_FREQ_900;
   \   00000008   0xF44F 0x7161      MOV      R1,#+900
   \   0000000C   0xE012             B.N      ??get_multiple_56_rate_1
    481          	}
    482          	// 225Hz - 500Hz
    483          	else if(( delayInMs >= 2 ) && ( delayInMs < 4 )){
   \                     ??get_multiple_56_rate_0: (+1)
   \   0000000E   0x1E83             SUBS     R3,R0,#+2
   \   00000010   0x2B02             CMP      R3,#+2
   \   00000012   0xD202             BCS.N    ??get_multiple_56_rate_2
    484          	lfreq = DMP_ALGO_FREQ_450;
   \   00000014   0xF44F 0x71E1      MOV      R1,#+450
   \   00000018   0xE00C             B.N      ??get_multiple_56_rate_1
    485          	}
    486          	// 112Hz - 225Hz
    487          	else if(( delayInMs >= 4 ) && ( delayInMs < 8 )){
   \                     ??get_multiple_56_rate_2: (+1)
   \   0000001A   0x1F03             SUBS     R3,R0,#+4
   \   0000001C   0x2B04             CMP      R3,#+4
   \   0000001E   0xD201             BCS.N    ??get_multiple_56_rate_3
    488          	lfreq = DMP_ALGO_FREQ_225;
   \   00000020   0x21E1             MOVS     R1,#+225
   \   00000022   0xE007             B.N      ??get_multiple_56_rate_1
    489          	}
    490          	// 56Hz - 112Hz
    491          	else if(( delayInMs >= 8 ) && ( delayInMs < 17 )){
   \                     ??get_multiple_56_rate_3: (+1)
   \   00000024   0x3808             SUBS     R0,R0,#+8
   \   00000026   0x2809             CMP      R0,#+9
   \   00000028   0xD201             BCS.N    ??get_multiple_56_rate_4
    492          	lfreq = DMP_ALGO_FREQ_112;
   \   0000002A   0x2170             MOVS     R1,#+112
   \   0000002C   0xE002             B.N      ??get_multiple_56_rate_1
    493          	}
    494          	// < 56Hz
    495          	else if(delayInMs >= 17){
   \                     ??get_multiple_56_rate_4: (+1)
   \   0000002E   0x2A11             CMP      R2,#+17
   \   00000030   0xDB00             BLT.N    ??get_multiple_56_rate_1
    496          	lfreq = DMP_ALGO_FREQ_56;
   \   00000032   0x2138             MOVS     R1,#+56
    497          	}
    498          	
    499          	return lfreq;
   \                     ??get_multiple_56_rate_1: (+1)
   \   00000034   0x4608             MOV      R0,R1
   \   00000036   0x4770             BX       LR               ;; return
    500          }
    501          

   \                                 In section .text, align 4, keep-with-next
    502          int inv_icm20948_set_odr(struct inv_icm20948 * s, unsigned char androidSensor, unsigned short delayInMs)
    503          {
   \                     inv_icm20948_set_odr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    504          	int result;
    505          
    506          	if(sensor_needs_compass(androidSensor))
   \   00000008   0x4630             MOV      R0,R6
   \   0000000A   0x.... 0x....      BL       sensor_needs_compass
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD007             BEQ.N    ??inv_icm20948_set_odr_1
    507          		if(!inv_icm20948_get_compass_availability(s))
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       inv_icm20948_get_compass_availability
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD102             BNE.N    ??inv_icm20948_set_odr_1
    508          			return -1;
   \   0000001C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    509          	
    510          	//check if sensor is bac algo dependant
    511          	if(sensor_needs_bac_algo(androidSensor)) {
   \                     ??inv_icm20948_set_odr_1: (+1)
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       sensor_needs_bac_algo
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD000             BEQ.N    ??inv_icm20948_set_odr_2
    512          		// set odr for sensors using BAC (1/56)
    513          		delayInMs = INV_ODR_DEFAULT_BAC;
   \   0000002C   0x2512             MOVS     R5,#+18
    514          	}
    515          	
    516          	inv_icm20948_prevent_lpen_control(s);
   \                     ??inv_icm20948_set_odr_2: (+1)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_icm20948_prevent_lpen_control
   \   00000034   0xEB04 0x0086      ADD      R0,R4,R6, LSL #+2
   \   00000038   0xF44F 0x71B4      MOV      R1,#+360
   \   0000003C   0x4408             ADD      R0,R0,R1
   \   0000003E   0x8801             LDRH     R1,[R0, #+0]
   \   00000040   0x462A             MOV      R2,R5
   \   00000042   0x460B             MOV      R3,R1
   \   00000044   0x429A             CMP      R2,R3
   \   00000046   0xD200             BCS.N    ??inv_icm20948_set_odr_3
    517          
    518          	// check that requested ODR is within the allowed limits
    519          	if (delayInMs < s->inv_androidSensorsOdr_boundaries[androidSensor][0]) delayInMs = s->inv_androidSensorsOdr_boundaries[androidSensor][0];
   \   00000048   0x460D             MOV      R5,R1
    520          	if (delayInMs > s->inv_androidSensorsOdr_boundaries[androidSensor][1]) delayInMs = s->inv_androidSensorsOdr_boundaries[androidSensor][1];
   \                     ??inv_icm20948_set_odr_3: (+1)
   \   0000004A   0x8840             LDRH     R0,[R0, #+2]
   \   0000004C   0x4601             MOV      R1,R0
   \   0000004E   0x462A             MOV      R2,R5
   \   00000050   0x4291             CMP      R1,R2
   \   00000052   0xD200             BCS.N    ??inv_icm20948_set_odr_4
   \   00000054   0x4605             MOV      R5,R0
    521          	switch (androidSensor) {
   \                     ??inv_icm20948_set_odr_4: (+1)
   \   00000056   0x4630             MOV      R0,R6
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x282E             CMP      R0,#+46
   \   0000005C   0xF200 0x8123      BHI.W    ??inv_icm20948_set_odr_5
   \   00000060   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??inv_icm20948_set_odr_0:
   \   00000064   0x002F 0x00B6      DC16     0x2F,0xB6,0xA4,0x93
   \              0x00A4 0x0093
   \   0000006C   0x00BB 0x0113      DC16     0xBB,0x113,0x121,0x10E
   \              0x0121 0x010E
   \   00000074   0x0098 0x0098      DC16     0x98,0x98,0xA4,0x121
   \              0x00A4 0x0121
   \   0000007C   0x0121 0x00B1      DC16     0x121,0xB1,0x98,0x69
   \              0x0098 0x0069
   \   00000084   0x00C5 0x0059      DC16     0xC5,0x59,0x59,0x5E
   \              0x0059 0x005E
   \   0000008C   0x0121 0x00BB      DC16     0x121,0xBB,0xC0,0x109
   \              0x00C0 0x0109
   \   00000094   0x00F4 0x00E0      DC16     0xF4,0xE0,0x10E,0x118
   \              0x010E 0x0118
   \   0000009C   0x00E5 0x00E5      DC16     0xE5,0xE5,0xF4,0x121
   \              0x00F4 0x0121
   \   000000A4   0x0121 0x0104      DC16     0x121,0x104,0xE5,0xDB
   \              0x00E5 0x00DB
   \   000000AC   0x00C5 0x00C5      DC16     0xC5,0xC5,0xCA,0x121
   \              0x00CA 0x0121
   \   000000B4   0x00D3 0x0044      DC16     0xD3,0x44,0x7E,0x121
   \              0x007E 0x0121
   \   000000BC   0x00D6 0x011D      DC16     0xD6,0x11D,0x64
   \              0x0064       
    522          		case ANDROID_SENSOR_ACCELEROMETER:
    523          			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
   \                     ??inv_icm20948_set_odr_6: (+1)
   \   000000C2   0xF44F 0x7083      MOV      R0,#+262
   \   000000C6   0x1826             ADDS     R6,R4,R0
   \   000000C8   0xF204 0x2746      ADDW     R7,R4,#+582
   \   000000CC   0x212A             MOVS     R1,#+42
   \   000000CE   0x4620             MOV      R0,R4
   \   000000D0   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD006             BEQ.N    ??inv_icm20948_set_odr_7
    524          				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(delayInMs,s->odr_racc_ms);
   \   000000D8   0x4628             MOV      R0,R5
   \   000000DA   0x8879             LDRH     R1,[R7, #+2]
   \   000000DC   0x4288             CMP      R0,R1
   \   000000DE   0xD900             BLS.N    ??inv_icm20948_set_odr_8
   \   000000E0   0x4608             MOV      R0,R1
   \                     ??inv_icm20948_set_odr_8: (+1)
   \   000000E2   0x8030             STRH     R0,[R6, #+0]
   \   000000E4   0xE000             B.N      ??inv_icm20948_set_odr_9
    525          			else
    526          				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = delayInMs;
   \                     ??inv_icm20948_set_odr_7: (+1)
   \   000000E6   0x8035             STRH     R5,[R6, #+0]
    527          			s->odr_acc_ms = delayInMs;
   \                     ??inv_icm20948_set_odr_9: (+1)
   \   000000E8   0x803D             STRH     R5,[R7, #+0]
    528          			break;
   \   000000EA   0xE0DC             B.N      ??inv_icm20948_set_odr_5
    529          		case ANDROID_SENSOR_RAW_ACCELEROMETER:
    530          			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER))
   \                     ??inv_icm20948_set_odr_10: (+1)
   \   000000EC   0xF44F 0x7083      MOV      R0,#+262
   \   000000F0   0x1826             ADDS     R6,R4,R0
   \   000000F2   0xF204 0x2746      ADDW     R7,R4,#+582
   \   000000F6   0x2101             MOVS     R1,#+1
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD006             BEQ.N    ??inv_icm20948_set_odr_11
    531          				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(delayInMs,s->odr_acc_ms);
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0x8839             LDRH     R1,[R7, #+0]
   \   00000106   0x4288             CMP      R0,R1
   \   00000108   0xD900             BLS.N    ??inv_icm20948_set_odr_12
   \   0000010A   0x4608             MOV      R0,R1
   \                     ??inv_icm20948_set_odr_12: (+1)
   \   0000010C   0x8030             STRH     R0,[R6, #+0]
   \   0000010E   0xE000             B.N      ??inv_icm20948_set_odr_13
    532          			else
    533          				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = delayInMs;
   \                     ??inv_icm20948_set_odr_11: (+1)
   \   00000110   0x8035             STRH     R5,[R6, #+0]
    534          			s->odr_racc_ms = delayInMs;
   \                     ??inv_icm20948_set_odr_13: (+1)
   \   00000112   0x807D             STRH     R5,[R7, #+2]
    535          			break;
   \   00000114   0xE0C7             B.N      ??inv_icm20948_set_odr_5
    536          
    537          		case ANDROID_SENSOR_STEP_DETECTOR:
    538          		case ANDROID_SENSOR_STEP_COUNTER:
    539          			s->inv_dmp_odr_delays[INV_SENSOR_STEP_COUNTER] = delayInMs;
   \                     ??inv_icm20948_set_odr_14: (+1)
   \   00000116   0xF44F 0x7083      MOV      R0,#+262
   \   0000011A   0x4420             ADD      R0,R4,R0
   \   0000011C   0x8305             STRH     R5,[R0, #+24]
    540          			break;
   \   0000011E   0xE0C2             B.N      ??inv_icm20948_set_odr_5
    541          
    542          		case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:
    543          			s->inv_dmp_odr_delays[INV_SENSOR_GEOMAG] = delayInMs;
   \                     ??inv_icm20948_set_odr_15: (+1)
   \   00000120   0xF44F 0x7083      MOV      R0,#+262
   \   00000124   0x1826             ADDS     R6,R4,R0
   \   00000126   0x81F5             STRH     R5,[R6, #+14]
    544          			s->inv_dmp_odr_delays[INV_SENSOR_GEOMAG_cpass] = delayInMs;
   \   00000128   0x84B5             STRH     R5,[R6, #+36]
    545          			break;
   \   0000012A   0xE0BC             B.N      ??inv_icm20948_set_odr_5
    546          
    547          		case ANDROID_SENSOR_ACTIVITY_CLASSIFICATON:
    548          			s->inv_dmp_odr_delays[INV_SENSOR_ACTIVITY_CLASSIFIER] = delayInMs;
   \                     ??inv_icm20948_set_odr_16: (+1)
   \   0000012C   0xF44F 0x7083      MOV      R0,#+262
   \   00000130   0x4420             ADD      R0,R4,R0
   \   00000132   0x8345             STRH     R5,[R0, #+26]
    549          			break;
   \   00000134   0xE0B7             B.N      ??inv_icm20948_set_odr_5
    550          
    551          		case ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED:
    552          			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
   \                     ??inv_icm20948_set_odr_17: (+1)
   \   00000136   0xF44F 0x7083      MOV      R0,#+262
   \   0000013A   0x1826             ADDS     R6,R4,R0
   \   0000013C   0xF204 0x2746      ADDW     R7,R4,#+582
   \   00000140   0x212B             MOVS     R1,#+43
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD006             BEQ.N    ??inv_icm20948_set_odr_18
    553          				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(delayInMs,s->odr_rgyr_ms);
   \   0000014C   0x4628             MOV      R0,R5
   \   0000014E   0x88F9             LDRH     R1,[R7, #+6]
   \   00000150   0x4288             CMP      R0,R1
   \   00000152   0xD900             BLS.N    ??inv_icm20948_set_odr_19
   \   00000154   0x4608             MOV      R0,R1
   \                     ??inv_icm20948_set_odr_19: (+1)
   \   00000156   0x8070             STRH     R0,[R6, #+2]
   \   00000158   0xE000             B.N      ??inv_icm20948_set_odr_20
    554          			else
    555          				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = delayInMs;
   \                     ??inv_icm20948_set_odr_18: (+1)
   \   0000015A   0x8075             STRH     R5,[R6, #+2]
    556          			s->odr_gyr_ms = delayInMs;
   \                     ??inv_icm20948_set_odr_20: (+1)
   \   0000015C   0x80BD             STRH     R5,[R7, #+4]
    557          			break;
   \   0000015E   0xE0A2             B.N      ??inv_icm20948_set_odr_5
    558          		case ANDROID_SENSOR_RAW_GYROSCOPE:
    559          			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED))
   \                     ??inv_icm20948_set_odr_21: (+1)
   \   00000160   0xF44F 0x7083      MOV      R0,#+262
   \   00000164   0x1826             ADDS     R6,R4,R0
   \   00000166   0xF204 0x2746      ADDW     R7,R4,#+582
   \   0000016A   0x2110             MOVS     R1,#+16
   \   0000016C   0x4620             MOV      R0,R4
   \   0000016E   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD006             BEQ.N    ??inv_icm20948_set_odr_22
    560          				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(delayInMs,s->odr_gyr_ms);
   \   00000176   0x4628             MOV      R0,R5
   \   00000178   0x88B9             LDRH     R1,[R7, #+4]
   \   0000017A   0x4288             CMP      R0,R1
   \   0000017C   0xD900             BLS.N    ??inv_icm20948_set_odr_23
   \   0000017E   0x4608             MOV      R0,R1
   \                     ??inv_icm20948_set_odr_23: (+1)
   \   00000180   0x8070             STRH     R0,[R6, #+2]
   \   00000182   0xE000             B.N      ??inv_icm20948_set_odr_24
    561          			else
    562          				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = delayInMs;
   \                     ??inv_icm20948_set_odr_22: (+1)
   \   00000184   0x8075             STRH     R5,[R6, #+2]
    563          			s->odr_rgyr_ms = delayInMs;
   \                     ??inv_icm20948_set_odr_24: (+1)
   \   00000186   0x80FD             STRH     R5,[R7, #+6]
    564          			break;
   \   00000188   0xE08D             B.N      ??inv_icm20948_set_odr_5
    565          		case ANDROID_SENSOR_GYROSCOPE:
    566          			s->inv_dmp_odr_delays[INV_SENSOR_CALIB_GYRO] = delayInMs;
   \                     ??inv_icm20948_set_odr_25: (+1)
   \   0000018A   0xF44F 0x7083      MOV      R0,#+262
   \   0000018E   0x4420             ADD      R0,R4,R0
   \   00000190   0x8285             STRH     R5,[R0, #+20]
    567          			break;
   \   00000192   0xE088             B.N      ??inv_icm20948_set_odr_5
    568          
    569          		case ANDROID_SENSOR_GRAVITY:
    570          		case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
    571          		case ANDROID_SENSOR_LINEAR_ACCELERATION:
    572          			// if augmented sensors are handled by this driver,
    573          			// then the fastest 6quat-based sensor which is enabled
    574          			// should be applied to all 6quat-based sensors
    575          			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
   \                     ??inv_icm20948_set_odr_26: (+1)
   \   00000194   0x462A             MOV      R2,R5
   \   00000196   0x4631             MOV      R1,R6
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       inv_icm20948_augmented_sensors_set_odr
   \   0000019E   0x4605             MOV      R5,R0
    576          			s->inv_dmp_odr_delays[INV_SENSOR_SIXQ] = delayInMs;
   \   000001A0   0xF44F 0x7083      MOV      R0,#+262
   \   000001A4   0x1826             ADDS     R6,R4,R0
   \   000001A6   0x8175             STRH     R5,[R6, #+10]
    577          			s->inv_dmp_odr_delays[INV_SENSOR_SIXQ_accel] = delayInMs;
   \   000001A8   0x8435             STRH     R5,[R6, #+32]
    578          			break;
   \   000001AA   0xE07C             B.N      ??inv_icm20948_set_odr_5
    579          
    580          		case ANDROID_SENSOR_ORIENTATION:
    581          		case ANDROID_SENSOR_ROTATION_VECTOR:
    582          			// if augmented sensors are handled by this driver,
    583          			// then the fastest 9quat-based sensor which is enabled
    584          			// should be applied to all 9quat-based sensors
    585          			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
   \                     ??inv_icm20948_set_odr_27: (+1)
   \   000001AC   0x462A             MOV      R2,R5
   \   000001AE   0x4631             MOV      R1,R6
   \   000001B0   0x4620             MOV      R0,R4
   \   000001B2   0x.... 0x....      BL       inv_icm20948_augmented_sensors_set_odr
   \   000001B6   0x4605             MOV      R5,R0
    586          			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ] = delayInMs;
   \   000001B8   0xF44F 0x7083      MOV      R0,#+262
   \   000001BC   0x1826             ADDS     R6,R4,R0
   \   000001BE   0x81B5             STRH     R5,[R6, #+12]
    587          			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_accel] = delayInMs;
   \   000001C0   0x8475             STRH     R5,[R6, #+34]
    588          			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_cpass] = delayInMs;
   \   000001C2   0x84F5             STRH     R5,[R6, #+38]
    589          			break;
   \   000001C4   0xE06F             B.N      ??inv_icm20948_set_odr_5
    590          
    591          		case ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:
    592          			s->inv_dmp_odr_delays[INV_SENSOR_COMPASS] = delayInMs;
   \                     ??inv_icm20948_set_odr_28: (+1)
   \   000001C6   0xF44F 0x7083      MOV      R0,#+262
   \   000001CA   0x4420             ADD      R0,R4,R0
   \   000001CC   0x80C5             STRH     R5,[R0, #+6]
    593          			break;
   \   000001CE   0xE06A             B.N      ??inv_icm20948_set_odr_5
    594          
    595          		case ANDROID_SENSOR_GEOMAGNETIC_FIELD:
    596          			s->inv_dmp_odr_delays[INV_SENSOR_CALIB_COMPASS] = delayInMs;
   \                     ??inv_icm20948_set_odr_29: (+1)
   \   000001D0   0xF44F 0x7083      MOV      R0,#+262
   \   000001D4   0x4420             ADD      R0,R4,R0
   \   000001D6   0x82C5             STRH     R5,[R0, #+22]
    597          			break;
   \   000001D8   0xE065             B.N      ??inv_icm20948_set_odr_5
    598          
    599          		case ANDROID_SENSOR_LIGHT:
    600          		case ANDROID_SENSOR_PROXIMITY:
    601          			s->inv_dmp_odr_delays[INV_SENSOR_ALS] = delayInMs;
   \                     ??inv_icm20948_set_odr_30: (+1)
   \   000001DA   0xF44F 0x7083      MOV      R0,#+262
   \   000001DE   0x4420             ADD      R0,R4,R0
   \   000001E0   0x8105             STRH     R5,[R0, #+8]
    602          			break;
   \   000001E2   0xE060             B.N      ??inv_icm20948_set_odr_5
    603          
    604          		case ANDROID_SENSOR_WAKEUP_ACCELEROMETER:
    605          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_ACCEL] = delayInMs;
   \                     ??inv_icm20948_set_odr_31: (+1)
   \   000001E4   0xF44F 0x7083      MOV      R0,#+262
   \   000001E8   0x4420             ADD      R0,R4,R0
   \   000001EA   0x8505             STRH     R5,[R0, #+40]
    606          			break;
   \   000001EC   0xE05B             B.N      ??inv_icm20948_set_odr_5
    607          
    608          		case ANDROID_SENSOR_WAKEUP_STEP_DETECTOR:
    609          		case ANDROID_SENSOR_WAKEUP_STEP_COUNTER:
    610          		case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:
    611          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_STEP_COUNTER] = delayInMs;
   \                     ??inv_icm20948_set_odr_32: (+1)
   \   000001EE   0xF44F 0x7083      MOV      R0,#+262
   \   000001F2   0x4420             ADD      R0,R4,R0
   \   000001F4   0x87C5             STRH     R5,[R0, #+62]
    612          			break;
   \   000001F6   0xE056             B.N      ??inv_icm20948_set_odr_5
    613          
    614          		case ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR:
    615          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GEOMAG] = delayInMs;
   \                     ??inv_icm20948_set_odr_33: (+1)
   \   000001F8   0xF44F 0x7083      MOV      R0,#+262
   \   000001FC   0x4420             ADD      R0,R4,R0
   \   000001FE   0x8685             STRH     R5,[R0, #+52]
    616          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GEOMAG_cpass] = delayInMs;
   \   00000200   0xF44F 0x70A3      MOV      R0,#+326
   \   00000204   0x4420             ADD      R0,R4,R0
   \   00000206   0x80C5             STRH     R5,[R0, #+6]
    617          			break;
   \   00000208   0xE04D             B.N      ??inv_icm20948_set_odr_5
    618          
    619          		case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:
    620          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_TILT_DETECTOR] = delayInMs;
   \                     ??inv_icm20948_set_odr_34: (+1)
   \   0000020A   0xF8A4 0x5146      STRH     R5,[R4, #+326]
    621          			break;
   \   0000020E   0xE04A             B.N      ??inv_icm20948_set_odr_5
    622          
    623          		case ANDROID_SENSOR_B2S:
    624          			s->inv_dmp_odr_delays[INV_SENSOR_BRING_TO_SEE] = delayInMs;
   \                     ??inv_icm20948_set_odr_35: (+1)
   \   00000210   0xF44F 0x7083      MOV      R0,#+262
   \   00000214   0x4420             ADD      R0,R4,R0
   \   00000216   0x83C5             STRH     R5,[R0, #+30]
    625          			break;
   \   00000218   0xE045             B.N      ??inv_icm20948_set_odr_5
    626          
    627          		case ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED:
    628          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GYRO] = delayInMs;
   \                     ??inv_icm20948_set_odr_36: (+1)
   \   0000021A   0xF44F 0x7083      MOV      R0,#+262
   \   0000021E   0x4420             ADD      R0,R4,R0
   \   00000220   0x8545             STRH     R5,[R0, #+42]
    629          			break;
   \   00000222   0xE040             B.N      ??inv_icm20948_set_odr_5
    630          
    631          		case ANDROID_SENSOR_WAKEUP_GYROSCOPE:
    632          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_CALIB_GYRO] = delayInMs;
   \                     ??inv_icm20948_set_odr_37: (+1)
   \   00000224   0xF44F 0x7083      MOV      R0,#+262
   \   00000228   0x4420             ADD      R0,R4,R0
   \   0000022A   0x8745             STRH     R5,[R0, #+58]
    633          			break;
   \   0000022C   0xE03B             B.N      ??inv_icm20948_set_odr_5
    634          
    635          		case ANDROID_SENSOR_WAKEUP_GRAVITY:
    636          		case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
    637          		case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
    638          			// if augmented sensors are handled by this driver,
    639          			// then the fastest 6quat-based sensor which is enabled
    640          			// should be applied to all 6quat-based sensors
    641          			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
   \                     ??inv_icm20948_set_odr_38: (+1)
   \   0000022E   0x462A             MOV      R2,R5
   \   00000230   0x4631             MOV      R1,R6
   \   00000232   0x4620             MOV      R0,R4
   \   00000234   0x.... 0x....      BL       inv_icm20948_augmented_sensors_set_odr
   \   00000238   0x4605             MOV      R5,R0
    642          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ] = delayInMs;
   \   0000023A   0xF44F 0x7083      MOV      R0,#+262
   \   0000023E   0x4420             ADD      R0,R4,R0
   \   00000240   0x8605             STRH     R5,[R0, #+48]
    643          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ_accel] = delayInMs;
   \   00000242   0xF44F 0x70A3      MOV      R0,#+326
   \   00000246   0x4420             ADD      R0,R4,R0
   \   00000248   0x8045             STRH     R5,[R0, #+2]
    644          			break;
   \   0000024A   0xE02C             B.N      ??inv_icm20948_set_odr_5
    645          
    646          		case ANDROID_SENSOR_WAKEUP_ORIENTATION:
    647          		case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
    648          			// if augmented sensors are handled by this driver,
    649          			// then the fastest 9quat-based sensor which is enabled
    650          			// should be applied to all 9quat-based sensors
    651          			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
   \                     ??inv_icm20948_set_odr_39: (+1)
   \   0000024C   0x462A             MOV      R2,R5
   \   0000024E   0x4631             MOV      R1,R6
   \   00000250   0x4620             MOV      R0,R4
   \   00000252   0x.... 0x....      BL       inv_icm20948_augmented_sensors_set_odr
   \   00000256   0x4605             MOV      R5,R0
    652          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ] = delayInMs;
   \   00000258   0xF44F 0x7083      MOV      R0,#+262
   \   0000025C   0x4420             ADD      R0,R4,R0
   \   0000025E   0x8645             STRH     R5,[R0, #+50]
    653          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_accel] = delayInMs;
   \   00000260   0xF44F 0x70A3      MOV      R0,#+326
   \   00000264   0x4420             ADD      R0,R4,R0
   \   00000266   0x8085             STRH     R5,[R0, #+4]
    654          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_cpass] = delayInMs;
   \   00000268   0x8105             STRH     R5,[R0, #+8]
    655          			break;
   \   0000026A   0xE01C             B.N      ??inv_icm20948_set_odr_5
    656          
    657          		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED:
    658          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_COMPASS] = delayInMs;
   \                     ??inv_icm20948_set_odr_40: (+1)
   \   0000026C   0xF44F 0x7083      MOV      R0,#+262
   \   00000270   0x4420             ADD      R0,R4,R0
   \   00000272   0x8585             STRH     R5,[R0, #+44]
    659          			break;
   \   00000274   0xE017             B.N      ??inv_icm20948_set_odr_5
    660          
    661          		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD:
    662          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_CALIB_COMPASS] = delayInMs;
   \                     ??inv_icm20948_set_odr_41: (+1)
   \   00000276   0xF44F 0x7083      MOV      R0,#+262
   \   0000027A   0x4420             ADD      R0,R4,R0
   \   0000027C   0x8785             STRH     R5,[R0, #+60]
    663          			break;
   \   0000027E   0xE012             B.N      ??inv_icm20948_set_odr_5
    664          
    665          		case ANDROID_SENSOR_WAKEUP_LIGHT:
    666          		case ANDROID_SENSOR_WAKEUP_PROXIMITY:
    667          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_ALS] = delayInMs;
   \                     ??inv_icm20948_set_odr_42: (+1)
   \   00000280   0xF44F 0x7083      MOV      R0,#+262
   \   00000284   0x4420             ADD      R0,R4,R0
   \   00000286   0x85C5             STRH     R5,[R0, #+46]
    668          			break;
   \   00000288   0xE00D             B.N      ??inv_icm20948_set_odr_5
    669          
    670          		case ANDROID_SENSOR_PRESSURE:
    671          			s->inv_dmp_odr_delays[INV_SENSOR_PRESSURE] = delayInMs;
   \                     ??inv_icm20948_set_odr_43: (+1)
   \   0000028A   0xF44F 0x7083      MOV      R0,#+262
   \   0000028E   0x4420             ADD      R0,R4,R0
   \   00000290   0x8245             STRH     R5,[R0, #+18]
    672          			break;
   \   00000292   0xE008             B.N      ??inv_icm20948_set_odr_5
    673          
    674          		case ANDROID_SENSOR_WAKEUP_PRESSURE:
    675          			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_PRESSURE] = delayInMs;
   \                     ??inv_icm20948_set_odr_44: (+1)
   \   00000294   0xF44F 0x7083      MOV      R0,#+262
   \   00000298   0x4420             ADD      R0,R4,R0
   \   0000029A   0x8705             STRH     R5,[R0, #+56]
    676          			break;
   \   0000029C   0xE003             B.N      ??inv_icm20948_set_odr_5
    677          
    678          		case ANDROID_SENSOR_FLIP_PICKUP:
    679          			s->inv_dmp_odr_delays[INV_SENSOR_FLIP_PICKUP] = delayInMs;
   \                     ??inv_icm20948_set_odr_45: (+1)
   \   0000029E   0xF44F 0x7083      MOV      R0,#+262
   \   000002A2   0x4420             ADD      R0,R4,R0
   \   000002A4   0x8385             STRH     R5,[R0, #+28]
    680          			break;
    681          
    682          		// not support yet
    683          		case ANDROID_SENSOR_META_DATA:
    684          		case ANDROID_SENSOR_TEMPERATURE:
    685          		case ANDROID_SENSOR_AMBIENT_TEMPERATURE:
    686          		case ANDROID_SENSOR_HUMIDITY:
    687          		case ANDROID_SENSOR_HEART_RATE:
    688          		case ANDROID_SENSOR_SCREEN_ROTATION:
    689          		case ANDROID_SENSOR_WAKEUP_AMBIENT_TEMPERATURE:
    690          		case ANDROID_SENSOR_WAKEUP_RELATIVE_HUMIDITY:
    691          		case ANDROID_SENSOR_WAKEUP_HEART_RATE:
    692          			break;
    693          
    694          		default:
    695          			break;
    696          	}
    697          
    698          	result = inv_set_hw_smplrt_dmp_odrs(s);
   \                     ??inv_icm20948_set_odr_5: (+1)
   \   000002A6   0x4620             MOV      R0,R4
   \   000002A8   0x.... 0x....      BL       inv_set_hw_smplrt_dmp_odrs
   \   000002AC   0x4605             MOV      R5,R0
    699          	result |= inv_icm20948_set_gyro_sf(s, inv_icm20948_get_gyro_divider(s), inv_icm20948_get_gyro_fullscale(s));
   \   000002AE   0x4620             MOV      R0,R4
   \   000002B0   0x.... 0x....      BL       inv_icm20948_get_gyro_fullscale
   \   000002B4   0x4606             MOV      R6,R0
   \   000002B6   0x4620             MOV      R0,R4
   \   000002B8   0x.... 0x....      BL       inv_icm20948_get_gyro_divider
   \   000002BC   0x4632             MOV      R2,R6
   \   000002BE   0x4601             MOV      R1,R0
   \   000002C0   0x4620             MOV      R0,R4
   \   000002C2   0x.... 0x....      BL       inv_icm20948_set_gyro_sf
   \   000002C6   0x4305             ORRS     R5,R0,R5
    700          
    701          	// debug get odr
    702          	// result should be SAME as you entered in Ms in the Rolldice console
    703          	// i.e. If you use: O a 63 [ Press capital O then 'a' then 63 then ENTER]
    704          	// You should get the nearest number to 63 here if you debug  the 'test_odr'  
    705          
    706          	//inv_icm20948_ctrl_get_odr( androidSensor, &test_odr );
    707          
    708          	inv_icm20948_allow_lpen_control(s);
   \   000002C8   0x4620             MOV      R0,R4
   \   000002CA   0x.... 0x....      BL       inv_icm20948_allow_lpen_control
    709          	return result;
   \   000002CE   0x4628             MOV      R0,R5
   \   000002D0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    710          }
    711          
    712          /*
    713             inv_icm20948_ctrl_get_odr(s)
    714             Function to Query DMP3 DataRate (ODR)
    715             
    716             *odr = inv_icm20948_get_odr_in_units( );
    717          
    718              The result in odr_units saved in *odr param
    719          */

   \                                 In section .text, align 4, keep-with-next
    720          int inv_icm20948_ctrl_get_odr(struct inv_icm20948 * s, unsigned char SensorId, uint32_t *odr, enum INV_ODR_TYPE odr_units)
    721          {
   \                     inv_icm20948_ctrl_get_odr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0014             MOVS     R4,R2
    722          	int result=0;
    723          
    724          	if(!odr) // sanity
   \   00000004   0xD102             BNE.N    ??inv_icm20948_ctrl_get_odr_1
    725          		return -1;
   \   00000006   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000A   0xBD10             POP      {R4,PC}
    726          
    727          	*odr = 0;
   \                     ??inv_icm20948_ctrl_get_odr_1: (+1)
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x6022             STR      R2,[R4, #+0]
    728          
    729          	/*
    730          	You can obtain the odr in Milliseconds, Micro Seconds or Ticks.
    731          	Use the enum values: ODR_IN_Ms, ODR_IN_Us or ODR_IN_Ticks,
    732          	when calling inv_icm20948_get_odr_in_units().
    733          	*/
    734          
    735          	switch (SensorId) {
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x292E             CMP      R1,#+46
   \   00000014   0xF200 0x8122      BHI.W    ??inv_icm20948_ctrl_get_odr_2
   \   00000018   0xE8DF 0xF011      TBH      [PC, R1, LSL #+1]
   \                     ??inv_icm20948_ctrl_get_odr_0:
   \   0000001C   0x002F 0x007F      DC16     0x2F,0x7F,0x6D,0x5B
   \              0x006D 0x005B
   \   00000024   0x0088 0x0105      DC16     0x88,0x105,0x120,0xFC
   \              0x0120 0x00FC
   \   0000002C   0x0064 0x0064      DC16     0x64,0x64,0x6D,0x120
   \              0x006D 0x0120
   \   00000034   0x0120 0x0076      DC16     0x120,0x76,0x64,0x52
   \              0x0064 0x0052
   \   0000003C   0x009A 0x0037      DC16     0x9A,0x37,0x37,0x40
   \              0x0037 0x0040
   \   00000044   0x0120 0x0088      DC16     0x120,0x88,0x91,0xF3
   \              0x0091 0x00F3
   \   0000004C   0x00E1 0x00C6      DC16     0xE1,0xC6,0xFC,0x10E
   \              0x00FC 0x010E
   \   00000054   0x00D8 0x00D8      DC16     0xD8,0xD8,0xE1,0x120
   \              0x00E1 0x0120
   \   0000005C   0x0120 0x00EA      DC16     0x120,0xEA,0xCF,0xBD
   \              0x00CF 0x00BD
   \   00000064   0x009A 0x009A      DC16     0x9A,0x9A,0xA3,0x120
   \              0x00A3 0x0120
   \   0000006C   0x00AC 0x002F      DC16     0xAC,0x2F,0x52,0x120
   \              0x0052 0x0120
   \   00000074   0x00B4 0x0117      DC16     0xB4,0x117,0x49
   \              0x0049       
    736          		case ANDROID_SENSOR_ACCELEROMETER:
    737          		case ANDROID_SENSOR_RAW_ACCELEROMETER:
    738          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_ACCEL] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_3: (+1)
   \   0000007A   0x461A             MOV      R2,R3
   \   0000007C   0xB2D2             UXTB     R2,R2
   \   0000007E   0xF8B0 0x10BC      LDRH     R1,[R0, #+188]
   \   00000082   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000086   0x6020             STR      R0,[R4, #+0]
    739          			break;
   \   00000088   0xE0EA             B.N      ??inv_icm20948_ctrl_get_odr_4
    740          
    741          		case ANDROID_SENSOR_STEP_DETECTOR:
    742          		case ANDROID_SENSOR_STEP_COUNTER:
    743          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_STEP_COUNTER] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_5: (+1)
   \   0000008A   0x461A             MOV      R2,R3
   \   0000008C   0xB2D2             UXTB     R2,R2
   \   0000008E   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000092   0x8B09             LDRH     R1,[R1, #+24]
   \   00000094   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000098   0x6020             STR      R0,[R4, #+0]
    744          			break;
   \   0000009A   0xE0E1             B.N      ??inv_icm20948_ctrl_get_odr_4
    745          
    746          		case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:
    747          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_GEOMAG] , odr_units );            
   \                     ??inv_icm20948_ctrl_get_odr_6: (+1)
   \   0000009C   0x461A             MOV      R2,R3
   \   0000009E   0xB2D2             UXTB     R2,R2
   \   000000A0   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000000A4   0x89C9             LDRH     R1,[R1, #+14]
   \   000000A6   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000000AA   0x6020             STR      R0,[R4, #+0]
    748          			break;
   \   000000AC   0xE0D8             B.N      ??inv_icm20948_ctrl_get_odr_4
    749          
    750          		case ANDROID_SENSOR_ACTIVITY_CLASSIFICATON:
    751          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_ACTIVITY_CLASSIFIER] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_7: (+1)
   \   000000AE   0x461A             MOV      R2,R3
   \   000000B0   0xB2D2             UXTB     R2,R2
   \   000000B2   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000000B6   0x8B49             LDRH     R1,[R1, #+26]
   \   000000B8   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000000BC   0x6020             STR      R0,[R4, #+0]
    752          			break;
   \   000000BE   0xE0CF             B.N      ??inv_icm20948_ctrl_get_odr_4
    753          
    754          		case ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED:
    755          		case ANDROID_SENSOR_RAW_GYROSCOPE:
    756          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_GYRO] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_8: (+1)
   \   000000C0   0x461A             MOV      R2,R3
   \   000000C2   0xB2D2             UXTB     R2,R2
   \   000000C4   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000000C8   0x8849             LDRH     R1,[R1, #+2]
   \   000000CA   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000000CE   0x6020             STR      R0,[R4, #+0]
    757          			break;
   \   000000D0   0xE0C6             B.N      ??inv_icm20948_ctrl_get_odr_4
    758          
    759          		case ANDROID_SENSOR_GYROSCOPE:
    760          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_CALIB_GYRO] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_9: (+1)
   \   000000D2   0x461A             MOV      R2,R3
   \   000000D4   0xB2D2             UXTB     R2,R2
   \   000000D6   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000000DA   0x8A89             LDRH     R1,[R1, #+20]
   \   000000DC   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000000E0   0x6020             STR      R0,[R4, #+0]
    761          			break;
   \   000000E2   0xE0BD             B.N      ??inv_icm20948_ctrl_get_odr_4
    762          
    763          		case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
    764          		case ANDROID_SENSOR_GRAVITY:
    765          		case ANDROID_SENSOR_LINEAR_ACCELERATION:
    766          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_SIXQ] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_10: (+1)
   \   000000E4   0x461A             MOV      R2,R3
   \   000000E6   0xB2D2             UXTB     R2,R2
   \   000000E8   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000000EC   0x8949             LDRH     R1,[R1, #+10]
   \   000000EE   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000000F2   0x6020             STR      R0,[R4, #+0]
    767          			break;
   \   000000F4   0xE0B4             B.N      ??inv_icm20948_ctrl_get_odr_4
    768          
    769          		case ANDROID_SENSOR_ORIENTATION:
    770          		case ANDROID_SENSOR_ROTATION_VECTOR:
    771          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_NINEQ] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_11: (+1)
   \   000000F6   0x461A             MOV      R2,R3
   \   000000F8   0xB2D2             UXTB     R2,R2
   \   000000FA   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000000FE   0x8989             LDRH     R1,[R1, #+12]
   \   00000100   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000104   0x6020             STR      R0,[R4, #+0]
    772          			break;
   \   00000106   0xE0AB             B.N      ??inv_icm20948_ctrl_get_odr_4
    773          
    774          		case ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:
    775          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_COMPASS] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_12: (+1)
   \   00000108   0x461A             MOV      R2,R3
   \   0000010A   0xB2D2             UXTB     R2,R2
   \   0000010C   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000110   0x88C9             LDRH     R1,[R1, #+6]
   \   00000112   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000116   0x6020             STR      R0,[R4, #+0]
    776          			break;
   \   00000118   0xE0A2             B.N      ??inv_icm20948_ctrl_get_odr_4
    777          
    778          		case ANDROID_SENSOR_GEOMAGNETIC_FIELD:
    779          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_CALIB_COMPASS] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_13: (+1)
   \   0000011A   0x461A             MOV      R2,R3
   \   0000011C   0xB2D2             UXTB     R2,R2
   \   0000011E   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000122   0x8AC9             LDRH     R1,[R1, #+22]
   \   00000124   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000128   0x6020             STR      R0,[R4, #+0]
    780          			break;
   \   0000012A   0xE099             B.N      ??inv_icm20948_ctrl_get_odr_4
    781          
    782          		case ANDROID_SENSOR_LIGHT:
    783          		case ANDROID_SENSOR_PROXIMITY:
    784          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_ALS] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_14: (+1)
   \   0000012C   0x461A             MOV      R2,R3
   \   0000012E   0xB2D2             UXTB     R2,R2
   \   00000130   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000134   0x8909             LDRH     R1,[R1, #+8]
   \   00000136   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   0000013A   0x6020             STR      R0,[R4, #+0]
    785          			break;
   \   0000013C   0xE090             B.N      ??inv_icm20948_ctrl_get_odr_4
    786          
    787          		case ANDROID_SENSOR_WAKEUP_ACCELEROMETER:
    788          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_ACCEL] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_15: (+1)
   \   0000013E   0x461A             MOV      R2,R3
   \   00000140   0xB2D2             UXTB     R2,R2
   \   00000142   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000146   0x8D09             LDRH     R1,[R1, #+40]
   \   00000148   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   0000014C   0x6020             STR      R0,[R4, #+0]
    789          			break;
   \   0000014E   0xE087             B.N      ??inv_icm20948_ctrl_get_odr_4
    790          
    791          		case ANDROID_SENSOR_WAKEUP_STEP_DETECTOR:
    792          		case ANDROID_SENSOR_WAKEUP_STEP_COUNTER:
    793          		case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:
    794          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_STEP_COUNTER] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_16: (+1)
   \   00000150   0x461A             MOV      R2,R3
   \   00000152   0xB2D2             UXTB     R2,R2
   \   00000154   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000158   0x8FC9             LDRH     R1,[R1, #+62]
   \   0000015A   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   0000015E   0x6020             STR      R0,[R4, #+0]
    795          			break;
   \   00000160   0xE07E             B.N      ??inv_icm20948_ctrl_get_odr_4
    796          
    797          		case ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR:
    798          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_GEOMAG] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_17: (+1)
   \   00000162   0x461A             MOV      R2,R3
   \   00000164   0xB2D2             UXTB     R2,R2
   \   00000166   0xF100 0x01BC      ADD      R1,R0,#+188
   \   0000016A   0x8E89             LDRH     R1,[R1, #+52]
   \   0000016C   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000170   0x6020             STR      R0,[R4, #+0]
    799          			break;
   \   00000172   0xE075             B.N      ??inv_icm20948_ctrl_get_odr_4
    800          
    801          		case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:
    802          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_TILT_DETECTOR] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_18: (+1)
   \   00000174   0x461A             MOV      R2,R3
   \   00000176   0xB2D2             UXTB     R2,R2
   \   00000178   0xF8B0 0x10FC      LDRH     R1,[R0, #+252]
   \   0000017C   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000180   0x6020             STR      R0,[R4, #+0]
    803          			break;
   \   00000182   0xE06D             B.N      ??inv_icm20948_ctrl_get_odr_4
    804          
    805          		case ANDROID_SENSOR_B2S:
    806          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_BRING_TO_SEE] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_19: (+1)
   \   00000184   0x461A             MOV      R2,R3
   \   00000186   0xB2D2             UXTB     R2,R2
   \   00000188   0xF100 0x01BC      ADD      R1,R0,#+188
   \   0000018C   0x8BC9             LDRH     R1,[R1, #+30]
   \   0000018E   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000192   0x6020             STR      R0,[R4, #+0]
    807          			break;
   \   00000194   0xE064             B.N      ??inv_icm20948_ctrl_get_odr_4
    808          
    809          		case ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED:
    810          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_GYRO] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_20: (+1)
   \   00000196   0x461A             MOV      R2,R3
   \   00000198   0xB2D2             UXTB     R2,R2
   \   0000019A   0xF100 0x01BC      ADD      R1,R0,#+188
   \   0000019E   0x8D49             LDRH     R1,[R1, #+42]
   \   000001A0   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000001A4   0x6020             STR      R0,[R4, #+0]
    811          			break;
   \   000001A6   0xE05B             B.N      ??inv_icm20948_ctrl_get_odr_4
    812          
    813          		case ANDROID_SENSOR_WAKEUP_GYROSCOPE:
    814          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_CALIB_GYRO] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_21: (+1)
   \   000001A8   0x461A             MOV      R2,R3
   \   000001AA   0xB2D2             UXTB     R2,R2
   \   000001AC   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000001B0   0x8F49             LDRH     R1,[R1, #+58]
   \   000001B2   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000001B6   0x6020             STR      R0,[R4, #+0]
    815          			break;
   \   000001B8   0xE052             B.N      ??inv_icm20948_ctrl_get_odr_4
    816          
    817          		case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
    818          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_SIXQ] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_22: (+1)
   \   000001BA   0x461A             MOV      R2,R3
   \   000001BC   0xB2D2             UXTB     R2,R2
   \   000001BE   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000001C2   0x8E09             LDRH     R1,[R1, #+48]
   \   000001C4   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000001C8   0x6020             STR      R0,[R4, #+0]
    819          			break;
   \   000001CA   0xE049             B.N      ??inv_icm20948_ctrl_get_odr_4
    820          
    821          		case ANDROID_SENSOR_WAKEUP_GRAVITY:
    822          		case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
    823          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_SIXQ_accel] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_23: (+1)
   \   000001CC   0x461A             MOV      R2,R3
   \   000001CE   0xB2D2             UXTB     R2,R2
   \   000001D0   0xF100 0x01FC      ADD      R1,R0,#+252
   \   000001D4   0x8849             LDRH     R1,[R1, #+2]
   \   000001D6   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000001DA   0x6020             STR      R0,[R4, #+0]
    824          			break;
   \   000001DC   0xE040             B.N      ??inv_icm20948_ctrl_get_odr_4
    825          
    826          		case ANDROID_SENSOR_WAKEUP_ORIENTATION:
    827          		case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
    828          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_NINEQ] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_24: (+1)
   \   000001DE   0x461A             MOV      R2,R3
   \   000001E0   0xB2D2             UXTB     R2,R2
   \   000001E2   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000001E6   0x8E49             LDRH     R1,[R1, #+50]
   \   000001E8   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000001EC   0x6020             STR      R0,[R4, #+0]
    829          			break;
   \   000001EE   0xE037             B.N      ??inv_icm20948_ctrl_get_odr_4
    830          
    831          		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED:
    832          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_COMPASS] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_25: (+1)
   \   000001F0   0x461A             MOV      R2,R3
   \   000001F2   0xB2D2             UXTB     R2,R2
   \   000001F4   0xF100 0x01BC      ADD      R1,R0,#+188
   \   000001F8   0x8D89             LDRH     R1,[R1, #+44]
   \   000001FA   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   000001FE   0x6020             STR      R0,[R4, #+0]
    833          			break;
   \   00000200   0xE02E             B.N      ??inv_icm20948_ctrl_get_odr_4
    834          
    835          		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD:
    836          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_CALIB_COMPASS] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_26: (+1)
   \   00000202   0x461A             MOV      R2,R3
   \   00000204   0xB2D2             UXTB     R2,R2
   \   00000206   0xF100 0x01BC      ADD      R1,R0,#+188
   \   0000020A   0x8F89             LDRH     R1,[R1, #+60]
   \   0000020C   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000210   0x6020             STR      R0,[R4, #+0]
    837          			break;
   \   00000212   0xE025             B.N      ??inv_icm20948_ctrl_get_odr_4
    838          
    839          		case ANDROID_SENSOR_WAKEUP_LIGHT:
    840          		case ANDROID_SENSOR_WAKEUP_PROXIMITY:
    841          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_ALS] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_27: (+1)
   \   00000214   0x461A             MOV      R2,R3
   \   00000216   0xB2D2             UXTB     R2,R2
   \   00000218   0xF100 0x01BC      ADD      R1,R0,#+188
   \   0000021C   0x8DC9             LDRH     R1,[R1, #+46]
   \   0000021E   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000222   0x6020             STR      R0,[R4, #+0]
    842          			break;
   \   00000224   0xE01C             B.N      ??inv_icm20948_ctrl_get_odr_4
    843          
    844          		case ANDROID_SENSOR_PRESSURE:
    845          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_PRESSURE] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_28: (+1)
   \   00000226   0x461A             MOV      R2,R3
   \   00000228   0xB2D2             UXTB     R2,R2
   \   0000022A   0xF100 0x01BC      ADD      R1,R0,#+188
   \   0000022E   0x8A49             LDRH     R1,[R1, #+18]
   \   00000230   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000234   0x6020             STR      R0,[R4, #+0]
    846          			break;
   \   00000236   0xE013             B.N      ??inv_icm20948_ctrl_get_odr_4
    847          
    848          		case ANDROID_SENSOR_WAKEUP_PRESSURE:
    849          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_WAKEUP_PRESSURE] , odr_units );
   \                     ??inv_icm20948_ctrl_get_odr_29: (+1)
   \   00000238   0x461A             MOV      R2,R3
   \   0000023A   0xB2D2             UXTB     R2,R2
   \   0000023C   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000240   0x8F09             LDRH     R1,[R1, #+56]
   \   00000242   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000246   0x6020             STR      R0,[R4, #+0]
    850          			break;
   \   00000248   0xE00A             B.N      ??inv_icm20948_ctrl_get_odr_4
    851          
    852          		case ANDROID_SENSOR_FLIP_PICKUP:
    853          			*odr = inv_icm20948_get_odr_in_units(s, s->inv_dmp_odr_dividers[INV_SENSOR_FLIP_PICKUP] , odr_units ); 
   \                     ??inv_icm20948_ctrl_get_odr_30: (+1)
   \   0000024A   0x461A             MOV      R2,R3
   \   0000024C   0xB2D2             UXTB     R2,R2
   \   0000024E   0xF100 0x01BC      ADD      R1,R0,#+188
   \   00000252   0x8B89             LDRH     R1,[R1, #+28]
   \   00000254   0x.... 0x....      BL       inv_icm20948_get_odr_in_units
   \   00000258   0x6020             STR      R0,[R4, #+0]
    854          			break;
   \   0000025A   0xE001             B.N      ??inv_icm20948_ctrl_get_odr_4
    855          
    856          		// not support yet
    857          		case ANDROID_SENSOR_META_DATA:
    858          		case ANDROID_SENSOR_TEMPERATURE:
    859          		case ANDROID_SENSOR_AMBIENT_TEMPERATURE:
    860          		case ANDROID_SENSOR_HUMIDITY:
    861          		case ANDROID_SENSOR_HEART_RATE:
    862          		case ANDROID_SENSOR_SCREEN_ROTATION:
    863          		case ANDROID_SENSOR_WAKEUP_AMBIENT_TEMPERATURE:
    864          		case ANDROID_SENSOR_WAKEUP_RELATIVE_HUMIDITY:
    865          		case ANDROID_SENSOR_WAKEUP_HEART_RATE:
    866          			*odr=0;
    867          			break;
    868          
    869          		default:
    870          			*odr=0;
   \                     ??inv_icm20948_ctrl_get_odr_2: (+1)
   \   0000025C   0x4610             MOV      R0,R2
   \   0000025E   0x6020             STR      R0,[R4, #+0]
    871          	}
    872          
    873          	return result;
   \                     ??inv_icm20948_ctrl_get_odr_4: (+1)
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xBD10             POP      {R4,PC}          ;; return
    874          }
    875          

   \                                 In section .text, align 2, keep-with-next
    876          static void inv_reGenerate_sensorControl(struct inv_icm20948 * s, const short *sen_num_2_ctrl, unsigned short *sensor_control, uint8_t header2_count)
    877          {
   \                     inv_reGenerate_sensorControl: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    878          	short delta;
    879          	int i, cntr;
    880          	unsigned long tmp_androidSensorsOn_mask;
    881          
    882          	//check if only header2 still remaining
    883          	if(header2_count)
   \   00000002   0x2B00             CMP      R3,#+0
   \   00000004   0xD002             BEQ.N    ??inv_reGenerate_sensorControl_0
    884          		*sensor_control = HEADER2_SET;
   \   00000006   0x2308             MOVS     R3,#+8
   \   00000008   0x8013             STRH     R3,[R2, #+0]
   \   0000000A   0xE001             B.N      ??inv_reGenerate_sensorControl_1
    885          	else
    886          		*sensor_control = 0;
   \                     ??inv_reGenerate_sensorControl_0: (+1)
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x8013             STRH     R3,[R2, #+0]
    887          	for (i = 0; i < 2; i++) {
   \                     ??inv_reGenerate_sensorControl_1: (+1)
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0xE00E             B.N      ??inv_reGenerate_sensorControl_2
    888          		cntr = 32 * i;
    889          		tmp_androidSensorsOn_mask = s->inv_androidSensorsOn_mask[i];
    890          		while (tmp_androidSensorsOn_mask) {
    891          			if (tmp_androidSensorsOn_mask & 1) {
   \                     ??inv_reGenerate_sensorControl_3: (+1)
   \   00000014   0x07E5             LSLS     R5,R4,#+31
   \   00000016   0xD507             BPL.N    ??inv_reGenerate_sensorControl_4
    892          				delta = sen_num_2_ctrl[cntr];
   \   00000018   0xF931 0x5016      LDRSH    R5,[R1, R6, LSL #+1]
    893          				if (delta != -1) *sensor_control |= delta;
   \   0000001C   0xF115 0x0F01      CMN      R5,#+1
   \   00000020   0xD002             BEQ.N    ??inv_reGenerate_sensorControl_4
   \   00000022   0x8817             LDRH     R7,[R2, #+0]
   \   00000024   0x433D             ORRS     R5,R5,R7
   \   00000026   0x8015             STRH     R5,[R2, #+0]
    894          			}
    895          			tmp_androidSensorsOn_mask >>= 1;
   \                     ??inv_reGenerate_sensorControl_4: (+1)
   \   00000028   0x0864             LSRS     R4,R4,#+1
    896          			cntr++;
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
    897          		}
   \                     ??inv_reGenerate_sensorControl_5: (+1)
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD1F1             BNE.N    ??inv_reGenerate_sensorControl_3
   \   00000030   0x1C5B             ADDS     R3,R3,#+1
   \                     ??inv_reGenerate_sensorControl_2: (+1)
   \   00000032   0x2B02             CMP      R3,#+2
   \   00000034   0xDA05             BGE.N    ??inv_reGenerate_sensorControl_6
   \   00000036   0x015E             LSLS     R6,R3,#+5
   \   00000038   0xEB00 0x0483      ADD      R4,R0,R3, LSL #+2
   \   0000003C   0xF8D4 0x4160      LDR      R4,[R4, #+352]
   \   00000040   0xE7F4             B.N      ??inv_reGenerate_sensorControl_5
    898          	}
    899          }
   \                     ??inv_reGenerate_sensorControl_6: (+1)
   \   00000042   0xBCF0             POP      {R4-R7}
   \   00000044   0x4770             BX       LR               ;; return
    900          
    901          /** Computes the sensor control register that needs to be sent to the DMP
    902          * @param[in] androidSensor A sensor number, the numbers correspond to sensors.h definition in Android
    903          * @param[in] enable non-zero to turn sensor on, 0 to turn sensor off
    904          * @param[in] sen_num_2_ctrl Table matching android sensor number to bits in DMP control register
    905          * @param[in,out] sensor_control Sensor control register to write to DMP to enable/disable sensors
    906          */

   \                                 In section .text, align 2, keep-with-next
    907          static void inv_convert_androidSensor_to_control(struct inv_icm20948 * s, unsigned char androidSensor, unsigned char enable, const short *sen_num_2_ctrl, unsigned short *sensor_control)
    908          {
   \                     inv_convert_androidSensor_to_control: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    909          	short delta = 0;
    910          
    911          	if (androidSensor == ANDROID_SENSOR_ACTIVITY_CLASSIFICATON || androidSensor == ANDROID_SENSOR_FLIP_PICKUP || 
    912          			androidSensor == ANDROID_SENSOR_WAKEUP_TILT_DETECTOR || androidSensor == ANDROID_SENSOR_B2S) {
   \   0000000C   0x46A9             MOV      R9,R5
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \   00000012   0xF1B9 0x0F2F      CMP      R9,#+47
   \   00000016   0xD008             BEQ.N    ??inv_convert_androidSensor_to_control_0
   \   00000018   0xF1B9 0x0F2E      CMP      R9,#+46
   \   0000001C   0xD005             BEQ.N    ??inv_convert_androidSensor_to_control_0
   \   0000001E   0xF1B9 0x0F29      CMP      R9,#+41
   \   00000022   0xD002             BEQ.N    ??inv_convert_androidSensor_to_control_0
   \   00000024   0xF1B9 0x0F2D      CMP      R9,#+45
   \   00000028   0xD118             BNE.N    ??inv_convert_androidSensor_to_control_1
    913          		if (enable) {
   \                     ??inv_convert_androidSensor_to_control_0: (+1)
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0xD00B             BEQ.N    ??inv_convert_androidSensor_to_control_2
    914          			*sensor_control |= HEADER2_SET;
   \   0000002E   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000032   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000036   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    915          			//we increment counter
    916          			s->header2_count ++;
   \   0000003A   0xF894 0x023B      LDRB     R0,[R4, #+571]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xF884 0x023B      STRB     R0,[R4, #+571]
   \   00000044   0xE00A             B.N      ??inv_convert_androidSensor_to_control_1
    917          		}
    918          		else {
    919          			s->header2_count --;
   \                     ??inv_convert_androidSensor_to_control_2: (+1)
   \   00000046   0xF894 0x023B      LDRB     R0,[R4, #+571]
   \   0000004A   0x1E43             SUBS     R3,R0,#+1
   \   0000004C   0xF884 0x323B      STRB     R3,[R4, #+571]
    920          			// control has to be regenerated when removing sensors because of overlap
    921          			inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
   \   00000050   0xB2DB             UXTB     R3,R3
   \   00000052   0x4642             MOV      R2,R8
   \   00000054   0x4639             MOV      R1,R7
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       inv_reGenerate_sensorControl
    922          		}
    923          	}
    924          
    925          	if (androidSensor >= ANDROID_SENSOR_NUM_MAX)
   \                     ??inv_convert_androidSensor_to_control_1: (+1)
   \   0000005C   0xF1B9 0x0F2C      CMP      R9,#+44
   \   00000060   0xDA26             BGE.N    ??inv_convert_androidSensor_to_control_3
    926          		return; // Sensor not supported
    927          
    928          	delta = sen_num_2_ctrl[androidSensor];
   \   00000062   0xF937 0x0019      LDRSH    R0,[R7, R9, LSL #+1]
    929          	if (delta == -1)
   \   00000066   0xF110 0x0F01      CMN      R0,#+1
   \   0000006A   0xD021             BEQ.N    ??inv_convert_androidSensor_to_control_3
    930          		return; // This sensor not supported
   \   0000006C   0xEA4F 0x1169      ASR      R1,R9,#+5
   \   00000070   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \   00000074   0xF8D1 0x2160      LDR      R2,[R1, #+352]
   \   00000078   0x2301             MOVS     R3,#+1
   \   0000007A   0xF005 0x051F      AND      R5,R5,#0x1F
   \   0000007E   0x40AB             LSLS     R3,R3,R5
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD008             BEQ.N    ??inv_convert_androidSensor_to_control_4
    931          
    932          	if (enable) {
    933          		s->inv_androidSensorsOn_mask[(androidSensor>>5)] |= 1L << (androidSensor & 0x1F); // Set bit
   \   00000084   0x431A             ORRS     R2,R3,R2
   \   00000086   0xF8C1 0x2160      STR      R2,[R1, #+352]
    934          		*sensor_control |= delta;
   \   0000008A   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   0000008E   0x4308             ORRS     R0,R0,R1
   \   00000090   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000094   0xE00C             B.N      ??inv_convert_androidSensor_to_control_3
    935          	}
    936          	else {
    937          		s->inv_androidSensorsOn_mask[(androidSensor>>5)] &= ~(1L << (androidSensor & 0x1F)); // Clear bit
   \                     ??inv_convert_androidSensor_to_control_4: (+1)
   \   00000096   0xEA22 0x0003      BIC      R0,R2,R3
   \   0000009A   0xF8C1 0x0160      STR      R0,[R1, #+352]
    938          		// control has to be regenerated when removing sensors because of overlap
    939          		inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
   \   0000009E   0xF894 0x323B      LDRB     R3,[R4, #+571]
   \   000000A2   0x4642             MOV      R2,R8
   \   000000A4   0x4639             MOV      R1,R7
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0xB001             ADD      SP,SP,#+4
   \   000000AA   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   000000AE   0x....             B.N      inv_reGenerate_sensorControl
    940          	}
    941          
    942          	return;
   \                     ??inv_convert_androidSensor_to_control_3: (+1)
   \   000000B0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    943          }
    944          

   \                                 In section .text, align 2, keep-with-next
    945          int inv_icm20948_ctrl_enable_sensor(struct inv_icm20948 * s, unsigned char androidSensor, unsigned char enable)
    946          {
   \                     inv_icm20948_ctrl_enable_sensor: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    947          	int result = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    948          
    949          	if(sensor_needs_compass(androidSensor))
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       sensor_needs_compass
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD007             BEQ.N    ??inv_icm20948_ctrl_enable_sensor_0
    950          		if(!inv_icm20948_get_compass_availability(s))
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       inv_icm20948_get_compass_availability
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD102             BNE.N    ??inv_icm20948_ctrl_enable_sensor_0
    951          			return -1;
   \   0000001E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}
    952          
    953          	inv_icm20948_prevent_lpen_control(s);
   \                     ??inv_icm20948_ctrl_enable_sensor_0: (+1)
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       inv_icm20948_prevent_lpen_control
    954          	if( s->mems_put_to_sleep ) {
   \   0000002A   0xF994 0x023C      LDRSB    R0,[R4, #+572]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD006             BEQ.N    ??inv_icm20948_ctrl_enable_sensor_1
    955          		s->mems_put_to_sleep = 0;
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0xF884 0x023C      STRB     R0,[R4, #+572]
    956          		result |= inv_icm20948_wakeup_mems(s);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       inv_icm20948_wakeup_mems
   \   0000003E   0x4607             MOV      R7,R0
    957          	}
    958          	result |= inv_enable_sensor_internal(s, androidSensor, enable, &s->mems_put_to_sleep);
   \                     ??inv_icm20948_ctrl_enable_sensor_1: (+1)
   \   00000040   0xF44F 0x700F      MOV      R0,#+572
   \   00000044   0x1823             ADDS     R3,R4,R0
   \   00000046   0x4632             MOV      R2,R6
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       inv_enable_sensor_internal
   \   00000050   0x4307             ORRS     R7,R0,R7
    959          	inv_icm20948_allow_lpen_control(s);
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       inv_icm20948_allow_lpen_control
    960          	return result;
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    961          }
    962          

   \                                 In section .text, align 2, keep-with-next
    963          static int inv_enable_sensor_internal(struct inv_icm20948 * s, unsigned char androidSensor, unsigned char enable, char * mems_put_to_sleep)
    964          {
   \                     inv_enable_sensor_internal: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xB09A             SUB      SP,SP,#+104
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x468B             MOV      R11,R1
   \   0000000A   0x4615             MOV      R5,R2
    965          	int result = 0;
    966          	unsigned short inv_event_control = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
    967          	unsigned short data_rdy_status = 0;
   \   0000000E   0x4637             MOV      R7,R6
    968          	unsigned long steps=0;
   \   00000010   0x4630             MOV      R0,R6
   \   00000012   0x9002             STR      R0,[SP, #+8]
    969          	const short inv_androidSensor_to_control_bits[ANDROID_SENSOR_NUM_MAX]=
    970          	{
    971          		// Unsupported Sensors are -1
    972          		-1, // Meta Data
    973          		-32760, //0x8008, // Accelerometer
    974          		0x0028, // Magnetic Field
    975          		0x0408, // Orientation
    976          		0x4048, // Gyroscope
    977          		0x1008, // Light
    978          		0x0088, // Pressure
    979          		-1, // Temperature
    980          		-1, // Proximity <----------- fixme
    981          		0x0808, // Gravity
    982          		-30712, // 0x8808, // Linear Acceleration
    983          		0x0408, // Rotation Vector
    984          		-1, // Humidity
    985          		-1, // Ambient Temperature
    986          		0x2008, // Magnetic Field Uncalibrated
    987          		0x0808, // Game Rotation Vector
    988          		0x4008, // Gyroscope Uncalibrated
    989          		0, // Significant Motion
    990          		0x0018, // Step Detector
    991          		0x0010, // Step Counter <----------- fixme
    992          		0x0108, // Geomagnetic Rotation Vector
    993          		-1, //ANDROID_SENSOR_HEART_RATE,
    994          		-1, //ANDROID_SENSOR_PROXIMITY,
    995          
    996          		-32760, // ANDROID_SENSOR_WAKEUP_ACCELEROMETER,
    997          		0x0028, // ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD,
    998          		0x0408, // ANDROID_SENSOR_WAKEUP_ORIENTATION,
    999          		0x4048, // ANDROID_SENSOR_WAKEUP_GYROSCOPE,
   1000          		0x1008, // ANDROID_SENSOR_WAKEUP_LIGHT,
   1001          		0x0088, // ANDROID_SENSOR_WAKEUP_PRESSURE,
   1002          		0x0808, // ANDROID_SENSOR_WAKEUP_GRAVITY,
   1003          		-30712, // ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,
   1004          		0x0408, // ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,
   1005          		-1,		// ANDROID_SENSOR_WAKEUP_RELATIVE_HUMIDITY,
   1006          		-1,		// ANDROID_SENSOR_WAKEUP_AMBIENT_TEMPERATURE,
   1007          		0x2008, // ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED,
   1008          		0x0808, // ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR,
   1009          		0x4008, // ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED,
   1010          		0x0018, // ANDROID_SENSOR_WAKEUP_STEP_DETECTOR,
   1011          		0x0010, // ANDROID_SENSOR_WAKEUP_STEP_COUNTER,
   1012          		0x0108, // ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR
   1013          		-1,		// ANDROID_SENSOR_WAKEUP_HEART_RATE,
   1014          		0,		// ANDROID_SENSOR_WAKEUP_TILT_DETECTOR,
   1015          		0x8008, // Raw Acc
   1016          		0x4048, // Raw Gyr
   1017          	};
   \   00000014   0xA803             ADD      R0,SP,#+12
   \   00000016   0x.... 0x....      ADR.W    R1,?_14
   \   0000001A   0x2258             MOVS     R2,#+88
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy4
   1018          	if(enable && !inv_icm20948_ctrl_androidSensor_enabled(s, androidSensor))
   \   00000020   0x46D8             MOV      R8,R11
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xD00C             BEQ.N    ??inv_enable_sensor_internal_0
   \   00000026   0x4659             MOV      R1,R11
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD106             BNE.N    ??inv_enable_sensor_internal_0
   1019          		s->skip_sample[inv_icm20948_sensor_android_2_sensor_type(androidSensor)] = 1;
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0x.... 0x....      BL       inv_icm20948_sensor_android_2_sensor_type
   \   00000038   0x4420             ADD      R0,R4,R0
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xF880 0x12AC      STRB     R1,[R0, #+684]
   1020          		
   1021          	if (androidSensor == ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION) {
   \                     ??inv_enable_sensor_internal_0: (+1)
   \   00000040   0xF204 0x293E      ADDW     R9,R4,#+574
   \   00000044   0xF1B8 0x0F11      CMP      R8,#+17
   \   00000048   0xD113             BNE.N    ??inv_enable_sensor_internal_1
   1022          		if (enable) {
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0xD009             BEQ.N    ??inv_enable_sensor_internal_2
   1023          			s->smd_status = INV_SMD_EN;
   \   0000004E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000052   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   1024          			s->bac_request ++;
   \   00000056   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   \   00000060   0xE007             B.N      ??inv_enable_sensor_internal_1
   1025          		}
   1026          		else {
   1027          			s->smd_status = 0;
   \                     ??inv_enable_sensor_internal_2: (+1)
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   1028          			s->bac_request --;
   \   00000068   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   1029          		}
   1030          	}
   1031          
   1032          	if (androidSensor == ANDROID_SENSOR_STEP_DETECTOR) {
   \                     ??inv_enable_sensor_internal_1: (+1)
   \   00000072   0xF1B8 0x0F12      CMP      R8,#+18
   \   00000076   0xD113             BNE.N    ??inv_enable_sensor_internal_3
   1033          		if (enable) {
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0xD009             BEQ.N    ??inv_enable_sensor_internal_4
   1034          			s->ped_int_status = INV_PEDOMETER_INT_EN;
   \   0000007C   0xF44F 0x5000      MOV      R0,#+8192
   \   00000080   0xF8A9 0x0002      STRH     R0,[R9, #+2]
   1035          			s->bac_request ++;
   \   00000084   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   \   0000008E   0xE007             B.N      ??inv_enable_sensor_internal_3
   1036          		}
   1037          		else {
   1038          			s->ped_int_status = 0;
   \                     ??inv_enable_sensor_internal_4: (+1)
   \   00000090   0x4630             MOV      R0,R6
   \   00000092   0xF8A9 0x0002      STRH     R0,[R9, #+2]
   1039          			s->bac_request --;
   \   00000096   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   0000009A   0x1E40             SUBS     R0,R0,#+1
   \   0000009C   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   1040          		}
   1041          	}
   1042          	
   1043          	if (androidSensor == ANDROID_SENSOR_STEP_COUNTER) {
   \                     ??inv_enable_sensor_internal_3: (+1)
   \   000000A0   0xF1B8 0x0F13      CMP      R8,#+19
   \   000000A4   0xD10A             BNE.N    ??inv_enable_sensor_internal_5
   1044          		if (enable) {
   \   000000A6   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   000000AA   0x0029             MOVS     R1,R5
   \   000000AC   0xD003             BEQ.N    ??inv_enable_sensor_internal_6
   1045          			s->bac_request ++;
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   \   000000B4   0xE002             B.N      ??inv_enable_sensor_internal_5
   1046          		}
   1047          		else {
   1048          			s->bac_request --;
   \                     ??inv_enable_sensor_internal_6: (+1)
   \   000000B6   0x1E40             SUBS     R0,R0,#+1
   \   000000B8   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   1049          		}
   1050          	}
   1051          
   1052          	if (androidSensor == ANDROID_SENSOR_FLIP_PICKUP) {
   \                     ??inv_enable_sensor_internal_5: (+1)
   \   000000BC   0xF44F 0x70AA      MOV      R0,#+340
   \   000000C0   0xEB04 0x0A00      ADD      R10,R4,R0
   \   000000C4   0xF1B8 0x0F2E      CMP      R8,#+46
   \   000000C8   0xD109             BNE.N    ??inv_enable_sensor_internal_7
   1053          		if (enable){
   \   000000CA   0x0028             MOVS     R0,R5
   \   000000CC   0xD004             BEQ.N    ??inv_enable_sensor_internal_8
   1054          			s->flip_pickup_status = FLIP_PICKUP_SET;
   \   000000CE   0xF44F 0x6080      MOV      R0,#+1024
   \   000000D2   0xF8AA 0x0004      STRH     R0,[R10, #+4]
   \   000000D6   0xE002             B.N      ??inv_enable_sensor_internal_7
   1055          		}
   1056          		else
   1057          			s->flip_pickup_status = 0;
   \                     ??inv_enable_sensor_internal_8: (+1)
   \   000000D8   0x4630             MOV      R0,R6
   \   000000DA   0xF8AA 0x0004      STRH     R0,[R10, #+4]
   1058          	}
   1059          
   1060          	if (androidSensor == ANDROID_SENSOR_B2S) {
   \                     ??inv_enable_sensor_internal_7: (+1)
   \   000000DE   0xF1B8 0x0F2D      CMP      R8,#+45
   \   000000E2   0xD112             BNE.N    ??inv_enable_sensor_internal_9
   1061          		if(enable){
   \   000000E4   0x0028             MOVS     R0,R5
   \   000000E6   0xD008             BEQ.N    ??inv_enable_sensor_internal_10
   1062          			s->b2s_status = INV_BTS_EN;
   \   000000E8   0x2020             MOVS     R0,#+32
   \   000000EA   0xF8AA 0x0002      STRH     R0,[R10, #+2]
   1063          			s->bac_request ++;
   \   000000EE   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   000000F2   0x1C40             ADDS     R0,R0,#+1
   \   000000F4   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   \   000000F8   0xE007             B.N      ??inv_enable_sensor_internal_9
   1064          		}
   1065          		else {
   1066          			s->b2s_status = 0;
   \                     ??inv_enable_sensor_internal_10: (+1)
   \   000000FA   0x4630             MOV      R0,R6
   \   000000FC   0xF8AA 0x0002      STRH     R0,[R10, #+2]
   1067          			s->bac_request --;
   \   00000100   0xF8B9 0x0004      LDRH     R0,[R9, #+4]
   \   00000104   0x1E40             SUBS     R0,R0,#+1
   \   00000106   0xF8A9 0x0004      STRH     R0,[R9, #+4]
   1068          		}
   1069          	}
   1070          	if (androidSensor == ANDROID_SENSOR_ACTIVITY_CLASSIFICATON)
   \                     ??inv_enable_sensor_internal_9: (+1)
   \   0000010A   0xF1B8 0x0F2F      CMP      R8,#+47
   \   0000010E   0xD103             BNE.N    ??inv_enable_sensor_internal_11
   1071          		inv_icm20948_ctrl_enable_activity_classifier(s, enable);
   \   00000110   0x4629             MOV      R1,R5
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       inv_icm20948_ctrl_enable_activity_classifier
   1072          
   1073          	if (androidSensor == ANDROID_SENSOR_WAKEUP_TILT_DETECTOR)
   \                     ??inv_enable_sensor_internal_11: (+1)
   \   00000118   0xF1B8 0x0F29      CMP      R8,#+41
   \   0000011C   0xD103             BNE.N    ??inv_enable_sensor_internal_12
   1074          		inv_icm20948_ctrl_enable_tilt(s, enable);
   \   0000011E   0x4629             MOV      R1,R5
   \   00000120   0x4620             MOV      R0,R4
   \   00000122   0x.... 0x....      BL       inv_icm20948_ctrl_enable_tilt
   1075          
   1076          	inv_convert_androidSensor_to_control(s, androidSensor, enable, inv_androidSensor_to_control_bits, &s->inv_sensor_control);
   \                     ??inv_enable_sensor_internal_12: (+1)
   \   00000126   0xF44F 0x70AD      MOV      R0,#+346
   \   0000012A   0x4420             ADD      R0,R4,R0
   \   0000012C   0x9000             STR      R0,[SP, #+0]
   \   0000012E   0xAB03             ADD      R3,SP,#+12
   \   00000130   0x462A             MOV      R2,R5
   \   00000132   0x4659             MOV      R1,R11
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       inv_convert_androidSensor_to_control
   1077          	result = dmp_icm20948_set_data_output_control1(s, s->inv_sensor_control);
   \   0000013A   0xF8BA 0x1006      LDRH     R1,[R10, #+6]
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x.... 0x....      BL       dmp_icm20948_set_data_output_control1
   1078          	if (s->b2s_status)
   \   00000144   0xF8BA 0x1006      LDRH     R1,[R10, #+6]
   \   00000148   0xF8BA 0x2002      LDRH     R2,[R10, #+2]
   \   0000014C   0x2A00             CMP      R2,#+0
   \   0000014E   0x9000             STR      R0,[SP, #+0]
   \   00000150   0xD00A             BEQ.N    ??inv_enable_sensor_internal_13
   1079          		result |= dmp_icm20948_set_data_interrupt_control(s, s->inv_sensor_control|0x8008);
   \   00000152   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000156   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000015A   0x4620             MOV      R0,R4
   \   0000015C   0x.... 0x....      BL       dmp_icm20948_set_data_interrupt_control
   \   00000160   0x9900             LDR      R1,[SP, #+0]
   \   00000162   0x4308             ORRS     R0,R0,R1
   \   00000164   0x9001             STR      R0,[SP, #+4]
   \   00000166   0xE005             B.N      ??inv_enable_sensor_internal_14
   1080          		// result |= dmp_icm20948_set_data_interrupt_control(s, s->inv_sensor_control|0x0000);
   1081          	else
   1082          		result |= dmp_icm20948_set_data_interrupt_control(s, s->inv_sensor_control);
   \                     ??inv_enable_sensor_internal_13: (+1)
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0x.... 0x....      BL       dmp_icm20948_set_data_interrupt_control
   \   0000016E   0x9900             LDR      R1,[SP, #+0]
   \   00000170   0x4308             ORRS     R0,R0,R1
   \   00000172   0x9001             STR      R0,[SP, #+4]
   1083          
   1084          	if (s->inv_sensor_control & ACCEL_SET)
   \                     ??inv_enable_sensor_internal_14: (+1)
   \   00000174   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \   00000178   0xF8BA 0x1006      LDRH     R1,[R10, #+6]
   \   0000017C   0x0409             LSLS     R1,R1,#+16
   \   0000017E   0xD504             BPL.N    ??inv_enable_sensor_internal_15
   1085          		s->inv_sensor_control2 |= ACCEL_ACCURACY_SET;
   \   00000180   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000184   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   \   00000188   0xE004             B.N      ??inv_enable_sensor_internal_16
   1086          	else
   1087          		s->inv_sensor_control2 &= ~ACCEL_ACCURACY_SET;
   \                     ??inv_enable_sensor_internal_15: (+1)
   \   0000018A   0xF64B 0x71FF      MOVW     R1,#+49151
   \   0000018E   0x4008             ANDS     R0,R1,R0
   \   00000190   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   1088          
   1089          	if ((s->inv_sensor_control & GYRO_CALIBR_SET) || (s->inv_sensor_control & GYRO_SET))
   \                     ??inv_enable_sensor_internal_16: (+1)
   \   00000194   0xF8BA 0x1008      LDRH     R1,[R10, #+8]
   \   00000198   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \   0000019C   0xF244 0x0240      MOVW     R2,#+16448
   \   000001A0   0x4210             TST      R0,R2
   \   000001A2   0xD004             BEQ.N    ??inv_enable_sensor_internal_17
   1090          		s->inv_sensor_control2 |= GYRO_ACCURACY_SET;
   \   000001A4   0xF441 0x5000      ORR      R0,R1,#0x2000
   \   000001A8   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   \   000001AC   0xE004             B.N      ??inv_enable_sensor_internal_18
   1091          	else
   1092          		s->inv_sensor_control2 &= ~GYRO_ACCURACY_SET;
   \                     ??inv_enable_sensor_internal_17: (+1)
   \   000001AE   0xF64D 0x70FF      MOVW     R0,#+57343
   \   000001B2   0x4008             ANDS     R0,R0,R1
   \   000001B4   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   1093          
   1094          	if ((s->inv_sensor_control & CPASS_CALIBR_SET) || (s->inv_sensor_control & QUAT9_SET)
   1095          		|| (s->inv_sensor_control & GEOMAG_SET) || (s->inv_sensor_control & CPASS_SET))
   \                     ??inv_enable_sensor_internal_18: (+1)
   \   000001B8   0xF8BA 0x1008      LDRH     R1,[R10, #+8]
   \   000001BC   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \   000001C0   0xF242 0x5220      MOVW     R2,#+9504
   \   000001C4   0x4210             TST      R0,R2
   \   000001C6   0xD004             BEQ.N    ??inv_enable_sensor_internal_19
   1096          		s->inv_sensor_control2 |= CPASS_ACCURACY_SET;
   \   000001C8   0xF441 0x5080      ORR      R0,R1,#0x1000
   \   000001CC   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   \   000001D0   0xE004             B.N      ??inv_enable_sensor_internal_20
   1097          	else
   1098          		s->inv_sensor_control2 &= ~CPASS_ACCURACY_SET;
   \                     ??inv_enable_sensor_internal_19: (+1)
   \   000001D2   0xF64E 0x70FF      MOVW     R0,#+61439
   \   000001D6   0x4008             ANDS     R0,R0,R1
   \   000001D8   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   1099          
   1100          	if(s->flip_pickup_status)
   \                     ??inv_enable_sensor_internal_20: (+1)
   \   000001DC   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \   000001E0   0xF8BA 0x1004      LDRH     R1,[R10, #+4]
   \   000001E4   0x2900             CMP      R1,#+0
   \   000001E6   0xD004             BEQ.N    ??inv_enable_sensor_internal_21
   1101          		s->inv_sensor_control2 |= FLIP_PICKUP_SET;
   \   000001E8   0xF440 0x6080      ORR      R0,R0,#0x400
   \   000001EC   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   \   000001F0   0xE004             B.N      ??inv_enable_sensor_internal_22
   1102          	else
   1103          		s->inv_sensor_control2 &= ~FLIP_PICKUP_SET;
   \                     ??inv_enable_sensor_internal_21: (+1)
   \   000001F2   0xF64F 0x31FF      MOVW     R1,#+64511
   \   000001F6   0x4008             ANDS     R0,R1,R0
   \   000001F8   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   1104          
   1105          	// inv_event_control   |= s->b2s_status; 
   1106          	if(s->b2s_status)
   \                     ??inv_enable_sensor_internal_22: (+1)
   \   000001FC   0xF8BA 0x0002      LDRH     R0,[R10, #+2]
   \   00000200   0x2800             CMP      R0,#+0
   \   00000202   0xD006             BEQ.N    ??inv_enable_sensor_internal_23
   1107          	{
   1108          		inv_event_control |= INV_BRING_AND_LOOK_T0_SEE_EN;
   1109          		inv_event_control |= INV_PEDOMETER_EN;
   1110          #ifndef ICM20948_FOR_MOBILE // Next lines change BAC behavior to wearable platform
   1111          		inv_event_control |= INV_BAC_WEARABLE_EN;
   \   00000204   0xF24C 0x0604      MOVW     R6,#+49156
   1112          		dmp_icm20948_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
   \   00000208   0xF04F 0x4180      MOV      R1,#+1073741824
   \   0000020C   0x4620             MOV      R0,R4
   \   0000020E   0x.... 0x....      BL       dmp_icm20948_set_ped_y_ratio
   1113          #endif
   1114          	}
   1115          	else
   1116          	{
   1117          		inv_event_control &= ~INV_BRING_AND_LOOK_T0_SEE_EN;
   1118          		inv_event_control &= ~INV_PEDOMETER_EN;
   1119          #ifndef ICM20948_FOR_MOBILE // Next lines change BAC behavior to wearable platform
   1120          		inv_event_control &= ~INV_BAC_WEARABLE_EN;
   1121          #endif
   1122          	}
   1123          
   1124          	result |= dmp_icm20948_set_data_output_control2(s, s->inv_sensor_control2);
   \                     ??inv_enable_sensor_internal_23: (+1)
   \   00000212   0x9801             LDR      R0,[SP, #+4]
   \   00000214   0x9000             STR      R0,[SP, #+0]
   \   00000216   0xF8BA 0x1008      LDRH     R1,[R10, #+8]
   \   0000021A   0x4620             MOV      R0,R4
   \   0000021C   0x.... 0x....      BL       dmp_icm20948_set_data_output_control2
   \   00000220   0x9900             LDR      R1,[SP, #+0]
   \   00000222   0x4308             ORRS     R0,R0,R1
   \   00000224   0x9000             STR      R0,[SP, #+0]
   1125          
   1126          	// sets DATA_RDY_STATUS in DMP based on which sensors are on
   1127          	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_GYRO_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_GYRO_MASK1)
   \   00000226   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0xe6018e18
   \   0000022E   0x4208             TST      R0,R1
   \   00000230   0xD105             BNE.N    ??inv_enable_sensor_internal_24
   \   00000232   0xF8DA 0x1010      LDR      R1,[R10, #+16]
   \   00000236   0xF640 0x0218      MOVW     R2,#+2072
   \   0000023A   0x4211             TST      R1,R2
   \   0000023C   0xD000             BEQ.N    ??inv_enable_sensor_internal_25
   1128          		data_rdy_status |= GYRO_AVAILABLE;
   \                     ??inv_enable_sensor_internal_24: (+1)
   \   0000023E   0x2701             MOVS     R7,#+1
   1129          	
   1130          	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_ACCEL_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_ACCEL_MASK1)
   \                     ??inv_enable_sensor_internal_25: (+1)
   \   00000240   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0xe29e8e0a
   \   00000244   0x4208             TST      R0,R1
   \   00000246   0xD104             BNE.N    ??inv_enable_sensor_internal_26
   \   00000248   0xF8DA 0x1010      LDR      R1,[R10, #+16]
   \   0000024C   0xF411 0x6FDD      TST      R1,#0x6E8
   \   00000250   0xD001             BEQ.N    ??inv_enable_sensor_internal_27
   1131          		data_rdy_status |= ACCEL_AVAILABLE;
   \                     ??inv_enable_sensor_internal_26: (+1)
   \   00000252   0xF047 0x0702      ORR      R7,R7,#0x2
   1132          
   1133          	if (s->flip_pickup_status || s->b2s_status)
   \                     ??inv_enable_sensor_internal_27: (+1)
   \   00000256   0xF8BA 0x1004      LDRH     R1,[R10, #+4]
   \   0000025A   0x2900             CMP      R1,#+0
   \   0000025C   0xD103             BNE.N    ??inv_enable_sensor_internal_28
   \   0000025E   0xF8BA 0x1002      LDRH     R1,[R10, #+2]
   \   00000262   0x2900             CMP      R1,#+0
   \   00000264   0xD001             BEQ.N    ??inv_enable_sensor_internal_29
   1134          		data_rdy_status |= ACCEL_AVAILABLE;
   \                     ??inv_enable_sensor_internal_28: (+1)
   \   00000266   0xF047 0x0702      ORR      R7,R7,#0x2
   1135          
   1136          	if (s->bac_status)
   \                     ??inv_enable_sensor_internal_29: (+1)
   \   0000026A   0xF8BA 0x1000      LDRH     R1,[R10, #+0]
   \   0000026E   0x2900             CMP      R1,#+0
   \   00000270   0xD001             BEQ.N    ??inv_enable_sensor_internal_30
   1137          		data_rdy_status |= ACCEL_AVAILABLE;
   \   00000272   0xF047 0x0702      ORR      R7,R7,#0x2
   1138          
   1139          	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_COMPASS_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_COMPASS_MASK1) {
   \                     ??inv_enable_sensor_internal_30: (+1)
   \   00000276   0x.... 0x....      LDR.W    R1,??DataTable18_2  ;; 0x8310480c
   \   0000027A   0x4208             TST      R0,R1
   \   0000027C   0xD104             BNE.N    ??inv_enable_sensor_internal_31
   \   0000027E   0xF89A 0x0010      LDRB     R0,[R10, #+16]
   \   00000282   0xF010 0x0F84      TST      R0,#0x84
   \   00000286   0xD003             BEQ.N    ??inv_enable_sensor_internal_32
   1140          		data_rdy_status |= SECONDARY_COMPASS_AVAILABLE;
   \                     ??inv_enable_sensor_internal_31: (+1)
   \   00000288   0xF047 0x0708      ORR      R7,R7,#0x8
   1141          		inv_event_control |= INV_COMPASS_CAL_EN;
   \   0000028C   0xF046 0x0680      ORR      R6,R6,#0x80
   1142          	}
   1143          	// turn on gyro cal only if gyro is available
   1144          	if (data_rdy_status & GYRO_AVAILABLE)
   \                     ??inv_enable_sensor_internal_32: (+1)
   \   00000290   0x4638             MOV      R0,R7
   \   00000292   0x07C0             LSLS     R0,R0,#+31
   \   00000294   0xD501             BPL.N    ??inv_enable_sensor_internal_33
   1145          		inv_event_control |= INV_GYRO_CAL_EN;
   \   00000296   0xF446 0x7680      ORR      R6,R6,#0x100
   1146          		
   1147          	// turn on acc cal only if acc is available
   1148          	if (data_rdy_status & ACCEL_AVAILABLE)
   \                     ??inv_enable_sensor_internal_33: (+1)
   \   0000029A   0x4638             MOV      R0,R7
   \   0000029C   0x0780             LSLS     R0,R0,#+30
   \   0000029E   0xD501             BPL.N    ??inv_enable_sensor_internal_34
   1149          		inv_event_control |= INV_ACCEL_CAL_EN;
   \   000002A0   0xF446 0x7600      ORR      R6,R6,#0x200
   1150          
   1151          	inv_event_control |= s->smd_status | s->ped_int_status;
   \                     ??inv_enable_sensor_internal_34: (+1)
   \   000002A4   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000002A8   0xF8B9 0x1002      LDRH     R1,[R9, #+2]
   \   000002AC   0x4308             ORRS     R0,R1,R0
   \   000002AE   0x4306             ORRS     R6,R0,R6
   1152          
   1153          	if (s->inv_sensor_control & QUAT9_SET)
   \   000002B0   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \   000002B4   0x0541             LSLS     R1,R0,#+21
   \   000002B6   0xD501             BPL.N    ??inv_enable_sensor_internal_35
   1154          		inv_event_control |= INV_NINE_AXIS_EN;
   \   000002B8   0xF046 0x0640      ORR      R6,R6,#0x40
   1155          
   1156          	if (s->inv_sensor_control & (PED_STEPDET_SET | PED_STEPIND_SET) || inv_event_control & INV_SMD_EN) {
   \                     ??inv_enable_sensor_internal_35: (+1)
   \   000002BC   0x2117             MOVS     R1,#+23
   \   000002BE   0x4208             TST      R0,R1
   \   000002C0   0xD101             BNE.N    ??inv_enable_sensor_internal_36
   \   000002C2   0x0530             LSLS     R0,R6,#+20
   \   000002C4   0xD506             BPL.N    ??inv_enable_sensor_internal_37
   1157          		inv_event_control |= INV_PEDOMETER_EN;
   1158          #ifndef ICM20948_FOR_MOBILE // Next lines change BAC behavior to wearable platform
   1159          		inv_event_control |= INV_BAC_WEARABLE_EN;
   \                     ??inv_enable_sensor_internal_36: (+1)
   \   000002C6   0xF446 0x4640      ORR      R6,R6,#0xC000
   1160          		dmp_icm20948_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
   \   000002CA   0xF04F 0x4180      MOV      R1,#+1073741824
   \   000002CE   0x4620             MOV      R0,R4
   \   000002D0   0x.... 0x....      BL       dmp_icm20948_set_ped_y_ratio
   1161          #endif
   1162          	}
   1163          
   1164          	if (s->inv_sensor_control2 & ACT_RECOG_SET) {
   \                     ??inv_enable_sensor_internal_37: (+1)
   \   000002D4   0xF89A 0x0008      LDRB     R0,[R10, #+8]
   \   000002D8   0x0600             LSLS     R0,R0,#+24
   \   000002DA   0xD506             BPL.N    ??inv_enable_sensor_internal_38
   1165          		inv_event_control |= INV_PEDOMETER_EN;
   1166          #ifndef ICM20948_FOR_MOBILE // Next lines this to change BAC behavior to wearable platform
   1167          		inv_event_control |= INV_BAC_WEARABLE_EN;
   \   000002DC   0xF446 0x4640      ORR      R6,R6,#0xC000
   1168          		dmp_icm20948_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
   \   000002E0   0xF04F 0x4180      MOV      R1,#+1073741824
   \   000002E4   0x4620             MOV      R0,R4
   \   000002E6   0x.... 0x....      BL       dmp_icm20948_set_ped_y_ratio
   1169          #endif
   1170          	}
   1171          
   1172          	if (s->inv_sensor_control2 & FLIP_PICKUP_SET){
   \                     ??inv_enable_sensor_internal_38: (+1)
   \   000002EA   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \   000002EE   0x0540             LSLS     R0,R0,#+21
   \   000002F0   0xD501             BPL.N    ??inv_enable_sensor_internal_39
   1173          		inv_event_control |= FLIP_PICKUP_EN;
   \   000002F2   0xF046 0x0610      ORR      R6,R6,#0x10
   1174          	}
   1175          
   1176          	if (s->inv_sensor_control & GEOMAG_SET)
   \                     ??inv_enable_sensor_internal_39: (+1)
   \   000002F6   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \   000002FA   0x05C0             LSLS     R0,R0,#+23
   \   000002FC   0xD501             BPL.N    ??inv_enable_sensor_internal_40
   1177          		inv_event_control |= GEOMAG_EN;
   \   000002FE   0xF046 0x0608      ORR      R6,R6,#0x8
   1178          
   1179          	result |= dmp_icm20948_set_motion_event_control(s, inv_event_control);
   \                     ??inv_enable_sensor_internal_40: (+1)
   \   00000302   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \   00000306   0x4631             MOV      R1,R6
   \   00000308   0x4620             MOV      R0,R4
   \   0000030A   0x.... 0x....      BL       dmp_icm20948_set_motion_event_control
   \   0000030E   0xEA40 0x0609      ORR      R6,R0,R9
   1180          	
   1181          	// A sensor was just enabled/disabled, need to recompute the required ODR for all augmented sensor-related sensors
   1182          	// The fastest ODR will always be applied to other related sensors
   1183          	if (   (androidSensor == ANDROID_SENSOR_GRAVITY) 
   1184          		|| (androidSensor == ANDROID_SENSOR_GAME_ROTATION_VECTOR) 
   1185          		|| (androidSensor == ANDROID_SENSOR_LINEAR_ACCELERATION) ) {
   \   00000312   0xF1B8 0x0F09      CMP      R8,#+9
   \   00000316   0xD005             BEQ.N    ??inv_enable_sensor_internal_41
   \   00000318   0xF1B8 0x0F0F      CMP      R8,#+15
   \   0000031C   0xD002             BEQ.N    ??inv_enable_sensor_internal_41
   \   0000031E   0xF1B8 0x0F0A      CMP      R8,#+10
   \   00000322   0xD10D             BNE.N    ??inv_enable_sensor_internal_42
   1186          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_SIXQ]);
   \                     ??inv_enable_sensor_internal_41: (+1)
   \   00000324   0xF44F 0x7088      MOV      R0,#+272
   \   00000328   0x1822             ADDS     R2,R4,R0
   \   0000032A   0x4659             MOV      R1,R11
   \   0000032C   0x4620             MOV      R0,R4
   \   0000032E   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1187          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_SIXQ_accel]);
   \   00000332   0xF44F 0x7093      MOV      R0,#+294
   \   00000336   0x1822             ADDS     R2,R4,R0
   \   00000338   0x4659             MOV      R1,R11
   \   0000033A   0x4620             MOV      R0,R4
   \   0000033C   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1188          	}
   1189          
   1190          	if (   (androidSensor == ANDROID_SENSOR_ORIENTATION) 
   1191          		|| (androidSensor == ANDROID_SENSOR_ROTATION_VECTOR) ) {
   \                     ??inv_enable_sensor_internal_42: (+1)
   \   00000340   0xF1B8 0x0F03      CMP      R8,#+3
   \   00000344   0xD002             BEQ.N    ??inv_enable_sensor_internal_43
   \   00000346   0xF1B8 0x0F0B      CMP      R8,#+11
   \   0000034A   0xD114             BNE.N    ??inv_enable_sensor_internal_44
   1192          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ]);
   \                     ??inv_enable_sensor_internal_43: (+1)
   \   0000034C   0xF44F 0x7089      MOV      R0,#+274
   \   00000350   0x1822             ADDS     R2,R4,R0
   \   00000352   0x4659             MOV      R1,R11
   \   00000354   0x4620             MOV      R0,R4
   \   00000356   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1193          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_accel]);
   \   0000035A   0xF44F 0x7094      MOV      R0,#+296
   \   0000035E   0x1822             ADDS     R2,R4,R0
   \   00000360   0x4659             MOV      R1,R11
   \   00000362   0x4620             MOV      R0,R4
   \   00000364   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1194          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_cpass]);
   \   00000368   0xF44F 0x7096      MOV      R0,#+300
   \   0000036C   0x1822             ADDS     R2,R4,R0
   \   0000036E   0x4659             MOV      R1,R11
   \   00000370   0x4620             MOV      R0,R4
   \   00000372   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1195          	}
   1196          
   1197          	if (   (androidSensor == ANDROID_SENSOR_WAKEUP_GRAVITY) 
   1198          		|| (androidSensor == ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR) 
   1199          		|| (androidSensor == ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION) ) {
   \                     ??inv_enable_sensor_internal_44: (+1)
   \   00000376   0xF1B8 0x0F1D      CMP      R8,#+29
   \   0000037A   0xD005             BEQ.N    ??inv_enable_sensor_internal_45
   \   0000037C   0xF1B8 0x0F23      CMP      R8,#+35
   \   00000380   0xD002             BEQ.N    ??inv_enable_sensor_internal_45
   \   00000382   0xF1B8 0x0F1E      CMP      R8,#+30
   \   00000386   0xD10D             BNE.N    ??inv_enable_sensor_internal_46
   1200          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ]);
   \                     ??inv_enable_sensor_internal_45: (+1)
   \   00000388   0xF44F 0x709B      MOV      R0,#+310
   \   0000038C   0x1822             ADDS     R2,R4,R0
   \   0000038E   0x4659             MOV      R1,R11
   \   00000390   0x4620             MOV      R0,R4
   \   00000392   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1201          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ_accel]);
   \   00000396   0xF44F 0x70A4      MOV      R0,#+328
   \   0000039A   0x1822             ADDS     R2,R4,R0
   \   0000039C   0x4659             MOV      R1,R11
   \   0000039E   0x4620             MOV      R0,R4
   \   000003A0   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1202          	}
   1203          
   1204          	if (   (androidSensor == ANDROID_SENSOR_WAKEUP_ORIENTATION) 
   1205          		|| (androidSensor == ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) ) {
   \                     ??inv_enable_sensor_internal_46: (+1)
   \   000003A4   0xF1B8 0x0F19      CMP      R8,#+25
   \   000003A8   0xD002             BEQ.N    ??inv_enable_sensor_internal_47
   \   000003AA   0xF1B8 0x0F1F      CMP      R8,#+31
   \   000003AE   0xD114             BNE.N    ??inv_enable_sensor_internal_48
   1206          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ]);
   \                     ??inv_enable_sensor_internal_47: (+1)
   \   000003B0   0xF44F 0x709C      MOV      R0,#+312
   \   000003B4   0x1822             ADDS     R2,R4,R0
   \   000003B6   0x4659             MOV      R1,R11
   \   000003B8   0x4620             MOV      R0,R4
   \   000003BA   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1207          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_accel]);
   \   000003BE   0xF44F 0x70A5      MOV      R0,#+330
   \   000003C2   0x1822             ADDS     R2,R4,R0
   \   000003C4   0x4659             MOV      R1,R11
   \   000003C6   0x4620             MOV      R0,R4
   \   000003C8   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1208          		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_cpass]);
   \   000003CC   0xF44F 0x70A7      MOV      R0,#+334
   \   000003D0   0x1822             ADDS     R2,R4,R0
   \   000003D2   0x4659             MOV      R1,R11
   \   000003D4   0x4620             MOV      R0,R4
   \   000003D6   0x.... 0x....      BL       inv_icm20948_augmented_sensors_update_odr
   1209          	}
   1210          
   1211          	result |= inv_set_hw_smplrt_dmp_odrs(s);
   \                     ??inv_enable_sensor_internal_48: (+1)
   \   000003DA   0x4620             MOV      R0,R4
   \   000003DC   0x.... 0x....      BL       inv_set_hw_smplrt_dmp_odrs
   \   000003E0   0x4306             ORRS     R6,R0,R6
   1212          	result |= inv_icm20948_set_gyro_sf(s, inv_icm20948_get_gyro_divider(s), inv_icm20948_get_gyro_fullscale(s));
   \   000003E2   0x4620             MOV      R0,R4
   \   000003E4   0x.... 0x....      BL       inv_icm20948_get_gyro_fullscale
   \   000003E8   0x4681             MOV      R9,R0
   \   000003EA   0x4620             MOV      R0,R4
   \   000003EC   0x.... 0x....      BL       inv_icm20948_get_gyro_divider
   \   000003F0   0x464A             MOV      R2,R9
   \   000003F2   0x4601             MOV      R1,R0
   \   000003F4   0x4620             MOV      R0,R4
   \   000003F6   0x.... 0x....      BL       inv_icm20948_set_gyro_sf
   \   000003FA   0x4306             ORRS     R6,R0,R6
   1213          
   1214          	if (!s->inv_sensor_control && !(s->inv_androidSensorsOn_mask[0] & (1L << ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION)) && !s->b2s_status) {
   \   000003FC   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \   00000400   0x2800             CMP      R0,#+0
   \   00000402   0xD10E             BNE.N    ??inv_enable_sensor_internal_49
   \   00000404   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000408   0x0380             LSLS     R0,R0,#+14
   \   0000040A   0xD40A             BMI.N    ??inv_enable_sensor_internal_49
   \   0000040C   0xF8BA 0x0002      LDRH     R0,[R10, #+2]
   \   00000410   0x2800             CMP      R0,#+0
   \   00000412   0xD106             BNE.N    ??inv_enable_sensor_internal_49
   1215          		*mems_put_to_sleep =1 ;
   \   00000414   0x2001             MOVS     R0,#+1
   \   00000416   0x991A             LDR      R1,[SP, #+104]
   \   00000418   0x7008             STRB     R0,[R1, #+0]
   1216          		result |= inv_icm20948_sleep_mems(s);
   \   0000041A   0x4620             MOV      R0,R4
   \   0000041C   0x.... 0x....      BL       inv_icm20948_sleep_mems
   \   00000420   0x4306             ORRS     R6,R0,R6
   1217          	}
   1218          
   1219          	// DMP no longer controls PWR_MGMT_2 because of hardware bug, 0x80 set to override default behaviour of inv_icm20948_enable_hw_sensors()
   1220          	result |= inv_icm20948_enable_hw_sensors(s, (int)data_rdy_status | 0x80);
   \                     ??inv_enable_sensor_internal_49: (+1)
   \   00000422   0xF047 0x0180      ORR      R1,R7,#0x80
   \   00000426   0x4620             MOV      R0,R4
   \   00000428   0x.... 0x....      BL       inv_icm20948_enable_hw_sensors
   \   0000042C   0x4306             ORRS     R6,R0,R6
   1221          
   1222          	// set DATA_RDY_STATUS in DMP
   1223          	if (data_rdy_status & SECONDARY_COMPASS_AVAILABLE)	{
   \   0000042E   0x4638             MOV      R0,R7
   \   00000430   0x0700             LSLS     R0,R0,#+28
   \   00000432   0xD501             BPL.N    ??inv_enable_sensor_internal_50
   1224          		data_rdy_status |= SECONDARY_COMPASS_AVAILABLE;
   \   00000434   0xF047 0x0708      ORR      R7,R7,#0x8
   1225          	}
   1226          
   1227          	result |= dmp_icm20948_set_data_rdy_status(s, data_rdy_status);
   \                     ??inv_enable_sensor_internal_50: (+1)
   \   00000438   0x4639             MOV      R1,R7
   \   0000043A   0x4620             MOV      R0,R4
   \   0000043C   0x.... 0x....      BL       dmp_icm20948_set_data_rdy_status
   \   00000440   0x4306             ORRS     R6,R0,R6
   1228          
   1229          	// To have the all steps when you enable the sensor
   1230          	if (androidSensor == ANDROID_SENSOR_STEP_COUNTER)
   \   00000442   0xF1B8 0x0F13      CMP      R8,#+19
   \   00000446   0xD10B             BNE.N    ??inv_enable_sensor_internal_51
   1231          	{
   1232          		if (enable)
   \   00000448   0x2D00             CMP      R5,#+0
   \   0000044A   0xD009             BEQ.N    ??inv_enable_sensor_internal_51
   1233          		{
   1234          			dmp_icm20948_get_pedometer_num_of_steps(s, &steps);
   \   0000044C   0xA902             ADD      R1,SP,#+8
   \   0000044E   0x4620             MOV      R0,R4
   \   00000450   0x.... 0x....      BL       dmp_icm20948_get_pedometer_num_of_steps
   1235          			s->sStepCounterToBeSubtracted = steps - s->sOldSteps;
   \   00000454   0xF104 0x00A0      ADD      R0,R4,#+160
   \   00000458   0x9902             LDR      R1,[SP, #+8]
   \   0000045A   0x6842             LDR      R2,[R0, #+4]
   \   0000045C   0x1A89             SUBS     R1,R1,R2
   \   0000045E   0x6001             STR      R1,[R0, #+0]
   1236          		}
   1237          	}
   1238          
   1239          	return result;
   \                     ??inv_enable_sensor_internal_51: (+1)
   \   00000460   0x4630             MOV      R0,R6
   \   00000462   0xB01B             ADD      SP,SP,#+108
   \   00000464   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1240          }
   1241          

   \                                 In section .text, align 2, keep-with-next
   1242          void inv_icm20948_ctrl_enable_activity_classifier(struct inv_icm20948 * s, unsigned char enable) 
   1243          {
   \                     inv_icm20948_ctrl_enable_activity_classifier: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1244          	s->bac_on = enable;
   \   00000004   0xF44F 0x70A8      MOV      R0,#+336
   \   00000008   0x1825             ADDS     R5,R4,R0
   \   0000000A   0x8029             STRH     R1,[R5, #+0]
   1245          	if (enable) {
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD00B             BEQ.N    ??inv_icm20948_ctrl_enable_activity_classifier_0
   1246          		s->bac_status = ACT_RECOG_SET;
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x80A8             STRH     R0,[R5, #+4]
   1247          		s->inv_sensor_control2 |= ACT_RECOG_SET;
   \   00000014   0x89A8             LDRH     R0,[R5, #+12]
   \   00000016   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000001A   0x81A8             STRH     R0,[R5, #+12]
   1248          		s->bac_request ++;
   \   0000001C   0xF8B4 0x0242      LDRH     R0,[R4, #+578]
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xF8A4 0x0242      STRH     R0,[R4, #+578]
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}
   1249          	}
   1250          	else {
   1251          		// only disable tilt engine if no request for tilt sensor
   1252          		if (!inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_TILT_DETECTOR)) {
   \                     ??inv_icm20948_ctrl_enable_activity_classifier_0: (+1)
   \   00000028   0x2129             MOVS     R1,#+41
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       inv_icm20948_ctrl_androidSensor_enabled
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD10B             BNE.N    ??inv_icm20948_ctrl_enable_activity_classifier_1
   1253          			s->bac_status = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x80A8             STRH     R0,[R5, #+4]
   1254          			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
   \   00000038   0x89A8             LDRH     R0,[R5, #+12]
   \   0000003A   0xF64F 0x717F      MOVW     R1,#+65407
   \   0000003E   0x4008             ANDS     R0,R1,R0
   \   00000040   0x81A8             STRH     R0,[R5, #+12]
   1255          			s->bac_request --;
   \   00000042   0xF8B4 0x0242      LDRH     R0,[R4, #+578]
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0xF8A4 0x0242      STRH     R0,[R4, #+578]
   1256          		}
   1257          	}
   1258          }
   \                     ??inv_icm20948_ctrl_enable_activity_classifier_1: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1259          

   \                                 In section .text, align 2, keep-with-next
   1260          void inv_icm20948_ctrl_enable_tilt(struct inv_icm20948 * s, unsigned char enable) 
   1261          {
   1262          	if (enable) {
   \                     inv_icm20948_ctrl_enable_tilt: (+1)
   \   00000000   0xF44F 0x72A8      MOV      R2,#+336
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD00B             BEQ.N    ??inv_icm20948_ctrl_enable_tilt_0
   1263          		s->bac_status = ACT_RECOG_SET;
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x8091             STRH     R1,[R2, #+4]
   1264          		s->inv_sensor_control2 |= ACT_RECOG_SET;
   \   0000000E   0x8991             LDRH     R1,[R2, #+12]
   \   00000010   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000014   0x8191             STRH     R1,[R2, #+12]
   1265          		s->bac_request ++;
   \   00000016   0xF8B0 0x1242      LDRH     R1,[R0, #+578]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xF8A0 0x1242      STRH     R1,[R0, #+578]
   \   00000020   0x4770             BX       LR
   1266          	}
   1267          	else {
   1268          		// do not disable BAC engine if BAC sensor is still on even though tilt is off
   1269          		if (!s->bac_on) {
   \                     ??inv_icm20948_ctrl_enable_tilt_0: (+1)
   \   00000022   0x8811             LDRH     R1,[R2, #+0]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD10B             BNE.N    ??inv_icm20948_ctrl_enable_tilt_1
   1270          			s->bac_status = 0;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x8091             STRH     R1,[R2, #+4]
   1271          			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
   \   0000002C   0x8991             LDRH     R1,[R2, #+12]
   \   0000002E   0xF64F 0x737F      MOVW     R3,#+65407
   \   00000032   0x4019             ANDS     R1,R3,R1
   \   00000034   0x8191             STRH     R1,[R2, #+12]
   1272          			s->bac_request --;
   \   00000036   0xF8B0 0x1242      LDRH     R1,[R0, #+578]
   \   0000003A   0x1E49             SUBS     R1,R1,#+1
   \   0000003C   0xF8A0 0x1242      STRH     R1,[R0, #+578]
   1273          		}
   1274          	}
   1275          }
   \                     ??inv_icm20948_ctrl_enable_tilt_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
   1276          

   \                                 In section .text, align 2, keep-with-next
   1277          int inv_icm20948_ctrl_enable_batch(struct inv_icm20948 * s, unsigned char enable)
   1278          {
   \                     inv_icm20948_ctrl_enable_batch: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1279          	int ret = 0;
   1280          
   1281          	if(enable)
   \   00000006   0xF8B4 0x015C      LDRH     R0,[R4, #+348]
   \   0000000A   0xD004             BEQ.N    ??inv_icm20948_ctrl_enable_batch_0
   1282          		s->inv_sensor_control2 |= BATCH_MODE_EN;
   \   0000000C   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000010   0xF8A4 0x015C      STRH     R0,[R4, #+348]
   \   00000014   0xE004             B.N      ??inv_icm20948_ctrl_enable_batch_1
   1283          	else
   1284          		s->inv_sensor_control2 &= ~BATCH_MODE_EN;
   \                     ??inv_icm20948_ctrl_enable_batch_0: (+1)
   \   00000016   0xF64F 0x61FF      MOVW     R1,#+65279
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0xF8A4 0x015C      STRH     R0,[R4, #+348]
   1285          
   1286          	ret = dmp_icm20948_set_data_output_control2(s, s->inv_sensor_control2);
   \                     ??inv_icm20948_ctrl_enable_batch_1: (+1)
   \   00000020   0xF8B4 0x115C      LDRH     R1,[R4, #+348]
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       dmp_icm20948_set_data_output_control2
   \   0000002A   0x4606             MOV      R6,R0
   1287          
   1288          	/* give batch mode status to mems transport layer 
   1289          	to allow disable/enable LP_EN when reading FIFO in batch mode */
   1290          	inv_icm20948_ctrl_set_batch_mode_status(s, enable);
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       inv_icm20948_ctrl_set_batch_mode_status
   1291          
   1292          	return ret;
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
   1293          }
   1294          

   \                                 In section .text, align 2, keep-with-next
   1295          void inv_icm20948_ctrl_set_batch_mode_status(struct inv_icm20948 * s, unsigned char enable)
   1296          {
   1297          	if(enable)
   \                     inv_icm20948_ctrl_set_batch_mode_status: (+1)
   \   00000000   0x460A             MOV      R2,R1
   \   00000002   0x1E52             SUBS     R2,R2,#+1
   \   00000004   0x4192             SBCS     R2,R2,R2
   \   00000006   0x43D2             MVNS     R2,R2
   \   00000008   0x0FD2             LSRS     R2,R2,#+31
   \   0000000A   0xF880 0x223A      STRB     R2,[R0, #+570]
   1298          		s->sBatchMode=1;
   1299          	else
   1300          		s->sBatchMode=0;
   1301          }
   \   0000000E   0x4770             BX       LR               ;; return
   1302          

   \                                 In section .text, align 2, keep-with-next
   1303          unsigned char inv_icm20948_ctrl_get_batch_mode_status(struct inv_icm20948 * s)
   1304          {
   1305          	return s->sBatchMode;
   \                     inv_icm20948_ctrl_get_batch_mode_status: (+1)
   \   00000000   0xF890 0x023A      LDRB     R0,[R0, #+570]
   \   00000004   0x4770             BX       LR               ;; return
   1306          }
   1307          

   \                                 In section .text, align 2, keep-with-next
   1308          int inv_icm20948_ctrl_set_batch_timeout(struct inv_icm20948 * s, unsigned short batch_time_in_seconds)
   1309          {
   \                     inv_icm20948_ctrl_set_batch_timeout: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1310          	unsigned int timeout = 0;
   1311          
   1312          	if(    s->inv_sensor_control & GYRO_CALIBR_SET 
   1313          		|| s->inv_sensor_control & QUAT6_SET 
   1314          		|| s->inv_sensor_control & QUAT9_SET 
   1315          		|| s->inv_sensor_control & GYRO_SET ) { // If Gyro based sensor is enabled.
   \   00000006   0xF8B4 0x015A      LDRH     R0,[R4, #+346]
   \   0000000A   0xF644 0x4140      MOVW     R1,#+19520
   \   0000000E   0x4208             TST      R0,R1
   \   00000010   0xD00F             BEQ.N    ??inv_icm20948_ctrl_set_batch_timeout_0
   1316          		timeout = (unsigned int) (batch_time_in_seconds * (BASE_SAMPLE_RATE/ (inv_icm20948_get_gyro_divider(s) + 1)));
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       inv_icm20948_get_gyro_divider
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0xF240 0x4165      MOVW     R1,#+1125
   \   0000001E   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000022   0xFB00 0xF105      MUL      R1,R0,R5
   1317          		return dmp_icm20948_set_batchmode_params(s, timeout, GYRO_AVAILABLE);
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   0000002E   0x.... 0x....      B.W      dmp_icm20948_set_batchmode_params
   1318          	}
   1319          
   1320          	if(    s->inv_sensor_control & ACCEL_SET 
   1321          		|| s->inv_sensor_control & GEOMAG_SET ) { // If Accel is enabled and no Gyro based sensor is enabled.
   \                     ??inv_icm20948_ctrl_set_batch_timeout_0: (+1)
   \   00000032   0xF44F 0x4101      MOV      R1,#+33024
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD00F             BEQ.N    ??inv_icm20948_ctrl_set_batch_timeout_1
   1322          		timeout = (unsigned int) (batch_time_in_seconds * (BASE_SAMPLE_RATE/ (inv_icm20948_get_accel_divider(s) + 1)));
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       inv_icm20948_get_accel_divider
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0xF240 0x4165      MOVW     R1,#+1125
   \   00000046   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   0000004A   0xFB00 0xF105      MUL      R1,R0,R5
   1323          		return dmp_icm20948_set_batchmode_params(s, timeout, ACCEL_AVAILABLE);
   \   0000004E   0x2202             MOVS     R2,#+2
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000056   0x.... 0x....      B.W      dmp_icm20948_set_batchmode_params
   1324          	}
   1325          
   1326          	if(    s->inv_sensor_control & CPASS_SET 
   1327          		|| s->inv_sensor_control & CPASS_CALIBR_SET ) {
   \                     ??inv_icm20948_ctrl_set_batch_timeout_1: (+1)
   \   0000005A   0xF242 0x0620      MOVW     R6,#+8224
   \   0000005E   0x4230             TST      R0,R6
   \   00000060   0xD014             BEQ.N    ??inv_icm20948_ctrl_set_batch_timeout_2
   1328          		int rc = 0;
   \   00000062   0x2700             MOVS     R7,#+0
   1329          
   1330          		timeout = (unsigned int) (batch_time_in_seconds * (BASE_SAMPLE_RATE/ inv_icm20948_get_secondary_divider(s)));
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       inv_icm20948_get_secondary_divider
   \   0000006A   0xF240 0x4165      MOVW     R1,#+1125
   \   0000006E   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000072   0xFB00 0xF105      MUL      R1,R0,R5
   1331          	
   1332          		if(    s->inv_sensor_control & CPASS_SET 
   1333          			|| s->inv_sensor_control & CPASS_CALIBR_SET ) {
   \   00000076   0xF8B4 0x015A      LDRH     R0,[R4, #+346]
   \   0000007A   0x4230             TST      R0,R6
   \   0000007C   0xD004             BEQ.N    ??inv_icm20948_ctrl_set_batch_timeout_3
   1334          			rc |= dmp_icm20948_set_batchmode_params(s, timeout, SECONDARY_COMPASS_AVAILABLE);
   \   0000007E   0x2208             MOVS     R2,#+8
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       dmp_icm20948_set_batchmode_params
   \   00000086   0x4607             MOV      R7,R0
   1335          		}
   1336          	
   1337          		return rc;
   \                     ??inv_icm20948_ctrl_set_batch_timeout_3: (+1)
   \   00000088   0x4638             MOV      R0,R7
   \   0000008A   0xBDF2             POP      {R1,R4-R7,PC}
   1338          	}
   1339          
   1340          	return -1;  // Call batch only when a sensor is enabled.
   \                     ??inv_icm20948_ctrl_set_batch_timeout_2: (+1)
   \   0000008C   0xF04F 0x30FF      MOV      R0,#-1
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1341          }    
   1342          

   \                                 In section .text, align 2, keep-with-next
   1343          int inv_icm20948_ctrl_set_batch_timeout_ms(struct inv_icm20948 * s, unsigned short batch_time_in_ms)
   1344          {
   \                     inv_icm20948_ctrl_set_batch_timeout_ms: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1345          	unsigned int timeout = 0;
   1346          
   1347          	if(    s->inv_sensor_control & GYRO_CALIBR_SET 
   1348          		|| s->inv_sensor_control & QUAT6_SET 
   1349          		|| s->inv_sensor_control & QUAT9_SET 
   1350          		|| s->inv_sensor_control & GYRO_SET ) { // If Gyro based sensor is enabled.
   \   00000006   0xF44F 0x70AD      MOV      R0,#+346
   \   0000000A   0x1826             ADDS     R6,R4,R0
   \   0000000C   0x8830             LDRH     R0,[R6, #+0]
   \   0000000E   0xF644 0x4140      MOVW     R1,#+19520
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD018             BEQ.N    ??inv_icm20948_ctrl_set_batch_timeout_ms_0
   1351          		timeout = (unsigned int) ((batch_time_in_ms * (BASE_SAMPLE_RATE/ (inv_icm20948_get_gyro_divider(s) + 1)))/1000);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       inv_icm20948_get_gyro_divider
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0xF240 0x4165      MOVW     R1,#+1125
   \   00000022   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000026   0x4368             MULS     R0,R0,R5
   \   00000028   0xF44F 0x717A      MOV      R1,#+1000
   \   0000002C   0xFB90 0xF1F1      SDIV     R1,R0,R1
   1352          		if(batch_time_in_ms < s->inv_androidSensorsOdr_boundaries[ANDROID_SENSOR_GYROSCOPE][0]) {
   \   00000030   0x8BF0             LDRH     R0,[R6, #+30]
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD202             BCS.N    ??inv_icm20948_ctrl_set_batch_timeout_ms_1
   1353          			return -1; // requested batch timeout is not supported
   \   00000036   0xF04F 0x30FF      MOV      R0,#-1
   \   0000003A   0xBD70             POP      {R4-R6,PC}
   1354          		} else {
   1355          			return dmp_icm20948_set_batchmode_params(s, timeout, GYRO_AVAILABLE);
   \                     ??inv_icm20948_ctrl_set_batch_timeout_ms_1: (+1)
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000044   0x.... 0x....      B.W      dmp_icm20948_set_batchmode_params
   1356          		}
   1357          	}
   1358          
   1359          	if(    s->inv_sensor_control & ACCEL_SET
   1360          		|| s->inv_sensor_control & GEOMAG_SET ) { // If Accel is enabled and no Gyro based sensor is enabled.
   \                     ??inv_icm20948_ctrl_set_batch_timeout_ms_0: (+1)
   \   00000048   0xF44F 0x4101      MOV      R1,#+33024
   \   0000004C   0x4208             TST      R0,R1
   \   0000004E   0xD018             BEQ.N    ??inv_icm20948_ctrl_set_batch_timeout_ms_2
   1361          		timeout = (unsigned int) ((batch_time_in_ms * (BASE_SAMPLE_RATE/ (inv_icm20948_get_accel_divider(s) + 1)))/1000);
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       inv_icm20948_get_accel_divider
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0xF240 0x4165      MOVW     R1,#+1125
   \   0000005C   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000060   0x4368             MULS     R0,R0,R5
   \   00000062   0xF44F 0x717A      MOV      R1,#+1000
   \   00000066   0xFB90 0xF1F1      SDIV     R1,R0,R1
   1362          		if(batch_time_in_ms < s->inv_androidSensorsOdr_boundaries[ANDROID_SENSOR_ACCELEROMETER][0]) {
   \   0000006A   0x8A70             LDRH     R0,[R6, #+18]
   \   0000006C   0x4285             CMP      R5,R0
   \   0000006E   0xD202             BCS.N    ??inv_icm20948_ctrl_set_batch_timeout_ms_3
   1363          			return -1; // requested batch timeout is not supported
   \   00000070   0xF04F 0x30FF      MOV      R0,#-1
   \   00000074   0xBD70             POP      {R4-R6,PC}
   1364          		} else {
   1365          			return dmp_icm20948_set_batchmode_params(s, timeout, ACCEL_AVAILABLE);
   \                     ??inv_icm20948_ctrl_set_batch_timeout_ms_3: (+1)
   \   00000076   0x2202             MOVS     R2,#+2
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007E   0x.... 0x....      B.W      dmp_icm20948_set_batchmode_params
   1366          		}
   1367          	}
   1368          
   1369          	if(    s->inv_sensor_control & CPASS_SET 
   1370          		|| s->inv_sensor_control & CPASS_CALIBR_SET ) {
   \                     ??inv_icm20948_ctrl_set_batch_timeout_ms_2: (+1)
   \   00000082   0xF242 0x0120      MOVW     R1,#+8224
   \   00000086   0x4208             TST      R0,R1
   \   00000088   0xD017             BEQ.N    ??inv_icm20948_ctrl_set_batch_timeout_ms_4
   1371          		timeout = (unsigned int) ((batch_time_in_ms * (BASE_SAMPLE_RATE/ inv_icm20948_get_secondary_divider(s)))/1000);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       inv_icm20948_get_secondary_divider
   \   00000090   0xF240 0x4165      MOVW     R1,#+1125
   \   00000094   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000098   0x4368             MULS     R0,R0,R5
   \   0000009A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000009E   0xFB90 0xF1F1      SDIV     R1,R0,R1
   1372          		if(batch_time_in_ms < s->inv_androidSensorsOdr_boundaries[ANDROID_SENSOR_GEOMAGNETIC_FIELD][0]) {
   \   000000A2   0x8AF0             LDRH     R0,[R6, #+22]
   \   000000A4   0x4285             CMP      R5,R0
   \   000000A6   0xD202             BCS.N    ??inv_icm20948_ctrl_set_batch_timeout_ms_5
   1373          			return -1; // requested batch timeout is not supported
   \   000000A8   0xF04F 0x30FF      MOV      R0,#-1
   \   000000AC   0xBD70             POP      {R4-R6,PC}
   1374          		} else {
   1375          			return dmp_icm20948_set_batchmode_params(s, timeout, SECONDARY_COMPASS_AVAILABLE);
   \                     ??inv_icm20948_ctrl_set_batch_timeout_ms_5: (+1)
   \   000000AE   0x2208             MOVS     R2,#+8
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000B6   0x.... 0x....      B.W      dmp_icm20948_set_batchmode_params
   1376          		}
   1377          	}
   1378          
   1379          	return -1; // Call batch only when a sensor is enabled.
   \                     ??inv_icm20948_ctrl_set_batch_timeout_ms_4: (+1)
   \   000000BA   0xF04F 0x30FF      MOV      R0,#-1
   \   000000BE   0xBD70             POP      {R4-R6,PC}       ;; return
   1380          }
   1381          
   1382          /** Each bit corresponds to a sensor being on (Sensors 0 to 21)
   1383          */

   \                                 In section .text, align 2, keep-with-next
   1384          unsigned long *inv_icm20948_ctrl_get_androidSensorsOn_mask(struct inv_icm20948 * s)
   1385          {
   1386          	return s->inv_androidSensorsOn_mask;
   \                     inv_icm20948_ctrl_get_androidSensorsOn_mask: (+1)
   \   00000000   0xF44F 0x71B0      MOV      R1,#+352
   \   00000004   0x4408             ADD      R0,R0,R1
   \   00000006   0x4770             BX       LR               ;; return
   1387          }
   1388          

   \                                 In section .text, align 2, keep-with-next
   1389          unsigned short inv_icm20948_ctrl_get_activitiy_classifier_on_flag(struct inv_icm20948 * s)
   1390          {
   1391          	return s->bac_on;
   \                     inv_icm20948_ctrl_get_activitiy_classifier_on_flag: (+1)
   \   00000000   0xF8B0 0x0150      LDRH     R0,[R0, #+336]
   \   00000004   0x4770             BX       LR               ;; return
   1392          }
   1393          
   1394          /** @brief Sets accel quaternion gain according to accel engine rate.
   1395          * @param[in] hw_smplrt_divider  hardware sample rate divider such that accel engine rate = 1125Hz/hw_smplrt_divider
   1396          * @return 0 in case of success, -1 for any error
   1397          */

   \                                 In section .text, align 2, keep-with-next
   1398          int inv_icm20948_ctrl_set_accel_quaternion_gain(struct inv_icm20948 * s, unsigned short hw_smplrt_divider)
   1399          {
   1400          	int accel_gain = 15252014L; //set 225Hz gain as default
   \                     inv_icm20948_ctrl_set_accel_quaternion_gain: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable18_3  ;; 0xe8ba2e
   1401          
   1402          	switch (hw_smplrt_divider) {
   \   00000002   0x290A             CMP      R1,#+10
   \   00000004   0xD004             BEQ.N    ??inv_icm20948_ctrl_set_accel_quaternion_gain_0
   \   00000006   0x290B             CMP      R1,#+11
   \   00000008   0xD004             BEQ.N    ??inv_icm20948_ctrl_set_accel_quaternion_gain_1
   \   0000000A   0x2916             CMP      R1,#+22
   \   0000000C   0xD005             BEQ.N    ??inv_icm20948_ctrl_set_accel_quaternion_gain_2
   \   0000000E   0xE006             B.N      ??inv_icm20948_ctrl_set_accel_quaternion_gain_3
   1403          		case 5: //1125Hz/5 = 225Hz
   1404          			accel_gain = 15252014L;
   1405          			break;
   1406          		case 10: //1125Hz/10 = 112Hz
   1407          			accel_gain = 30504029L;
   \                     ??inv_icm20948_ctrl_set_accel_quaternion_gain_0: (+1)
   \   00000010   0x....             LDR.N    R2,??DataTable18_4  ;; 0x1d1745d
   1408          			break;
   \   00000012   0xE004             B.N      ??inv_icm20948_ctrl_set_accel_quaternion_gain_3
   1409          		case 11: //1125Hz/11 = 102Hz
   1410          			accel_gain = 33554432L;
   \                     ??inv_icm20948_ctrl_set_accel_quaternion_gain_1: (+1)
   \   00000014   0xF04F 0x7200      MOV      R2,#+33554432
   1411          			break;
   \   00000018   0xE001             B.N      ??inv_icm20948_ctrl_set_accel_quaternion_gain_3
   1412          		case 22: //1125Hz/22 = 51Hz
   1413          			accel_gain = 67108864L;
   \                     ??inv_icm20948_ctrl_set_accel_quaternion_gain_2: (+1)
   \   0000001A   0xF04F 0x6280      MOV      R2,#+67108864
   1414          			break;
   1415          		default:
   1416          			accel_gain = 15252014L;
   1417          			break;
   1418          	}
   1419          
   1420          	return dmp_icm20948_set_accel_feedback_gain(s, accel_gain);
   \                     ??inv_icm20948_ctrl_set_accel_quaternion_gain_3: (+1)
   \   0000001E   0x4611             MOV      R1,R2
   \   00000020   0x.... 0x....      B.W      dmp_icm20948_set_accel_feedback_gain
   1421          }
   1422          

   \                                 In section .text, align 2, keep-with-next
   1423          int inv_icm20948_ctrl_set_accel_cal_params(struct inv_icm20948 * s, unsigned short hw_smplrt_divider)
   1424          {
   \                     inv_icm20948_ctrl_set_accel_cal_params: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   1425          	int accel_cal_params[NUM_ACCEL_CAL_PARAMS] = {0};
   \   00000002   0x466A             MOV      R2,SP
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x461C             MOV      R4,R3
   \   00000008   0x461D             MOV      R5,R3
   \   0000000A   0xC238             STM      R2!,{R3-R5}
   1426          
   1427          	if (hw_smplrt_divider <= 5) { // freq = 225Hz
   \   0000000C   0x2906             CMP      R1,#+6
   \   0000000E   0xDA04             BGE.N    ??inv_icm20948_ctrl_set_accel_cal_params_0
   1428          		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 1026019965L;
   \   00000010   0x....             LDR.N    R1,??DataTable18_5  ;; 0x3d27d27d
   \   00000012   0x9100             STR      R1,[SP, #+0]
   1429          		accel_cal_params[ACCEL_CAL_A_VAR] = 47721859L;
   \   00000014   0x....             LDR.N    R1,??DataTable18_6  ;; 0x2d82d83
   \   00000016   0x9101             STR      R1,[SP, #+4]
   \   00000018   0xE02C             B.N      ??inv_icm20948_ctrl_set_accel_cal_params_1
   1430          	} 
   1431          	else if (hw_smplrt_divider <= 10) { // 225Hz > freq >= 112Hz
   \                     ??inv_icm20948_ctrl_set_accel_cal_params_0: (+1)
   \   0000001A   0x290B             CMP      R1,#+11
   \   0000001C   0xDA04             BGE.N    ??inv_icm20948_ctrl_set_accel_cal_params_2
   1432          		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 977872018L;
   \   0000001E   0x....             LDR.N    R1,??DataTable18_7  ;; 0x3a492492
   \   00000020   0x9100             STR      R1,[SP, #+0]
   1433          		accel_cal_params[ACCEL_CAL_A_VAR] = 95869806L;
   \   00000022   0x....             LDR.N    R1,??DataTable18_8  ;; 0x5b6db6e
   \   00000024   0x9101             STR      R1,[SP, #+4]
   \   00000026   0xE025             B.N      ??inv_icm20948_ctrl_set_accel_cal_params_1
   1434          	} 
   1435          	else if (hw_smplrt_divider <= 11) { // 112Hz > freq >= 102Hz
   \                     ??inv_icm20948_ctrl_set_accel_cal_params_2: (+1)
   \   00000028   0x290C             CMP      R1,#+12
   \   0000002A   0xDA07             BGE.N    ??inv_icm20948_ctrl_set_accel_cal_params_3
   1436          		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 858993459L;
   \   0000002C   0xF04F 0x3133      MOV      R1,#+858993459
   \   00000030   0x9100             STR      R1,[SP, #+0]
   1437          		accel_cal_params[ACCEL_CAL_A_VAR] = 214748365L;
   \   00000032   0x....             LDR.N    R1,??DataTable18_9  ;; 0xccccccd
   \   00000034   0x9101             STR      R1,[SP, #+4]
   1438          		accel_cal_params[ACCEL_CAL_DIV] = 1;
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x9102             STR      R1,[SP, #+8]
   \   0000003A   0xE01B             B.N      ??inv_icm20948_ctrl_set_accel_cal_params_1
   1439          	} 
   1440          	else if (hw_smplrt_divider <= 20) { // 102Hz > freq >= 56Hz
   \                     ??inv_icm20948_ctrl_set_accel_cal_params_3: (+1)
   \   0000003C   0x2915             CMP      R1,#+21
   \   0000003E   0xDA04             BGE.N    ??inv_icm20948_ctrl_set_accel_cal_params_4
   1441          		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 882002213L;
   \   00000040   0x....             LDR.N    R1,??DataTable18_10  ;; 0x34924925
   \   00000042   0x9100             STR      R1,[SP, #+0]
   1442          		accel_cal_params[ACCEL_CAL_A_VAR] = 191739611L;
   \   00000044   0x....             LDR.N    R1,??DataTable18_11  ;; 0xb6db6db
   \   00000046   0x9101             STR      R1,[SP, #+4]
   \   00000048   0xE014             B.N      ??inv_icm20948_ctrl_set_accel_cal_params_1
   1443          	} 
   1444          	else if (hw_smplrt_divider <= 22) { // 56Hz > freq >= 51Hz
   \                     ??inv_icm20948_ctrl_set_accel_cal_params_4: (+1)
   \   0000004A   0x2917             CMP      R1,#+23
   \   0000004C   0xDA05             BGE.N    ??inv_icm20948_ctrl_set_accel_cal_params_5
   1445          		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 858993459L;
   \   0000004E   0xF04F 0x3133      MOV      R1,#+858993459
   \   00000052   0x9100             STR      R1,[SP, #+0]
   1446          		accel_cal_params[ACCEL_CAL_A_VAR] = 214748365L;
   \   00000054   0x....             LDR.N    R1,??DataTable18_9  ;; 0xccccccd
   \   00000056   0x9101             STR      R1,[SP, #+4]
   \   00000058   0xE00C             B.N      ??inv_icm20948_ctrl_set_accel_cal_params_1
   1447          	} 
   1448          	else if (hw_smplrt_divider <= 75) { // 51Hz > freq >= 15Hz
   \                     ??inv_icm20948_ctrl_set_accel_cal_params_5: (+1)
   \   0000005A   0x294C             CMP      R1,#+76
   \   0000005C   0xDA04             BGE.N    ??inv_icm20948_ctrl_set_accel_cal_params_6
   1449          		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 357913941L;
   \   0000005E   0x....             LDR.N    R1,??DataTable18_12  ;; 0x15555555
   \   00000060   0x9100             STR      R1,[SP, #+0]
   1450          		accel_cal_params[ACCEL_CAL_A_VAR] = 715827883L;
   \   00000062   0x....             LDR.N    R1,??DataTable18_13  ;; 0x2aaaaaab
   \   00000064   0x9101             STR      R1,[SP, #+4]
   \   00000066   0xE005             B.N      ??inv_icm20948_ctrl_set_accel_cal_params_1
   1451          	} 
   1452          	else if (hw_smplrt_divider <= 225) { // 15Hz > freq >= 5Hz
   \                     ??inv_icm20948_ctrl_set_accel_cal_params_6: (+1)
   \   00000068   0x29E2             CMP      R1,#+226
   \   0000006A   0xDA03             BGE.N    ??inv_icm20948_ctrl_set_accel_cal_params_1
   1453          		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 107374182L;
   \   0000006C   0x....             LDR.N    R1,??DataTable18_14  ;; 0x6666666
   \   0000006E   0x9100             STR      R1,[SP, #+0]
   1454          		accel_cal_params[ACCEL_CAL_A_VAR] = 966367642L;
   \   00000070   0x....             LDR.N    R1,??DataTable18_15  ;; 0x3999999a
   \   00000072   0x9101             STR      R1,[SP, #+4]
   1455          	}
   1456          
   1457          	return dmp_icm20948_set_accel_cal_params(s, accel_cal_params);
   \                     ??inv_icm20948_ctrl_set_accel_cal_params_1: (+1)
   \   00000074   0x4669             MOV      R1,SP
   \   00000076   0x.... 0x....      BL       dmp_icm20948_set_accel_cal_params
   \   0000007A   0xBD3E             POP      {R1-R5,PC}       ;; return
   1458          }
   1459          
   1460          /* 5061:  this should be used to disable PICKUp after it triggers once
   1461           * DO WE NEED TO CLEAR A BIT IN EVENT CONTROL?
   1462           */

   \                                 In section .text, align 2, keep-with-next
   1463          int inv_icm20948_ctrl_enable_pickup(struct inv_icm20948 * s, unsigned char enable)
   1464          {
   1465          	s->pickup = enable;
   \                     inv_icm20948_ctrl_enable_pickup: (+1)
   \   00000000   0xF44F 0x72A9      MOV      R2,#+338
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0x8011             STRH     R1,[R2, #+0]
   1466          	if(enable)
   \   00000008   0x8953             LDRH     R3,[R2, #+10]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD003             BEQ.N    ??inv_icm20948_ctrl_enable_pickup_0
   1467          		s->inv_sensor_control2 |= FLIP_PICKUP_EN;
   \   0000000E   0xF043 0x0110      ORR      R1,R3,#0x10
   \   00000012   0x8151             STRH     R1,[R2, #+10]
   \   00000014   0xE003             B.N      ??inv_icm20948_ctrl_enable_pickup_1
   1468          	else
   1469          		s->inv_sensor_control2 &= ~FLIP_PICKUP_EN;
   \                     ??inv_icm20948_ctrl_enable_pickup_0: (+1)
   \   00000016   0xF64F 0x71EF      MOVW     R1,#+65519
   \   0000001A   0x4019             ANDS     R1,R1,R3
   \   0000001C   0x8151             STRH     R1,[R2, #+10]
   1470          
   1471          	return dmp_icm20948_set_data_output_control2(s, s->inv_sensor_control2);
   \                     ??inv_icm20948_ctrl_enable_pickup_1: (+1)
   \   0000001E   0x8951             LDRH     R1,[R2, #+10]
   \   00000020   0x.... 0x....      B.W      dmp_icm20948_set_data_output_control2
   1472          }
   1473          

   \                                 In section .text, align 2, keep-with-next
   1474          int inv_icm20948_ctrl_get_acc_bias(struct inv_icm20948 * s, int * acc_bias)
   1475          {
   1476          	return dmp_icm20948_get_bias_acc(s, acc_bias);
   \                     inv_icm20948_ctrl_get_acc_bias: (+1)
   \   00000000   0x.... 0x....      B.W      dmp_icm20948_get_bias_acc
   1477          }
   1478          

   \                                 In section .text, align 2, keep-with-next
   1479          int inv_icm20948_ctrl_get_gyr_bias(struct inv_icm20948 * s, int * gyr_bias)
   1480          {
   1481          	return dmp_icm20948_get_bias_gyr(s, gyr_bias);
   \                     inv_icm20948_ctrl_get_gyr_bias: (+1)
   \   00000000   0x.... 0x....      B.W      dmp_icm20948_get_bias_gyr
   1482          }
   1483          

   \                                 In section .text, align 2, keep-with-next
   1484          int inv_icm20948_ctrl_get_mag_bias(struct inv_icm20948 * s, int * mag_bias)
   1485          {
   1486          	return dmp_icm20948_get_bias_cmp(s, mag_bias);
   \                     inv_icm20948_ctrl_get_mag_bias: (+1)
   \   00000000   0x.... 0x....      B.W      dmp_icm20948_get_bias_cmp
   1487          }
   1488          

   \                                 In section .text, align 2, keep-with-next
   1489          int inv_icm20948_ctrl_set_acc_bias(struct inv_icm20948 * s, int * acc_bias)
   1490          {
   1491          	int rc = 0;
   1492          	
   1493          	s->bias[0] = acc_bias[0];
   \                     inv_icm20948_ctrl_set_acc_bias: (+1)
   \   00000000   0xF44F 0x7214      MOV      R2,#+592
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x6013             STR      R3,[R2, #+0]
   1494          	s->bias[1] = acc_bias[1];
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0x6053             STR      R3,[R2, #+4]
   1495          	s->bias[2] = acc_bias[2];
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6091             STR      R1,[R2, #+8]
   1496          	
   1497          	rc = dmp_icm20948_set_bias_acc(s, &s->bias[0]);
   1498          	
   1499          	return rc;
   \   00000012   0x4611             MOV      R1,R2
   \   00000014   0x.... 0x....      B.W      dmp_icm20948_set_bias_acc
   1500          }
   1501          

   \                                 In section .text, align 2, keep-with-next
   1502          int inv_icm20948_ctrl_set_gyr_bias(struct inv_icm20948 * s, int * gyr_bias)
   1503          {
   1504          	int rc = 0;
   1505          	
   1506          	s->bias[3] = gyr_bias[0];
   \                     inv_icm20948_ctrl_set_gyr_bias: (+1)
   \   00000000   0xF44F 0x7217      MOV      R2,#+604
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x6013             STR      R3,[R2, #+0]
   1507          	s->bias[4] = gyr_bias[1];
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0x6053             STR      R3,[R2, #+4]
   1508          	s->bias[5] = gyr_bias[2];
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6091             STR      R1,[R2, #+8]
   1509          	
   1510          	rc = dmp_icm20948_set_bias_gyr(s, &s->bias[3]);
   1511          	
   1512          	return rc;
   \   00000012   0x4611             MOV      R1,R2
   \   00000014   0x.... 0x....      B.W      dmp_icm20948_set_bias_gyr
   1513          }
   1514          

   \                                 In section .text, align 2, keep-with-next
   1515          int inv_icm20948_ctrl_set_mag_bias(struct inv_icm20948 * s, int * mag_bias)
   1516          {
   1517          	int rc = 0;
   1518          	
   1519          	s->bias[6] = mag_bias[0];
   \                     inv_icm20948_ctrl_set_mag_bias: (+1)
   \   00000000   0xF44F 0x721A      MOV      R2,#+616
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x6013             STR      R3,[R2, #+0]
   1520          	s->bias[7] = mag_bias[1];
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0x6053             STR      R3,[R2, #+4]
   1521          	s->bias[8] = mag_bias[2];
   \   0000000E   0x6889             LDR      R1,[R1, #+8]
   \   00000010   0x6091             STR      R1,[R2, #+8]
   1522          	
   1523          	rc = dmp_icm20948_set_bias_cmp(s, &s->bias[6]);
   1524          	
   1525          	return rc;
   \   00000012   0x4611             MOV      R1,R2
   \   00000014   0x.... 0x....      B.W      dmp_icm20948_set_bias_cmp
   1526          }

   \                                 In section .text, align 2, keep-with-next
   1527          static unsigned char sensor_needs_compass(unsigned char androidSensor)
   1528          {
   1529          	switch(androidSensor) {
   \                     sensor_needs_compass: (+1)
   \   00000000   0x2802             CMP      R0,#+2
   \   00000002   0xD00D             BEQ.N    ??sensor_needs_compass_0
   \   00000004   0x280B             CMP      R0,#+11
   \   00000006   0xD00B             BEQ.N    ??sensor_needs_compass_0
   \   00000008   0x280E             CMP      R0,#+14
   \   0000000A   0xD009             BEQ.N    ??sensor_needs_compass_0
   \   0000000C   0x2814             CMP      R0,#+20
   \   0000000E   0xD007             BEQ.N    ??sensor_needs_compass_0
   \   00000010   0x2818             CMP      R0,#+24
   \   00000012   0xD005             BEQ.N    ??sensor_needs_compass_0
   \   00000014   0x281F             CMP      R0,#+31
   \   00000016   0xD003             BEQ.N    ??sensor_needs_compass_0
   \   00000018   0x2822             CMP      R0,#+34
   \   0000001A   0xD001             BEQ.N    ??sensor_needs_compass_0
   \   0000001C   0x2827             CMP      R0,#+39
   \   0000001E   0xD101             BNE.N    ??sensor_needs_compass_1
   1530          		case ANDROID_SENSOR_GEOMAGNETIC_FIELD:
   1531          		case ANDROID_SENSOR_ROTATION_VECTOR:
   1532          		case ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:
   1533          		case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:
   1534          		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD:
   1535          		case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
   1536          		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED:
   1537          		case ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR:
   1538          			return 1;
   \                     ??sensor_needs_compass_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4770             BX       LR
   1539          
   1540          		default :
   1541          			return 0;
   \                     ??sensor_needs_compass_1: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
   1542          	}
   1543          }
   1544          

   \                                 In section .text, align 2, keep-with-next
   1545          static unsigned char sensor_needs_bac_algo(unsigned char androidSensor)
   1546          {
   1547          	switch(androidSensor){
   \                     sensor_needs_bac_algo: (+1)
   \   00000000   0x3811             SUBS     R0,R0,#+17
   \   00000002   0x2802             CMP      R0,#+2
   \   00000004   0xD907             BLS.N    ??sensor_needs_bac_algo_0
   \   00000006   0x3814             SUBS     R0,R0,#+20
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD904             BLS.N    ??sensor_needs_bac_algo_0
   \   0000000C   0x1F00             SUBS     R0,R0,#+4
   \   0000000E   0xD002             BEQ.N    ??sensor_needs_bac_algo_0
   \   00000010   0x1F00             SUBS     R0,R0,#+4
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD801             BHI.N    ??sensor_needs_bac_algo_1
   1548          	case ANDROID_SENSOR_FLIP_PICKUP:
   1549          	case ANDROID_SENSOR_ACTIVITY_CLASSIFICATON:
   1550          	case ANDROID_SENSOR_STEP_DETECTOR:
   1551          	case ANDROID_SENSOR_STEP_COUNTER:
   1552          	case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:
   1553          	case ANDROID_SENSOR_WAKEUP_STEP_DETECTOR:
   1554          	case ANDROID_SENSOR_WAKEUP_STEP_COUNTER:
   1555          	case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:
   1556          	case ANDROID_SENSOR_B2S:
   1557          		return 1;
   \                     ??sensor_needs_bac_algo_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x4770             BX       LR
   1558          	default:
   1559          		return 0;
   \                     ??sensor_needs_bac_algo_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   1560          	}
   1561          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_15:
   \   00000000   0x00000000         DC32 0, 0, 0
   \              0x00000000   
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x01 0x00          DC8 1, 0, 42, 0, 23, 20, 20, 7, 39, 26, 18, 12, 19, 12, 37, 31, 38, 31
   \              0x2A 0x00    
   \              0x17 0x14    
   \              0x14 0x07    
   \              0x27 0x1A    
   \              0x12 0x0C    
   \              0x13 0x0C    
   \              0x25 0x1F    
   \              0x26 0x1F    
   \   00000012   0x11 0x1F          DC8 17, 31, 41, 32, 9, 16, 15, 16, 10, 16, 29, 33, 35, 33, 30, 33, 3
   \              0x29 0x20    
   \              0x09 0x10    
   \              0x0F 0x10    
   \              0x0A 0x10    
   \              0x1D 0x21    
   \              0x23 0x21    
   \              0x1E 0x21    
   \              0x03         
   \   00000023   0x11 0x0B          DC8 17, 11, 17, 25, 34, 31, 34, 0, 0
   \              0x11 0x19    
   \              0x22 0x1F    
   \              0x22 0x00    
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x10 0x01          DC8 16, 1, 36, 21, 4, 10, 43, 1, 26, 29, 9, 5, 15, 5, 10, 5, 29, 24, 35
   \              0x24 0x15    
   \              0x04 0x0A    
   \              0x2B 0x01    
   \              0x1A 0x1D    
   \              0x09 0x05    
   \              0x0F 0x05    
   \              0x0A 0x05    
   \              0x1D 0x18    
   \              0x23         
   \   00000013   0x18 0x1E          DC8 24, 30, 24, 3, 6, 11, 6, 25, 25, 31, 25, 0, 0
   \              0x18 0x03    
   \              0x06 0x0B    
   \              0x06 0x19    
   \              0x19 0x1F    
   \              0x19 0x00    
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x0E 0x03          DC8 14, 3, 34, 22, 2, 11, 24, 30, 20, 18, 3, 19, 11, 19, 39, 35, 25, 36
   \              0x22 0x16    
   \              0x02 0x0B    
   \              0x18 0x1E    
   \              0x14 0x12    
   \              0x03 0x13    
   \              0x0B 0x13    
   \              0x27 0x23    
   \              0x19 0x24    
   \   00000012   0x1F 0x24          DC8 31, 36

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x06 0x09          DC8 6, 9, 28, 28
   \              0x1C 0x1C    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x01 0x00          DC8 1, 0, 23, 20, 42, 0, 10, 16, 30, 33, 0, 0
   \              0x17 0x14    
   \              0x2A 0x00    
   \              0x0A 0x10    
   \              0x1E 0x21    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \   00000000   0x14 0x07          DC8 20, 7, 39, 26
   \              0x27 0x1A    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \   00000000   0x12 0x0C          DC8 18, 12, 19, 12, 37, 31, 38, 31, 17, 31, 0, 0
   \              0x13 0x0C    
   \              0x25 0x1F    
   \              0x26 0x1F    
   \              0x11 0x1F    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \   00000000   0x10 0x01          DC8 16, 1, 36, 21, 4, 10, 43, 1, 26, 29, 0, 0
   \              0x24 0x15    
   \              0x04 0x0A    
   \              0x2B 0x01    
   \              0x1A 0x1D    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \   00000000   0x04 0x0A          DC8 4, 10, 26, 29
   \              0x1A 0x1D    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \   00000000   0x09 0x05          DC8 9, 5, 15, 5, 10, 5, 29, 24, 35, 24, 30, 24
   \              0x0F 0x05    
   \              0x0A 0x05    
   \              0x1D 0x18    
   \              0x23 0x18    
   \              0x1E 0x18    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \   00000000   0x03 0x06          DC8 3, 6, 11, 6, 25, 25, 31, 25
   \              0x0B 0x06    
   \              0x19 0x19    
   \              0x1F 0x19    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \   00000000   0x0E 0x03          DC8 14, 3, 34, 22
   \              0x22 0x16    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \   00000000   0x02 0x0B          DC8 2, 11, 24, 30
   \              0x18 0x1E    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \   00000000   0x06 0x09          DC8 6, 9, 28, 28
   \              0x1C 0x1C    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xE6018E18         DC32     0xe6018e18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0xE29E8E0A         DC32     0xe29e8e0a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x8310480C         DC32     0x8310480c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x00E8BA2E         DC32     0xe8ba2e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x01D1745D         DC32     0x1d1745d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x3D27D27D         DC32     0x3d27d27d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x02D82D83         DC32     0x2d82d83

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x3A492492         DC32     0x3a492492

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x05B6DB6E         DC32     0x5b6db6e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x0CCCCCCD         DC32     0xccccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x34924925         DC32     0x34924925

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x0B6DB6DB         DC32     0xb6db6db

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x15555555         DC32     0x15555555

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x2AAAAAAB         DC32     0x2aaaaaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \   00000000   0x06666666         DC32     0x6666666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \   00000000   0x3999999A         DC32     0x3999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \   00000000   0xFFFF 0x8008      DC16 -1, -32760, 40, 1032, 16456, 4104, 136, -1, -1, 2056, -30712, 1032
   \              0x0028 0x0408
   \              0x4048 0x1008
   \              0x0088 0xFFFF
   \              0xFFFF 0x0808
   \              0x8808 0x0408
   \   00000018   0xFFFF 0xFFFF      DC16 -1, -1, 8200, 2056, 16392, 0, 24, 16, 264, -1, -1, -32760, 40
   \              0x2008 0x0808
   \              0x4008 0x0000
   \              0x0018 0x0010
   \              0x0108 0xFFFF
   \              0xFFFF 0x8008
   \              0x0028       
   \   00000032   0x0408 0x4048      DC16 1032, 16456, 4104, 136, 2056, -30712, 1032, -1, -1, 8200, 2056
   \              0x1008 0x0088
   \              0x0808 0x8808
   \              0x0408 0xFFFF
   \              0xFFFF 0x2008
   \              0x0808       
   \   00000048   0x4008 0x0018      DC16 16392, 24, 16, 264, -1, 0, -32760, 16456
   \              0x0010 0x0108
   \              0xFFFF 0x0000
   \              0x8008 0x4048

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DividerRateSet
        16   -> dmp_icm20948_set_sensor_rate
      24   MinDelayGenActual
        24   -> inv_icm20948_ctrl_androidSensor_enabled
       0   SampleRateDividerGet
      64   getMinDlyAccel
        64   -> MinDelayGenActual
        64   -> __aeabi_memcpy4
        64   -> inv_icm20948_ctrl_androidSensor_enabled
      32   getMinDlyCompass
        32   -> MinDelayGenActual
        32   -> __aeabi_memcpy4
        32   -> inv_icm20948_ctrl_androidSensor_enabled
      48   getMinDlyGyro
        48   -> MinDelayGenActual
        48   -> __aeabi_memcpy4
        48   -> inv_icm20948_ctrl_androidSensor_enabled
       0   get_multiple_56_rate
      32   inv_convert_androidSensor_to_control
         0   -> inv_reGenerate_sensorControl
        32   -> inv_reGenerate_sensorControl
     144   inv_enable_sensor_internal
       144   -> __aeabi_memcpy4
       144   -> dmp_icm20948_get_pedometer_num_of_steps
       144   -> dmp_icm20948_set_data_interrupt_control
       144   -> dmp_icm20948_set_data_output_control1
       144   -> dmp_icm20948_set_data_output_control2
       144   -> dmp_icm20948_set_data_rdy_status
       144   -> dmp_icm20948_set_motion_event_control
       144   -> dmp_icm20948_set_ped_y_ratio
       144   -> inv_convert_androidSensor_to_control
       144   -> inv_icm20948_augmented_sensors_update_odr
       144   -> inv_icm20948_ctrl_androidSensor_enabled
       144   -> inv_icm20948_ctrl_enable_activity_classifier
       144   -> inv_icm20948_ctrl_enable_tilt
       144   -> inv_icm20948_enable_hw_sensors
       144   -> inv_icm20948_get_gyro_divider
       144   -> inv_icm20948_get_gyro_fullscale
       144   -> inv_icm20948_sensor_android_2_sensor_type
       144   -> inv_icm20948_set_gyro_sf
       144   -> inv_icm20948_sleep_mems
       144   -> inv_set_hw_smplrt_dmp_odrs
       8   inv_icm20948_base_control_init
         8   -> __aeabi_memset4
       0   inv_icm20948_ctrl_androidSensor_enabled
      16   inv_icm20948_ctrl_enable_activity_classifier
        16   -> inv_icm20948_ctrl_androidSensor_enabled
      16   inv_icm20948_ctrl_enable_batch
        16   -> dmp_icm20948_set_data_output_control2
        16   -> inv_icm20948_ctrl_set_batch_mode_status
       0   inv_icm20948_ctrl_enable_pickup
         0   -> dmp_icm20948_set_data_output_control2
      24   inv_icm20948_ctrl_enable_sensor
        24   -> inv_enable_sensor_internal
        24   -> inv_icm20948_allow_lpen_control
        24   -> inv_icm20948_get_compass_availability
        24   -> inv_icm20948_prevent_lpen_control
        24   -> inv_icm20948_wakeup_mems
        24   -> sensor_needs_compass
       0   inv_icm20948_ctrl_enable_tilt
       0   inv_icm20948_ctrl_get_acc_bias
         0   -> dmp_icm20948_get_bias_acc
       0   inv_icm20948_ctrl_get_activitiy_classifier_on_flag
       0   inv_icm20948_ctrl_get_androidSensorsOn_mask
       0   inv_icm20948_ctrl_get_batch_mode_status
       0   inv_icm20948_ctrl_get_gyr_bias
         0   -> dmp_icm20948_get_bias_gyr
       0   inv_icm20948_ctrl_get_mag_bias
         0   -> dmp_icm20948_get_bias_cmp
       8   inv_icm20948_ctrl_get_odr
         8   -> inv_icm20948_get_odr_in_units
       0   inv_icm20948_ctrl_set_acc_bias
         0   -> dmp_icm20948_set_bias_acc
      24   inv_icm20948_ctrl_set_accel_cal_params
        24   -> dmp_icm20948_set_accel_cal_params
       0   inv_icm20948_ctrl_set_accel_quaternion_gain
         0   -> dmp_icm20948_set_accel_feedback_gain
       0   inv_icm20948_ctrl_set_batch_mode_status
      24   inv_icm20948_ctrl_set_batch_timeout
         0   -> dmp_icm20948_set_batchmode_params
        24   -> dmp_icm20948_set_batchmode_params
        24   -> inv_icm20948_get_accel_divider
        24   -> inv_icm20948_get_gyro_divider
        24   -> inv_icm20948_get_secondary_divider
      16   inv_icm20948_ctrl_set_batch_timeout_ms
         0   -> dmp_icm20948_set_batchmode_params
        16   -> inv_icm20948_get_accel_divider
        16   -> inv_icm20948_get_gyro_divider
        16   -> inv_icm20948_get_secondary_divider
       0   inv_icm20948_ctrl_set_gyr_bias
         0   -> dmp_icm20948_set_bias_gyr
       0   inv_icm20948_ctrl_set_mag_bias
         0   -> dmp_icm20948_set_bias_cmp
      24   inv_icm20948_set_odr
        24   -> inv_icm20948_allow_lpen_control
        24   -> inv_icm20948_augmented_sensors_set_odr
        24   -> inv_icm20948_ctrl_androidSensor_enabled
        24   -> inv_icm20948_get_compass_availability
        24   -> inv_icm20948_get_gyro_divider
        24   -> inv_icm20948_get_gyro_fullscale
        24   -> inv_icm20948_prevent_lpen_control
        24   -> inv_icm20948_set_gyro_sf
        24   -> inv_set_hw_smplrt_dmp_odrs
        24   -> sensor_needs_bac_algo
        24   -> sensor_needs_compass
      16   inv_reGenerate_sensorControl
     128   inv_set_hw_smplrt_dmp_odrs
       128   -> DividerRateSet
       128   -> MinDelayGenActual
       128   -> SampleRateDividerGet
       128   -> dmp_icm20948_set_b2s_rate
       128   -> dmp_icm20948_set_bac_rate
       128   -> getMinDlyAccel
       128   -> getMinDlyCompass
       128   -> getMinDlyGyro
       128   -> get_multiple_56_rate
       128   -> inv_icm20948_ctrl_set_accel_cal_params
       128   -> inv_icm20948_ctrl_set_accel_quaternion_gain
       128   -> inv_icm20948_enter_duty_cycle_mode
       128   -> inv_icm20948_enter_low_noise_mode
       128   -> inv_icm20948_secondary_set_odr
       128   -> inv_icm20948_set_accel_divider
       128   -> inv_icm20948_set_gyro_divider
       0   sensor_needs_bac_algo
       0   sensor_needs_compass


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      44  ?_0
      32  ?_1
       8  ?_10
       4  ?_11
       4  ?_12
       4  ?_13
      88  ?_14
      12  ?_15
      20  ?_2
       4  ?_3
      12  ?_4
       4  ?_5
      12  ?_6
      12  ?_7
       4  ?_8
      12  ?_9
      60  DividerRateSet
      68  MinDelayGenActual
      24  SampleRateDividerGet
     216  getMinDlyAccel
      96  getMinDlyCompass
     138  getMinDlyGyro
      56  get_multiple_56_rate
     180  inv_convert_androidSensor_to_control
    1128  inv_enable_sensor_internal
     244  inv_icm20948_base_control_init
      24  inv_icm20948_ctrl_androidSensor_enabled
      78  inv_icm20948_ctrl_enable_activity_classifier
      56  inv_icm20948_ctrl_enable_batch
      36  inv_icm20948_ctrl_enable_pickup
      92  inv_icm20948_ctrl_enable_sensor
      66  inv_icm20948_ctrl_enable_tilt
       4  inv_icm20948_ctrl_get_acc_bias
       6  inv_icm20948_ctrl_get_activitiy_classifier_on_flag
       8  inv_icm20948_ctrl_get_androidSensorsOn_mask
       6  inv_icm20948_ctrl_get_batch_mode_status
       4  inv_icm20948_ctrl_get_gyr_bias
       4  inv_icm20948_ctrl_get_mag_bias
     612  inv_icm20948_ctrl_get_odr
      24  inv_icm20948_ctrl_set_acc_bias
     124  inv_icm20948_ctrl_set_accel_cal_params
      36  inv_icm20948_ctrl_set_accel_quaternion_gain
      16  inv_icm20948_ctrl_set_batch_mode_status
     146  inv_icm20948_ctrl_set_batch_timeout
     192  inv_icm20948_ctrl_set_batch_timeout_ms
      24  inv_icm20948_ctrl_set_gyr_bias
      24  inv_icm20948_ctrl_set_mag_bias
     722  inv_icm20948_set_odr
      70  inv_reGenerate_sensorControl
     878  inv_set_hw_smplrt_dmp_odrs
      30  sensor_needs_bac_algo
      40  sensor_needs_compass

 
    12 bytes in section .rodata
 5 860 bytes in section .text
 
 5 860 bytes of CODE  memory
    12 bytes of CONST memory

Errors: none
Warnings: none
