###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.2.11706/W32 for ARM       22/Dec/2017  10:34:40
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\prasa\Documents\1.0.0\sources\board-hal\timer.c
#    Command line =  
#        C:\Users\prasa\Documents\1.0.0\sources\board-hal\timer.c -D
#        IAR_COMPILER -D __inline=inline -D INV_MSG_ENABLE -D ASSERT -D NUCLEO
#        -D USE_STDPERIPH_DRIVER -D USE_HSE_BYPASS -D HSE_VALUE=8000000 -D
#        STM32F411xE -lC
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list
#        --diag_suppress Pa050 -o
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 --silent --warnings_are_errors -e
#        --char_is_signed --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../board-hal\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Core\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/CMSIS/Device\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../stm32f4x/STM32F4xx_StdPeriph_Driver/inc\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/Images\
#        -I
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948/../../Invn/DynamicProtocol\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  English_United States.1252
#    List file    =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\list\timer.lst
#    Object file  =  
#        C:\Users\prasa\Documents\1.0.0\sources\examples\example-icm20948\build\example-icm20948\obj\timer.o
#
###############################################################################

C:\Users\prasa\Documents\1.0.0\sources\board-hal\timer.c
      1          /*
      2           * ________________________________________________________________________________________________________
      3           * Copyright (c) 2016-2016 InvenSense Inc. All rights reserved.
      4           *
      5           * This software, related documentation and any modifications thereto (collectively “Software”) is subject
      6           * to InvenSense and its licensors' intellectual property rights under U.S. and international copyright
      7           * and other intellectual property rights laws.
      8           *
      9           * InvenSense and its licensors retain all intellectual property and proprietary rights in and to the Software
     10           * and any use, reproduction, disclosure or distribution of the Software without an express license agreement
     11           * from InvenSense is strictly prohibited.
     12           *
     13           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE SOFTWARE IS
     14           * PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
     15           * TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
     16           * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
     17           * INVENSENSE BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
     18           * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
     19           * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
     20           * OF THE SOFTWARE.
     21           * ________________________________________________________________________________________________________
     22           */
     23          
     24          #include "common.h"
     25          #include "timer.h"
     26          #include "gpio.h"
     27          
     28          // system drivers
     29          #include "stm32f4xx.h"
     30          #include "stm32f4xx_gpio.h"
     31          #include "stm32f4xx_tim.h"
     32          #include "stm32f4xx_rcc.h"
     33          #include "stm32f4xx_syscfg.h"
     34          
     35          #include "Invn/EmbUtils/RingBuffer.h"
     36          

   \                                 In section .bss, align 1
     37          static uint8_t timer2_initied = 0;
   \                     timer2_initied:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     38          static RINGBUFFER(int_timestamp_buffer, 256, uint32_t);
   \                     int_timestamp_buffer:
   \   00000000                      DS8 1028
     39          
     40          #define MAX_TIMER_CHANNELS (4)
     41          /* Channel count goes from 1 to @see MAX_TIMER_CHANNELS, index starts from 0. By default CH3 is used for input capture */
     42          #define TIMER_CHANNEL_FOR_INPUT_CAPTURE (2)
     43          #if (TIMER_CHANNEL_FOR_INPUT_CAPTURE != 2)
     44          	#error "Input capture configuration is expected to be on CH3, further updates are required"
     45          #endif
     46          
     47          struct timer_state {
     48          	struct channel_state {
     49          		void (*callback) (void *context);
     50          		void *context;
     51          		uint32_t ccr_value;
     52          	} channels[MAX_TIMER_CHANNELS];
     53          	uint8_t occupied_channels;				/* Flag to identify which channels are already occupied */
     54          };
     55          

   \                                 In section .bss, align 4
     56          static struct timer_state timer2_state;
   \                     timer2_state:
   \   00000000                      DS8 52
   \   00000034                      DS8 4
   \   00000038                      DS8 4

   \                                 In section .bss, align 4
     57          static struct timer_state timer3_state;
   \                     timer3_state:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
     58          static struct timer_state timer4_state;
   \                     timer4_state:
   \   00000000                      DS8 52
     59          
     60          /*
     61           * Callback and context for input capture timer interruption
     62           */
     63          static void (*sInterrupt_cb)(void * context, int int_num);
     64          static void *sContext;
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void timer_enable(unsigned timer_num)
     67          {
     68          	switch(timer_num) {
   \                     timer_enable: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD003             BEQ.N    ??timer_enable_0
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD00B             BEQ.N    ??timer_enable_1
   \   00000008   0xD305             BCC.N    ??timer_enable_2
   \   0000000A   0x4770             BX       LR
     69          		case TIMER2:
     70          			TIM_Cmd(TIM2, ENABLE);
   \                     ??timer_enable_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000012   0x.... 0x....      B.W      TIM_Cmd
     71          			break;
     72          		case TIMER3:
     73          			TIM_Cmd(TIM3, ENABLE);
   \                     ??timer_enable_2: (+1)
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x40000400
   \   0000001C   0x.... 0x....      B.W      TIM_Cmd
     74          			break;
     75          		case TIMER4:
     76          			TIM_Cmd(TIM4, ENABLE);
   \                     ??timer_enable_1: (+1)
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x40000800
   \   00000026   0x.... 0x....      B.W      TIM_Cmd
     77          			break;
     78          		default:
     79          			break;
     80          	}
     81          }
     82          

   \                                 In section .text, align 2, keep-with-next
     83          int timer_configure_timebase(unsigned timer_num, uint32_t frequency)
     84          {
   \                     timer_configure_timebase: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
     85          	NVIC_InitTypeDef NVIC_InitStructure;
     86          	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
     87          	uint32_t prescaler;
     88          
     89          	/* Compute the prescaler value for the requested frequency */
     90          	prescaler = (SystemCoreClock / frequency) - 1; 
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xFBB2 0xF1F1      UDIV     R1,R2,R1
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
     91          	if(prescaler > UINT16_MAX)
   \   00000010   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000014   0xD25C             BCS.N    ??timer_configure_timebase_0
     92          		return -1;
     93          
     94          	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0x0000;
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0xF88D 0x200E      STRB     R2,[SP, #+14]
     95          	TIM_TimeBaseStructure.TIM_Prescaler = (uint16_t)prescaler;
   \   0000001C   0xF8AD 0x1004      STRH     R1,[SP, #+4]
     96          	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   \   00000020   0x4611             MOV      R1,R2
   \   00000022   0xF8AD 0x100C      STRH     R1,[SP, #+12]
     97          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   00000026   0xF8AD 0x1006      STRH     R1,[SP, #+6]
     98          
     99          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
   \   0000002A   0x2105             MOVS     R1,#+5
   \   0000002C   0xF88D 0x1001      STRB     R1,[SP, #+1]
    100          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000030   0x4611             MOV      R1,R2
   \   00000032   0xF88D 0x1002      STRB     R1,[SP, #+2]
    101          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF88D 0x1003      STRB     R1,[SP, #+3]
    102          
    103          	if(timer_num == TIMER2) {
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD11F             BNE.N    ??timer_configure_timebase_1
    104          		/* TIM2 clock enable */
    105          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000040   0x4608             MOV      R0,R1
   \   00000042   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    106          
    107          		TIM_TimeBaseStructure.TIM_Period = UINT32_MAX;
   \   00000046   0xF04F 0x30FF      MOV      R0,#-1
   \   0000004A   0x9002             STR      R0,[SP, #+8]
    108          		TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000052   0x.... 0x....      BL       TIM_TimeBaseInit
    109          
    110          		/* Enable the TIM2 global Interrupt */
    111          		NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
   \   00000056   0x201C             MOVS     R0,#+28
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
    112          		NVIC_Init(&NVIC_InitStructure);
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x.... 0x....      BL       NVIC_Init
    113          
    114          		timer2_initied = 1;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    115          		timer2_state.occupied_channels |= (1 << TIMER_CHANNEL_FOR_INPUT_CAPTURE);
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \   0000006E   0xF890 0x1030      LDRB     R1,[R0, #+48]
   \   00000072   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000076   0xF880 0x1030      STRB     R1,[R0, #+48]
    116          
    117          	} else if(timer_num == TIMER3) {
    118          		/* TIM3 clock enable */
    119          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    120          
    121          		TIM_TimeBaseStructure.TIM_Period = UINT16_MAX;
    122          		TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    123          
    124          		/* Enable the TIM3 global Interrupt */
    125          		NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    126          		NVIC_Init(&NVIC_InitStructure);
    127          
    128          	} else if(timer_num == TIMER4) {
    129          		/* TIM4 clock enable */
    130          		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
    131          
    132          		TIM_TimeBaseStructure.TIM_Period = UINT16_MAX;
    133          		TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
    134          
    135          		/* Enable the TIM4 global Interrupt */
    136          		NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
    137          		NVIC_Init(&NVIC_InitStructure);
    138          	} else
    139          		return -1;
    140          
    141          	return 0;
   \                     ??timer_configure_timebase_2: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??timer_configure_timebase_3: (+1)
   \   0000007C   0xB005             ADD      SP,SP,#+20
   \   0000007E   0xBD00             POP      {PC}             ;; return
   \                     ??timer_configure_timebase_1: (+1)
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xD111             BNE.N    ??timer_configure_timebase_4
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   0000008A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000008E   0x9002             STR      R0,[SP, #+8]
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x40000400
   \   00000096   0x.... 0x....      BL       TIM_TimeBaseInit
   \   0000009A   0x201D             MOVS     R0,#+29
   \   0000009C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x.... 0x....      BL       NVIC_Init
   \   000000A6   0xE7E8             B.N      ??timer_configure_timebase_2
   \                     ??timer_configure_timebase_4: (+1)
   \   000000A8   0x2802             CMP      R0,#+2
   \   000000AA   0xD111             BNE.N    ??timer_configure_timebase_0
   \   000000AC   0x2004             MOVS     R0,#+4
   \   000000AE   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
   \   000000B2   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000B6   0x9002             STR      R0,[SP, #+8]
   \   000000B8   0xA901             ADD      R1,SP,#+4
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x40000800
   \   000000BE   0x.... 0x....      BL       TIM_TimeBaseInit
   \   000000C2   0x201E             MOVS     R0,#+30
   \   000000C4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000C8   0x4668             MOV      R0,SP
   \   000000CA   0x.... 0x....      BL       NVIC_Init
   \   000000CE   0xE7D4             B.N      ??timer_configure_timebase_2
   \                     ??timer_configure_timebase_0: (+1)
   \   000000D0   0xF04F 0x30FF      MOV      R0,#-1
   \   000000D4   0xE7D2             B.N      ??timer_configure_timebase_3
    142          }
    143          

   \                                 In section .text, align 2, keep-with-next
    144          int timer_configure_irq_capture(unsigned enable_mask, 
    145          		void (*interrupt_cb)(void * context, int int_num), void * context)
    146          {
   \                     timer_configure_irq_capture: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    147          	GPIO_InitTypeDef GPIO_InitStructure;
    148          	TIM_ICInitTypeDef  TIM_ICInitStructure;
    149          
    150          	sInterrupt_cb = interrupt_cb;
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable11_5
   \   00000008   0x6059             STR      R1,[R3, #+4]
    151          	sContext = context;
   \   0000000A   0x609A             STR      R2,[R3, #+8]
    152          
    153          	if(enable_mask & TO_MASK(GPIO_SENSOR_IRQ_D6)) {
   \   0000000C   0x0780             LSLS     R0,R0,#+30
   \   0000000E   0xD54E             BPL.N    ??timer_configure_irq_capture_0
    154          
    155          		if(!timer2_initied) {
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD106             BNE.N    ??timer_configure_irq_capture_1
    156          			timer2_state.occupied_channels &= ~(1 << TIMER_CHANNEL_FOR_INPUT_CAPTURE);
   \   0000001A   0x7818             LDRB     R0,[R3, #+0]
   \   0000001C   0xF000 0x00FB      AND      R0,R0,#0xFB
   \   00000020   0x7018             STRB     R0,[R3, #+0]
    157          			return -1;
   \   00000022   0xF04F 0x30FF      MOV      R0,#-1
   \   00000026   0xE044             B.N      ??timer_configure_irq_capture_2
    158          		}
    159          
    160          		/* Configure as alternate function */
    161          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \                     ??timer_configure_irq_capture_1: (+1)
   \   00000028   0xF44F 0x6080      MOV      R0,#+1024
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    162          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF88D 0x0004      STRB     R0,[SP, #+4]
    163          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0xF88D 0x0005      STRB     R0,[SP, #+5]
    164          		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    165          		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0007      STRB     R0,[SP, #+7]
    166          
    167          		GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000046   0x.... 0x....      LDR.W    R4,??DataTable11_6  ;; 0x40020400
   \   0000004A   0x4669             MOV      R1,SP
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       GPIO_Init
    168          		GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_TIM2);  
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x210A             MOVS     R1,#+10
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       GPIO_PinAFConfig
    169          
    170          		/* TIM2 configuration: Input Capture mode ---------------------
    171          		 The external signal is connected to TIM2 CH3 pin (PB.10)  
    172          		 The Rising edge is used as active edge,
    173          		 The TIM2 CCR3 is used to compute the frequency value 
    174          		------------------------------------------------------------ */
    175          
    176          		TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;
   \   0000005C   0x2008             MOVS     R0,#+8
   \   0000005E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    177          		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    178          		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    179          		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    180          		TIM_ICInitStructure.TIM_ICFilter = 0x0;
   \   00000074   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    181          
    182          		TIM_ICInit(TIM2, &TIM_ICInitStructure);
   \   00000078   0xA902             ADD      R1,SP,#+8
   \   0000007A   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000007E   0x.... 0x....      BL       TIM_ICInit
    183          
    184          		/* Clear the buffer used to store the timestamp catched on interrupt */
    185          		RINGBUFFER_CLEAR(&int_timestamp_buffer);
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6001             STR      R1,[R0, #+0]
    186          
    187          		/* Enable the TIM2 CC3 Interrupt Request */
    188          		TIM_ClearITPendingBit(TIM2, TIM_IT_CC3);
   \   0000008A   0x2108             MOVS     R1,#+8
   \   0000008C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000090   0x.... 0x....      BL       TIM_ClearITPendingBit
    189          		TIM_ITConfig(TIM2, TIM_IT_CC3, ENABLE);
   \   00000094   0x2201             MOVS     R2,#+1
   \   00000096   0x2108             MOVS     R1,#+8
   \   00000098   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000009C   0x.... 0x....      BL       TIM_ITConfig
    190          
    191          		/* TIM enable counter */
    192          		TIM_Cmd(TIM2, ENABLE);
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000A6   0x.... 0x....      BL       TIM_Cmd
    193          
    194          		return 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xE001             B.N      ??timer_configure_irq_capture_2
    195          	}
    196          	return -1;
   \                     ??timer_configure_irq_capture_0: (+1)
   \   000000AE   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??timer_configure_irq_capture_2: (+1)
   \   000000B2   0xB006             ADD      SP,SP,#+24
   \   000000B4   0xBD10             POP      {R4,PC}          ;; return
    197          }
    198          

   \                                 In section .text, align 2, keep-with-next
    199          uint64_t timer_get_irq_timestamp(unsigned mask)
    200          {
   \                     timer_get_irq_timestamp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    201          	if(mask & TO_MASK(GPIO_SENSOR_IRQ_D6)) {
   \   00000002   0x0780             LSLS     R0,R0,#+30
   \   00000004   0xD516             BPL.N    ??timer_get_irq_timestamp_0
    202          		uint32_t timestamp = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    203          
    204          		disable_irq();
   \   00000008   0x.... 0x....      BL       disable_irq
    205          		if(!RINGBUFFER_EMPTY(&int_timestamp_buffer))
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0x8842             LDRH     R2,[R0, #+2]
   \   00000014   0x1A52             SUBS     R2,R2,R1
   \   00000016   0xB292             UXTH     R2,R2
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD006             BEQ.N    ??timer_get_irq_timestamp_1
    206          			RINGBUFFER_POP(&int_timestamp_buffer, &timestamp);
   \   0000001C   0xF001 0x02FF      AND      R2,R1,#0xFF
   \   00000020   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \   00000024   0x6854             LDR      R4,[R2, #+4]
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \   00000028   0x8001             STRH     R1,[R0, #+0]
    207          		enable_irq();
   \                     ??timer_get_irq_timestamp_1: (+1)
   \   0000002A   0x.... 0x....      BL       enable_irq
    208          
    209          		return (uint64_t)timestamp;
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xBD10             POP      {R4,PC}
    210          	}
    211          	return 0;
   \                     ??timer_get_irq_timestamp_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    212          }
    213          

   \                                 In section .text, align 2, keep-with-next
    214          int timer_clear_irq_timestamp(unsigned mask)
    215          {
   \                     timer_clear_irq_timestamp: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    216          	if(mask & TO_MASK(GPIO_SENSOR_IRQ_D6)) {
   \   00000002   0x0780             LSLS     R0,R0,#+30
   \   00000004   0xD509             BPL.N    ??timer_clear_irq_timestamp_0
    217          		disable_irq();
   \   00000006   0x.... 0x....      BL       disable_irq
    218          		RINGBUFFER_CLEAR(&int_timestamp_buffer);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6001             STR      R1,[R0, #+0]
    219          		enable_irq();
   \   00000012   0x.... 0x....      BL       enable_irq
    220          		return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD02             POP      {R1,PC}
    221          	}
    222          	return -1;
   \                     ??timer_clear_irq_timestamp_0: (+1)
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    223          }
    224          

   \                                 In section .text, align 2, keep-with-next
    225          uint64_t timer_get_counter(unsigned timer_num)
    226          {
   \                     timer_get_counter: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    227          	if(timer_num == TIMER2) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD105             BNE.N    ??timer_get_counter_0
    228          		return (uint64_t)(TIM_GetCounter(TIM2));
   \   00000006   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000000A   0x.... 0x....      BL       TIM_GetCounter
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xBD04             POP      {R2,PC}
    229          	}
    230          	return 0;
   \                     ??timer_get_counter_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0xBD04             POP      {R2,PC}          ;; return
    231          }
    232          

   \                                 In section .text, align 2, keep-with-next
    233          static int timer_verify_freq(unsigned timer_num, uint32_t freq)
    234          {
   \                     timer_verify_freq: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    235          	uint32_t timer_counting_freq, timer_period, min_freq, max_freq;
    236          	TIM_TypeDef* TIMx;
    237          
    238          	/*
    239          		Prescaler is configured by <timer_configure_timebase> as: (SystemCoreClock / frequency) - 1.
    240          		Timer frequency can be obtained using the following:
    241          			PSC = (SystemCoreClock / frequency) - 1
    242          			PSC + 1 = (SystemCoreClock / frequency)
    243          			frequency = SystemCoreClock / (PSC + 1)
    244          		For example, a timer with 1Mhz resolution on 16bit can do a minimum of:
    245          		1,000,000 / 2^16 ~= 15.26Hz
    246          	*/
    247          
    248          	if(timer_num == TIMER2) {
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD104             BNE.N    ??timer_verify_freq_0
    249          		TIMx = TIM2;
   \   00000008   0xF04F 0x4080      MOV      R0,#+1073741824
    250          		timer_period = UINT32_MAX;
   \   0000000C   0xF04F 0x35FF      MOV      R5,#-1
   \   00000010   0xE00C             B.N      ??timer_verify_freq_1
    251          	} else if(timer_num == TIMER3) {
   \                     ??timer_verify_freq_0: (+1)
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD104             BNE.N    ??timer_verify_freq_2
    252          		TIMx = TIM3;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable11  ;; 0x40000400
    253          		timer_period = UINT16_MAX;
   \   0000001A   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000001E   0xE005             B.N      ??timer_verify_freq_1
    254          	} else if(timer_num == TIMER4) {
   \                     ??timer_verify_freq_2: (+1)
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD116             BNE.N    ??timer_verify_freq_3
    255          		TIMx = TIM4;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable11_1  ;; 0x40000800
    256          		timer_period = UINT16_MAX;
   \   00000028   0xF64F 0x75FF      MOVW     R5,#+65535
    257          	} else {
    258          		return -1;
    259          	}
    260          
    261          	timer_counting_freq = SystemCoreClock / (TIM_GetPrescaler(TIMx) + 1);
   \                     ??timer_verify_freq_1: (+1)
   \   0000002C   0x.... 0x....      BL       TIM_GetPrescaler
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    262          
    263          	min_freq = timer_counting_freq / timer_period;
   \   0000003C   0xFBB0 0xF1F5      UDIV     R1,R0,R5
    264          	if (min_freq == 0)
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD100             BNE.N    ??timer_verify_freq_4
    265          		/* above line will return 0 if timer_period>timer_counting_freq,
    266          		setting 1 here also protects from <freq> being 0 */
    267          		min_freq = 1;
   \   00000044   0x2101             MOVS     R1,#+1
    268          	max_freq = timer_counting_freq; /*maximum one interrupt every tick*/
    269          
    270          	if (freq >= min_freq && freq <= max_freq) {
   \                     ??timer_verify_freq_4: (+1)
   \   00000046   0x428C             CMP      R4,R1
   \   00000048   0xD303             BCC.N    ??timer_verify_freq_3
   \   0000004A   0x42A0             CMP      R0,R4
   \   0000004C   0xD301             BCC.N    ??timer_verify_freq_3
    271          		return 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}
    272          	}
    273          
    274          	return -1;
   \                     ??timer_verify_freq_3: (+1)
   \   00000052   0xF04F 0x30FF      MOV      R0,#-1
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    275          }
    276          

   \                                 In section .text, align 4, keep-with-next
    277          int timer_configure_callback(unsigned timer_num, uint32_t freq,
    278          	void * context, void (*callback) (void *context))
    279          {
   \                     timer_configure_callback: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x469B             MOV      R11,R3
    280          	TIM_OCInitTypeDef  TIM_OCInitStructure;
    281          	TIM_TypeDef* TIMx;
    282          	uint16_t channel_it;
    283          	void (*init_channel_fct) (TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
    284          	uint8_t current_channel, i;
    285          	struct timer_state *current_timer;
    286          
    287          	if (timer_verify_freq(timer_num, freq) != 0) {
   \   0000000C   0x.... 0x....      BL       timer_verify_freq
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD163             BNE.N    ??timer_configure_callback_1
    288          		return -1;
    289          	}
    290          
    291          	if(timer_num == TIMER2) {
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD104             BNE.N    ??timer_configure_callback_2
    292          		TIMx = TIM2; /*not for all channels*/
   \   00000018   0xF04F 0x4580      MOV      R5,#+1073741824
    293          		current_timer = &timer2_state;
   \   0000001C   0x.... 0x....      LDR.W    R9,??DataTable11_4
   \   00000020   0xE00C             B.N      ??timer_configure_callback_3
    294          	} else if(timer_num == TIMER3) {
   \                     ??timer_configure_callback_2: (+1)
   \   00000022   0x2C01             CMP      R4,#+1
   \   00000024   0xD104             BNE.N    ??timer_configure_callback_4
    295          		TIMx = TIM3;
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable11  ;; 0x40000400
    296          		current_timer = &timer3_state;
   \   0000002A   0x.... 0x....      LDR.W    R9,??DataTable11_8
   \   0000002E   0xE005             B.N      ??timer_configure_callback_3
    297          	} else if(timer_num == TIMER4) {
   \                     ??timer_configure_callback_4: (+1)
   \   00000030   0x2C02             CMP      R4,#+2
   \   00000032   0xD153             BNE.N    ??timer_configure_callback_1
    298          		TIMx = TIM4;
   \   00000034   0x.... 0x....      LDR.W    R5,??DataTable11_1  ;; 0x40000800
    299          		current_timer = &timer4_state;
   \   00000038   0x.... 0x....      LDR.W    R9,??DataTable11_9
    300          	} else
    301          		return -1;
    302          
    303          	current_channel = MAX_TIMER_CHANNELS; /*not found by default*/
   \                     ??timer_configure_callback_3: (+1)
   \   0000003C   0x2604             MOVS     R6,#+4
    304          	for (i = 0; i < MAX_TIMER_CHANNELS; i++) {
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xF899 0x1030      LDRB     R1,[R9, #+48]
   \   00000044   0xE000             B.N      ??timer_configure_callback_5
   \                     ??timer_configure_callback_6: (+1)
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \                     ??timer_configure_callback_5: (+1)
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x2804             CMP      R0,#+4
   \   0000004C   0xDA09             BGE.N    ??timer_configure_callback_7
    305          		if (0 == ((1 << i) & current_timer->occupied_channels)) {
   \   0000004E   0x460A             MOV      R2,R1
   \   00000050   0x4102             ASRS     R2,R2,R0
   \   00000052   0x07D2             LSLS     R2,R2,#+31
   \   00000054   0xD4F7             BMI.N    ??timer_configure_callback_6
    306          			/* found an unused channel, break now */
    307          			current_timer->occupied_channels |= (1 << i);
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x4082             LSLS     R2,R2,R0
   \   0000005A   0x4311             ORRS     R1,R2,R1
   \   0000005C   0xF889 0x1030      STRB     R1,[R9, #+48]
    308          			current_channel = i;
   \   00000060   0x4606             MOV      R6,R0
    309          			break;
    310          		}
    311          	}
    312          
    313          	switch (current_channel) {
   \                     ??timer_configure_callback_7: (+1)
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x2803             CMP      R0,#+3
   \   00000066   0xD839             BHI.N    ??timer_configure_callback_1
   \   00000068   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??timer_configure_callback_0:
   \   0000006C   0x02 0x2A          DC8      0x2,0x2A,0x2E,0x34
   \              0x2E 0x34    
    314          	case 0:
    315          		channel_it = TIM_IT_CC1;
   \                     ??timer_configure_callback_8: (+1)
   \   00000070   0x2702             MOVS     R7,#+2
    316          		init_channel_fct = TIM_OC1Init;
   \   00000072   0x.... 0x....      LDR.W    R8,??DataTable11_10
    317          		break;
    318          	case 1:
    319          		channel_it = TIM_IT_CC2;
    320          		init_channel_fct = TIM_OC2Init;
    321          		break;
    322          	case 2:
    323          		if (timer_num == TIMER2) {
    324          			/* used for input capture and nothing else, this case shall never be reached */
    325          			return -1;
    326          		}
    327          		channel_it = TIM_IT_CC3;
    328          		init_channel_fct = TIM_OC3Init;
    329          		break;
    330          	case 3:
    331          		channel_it = TIM_IT_CC4;
    332          		init_channel_fct = TIM_OC4Init;
    333          		break;
    334          	default:
    335          		return -1;
    336          	}
    337          
    338          	/* 
    339          		TIM2, TIM3, TIM4 input clock (TIM_CLK) is set to 2 * APB1 clock (PCLK1)
    340          		TIM_CLK = 2 * PCLK1
    341          		PCLK1 = HCLK / 2
    342          		=> TIM_CLK = HCLK = SystemCoreClock
    343          
    344          		For example :
    345          		Compute the prescaler value to get TIM counter clock at 1MHz 
    346          		Prescaler = (TIMCLK / TIM counter clock) - 1
    347          		Prescaler = (SystemCoreClock) /1 MHz) - 1
    348          
    349          		To get TIM output clock at 30 Hz, the period (ARR)) is computed as follows:
    350          		ARR = (TIM counter clock / TIM output clock) - 1
    351          			= 33332
    352          		CCR_VALUE = AAR / 2 to get a signal with 50% duty cycle
    353          			= 16666
    354          	*/
    355          
    356          	current_timer->channels[current_channel].ccr_value = 
    357          		((SystemCoreClock / (TIM_GetPrescaler(TIMx) + 1)) / freq /*Hz*/);
   \                     ??timer_configure_callback_9: (+1)
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       TIM_GetPrescaler
   \   0000007C   0xEB06 0x0146      ADD      R1,R6,R6, LSL #+1
   \   00000080   0xEB09 0x0981      ADD      R9,R9,R1, LSL #+2
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   00000090   0x9906             LDR      R1,[SP, #+24]
   \   00000092   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000096   0xF8C9 0x0008      STR      R0,[R9, #+8]
    358          	current_timer->channels[current_channel].callback = callback;
   \   0000009A   0xF8C9 0xB000      STR      R11,[R9, #+0]
    359          	current_timer->channels[current_channel].context = context;
   \   0000009E   0xF8C9 0xA004      STR      R10,[R9, #+4]
    360          
    361          	TIM_OCStructInit(&TIM_OCInitStructure);
   \   000000A2   0x4668             MOV      R0,SP
   \   000000A4   0x.... 0x....      BL       TIM_OCStructInit
    362          	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x9000             STR      R0,[SP, #+0]
    363          	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
    364          	if(timer_num == TIMER2) { /* TIM2 is 32bit */
   \   000000AC   0x2C00             CMP      R4,#+0
   \   000000AE   0x4628             MOV      R0,R5
   \   000000B0   0xD117             BNE.N    ??timer_configure_callback_10
    365          		TIM_OCInitStructure.TIM_Pulse = (TIM_GetCounter(TIMx) + current_timer->channels[current_channel].ccr_value);
   \   000000B2   0x.... 0x....      BL       TIM_GetCounter
   \   000000B6   0xF8D9 0x1008      LDR      R1,[R9, #+8]
   \   000000BA   0x1808             ADDS     R0,R1,R0
   \   000000BC   0x9002             STR      R0,[SP, #+8]
   \   000000BE   0xE017             B.N      ??timer_configure_callback_11
    366          	} else {
   \                     ??timer_configure_callback_12: (+1)
   \   000000C0   0x2704             MOVS     R7,#+4
   \   000000C2   0x.... 0x....      LDR.W    R8,??DataTable11_11
   \   000000C6   0xE7D6             B.N      ??timer_configure_callback_9
   \                     ??timer_configure_callback_13: (+1)
   \   000000C8   0x2C00             CMP      R4,#+0
   \   000000CA   0xD007             BEQ.N    ??timer_configure_callback_1
   \   000000CC   0x2708             MOVS     R7,#+8
   \   000000CE   0x.... 0x....      LDR.W    R8,??DataTable11_12
   \   000000D2   0xE7D0             B.N      ??timer_configure_callback_9
   \                     ??timer_configure_callback_14: (+1)
   \   000000D4   0x2710             MOVS     R7,#+16
   \   000000D6   0x.... 0x....      LDR.W    R8,??DataTable11_13
   \   000000DA   0xE7CC             B.N      ??timer_configure_callback_9
   \                     ??timer_configure_callback_1: (+1)
   \   000000DC   0xF04F 0x30FF      MOV      R0,#-1
   \   000000E0   0xE01A             B.N      ??timer_configure_callback_15
    367          		TIM_OCInitStructure.TIM_Pulse = (uint16_t)(TIM_GetCounter(TIMx) + current_timer->channels[current_channel].ccr_value);
   \                     ??timer_configure_callback_10: (+1)
   \   000000E2   0x.... 0x....      BL       TIM_GetCounter
   \   000000E6   0xF8D9 0x1008      LDR      R1,[R9, #+8]
   \   000000EA   0x1808             ADDS     R0,R1,R0
   \   000000EC   0xB280             UXTH     R0,R0
   \   000000EE   0x9002             STR      R0,[SP, #+8]
    368          	}
    369          	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \                     ??timer_configure_callback_11: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    370          
    371          	/* Timing Mode configuration: Channel */
    372          	init_channel_fct(TIMx, &TIM_OCInitStructure);
   \   000000F6   0x4669             MOV      R1,SP
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x47C0             BLX      R8
    373          
    374          	/* TIM Interrupts enable */
    375          	TIM_ClearITPendingBit(TIMx, channel_it);
   \   000000FC   0x4639             MOV      R1,R7
   \   000000FE   0x4628             MOV      R0,R5
   \   00000100   0x.... 0x....      BL       TIM_ClearITPendingBit
    376          	TIM_ITConfig(TIMx, channel_it, ENABLE);
   \   00000104   0x2201             MOVS     R2,#+1
   \   00000106   0x4639             MOV      R1,R7
   \   00000108   0x4628             MOV      R0,R5
   \   0000010A   0x.... 0x....      BL       TIM_ITConfig
    377          
    378          	/* TIMx enable counter */
    379          	TIM_Cmd(TIMx, ENABLE);
   \   0000010E   0x2101             MOVS     R1,#+1
   \   00000110   0x4628             MOV      R0,R5
   \   00000112   0x.... 0x....      BL       TIM_Cmd
    380          
    381          	return current_channel;
   \   00000116   0x4630             MOV      R0,R6
   \                     ??timer_configure_callback_15: (+1)
   \   00000118   0xB007             ADD      SP,SP,#+28
   \   0000011A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    382          }
    383          

   \                                 In section .text, align 4, keep-with-next
    384          int timer_channel_stop(unsigned timer_num, uint8_t channel)
    385          {
   \                     timer_channel_stop: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x460C             MOV      R4,R1
    386          	TIM_OCInitTypeDef  TIM_OCInitStructure;
    387          	void (*init_channel_fct) (TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
    388          	TIM_TypeDef* TIMx;
    389          	uint16_t channel_it;
    390          	struct timer_state *current_timer;
    391          
    392          	if(timer_num == TIMER2) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD104             BNE.N    ??timer_channel_stop_1
    393          		TIMx = TIM2;
   \   0000000C   0xF04F 0x4580      MOV      R5,#+1073741824
    394          		current_timer = &timer2_state;
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable11_4
   \   00000014   0xE00C             B.N      ??timer_channel_stop_2
    395          	} else if(timer_num == TIMER3) {
   \                     ??timer_channel_stop_1: (+1)
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD104             BNE.N    ??timer_channel_stop_3
    396          		TIMx = TIM3;
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable11  ;; 0x40000400
    397          		current_timer = &timer3_state;
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable11_8
   \   00000022   0xE005             B.N      ??timer_channel_stop_2
    398          	} else if(timer_num == TIMER4) {
   \                     ??timer_channel_stop_3: (+1)
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD13C             BNE.N    ??timer_channel_stop_4
    399          		TIMx = TIM4;
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable11_1  ;; 0x40000800
    400          		current_timer = &timer4_state;
   \   0000002C   0x.... 0x....      LDR.W    R6,??DataTable11_9
    401          	} else
    402          		return -1;
    403          
    404          	if (0 == ((1 << channel) & current_timer->occupied_channels))
   \                     ??timer_channel_stop_2: (+1)
   \   00000030   0xF896 0x0030      LDRB     R0,[R6, #+48]
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x4121             ASRS     R1,R1,R4
   \   00000038   0x07C9             LSLS     R1,R1,#+31
   \   0000003A   0xD532             BPL.N    ??timer_channel_stop_4
    405          		/* unused channel shall not be stopped */
    406          		return -1;
    407          
    408          	switch (channel) {
   \   0000003C   0x4621             MOV      R1,R4
   \   0000003E   0x2903             CMP      R1,#+3
   \   00000040   0xD82F             BHI.N    ??timer_channel_stop_4
   \   00000042   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??timer_channel_stop_0:
   \   00000046   0x02 0x22          DC8      0x2,0x22,0x26,0x2A
   \              0x26 0x2A    
    409          	case 0:
    410          		channel_it = TIM_IT_CC1;
   \                     ??timer_channel_stop_5: (+1)
   \   0000004A   0x2702             MOVS     R7,#+2
    411          		init_channel_fct = TIM_OC1Init;
   \   0000004C   0x.... 0x....      LDR.W    R8,??DataTable11_10
    412          		break;
    413          	case 1:
    414          		channel_it = TIM_IT_CC2;
    415          		init_channel_fct = TIM_OC2Init;
    416          		break;
    417          	case 2:
    418          		channel_it = TIM_IT_CC3;
    419          		init_channel_fct = TIM_OC3Init;
    420          		break;
    421          	case 3:
    422          		channel_it = TIM_IT_CC4;
    423          		init_channel_fct = TIM_OC4Init;
    424          		break;
    425          	default:
    426          		return -1;
    427          	}
    428          	current_timer->occupied_channels &= (uint8_t)(~(1 << channel));
   \                     ??timer_channel_stop_6: (+1)
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x40A1             LSLS     R1,R1,R4
   \   00000054   0x4388             BICS     R0,R0,R1
   \   00000056   0xF886 0x0030      STRB     R0,[R6, #+48]
    429          
    430          	/* TIM Interrupts disable */
    431          	TIM_ITConfig(TIMx, channel_it, DISABLE);
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x4639             MOV      R1,R7
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x.... 0x....      BL       TIM_ITConfig
    432          	TIM_ClearITPendingBit(TIMx, channel_it);
   \   00000064   0x4639             MOV      R1,R7
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       TIM_ClearITPendingBit
    433          	
    434          	current_timer->channels[channel].callback = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xEB04 0x0144      ADD      R1,R4,R4, LSL #+1
   \   00000072   0x0089             LSLS     R1,R1,#+2
   \   00000074   0x5070             STR      R0,[R6, R1]
    435          	
    436          	/* Reset channel to its default value */
    437          	TIM_OCStructInit(&TIM_OCInitStructure);
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x.... 0x....      BL       TIM_OCStructInit
    438          	init_channel_fct(TIMx, &TIM_OCInitStructure);
   \   0000007C   0x4669             MOV      R1,SP
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x47C0             BLX      R8
    439          
    440          	return 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??timer_channel_stop_7: (+1)
   \   00000084   0xB006             ADD      SP,SP,#+24
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??timer_channel_stop_8: (+1)
   \   0000008A   0x2704             MOVS     R7,#+4
   \   0000008C   0x.... 0x....      LDR.W    R8,??DataTable11_11
   \   00000090   0xE7DE             B.N      ??timer_channel_stop_6
   \                     ??timer_channel_stop_9: (+1)
   \   00000092   0x2708             MOVS     R7,#+8
   \   00000094   0x.... 0x....      LDR.W    R8,??DataTable11_12
   \   00000098   0xE7DA             B.N      ??timer_channel_stop_6
   \                     ??timer_channel_stop_10: (+1)
   \   0000009A   0x2710             MOVS     R7,#+16
   \   0000009C   0x.... 0x....      LDR.W    R8,??DataTable11_13
   \   000000A0   0xE7D6             B.N      ??timer_channel_stop_6
   \                     ??timer_channel_stop_4: (+1)
   \   000000A2   0xF04F 0x30FF      MOV      R0,#-1
   \   000000A6   0xE7ED             B.N      ??timer_channel_stop_7
    441          }
    442          

   \                                 In section .text, align 4, keep-with-next
    443          int timer_channel_reconfigure_freq(unsigned timer_num, uint8_t channel, uint32_t new_freq)
    444          {
   \                     timer_channel_reconfigure_freq: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4691             MOV      R9,R2
    445          	TIM_OCInitTypeDef  TIM_OCInitStructure;
    446          	void (*init_channel_fct) (TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
    447          	TIM_TypeDef* TIMx;
    448          	uint16_t channel_it;
    449          	struct timer_state *current_timer;
    450          
    451          	if (timer_verify_freq(timer_num, new_freq) != 0) {
   \   0000000C   0x4649             MOV      R1,R9
   \   0000000E   0x.... 0x....      BL       timer_verify_freq
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD151             BNE.N    ??timer_channel_reconfigure_freq_1
    452          		return -1;
    453          	}
    454          
    455          	if(timer_num == TIMER2) {
   \   00000016   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001A   0xD104             BNE.N    ??timer_channel_reconfigure_freq_2
    456          		TIMx = TIM2; /*not for all channels*/
   \   0000001C   0xF04F 0x4480      MOV      R4,#+1073741824
    457          		current_timer = &timer2_state;
   \   00000020   0x.... 0x....      LDR.W    R10,??DataTable11_4
   \   00000024   0xE00C             B.N      ??timer_channel_reconfigure_freq_3
    458          	} else if(timer_num == TIMER3) {
   \                     ??timer_channel_reconfigure_freq_2: (+1)
   \   00000026   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000002A   0xD103             BNE.N    ??timer_channel_reconfigure_freq_4
    459          		TIMx = TIM3;
   \   0000002C   0x....             LDR.N    R4,??DataTable11  ;; 0x40000400
    460          		current_timer = &timer3_state;
   \   0000002E   0x.... 0x....      LDR.W    R10,??DataTable11_8
   \   00000032   0xE005             B.N      ??timer_channel_reconfigure_freq_3
    461          	} else if(timer_num == TIMER4) {
   \                     ??timer_channel_reconfigure_freq_4: (+1)
   \   00000034   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000038   0xD13F             BNE.N    ??timer_channel_reconfigure_freq_1
    462          		TIMx = TIM4;
   \   0000003A   0x....             LDR.N    R4,??DataTable11_1  ;; 0x40000800
    463          		current_timer = &timer4_state;
   \   0000003C   0x.... 0x....      LDR.W    R10,??DataTable11_9
    464          	} else
    465          		return -1;
    466          
    467          	if (0 == ((1 << channel) & current_timer->occupied_channels)) {
   \                     ??timer_channel_reconfigure_freq_3: (+1)
   \   00000040   0xF89A 0x0030      LDRB     R0,[R10, #+48]
   \   00000044   0x4138             ASRS     R0,R0,R7
   \   00000046   0x07C0             LSLS     R0,R0,#+31
   \   00000048   0xD537             BPL.N    ??timer_channel_reconfigure_freq_1
    468          		/* unused channel shall not be reconfigured */
    469          		return -1;
    470          	}
    471          
    472          	switch (channel) {
   \   0000004A   0x4638             MOV      R0,R7
   \   0000004C   0x2803             CMP      R0,#+3
   \   0000004E   0xD834             BHI.N    ??timer_channel_reconfigure_freq_1
   \   00000050   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??timer_channel_reconfigure_freq_0:
   \   00000054   0x02 0x27          DC8      0x2,0x27,0x2A,0x30
   \              0x2A 0x30    
    473          	case 0:
    474          		channel_it = TIM_IT_CC1;
   \                     ??timer_channel_reconfigure_freq_5: (+1)
   \   00000058   0x2502             MOVS     R5,#+2
    475          		init_channel_fct = TIM_OC1Init;
   \   0000005A   0x....             LDR.N    R6,??DataTable11_10
    476          		break;
    477          	case 1:
    478          		channel_it = TIM_IT_CC2;
    479          		init_channel_fct = TIM_OC2Init;
    480          		break;
    481          	case 2:
    482          		if (timer_num == TIMER2) {
    483          			/* used for input capture and nothing else, should never be reached */
    484          			return -1;
    485          		}
    486          		channel_it = TIM_IT_CC3;
    487          		init_channel_fct = TIM_OC3Init;
    488          		break;
    489          	case 3:
    490          		channel_it = TIM_IT_CC4;
    491          		init_channel_fct = TIM_OC4Init;
    492          		break;
    493          	default:
    494          		return -1;
    495          	}
    496          
    497          	/* TIM Interrupts disable, do not wait a full period */
    498          	TIM_ITConfig(TIMx, channel_it, DISABLE);
   \                     ??timer_channel_reconfigure_freq_6: (+1)
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x4629             MOV      R1,R5
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       TIM_ITConfig
    499          	
    500          	/* Only CCR value will change */
    501          	current_timer->channels[channel].ccr_value = 
    502          		((SystemCoreClock / (TIM_GetPrescaler(TIMx) + 1)) / new_freq /*Hz*/);
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       TIM_GetPrescaler
   \   0000006C   0xEB07 0x0147      ADD      R1,R7,R7, LSL #+1
   \   00000070   0xEB0A 0x0781      ADD      R7,R10,R1, LSL #+2
   \   00000074   0x....             LDR.N    R1,??DataTable11_2
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000007E   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   00000082   0x60B8             STR      R0,[R7, #+8]
    503          	TIM_OCStructInit(&TIM_OCInitStructure);
   \   00000084   0x4668             MOV      R0,SP
   \   00000086   0x.... 0x....      BL       TIM_OCStructInit
    504          	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x9000             STR      R0,[SP, #+0]
    505          	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
    506          	if(timer_num == TIMER2) { /* TIM2 is 32bit */
   \   0000008E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0xD114             BNE.N    ??timer_channel_reconfigure_freq_7
    507          		TIM_OCInitStructure.TIM_Pulse = (TIM_GetCounter(TIMx) + current_timer->channels[channel].ccr_value);
   \   00000096   0x.... 0x....      BL       TIM_GetCounter
   \   0000009A   0x68B9             LDR      R1,[R7, #+8]
   \   0000009C   0x1808             ADDS     R0,R1,R0
   \   0000009E   0x9002             STR      R0,[SP, #+8]
   \   000000A0   0xE014             B.N      ??timer_channel_reconfigure_freq_8
    508          	} else {
   \                     ??timer_channel_reconfigure_freq_9: (+1)
   \   000000A2   0x2504             MOVS     R5,#+4
   \   000000A4   0x....             LDR.N    R6,??DataTable11_11
   \   000000A6   0xE7D9             B.N      ??timer_channel_reconfigure_freq_6
   \                     ??timer_channel_reconfigure_freq_10: (+1)
   \   000000A8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AC   0xD005             BEQ.N    ??timer_channel_reconfigure_freq_1
   \   000000AE   0x2508             MOVS     R5,#+8
   \   000000B0   0x....             LDR.N    R6,??DataTable11_12
   \   000000B2   0xE7D3             B.N      ??timer_channel_reconfigure_freq_6
   \                     ??timer_channel_reconfigure_freq_11: (+1)
   \   000000B4   0x2510             MOVS     R5,#+16
   \   000000B6   0x....             LDR.N    R6,??DataTable11_13
   \   000000B8   0xE7D0             B.N      ??timer_channel_reconfigure_freq_6
   \                     ??timer_channel_reconfigure_freq_1: (+1)
   \   000000BA   0xF04F 0x30FF      MOV      R0,#-1
   \   000000BE   0xE011             B.N      ??timer_channel_reconfigure_freq_12
    509          		TIM_OCInitStructure.TIM_Pulse = (uint16_t)(TIM_GetCounter(TIMx) + current_timer->channels[channel].ccr_value);
   \                     ??timer_channel_reconfigure_freq_7: (+1)
   \   000000C0   0x.... 0x....      BL       TIM_GetCounter
   \   000000C4   0x68B9             LDR      R1,[R7, #+8]
   \   000000C6   0x1808             ADDS     R0,R1,R0
   \   000000C8   0xB280             UXTH     R0,R0
   \   000000CA   0x9002             STR      R0,[SP, #+8]
    510          	}
    511          	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \                     ??timer_channel_reconfigure_freq_8: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    512          	init_channel_fct(TIMx, &TIM_OCInitStructure);
   \   000000D2   0x4669             MOV      R1,SP
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x47B0             BLX      R6
    513          
    514          	/* Compare has been reset by TIM_OCXInit */
    515          
    516          	/* TIM Interrupts re-enable */
    517          	TIM_ITConfig(TIMx, channel_it, ENABLE);
   \   000000D8   0x2201             MOVS     R2,#+1
   \   000000DA   0x4629             MOV      R1,R5
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0x.... 0x....      BL       TIM_ITConfig
    518          
    519          	return 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \                     ??timer_channel_reconfigure_freq_12: (+1)
   \   000000E4   0xB006             ADD      SP,SP,#+24
   \   000000E6   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    520          }
    521          

   \                                 In section .text, align 2, keep-with-next
    522          void TIM2_IRQHandler(void)
    523          { 
   \                     TIM2_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    524          	/* channel 1 */
    525          	if(TIM_GetITStatus(TIM2, TIM_IT_CC1) == SET) 
   \   00000002   0x....             LDR.N    R4,??DataTable11_4
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000000A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD113             BNE.N    ??TIM2_IRQHandler_0
    526          	{
    527          		/* Clear TIM2 Capture compare interrupt pending bit */
    528          		TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000018   0x.... 0x....      BL       TIM_ClearITPendingBit
    529          
    530          		uint32_t capture = TIM_GetCapture1(TIM2);
   \   0000001C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000020   0x.... 0x....      BL       TIM_GetCapture1
    531          		TIM_SetCompare1(TIM2, capture + timer2_state.channels[0].ccr_value);
   \   00000024   0x68A1             LDR      R1,[R4, #+8]
   \   00000026   0x1809             ADDS     R1,R1,R0
   \   00000028   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000002C   0x.... 0x....      BL       TIM_SetCompare1
    532          
    533          		if (timer2_state.channels[0].callback)
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x0008             MOVS     R0,R1
   \   00000034   0xD001             BEQ.N    ??TIM2_IRQHandler_0
    534          			timer2_state.channels[0].callback(timer2_state.channels[0].context);
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x4788             BLX      R1
    535          	}
    536          	/* channel 2 */
    537          	if(TIM_GetITStatus(TIM2, TIM_IT_CC2) == SET) 
   \                     ??TIM2_IRQHandler_0: (+1)
   \   0000003A   0x2104             MOVS     R1,#+4
   \   0000003C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000040   0x.... 0x....      BL       TIM_GetITStatus
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD113             BNE.N    ??TIM2_IRQHandler_1
    538          	{
    539          		/* Clear TIM2 Capture compare interrupt pending bit */
    540          		TIM_ClearITPendingBit(TIM2, TIM_IT_CC2);
   \   00000048   0x2104             MOVS     R1,#+4
   \   0000004A   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000004E   0x.... 0x....      BL       TIM_ClearITPendingBit
    541          
    542          		uint32_t capture = TIM_GetCapture2(TIM2);
   \   00000052   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000056   0x.... 0x....      BL       TIM_GetCapture2
    543          		TIM_SetCompare2(TIM2, capture + timer2_state.channels[1].ccr_value);
   \   0000005A   0x6961             LDR      R1,[R4, #+20]
   \   0000005C   0x1809             ADDS     R1,R1,R0
   \   0000005E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000062   0x.... 0x....      BL       TIM_SetCompare2
    544          
    545          		if (timer2_state.channels[1].callback)
   \   00000066   0x68E1             LDR      R1,[R4, #+12]
   \   00000068   0x0008             MOVS     R0,R1
   \   0000006A   0xD001             BEQ.N    ??TIM2_IRQHandler_1
    546          			timer2_state.channels[1].callback(timer2_state.channels[1].context);
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0x4788             BLX      R1
    547          	}
    548          
    549          	/* channel 3 */
    550          	if(TIM_GetITStatus(TIM2, TIM_IT_CC3) == SET) 
   \                     ??TIM2_IRQHandler_1: (+1)
   \   00000070   0x2108             MOVS     R1,#+8
   \   00000072   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000076   0x.... 0x....      BL       TIM_GetITStatus
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD11E             BNE.N    ??TIM2_IRQHandler_2
    551          	{
    552          		/* Clear TIM2 Capture compare interrupt pending bit */
    553          		TIM_ClearITPendingBit(TIM2, TIM_IT_CC3);
   \   0000007E   0x2108             MOVS     R1,#+8
   \   00000080   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000084   0x.... 0x....      BL       TIM_ClearITPendingBit
    554          
    555          		/* Get the Input Capture value */
    556          		uint32_t read_value = TIM_GetCapture3(TIM2);
   \   00000088   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000008C   0x.... 0x....      BL       TIM_GetCapture3
    557          
    558          		if(!RINGBUFFER_FULL(&int_timestamp_buffer))
   \   00000090   0x....             LDR.N    R1,??DataTable11_7
   \   00000092   0x884A             LDRH     R2,[R1, #+2]
   \   00000094   0x880B             LDRH     R3,[R1, #+0]
   \   00000096   0x1AD3             SUBS     R3,R2,R3
   \   00000098   0xB29B             UXTH     R3,R3
   \   0000009A   0xF5B3 0x7F80      CMP      R3,#+256
   \   0000009E   0xD007             BEQ.N    ??TIM2_IRQHandler_3
    559          			RINGBUFFER_PUSH(&int_timestamp_buffer, &read_value);
   \   000000A0   0xF002 0x02FF      AND      R2,R2,#0xFF
   \   000000A4   0xEB01 0x0282      ADD      R2,R1,R2, LSL #+2
   \   000000A8   0x6050             STR      R0,[R2, #+4]
   \   000000AA   0x8848             LDRH     R0,[R1, #+2]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x8048             STRH     R0,[R1, #+2]
    560          
    561          		/* callback on interrupt */
    562          		if(sInterrupt_cb)
   \                     ??TIM2_IRQHandler_3: (+1)
   \   000000B0   0x6B62             LDR      R2,[R4, #+52]
   \   000000B2   0x0010             MOVS     R0,R2
   \   000000B4   0xD002             BEQ.N    ??TIM2_IRQHandler_2
    563          			sInterrupt_cb(sContext, GPIO_SENSOR_IRQ_D6);
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000BA   0x4790             BLX      R2
    564          	}
    565          	
    566          	/* channel 4 */
    567          	if(TIM_GetITStatus(TIM2, TIM_IT_CC4) == SET) 
   \                     ??TIM2_IRQHandler_2: (+1)
   \   000000BC   0x2110             MOVS     R1,#+16
   \   000000BE   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C2   0x.... 0x....      BL       TIM_GetITStatus
   \   000000C6   0x2801             CMP      R0,#+1
   \   000000C8   0xD115             BNE.N    ??TIM2_IRQHandler_4
    568          	{
    569          		/* Clear TIM2 Capture compare interrupt pending bit */
    570          		TIM_ClearITPendingBit(TIM2, TIM_IT_CC4);
   \   000000CA   0x2110             MOVS     R1,#+16
   \   000000CC   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000D0   0x.... 0x....      BL       TIM_ClearITPendingBit
    571          
    572          		uint32_t capture = TIM_GetCapture4(TIM2);
   \   000000D4   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000D8   0x.... 0x....      BL       TIM_GetCapture4
    573          		TIM_SetCompare4(TIM2, capture + timer2_state.channels[3].ccr_value);
   \   000000DC   0x6AE1             LDR      R1,[R4, #+44]
   \   000000DE   0x1809             ADDS     R1,R1,R0
   \   000000E0   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000E4   0x.... 0x....      BL       TIM_SetCompare4
    574          
    575          		if (timer2_state.channels[3].callback)
   \   000000E8   0x6A61             LDR      R1,[R4, #+36]
   \   000000EA   0x0008             MOVS     R0,R1
   \   000000EC   0xD003             BEQ.N    ??TIM2_IRQHandler_4
    576          			timer2_state.channels[3].callback(timer2_state.channels[3].context);
   \   000000EE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000F0   0xE8BD 0x4010      POP      {R4,LR}
   \   000000F4   0x4708             BX       R1
    577          	}
    578          }
   \                     ??TIM2_IRQHandler_4: (+1)
   \   000000F6   0xBD10             POP      {R4,PC}          ;; return
    579          

   \                                 In section .text, align 2, keep-with-next
    580          void TIM3_IRQHandler(void)
    581          {
   \                     TIM3_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    582          	/* channel 1 */
    583          	if(TIM_GetITStatus(TIM3, TIM_IT_CC1) == SET) 
   \   00000002   0x....             LDR.N    R4,??DataTable11_8
   \   00000004   0x....             LDR.N    R5,??DataTable11  ;; 0x40000400
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD111             BNE.N    ??TIM3_IRQHandler_0
    584          	{
    585          		/* Clear TIM3 Capture compare interrupt pending bit */
    586          		TIM_ClearITPendingBit(TIM3, TIM_IT_CC1);
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       TIM_ClearITPendingBit
    587          
    588          		uint32_t capture = TIM_GetCapture1(TIM3);
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       TIM_GetCapture1
    589          		TIM_SetCompare1(TIM3, (uint32_t)(uint16_t)(capture + timer3_state.channels[0].ccr_value));
   \   00000020   0x68A1             LDR      R1,[R4, #+8]
   \   00000022   0x1809             ADDS     R1,R1,R0
   \   00000024   0xB289             UXTH     R1,R1
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       TIM_SetCompare1
    590          
    591          		if (timer3_state.channels[0].callback)
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x0008             MOVS     R0,R1
   \   00000030   0xD001             BEQ.N    ??TIM3_IRQHandler_0
    592          			timer3_state.channels[0].callback(timer3_state.channels[0].context);
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0x4788             BLX      R1
    593          	}
    594          	/* channel 2 */
    595          	if(TIM_GetITStatus(TIM3, TIM_IT_CC2) == SET) 
   \                     ??TIM3_IRQHandler_0: (+1)
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD111             BNE.N    ??TIM3_IRQHandler_1
    596          	{
    597          		/* Clear TIM3 Capture compare interrupt pending bit */
    598          		TIM_ClearITPendingBit(TIM3, TIM_IT_CC2);
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       TIM_ClearITPendingBit
    599          
    600          		uint32_t capture = TIM_GetCapture2(TIM3);
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       TIM_GetCapture2
    601          		TIM_SetCompare2(TIM3, (uint32_t)(uint16_t)(capture + timer3_state.channels[1].ccr_value));
   \   00000050   0x6961             LDR      R1,[R4, #+20]
   \   00000052   0x1809             ADDS     R1,R1,R0
   \   00000054   0xB289             UXTH     R1,R1
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       TIM_SetCompare2
    602          
    603          		if (timer3_state.channels[1].callback)
   \   0000005C   0x68E1             LDR      R1,[R4, #+12]
   \   0000005E   0x0008             MOVS     R0,R1
   \   00000060   0xD001             BEQ.N    ??TIM3_IRQHandler_1
    604          			timer3_state.channels[1].callback(timer3_state.channels[1].context);
   \   00000062   0x6920             LDR      R0,[R4, #+16]
   \   00000064   0x4788             BLX      R1
    605          	}
    606          	/* channel 3 */
    607          	if(TIM_GetITStatus(TIM3, TIM_IT_CC3) == SET) 
   \                     ??TIM3_IRQHandler_1: (+1)
   \   00000066   0x2108             MOVS     R1,#+8
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD111             BNE.N    ??TIM3_IRQHandler_2
    608          	{
    609          		/* Clear TIM3 Capture compare interrupt pending bit */
    610          		TIM_ClearITPendingBit(TIM3, TIM_IT_CC3);
   \   00000072   0x2108             MOVS     R1,#+8
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       TIM_ClearITPendingBit
    611          
    612          		uint32_t capture = TIM_GetCapture3(TIM3);
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0x.... 0x....      BL       TIM_GetCapture3
    613          		TIM_SetCompare3(TIM3, (uint32_t)(uint16_t)(capture + timer3_state.channels[2].ccr_value));
   \   00000080   0x6A21             LDR      R1,[R4, #+32]
   \   00000082   0x1809             ADDS     R1,R1,R0
   \   00000084   0xB289             UXTH     R1,R1
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       TIM_SetCompare3
    614          
    615          		if (timer3_state.channels[2].callback)
   \   0000008C   0x69A1             LDR      R1,[R4, #+24]
   \   0000008E   0x0008             MOVS     R0,R1
   \   00000090   0xD001             BEQ.N    ??TIM3_IRQHandler_2
    616          			timer3_state.channels[2].callback(timer3_state.channels[2].context);
   \   00000092   0x69E0             LDR      R0,[R4, #+28]
   \   00000094   0x4788             BLX      R1
    617          	}
    618          	/* channel 4 */
    619          	if(TIM_GetITStatus(TIM3, TIM_IT_CC4) == SET) 
   \                     ??TIM3_IRQHandler_2: (+1)
   \   00000096   0x2110             MOVS     R1,#+16
   \   00000098   0x4628             MOV      R0,R5
   \   0000009A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD113             BNE.N    ??TIM3_IRQHandler_3
    620          	{
    621          		/* Clear TIM3 Capture compare interrupt pending bit */
    622          		TIM_ClearITPendingBit(TIM3, TIM_IT_CC4);
   \   000000A2   0x2110             MOVS     R1,#+16
   \   000000A4   0x4628             MOV      R0,R5
   \   000000A6   0x.... 0x....      BL       TIM_ClearITPendingBit
    623          
    624          		uint32_t capture = TIM_GetCapture4(TIM3);
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       TIM_GetCapture4
    625          		TIM_SetCompare4(TIM3, (uint32_t)(uint16_t)(capture + timer3_state.channels[3].ccr_value));
   \   000000B0   0x6AE1             LDR      R1,[R4, #+44]
   \   000000B2   0x1809             ADDS     R1,R1,R0
   \   000000B4   0xB289             UXTH     R1,R1
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x.... 0x....      BL       TIM_SetCompare4
    626          
    627          		if (timer3_state.channels[3].callback)
   \   000000BC   0x6A61             LDR      R1,[R4, #+36]
   \   000000BE   0x0008             MOVS     R0,R1
   \   000000C0   0xD003             BEQ.N    ??TIM3_IRQHandler_3
    628          			timer3_state.channels[3].callback(timer3_state.channels[3].context);
   \   000000C2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C4   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000C8   0x4708             BX       R1
    629          	}
    630          }
   \                     ??TIM3_IRQHandler_3: (+1)
   \   000000CA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    631          

   \                                 In section .text, align 2, keep-with-next
    632          void TIM4_IRQHandler(void)
    633          {
   \                     TIM4_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    634          	/* channel 1 */
    635          	if(TIM_GetITStatus(TIM4, TIM_IT_CC1) == SET) 
   \   00000002   0x....             LDR.N    R4,??DataTable11_9
   \   00000004   0x....             LDR.N    R5,??DataTable11_1  ;; 0x40000800
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD111             BNE.N    ??TIM4_IRQHandler_0
    636          	{
    637          		/* Clear TIM4 Capture compare interrupt pending bit */
    638          		TIM_ClearITPendingBit(TIM4, TIM_IT_CC1);
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       TIM_ClearITPendingBit
    639          
    640          		uint32_t capture = TIM_GetCapture1(TIM4);
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       TIM_GetCapture1
    641          		TIM_SetCompare1(TIM4, (uint32_t)(uint16_t)(capture + timer4_state.channels[0].ccr_value));
   \   00000020   0x68A1             LDR      R1,[R4, #+8]
   \   00000022   0x1809             ADDS     R1,R1,R0
   \   00000024   0xB289             UXTH     R1,R1
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       TIM_SetCompare1
    642          
    643          		if (timer4_state.channels[0].callback)
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x0008             MOVS     R0,R1
   \   00000030   0xD001             BEQ.N    ??TIM4_IRQHandler_0
    644          			timer4_state.channels[0].callback(timer4_state.channels[0].context);
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \   00000034   0x4788             BLX      R1
    645          	}
    646          	/* channel 2 */
    647          	if(TIM_GetITStatus(TIM4, TIM_IT_CC2) == SET) 
   \                     ??TIM4_IRQHandler_0: (+1)
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD111             BNE.N    ??TIM4_IRQHandler_1
    648          	{
    649          		/* Clear TIM4 Capture compare interrupt pending bit */
    650          		TIM_ClearITPendingBit(TIM4, TIM_IT_CC2);
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       TIM_ClearITPendingBit
    651          
    652          		uint32_t capture = TIM_GetCapture2(TIM4);
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       TIM_GetCapture2
    653          		TIM_SetCompare2(TIM4, (uint32_t)(uint16_t)(capture + timer4_state.channels[1].ccr_value));
   \   00000050   0x6961             LDR      R1,[R4, #+20]
   \   00000052   0x1809             ADDS     R1,R1,R0
   \   00000054   0xB289             UXTH     R1,R1
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       TIM_SetCompare2
    654          
    655          		if (timer4_state.channels[1].callback)
   \   0000005C   0x68E1             LDR      R1,[R4, #+12]
   \   0000005E   0x0008             MOVS     R0,R1
   \   00000060   0xD001             BEQ.N    ??TIM4_IRQHandler_1
    656          			timer4_state.channels[1].callback(timer4_state.channels[1].context);
   \   00000062   0x6920             LDR      R0,[R4, #+16]
   \   00000064   0x4788             BLX      R1
    657          	}
    658          	/* channel 3 */
    659          	if(TIM_GetITStatus(TIM4, TIM_IT_CC3) == SET) 
   \                     ??TIM4_IRQHandler_1: (+1)
   \   00000066   0x2108             MOVS     R1,#+8
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD111             BNE.N    ??TIM4_IRQHandler_2
    660          	{
    661          		/* Clear TIM4 Capture compare interrupt pending bit */
    662          		TIM_ClearITPendingBit(TIM4, TIM_IT_CC3);
   \   00000072   0x2108             MOVS     R1,#+8
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       TIM_ClearITPendingBit
    663          
    664          		uint32_t capture = TIM_GetCapture3(TIM4);
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0x.... 0x....      BL       TIM_GetCapture3
    665          		TIM_SetCompare3(TIM4, (uint32_t)(uint16_t)(capture + timer4_state.channels[2].ccr_value));
   \   00000080   0x6A21             LDR      R1,[R4, #+32]
   \   00000082   0x1809             ADDS     R1,R1,R0
   \   00000084   0xB289             UXTH     R1,R1
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       TIM_SetCompare3
    666          
    667          		if (timer4_state.channels[2].callback)
   \   0000008C   0x69A1             LDR      R1,[R4, #+24]
   \   0000008E   0x0008             MOVS     R0,R1
   \   00000090   0xD001             BEQ.N    ??TIM4_IRQHandler_2
    668          			timer4_state.channels[2].callback(timer4_state.channels[2].context);
   \   00000092   0x69E0             LDR      R0,[R4, #+28]
   \   00000094   0x4788             BLX      R1
    669          	}
    670          	/* channel 4 */
    671          	if(TIM_GetITStatus(TIM4, TIM_IT_CC4) == SET) 
   \                     ??TIM4_IRQHandler_2: (+1)
   \   00000096   0x2110             MOVS     R1,#+16
   \   00000098   0x4628             MOV      R0,R5
   \   0000009A   0x.... 0x....      BL       TIM_GetITStatus
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD113             BNE.N    ??TIM4_IRQHandler_3
    672          	{
    673          		/* Clear TIM4 Capture compare interrupt pending bit */
    674          		TIM_ClearITPendingBit(TIM4, TIM_IT_CC4);
   \   000000A2   0x2110             MOVS     R1,#+16
   \   000000A4   0x4628             MOV      R0,R5
   \   000000A6   0x.... 0x....      BL       TIM_ClearITPendingBit
    675          
    676          		uint32_t capture = TIM_GetCapture4(TIM4);
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       TIM_GetCapture4
    677          		TIM_SetCompare4(TIM4, (uint32_t)(uint16_t)(capture + timer4_state.channels[3].ccr_value));
   \   000000B0   0x6AE1             LDR      R1,[R4, #+44]
   \   000000B2   0x1809             ADDS     R1,R1,R0
   \   000000B4   0xB289             UXTH     R1,R1
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x.... 0x....      BL       TIM_SetCompare4
    678          
    679          		if (timer4_state.channels[3].callback)
   \   000000BC   0x6A61             LDR      R1,[R4, #+36]
   \   000000BE   0x0008             MOVS     R0,R1
   \   000000C0   0xD003             BEQ.N    ??TIM4_IRQHandler_3
    680          			timer4_state.channels[3].callback(timer4_state.channels[3].context);
   \   000000C2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C4   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000C8   0x4708             BX       R1
    681          	}
    682          }
   \                     ??TIM4_IRQHandler_3: (+1)
   \   000000CA   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     timer2_initied

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     timer2_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     timer2_state+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     int_timestamp_buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     timer3_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     timer4_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     TIM_OC1Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     TIM_OC2Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     TIM_OC3Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     TIM_OC4Init

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   TIM2_IRQHandler
         0   -- Indirect call
         8   -- Indirect call
         8   -> TIM_ClearITPendingBit
         8   -> TIM_GetCapture1
         8   -> TIM_GetCapture2
         8   -> TIM_GetCapture3
         8   -> TIM_GetCapture4
         8   -> TIM_GetITStatus
         8   -> TIM_SetCompare1
         8   -> TIM_SetCompare2
         8   -> TIM_SetCompare4
      16   TIM3_IRQHandler
         0   -- Indirect call
        16   -- Indirect call
        16   -> TIM_ClearITPendingBit
        16   -> TIM_GetCapture1
        16   -> TIM_GetCapture2
        16   -> TIM_GetCapture3
        16   -> TIM_GetCapture4
        16   -> TIM_GetITStatus
        16   -> TIM_SetCompare1
        16   -> TIM_SetCompare2
        16   -> TIM_SetCompare3
        16   -> TIM_SetCompare4
      16   TIM4_IRQHandler
         0   -- Indirect call
        16   -- Indirect call
        16   -> TIM_ClearITPendingBit
        16   -> TIM_GetCapture1
        16   -> TIM_GetCapture2
        16   -> TIM_GetCapture3
        16   -> TIM_GetCapture4
        16   -> TIM_GetITStatus
        16   -> TIM_SetCompare1
        16   -> TIM_SetCompare2
        16   -> TIM_SetCompare3
        16   -> TIM_SetCompare4
      56   timer_channel_reconfigure_freq
        56   -- Indirect call
        56   -> TIM_GetCounter
        56   -> TIM_GetPrescaler
        56   -> TIM_ITConfig
        56   -> TIM_OCStructInit
        56   -> timer_verify_freq
      48   timer_channel_stop
        48   -- Indirect call
        48   -> TIM_ClearITPendingBit
        48   -> TIM_ITConfig
        48   -> TIM_OCStructInit
       8   timer_clear_irq_timestamp
         8   -> disable_irq
         8   -> enable_irq
      64   timer_configure_callback
        64   -- Indirect call
        64   -> TIM_ClearITPendingBit
        64   -> TIM_Cmd
        64   -> TIM_GetCounter
        64   -> TIM_GetPrescaler
        64   -> TIM_ITConfig
        64   -> TIM_OCStructInit
        64   -> timer_verify_freq
      32   timer_configure_irq_capture
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> TIM_ClearITPendingBit
        32   -> TIM_Cmd
        32   -> TIM_ICInit
        32   -> TIM_ITConfig
      24   timer_configure_timebase
        24   -> NVIC_Init
        24   -> RCC_APB1PeriphClockCmd
        24   -> TIM_TimeBaseInit
       0   timer_enable
         0   -> TIM_Cmd
       8   timer_get_counter
         8   -> TIM_GetCounter
       8   timer_get_irq_timestamp
         8   -> disable_irq
         8   -> enable_irq
      16   timer_verify_freq
        16   -> TIM_GetPrescaler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
     248  TIM2_IRQHandler
     204  TIM3_IRQHandler
     204  TIM4_IRQHandler
    1028  int_timestamp_buffer
       1  timer2_initied
      60  timer2_state
          sInterrupt_cb
          sContext
      52  timer3_state
      52  timer4_state
     234  timer_channel_reconfigure_freq
     168  timer_channel_stop
      32  timer_clear_irq_timestamp
     286  timer_configure_callback
     182  timer_configure_irq_capture
     214  timer_configure_timebase
      42  timer_enable
      24  timer_get_counter
      58  timer_get_irq_timestamp
      88  timer_verify_freq

 
 1 193 bytes in section .bss
 2 040 bytes in section .text
 
 2 040 bytes of CODE memory
 1 193 bytes of DATA memory

Errors: none
Warnings: none
